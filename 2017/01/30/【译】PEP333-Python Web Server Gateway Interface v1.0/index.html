<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Web,Python," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="原文：PEP 333 – Python Web Server Gateway Interface v1.0 第一版发布时间：2017-01-30最后更新时间：2017-02-03">
<meta name="keywords" content="Web,Python">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】PEP333-Python Web Server Gateway Interface v1.0">
<meta property="og:url" content="http://knarfeh.github.io/2017/01/30/【译】PEP333-Python Web Server Gateway Interface v1.0/index.html">
<meta property="og:site_name" content="Frank&#39;s Notes">
<meta property="og:description" content="原文：PEP 333 – Python Web Server Gateway Interface v1.0 第一版发布时间：2017-01-30最后更新时间：2017-02-03">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-02T11:27:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】PEP333-Python Web Server Gateway Interface v1.0">
<meta name="twitter:description" content="原文：PEP 333 – Python Web Server Gateway Interface v1.0 第一版发布时间：2017-01-30最后更新时间：2017-02-03">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 【译】PEP333-Python Web Server Gateway Interface v1.0 | Frank's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-75002639-1', 'auto');
  ga('send', 'pageview');
</script>









  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Frank's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-twitter">
          <a href="/twitter" rel="section">
            
              <i class="menu-item-icon fa fa-coffee fa-fw"></i> <br />
            
            Twitter
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【译】PEP333-Python Web Server Gateway Interface v1.0
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-30T23:13:35+08:00" content="2017-01-30">
              2017-01-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/30/【译】PEP333-Python Web Server Gateway Interface v1.0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/30/【译】PEP333-Python Web Server Gateway Interface v1.0/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文：<a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="external">PEP 333 – Python Web Server Gateway Interface v1.0</a></p>
<p>第一版发布时间：2017-01-30<br>最后更新时间：2017-02-03</p>
<a id="more"></a>
<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li><a href="#preface">序言</a></li>
<li><a href="#abstract">摘要</a></li>
<li><a href="#rationaleandgoal">基本原理及目标</a>  </li>
<li><a href="#overview">规范概述</a>  <ul>
<li><a href="#applicationandframework">应用程序/框架 端</a></li>
<li><a href="#serverandgateway">服务器/网关 端</a></li>
<li><a href="#middleware">中间件：可扮演两端角色的组件</a></li>
</ul>
</li>
<li><a href="#detail">规范细则</a>  <ul>
<li><a href="#environ"><code>environ</code> 变量</a><ul>
<li><a href="#input_error">输入和错误流</a></li>
</ul>
</li>
<li><a href="#start_response">可调用 <code>start_response()</code></a><ul>
<li><a href="#content_length">处理 <code>Content-Length</code>头信息</a></li>
</ul>
</li>
<li><a href="#bufferandstreaming">缓冲和流</a><ul>
<li><a href="#middle_block">中间件处理块边界</a></li>
<li><a href="#write">可调用 <code>write()</code></a></li>
</ul>
</li>
<li><a href="#unicode">Unicode 问题</a></li>
<li><a href="#error_handle">错误处理</a></li>
<li><a href="#HTTP1.1"><code>HTTP 1.1 Expect/Continue</code>机制</a></li>
<li><a href="#HTTP_other">HTTP 的其他特性</a></li>
<li><a href="#thread">线程支持</a></li>
</ul>
</li>
<li><a href="#implementandapplication">具体实现/应用程序</a><ul>
<li><a href="#server_api">服务器扩展API</a></li>
<li><a href="#config">应用程序配置</a></li>
<li><a href="#URL">URL 的构建</a></li>
<li><a href="#Python2.2">对 Python2.2 之前的版本的支持</a></li>
<li><a href="#optional">可选的平台相关的文件处理</a></li>
</ul>
</li>
<li><a href="#QA">问题和回答</a></li>
<li><a href="#in_discussion">尚在讨论中的提议</a></li>
<li><a href="#acknowledgements">鸣谢</a></li>
<li><a href="#refrence">参考文献</a></li>
<li><a href="#copyright">版权声明</a></li>
</ul>
<p><a name="preface"></a></p>
<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><br>注意：关于本规范的后续版本，请参考 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="external">PEP 3333</a>， PEP 3333 是支持 Python 3.X 的新版本，包含了一些社区勘误，补充，更正的的相关说明信息。</p>
<p><a name="abstract"></a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><br>这份规范规定了一种在 web 服务器与 web 应用程序/框架之间的标准接口，以确保 web 应用程序在不同的 web 服务器之间具有可移植性。</p>
<p><a name="rationaleandgoal"></a></p>
<h3 id="基本原理和目标"><a href="#基本原理和目标" class="headerlink" title="基本原理和目标"></a>基本原理和目标</h3><p></p>
<p>目前 Python 有大量的 Web 框架，比如 Zope, Quixote, Webware, SkunkWeb, PSO 和 Twisted Web – 这里我仅列举出这么几个 <a name="id1"><a href="#id6">[1]</a></a>。这么多的选择让新手无所适从，因为基本上，选择什么样的框架有时会反过来限制对web服务器的选择，反之亦然。</p>
<p>相比之下，虽然 java 也拥有众多 web 的框架，但是 java 的『servlet』API 使得用任何框架编写出来的应用程序都可以在所有支持 servlet API 的 web 服务器上运行。  </p>
<p>服务器中这种针对 Python 的 API 的使用和普及 – 不管服务器是用 python 写的（如: Medusa），还是内嵌 python（如: mod_python），抑或是通过一种网关协议来调用 Python（如:CGI, FastCGI等） – 把人们从 web 框架的选择和 web 服务器的选择中剥离开来，使他们能够任意选择适合自己的组合，而 web 服务器和 web 框架的开发者们也能够把精力集中到各自的领域。  </p>
<p>鉴于此，这份 PEP 建议在 web 服务器和 web 应用/框架之间建立一种简单通用的接口规范，即 Python Web 服务器网关接口（简称 WSGI）。</p>
<p>然而光有这么一份规范，对于改变 web 服务器和 web 应用/框架的现状是不够的，只有当那些 web 服务器和 web 框架的作者/维护者们真正地实现了 WSGI，这份 WSGI 规范才能起到它该起的作用。  </p>
<p>不过，由于目前还没有任何框架或服务器实现了 WSGI，而那些新转向支持 WSGI 的框架的作者们也不会从我们这得到任何直接的奖励或者好处，所以，我们的这份 WSGI 必须要拟定地足够容易实现，这样才能降低框架作者们在实现接口这件事上的初始投资成本。</p>
<p>由此可见，服务器和框架两边接口实现的简单性，对于提高 WSGI 的实用性来说，绝对是非常重要的，同时，这一点也是任何设计决策的首要依据。</p>
<p>需要注意的是，框架作者实现框架时的简单性和 web 应用程序开发者使用框架时的易用性是两码事。WSGI 为框架作者们提出了一套只包含必需、最基本元素的接口，因为像响应对象以及 cookie 处理等这些花哨的高级功能只会妨碍现有的框架对这些问题的处理。再说一次，WSGI 的目标是使现有的 web 服务器和 web 框架之间更加方便地互联互通，而不是想重新创建一套新的 web 框架。</p>
<p>同时也要注意到，我们的这个目标也限制了 WSGI 不会用到任何当前发布 Python 版本里没有的东西。因此，这一份规范中不会推荐或要求任何新的 Python 标准模块，WSGI 中规定的所有东西都不需要 2.2.2 以上版本的 Python 支持。（当然，在未来版本的 Python 标准库中，如果 Python 自带的标准库中的 web 服务器能够包含对我们这份接口的支持，那将会是一个很不错的主意。)</p>
<p>除了要让现有的以及将要出现的框架和服务器容易实现之外，也应该让创建诸如请求预处理器，响应处理器，及创建其他基于 WSGI 的中间件组件这一类事情变得简单易操作。这里说的中间件组件，概念是这样的：它们对服务器来说它们是应用程序，而对中间件包含的应用程序来说，它们又可以被看作是服务器。</p>
<p>如果中间件既简单又鲁棒，并且 WSGI 广泛地应用在服务器和框架中，那么就有可能出现全新的 Python web 框架：一个由若干个 WSGI 中间件组件组成的松耦合的框架。事实上，现有框架的作者们甚至可能会选择去重构他们框架中已有的服务，使它们变得更像是一些配合 WSGI 使用的库而不是一个完整的框架。这样一来，web 应用程序开发者们就可以为他们想实现的特定功能选择最佳组合的组件，而不用再局限于某一个特定框架并忍受该框架的所有优缺点。</p>
<p>当然，就现在来说，这一天毫无疑问还要等很久。同时，对 WSGI 来说，让每一个框架都能在任何服务器上运行起来，又是一个足够的短期目标。</p>
<p>最后，需要指出的是，当前版本的 WSGI 对于一个应用程序具体该以何种方式部署在 web 服务器或者服务器网关上并没有做具体说明。就现在来看，这个是需要由服务器或网关来负责定义怎么实现的。等到以后，等有了足够多的服务器/网关通过实现了 WSGI 并积累了多样化的部署需求方面的领域经验，那么到时候也许会产生另一份 PEP 来描述 WSGI 服务器和应用框架的部署标准。</p>
<p><a name="overview"></a></p>
<h3 id="规范概述"><a href="#规范概述" class="headerlink" title="规范概述"></a>规范概述</h3><p><br>WSGI 接口有两个部分：『服务器端』或『网关端』和『应用程序』或 『Web 框架端』。服务器端调用一个由应用程序端提供的可调用者对象(callable)，至于它是如何被调用的，这要取决于服务器/网关这一端。我们假定有一些服务器/网关会要求应用程序的部署人员编写一个简短的脚本来启动一个服务器/网关的实例，并提供给服务器/网关一个应用程序对象，而还有的一些服务器/网关则不需要这样，它们会需要一个配置文件又或者是其他机制来指明应该从哪里导入或者获得应用程序对象。</p>
<p>除了『纯粹』的服务器/网关和应用程序/框架，还可以创建一种叫做『中间件』的组件，中间件它对这份规范当中的两端(服务器端和应用程序端)都做了实现，我们可以这样解释中间件，对于包含它们的服务器，中间件是应用程序，而对于包含在中间件当中的应用程序来说，它又扮演着服务器的角色。不仅如此，中间件还可以用来提供可扩展的 API，以及内容转换，导航和其他有用的功能。</p>
<p>在这份规范说明书中，我们将使用术语『一个可调用对象』（a callable），它的意思是『一个函数，方法，类，或者拥有 <code>__call__</code> 方法的一个对象实例』，这取决于服务器，网关，或者应用程序根据需要而选择的合适的实现技术。相反，服务器，网关，或者请求一个可调用者（callable）的应用程序必须<strong>不依赖</strong>可调用者（callable）的具体提供方式。记住，可调用者（callable）只是被调用，不会自省（introspect）。</p>
<p><a name="refrence"></a></p>
<p><a name="applicationandframework"></a></p>
<h4 id="应用程序-框架-端"><a href="#应用程序-框架-端" class="headerlink" title="应用程序/框架 端"></a>应用程序/框架 端</h4><p></p>
<p>简单地说, 一个应用程序对象是一个接受了 2 个参数的可调用对象, 这里的对象并不能理解为它真的需要一个对象实例：一个函数、方法、类、或者带有 <code>__call__</code> 方法的对象实例都可以用来当做应用程序对象。应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了 CGI）都会产生这样的重复请求。</p>
<p>（注意：虽然我们把它叫做『应用程序』对象，但这并不意味着程序员需要把 WSGI 当做 API 来调用！我们假定应用程序开发者将会仍然使用更高层的框架服务来开发它们的应用程序，WSGI 只是一个提供给框架和服务器开发者们使用的工具，它并没有打算直接向应用程序开发者提供支持。)</p>
<p>这里我们来看两个应用程序对象的示例；其中，一个是函数，另一个是类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    <span class="string">"""这可能是最简单的应用程序对象了。"""</span></div><div class="line">    status = <span class="string">'200 OK'</span></div><div class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></div><div class="line">    <span class="string">"""生成相同的输出，但是使用的是一个类。</span></div><div class="line">    （注意：这里『AppClass』就是一个『应用程序』，故调用它会返回一个『AppClass』的实例，这个实例就是规范里面说的由一个『可调用的应用程序』（application callable）返回的可迭代者（iterable）。</div><div class="line"></div><div class="line">    如果我们希望使用『AppClass』的实例，而不是应用程序对象，那么我们就必须实现这个『__call__』方法，这个方法将用来执行应用程序，然后我们需要创建一个实例来提供给服务器/网关使用。</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">        self.environ = environ</div><div class="line">        self.start = start_response</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        status = <span class="string">'200 OK'</span></div><div class="line">        response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</div><div class="line">        self.start(status, response_headers)</div><div class="line">        <span class="keyword">yield</span> <span class="string">"Hello world!\n"</span></div></pre></td></tr></table></figure>
<p><a name="serverandgateway"></a></p>
<h4 id="服务器-网关-端"><a href="#服务器-网关-端" class="headerlink" title="服务器/网关 端"></a>服务器/网关 端</h4><p><br>每一次，当 HTTP 客户端向应用程序发来一个请求，服务器/网关都会调用应用程序可调用对象（callable）。为了阐述方便，这里有一个 CGI 网关，简单的说它就是一个以应用程序对象为参数的函数实现，注意，本例中对错误只做了有限的处理，因为默认情况下没有被捕获到的异常都会被输出到 <code>sys.stderr</code> 并被服务器记录下来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os, sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></div><div class="line"></div><div class="line">    environ = dict(os.environ.items())</div><div class="line">    environ[<span class="string">'wsgi.input'</span>]        = sys.stdin</div><div class="line">    environ[<span class="string">'wsgi.errors'</span>]       = sys.stderr</div><div class="line">    environ[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</div><div class="line">    environ[<span class="string">'wsgi.multithread'</span>]  = <span class="keyword">False</span></div><div class="line">    environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="keyword">True</span></div><div class="line">    environ[<span class="string">'wsgi.run_once'</span>]     = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> environ.get(<span class="string">'HTTPS'</span>, <span class="string">'off'</span>) <span class="keyword">in</span> (<span class="string">'on'</span>, <span class="string">'1'</span>):</div><div class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'https'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></div><div class="line"></div><div class="line">    headers_set = []</div><div class="line">    headers_sent = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</div><div class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</div><div class="line">             <span class="comment"># 在第一次输出之前发送已存储的报头。</span></div><div class="line">             status, response_headers = headers_sent[:] = headers_set</div><div class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</div><div class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</div><div class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</div><div class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</div><div class="line"></div><div class="line">        sys.stdout.write(data)</div><div class="line">        sys.stdout.flush()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> exc_info:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">if</span> headers_sent:</div><div class="line">                    <span class="comment"># 如果报头已发送，则重新抛出原始的异常。</span></div><div class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</div><div class="line">            <span class="keyword">finally</span>:</div><div class="line">                exc_info = <span class="keyword">None</span>     <span class="comment"># 避免死循环。</span></div><div class="line">        <span class="keyword">elif</span> headers_set:</div><div class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</div><div class="line"></div><div class="line">        headers_set[:] = [status, response_headers]</div><div class="line">        <span class="keyword">return</span> write</div><div class="line"></div><div class="line">    result = application(environ, start_response)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:</div><div class="line">            <span class="keyword">if</span> data:    <span class="comment"># 在报文体出现前不发送报头。</span></div><div class="line">                write(data)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</div><div class="line">            write(<span class="string">''</span>)   <span class="comment"># 如果报文体为空，则发送报头。</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</div><div class="line">            result.close()</div></pre></td></tr></table></figure>
<p><a name="middleware"></a></p>
<h4 id="中间件：可扮演两端角色的组件"><a href="#中间件：可扮演两端角色的组件" class="headerlink" title="中间件：可扮演两端角色的组件"></a>中间件：可扮演两端角色的组件</h4><p></p>
<p>我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。这样的『中间件』可以执行以下这些功能：</p>
<ul>
<li>在重写相应的 <code>environ</code> 变量之后，根据目标 URL 地址将请求路由到不同的应用程序对象。</li>
<li>允许多个应用程序或框架在同一个进程中并行运行。</li>
<li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>
<li>对上下文（content）进行后加工（postprocessing），比如应用 xsl 样式表等。</li>
</ul>
<p>中间件的存在对于『服务器/网关』和『应用程序/框架』来说是透明的，并不需要特殊的支持。想在应用程序中加入中间件的用户只须简单地把中间件当作应用程序提供给服务器，并配置中间件组件以服务器的身份来调用应用程序。当然，中间件组件包裹的『应用程序』也可能是另外一个包裹了应用程序的中间件组件，这样循环下去就构成了我们所说的『中间件栈』了。</p>
<p>别忘了最重要的部分，中间件必须遵循 WSGI 服务器和应用程序两端提出的一些限制和要求，有些时候，对中间件的要求甚至比对单纯的服务器或应用程序还要严格，关于这些我们都会在这份规范文档中指出来。</p>
<p>这里有一个（有趣的）中间件组件的例子，这个中间件使用 Joe Strout 写的 <code>piglatin.py</code> 程序将 <code>text/plain</code> 的响应转换成 pig latin（注意：一个『真实』的中间件组件很可能会使用更加鲁棒的方式来检查上下文的类型和上下文的编码。同样，这个简单的例子还忽略了一个单词还可能跨区块分割的可能性。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> piglatin <span class="keyword">import</span> piglatin</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatinIter</span>:</span></div><div class="line"></div><div class="line">    <span class="string">"""如果可以转换的话，将可迭代的输出转换成拉丁语式。</span></div><div class="line"></div><div class="line">    注意『okayness』可能改变，直到应用程序生成（yield）出它自己的第一个非空字符串，所以，『transform_ok』必须是一个可变的真实值。</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, result, transform_ok)</span>:</span></div><div class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</div><div class="line">            self.close = result.close</div><div class="line">        self._next = iter(result).next</div><div class="line">        self.transform_ok = transform_ok</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.transform_ok:</div><div class="line">            <span class="keyword">return</span> piglatin(self._next())</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self._next()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latinator</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 默认情况下不传送输出。</span></div><div class="line">    transform = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application)</span>:</span></div><div class="line">        self.application = application</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line"></div><div class="line">        transform_ok = []</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_latin</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></div><div class="line"></div><div class="line">            <span class="comment"># 重置 ok 标志位，防止重复的调用。 </span></div><div class="line">            <span class="keyword">del</span> transform_ok[:]</div><div class="line"></div><div class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers:</div><div class="line">                <span class="keyword">if</span> name.lower() == <span class="string">'content-type'</span> <span class="keyword">and</span> value == <span class="string">'text/plain'</span>:</div><div class="line">                    transform_ok.append(<span class="keyword">True</span>)</div><div class="line">                    <span class="comment"># 若出现content-length，则需要strip，否则会出错。</span></div><div class="line">                    response_headers = [(name, value)</div><div class="line">                        <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers</div><div class="line">                            <span class="keyword">if</span> name.lower() != <span class="string">'content-length'</span></div><div class="line">                    ]</div><div class="line">                    <span class="keyword">break</span></div><div class="line"></div><div class="line">            write = start_response(status, response_headers, exc_info)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> transform_ok:</div><div class="line">                <span class="function"><span class="keyword">def</span> <span class="title">write_latin</span><span class="params">(data)</span>:</span></div><div class="line">                    write(piglatin(data))</div><div class="line">                <span class="keyword">return</span> write_latin</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> write</div><div class="line"></div><div class="line">        <span class="keyword">return</span> LatinIter(self.application(environ, start_latin), transform_ok)</div><div class="line"><span class="comment"># 在Latinator's控制下运行foo_app, 使用示例的CGI网关例子。</span></div><div class="line"><span class="keyword">from</span> foo_app <span class="keyword">import</span> foo_app</div><div class="line">run_with_cgi(Latinator(foo_app))</div></pre></td></tr></table></figure>
<p><a name="detail"></a></p>
<h3 id="规范细则"><a href="#规范细则" class="headerlink" title="规范细则"></a>规范细则</h3><p></p>
<p>应用程序对象必须接受两个位置参数（positional arguments），为了方便说明，我们不妨将它们分别命名为 <code>environ</code> 和 <code>start_response</code>，但是这并不是说它们必须取这两个名字。服务器或网关必须用这两个位置参数（注意不是关键字参数）来调用应用程序对象（比如，像上面展示的那样调用 <code>result = application(environ, start_response)</code>）</p>
<p><code>environ</code> 参数是一个字典对象，也是一个有着 CGI 风格的环境变量。这个对象必须是一个 Python 内建的字典对象（不能是子类、用户字典（UserDict）或其他对字典对象的模拟），应用程序必须允许以任何它需要的方式来修改这个字典， <code>environ</code> 还必须包含一些特定的 WSGI 所需的变量（在后面章节里会提到），有时也可以包含一些服务器相关的扩展变量，变量的命名规范在下文中会提到。</p>
<p><code>start_response</code> 参数是一个可调用对象（callable），它接受两个必要的位置参数和一个可选参数。为方便说明，我们分别将它们命名为 <code>status</code>，<code>response_headers</code> 和 <code>exc_info</code> 。再强调一遍，这并不是说它们一定要用这些名字。应用程序必须用这些位置参数来请求可调用对象 <code>start_response</code>（比如：<code>start_response(status, response_headers)</code>)。</p>
<p><code>status</code> 参数是一个形如『999 Message here』这样的状态字符串。而 <code>response_headers</code> 参数是一个包含有 <code>（header_name,header_value）</code> 参数列表的元组，用来描述 HTTP 的响应头。可选的 <code>exc_info</code> 参数会在接下来的 <a href="#start_response">可调用 <code>start_response()</code></a> 和 <a href="#error">错误处理</a> 两章节中详细描述，它只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。</p>
<p><code>start_response</code> 可调用对象（callable）必须返回一个 <code>write(body_data)</code> 可调用对象（callable），<code>write(body_data)</code> 接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串（注意：提供可调用对象 <code>write()</code> 只是为了支持一些现有框架的命令式输出 APIs；新的应用程序或框架应当尽量避免使用 <code>write()</code>，详细情况请参照 <a href="#bufferandstreaming">缓冲和流</a> 章节。)</p>
<p>当应用程序被服务器调用的时候，它必须返回一个能够生成0个或多个字符串的可迭代对象（iterable）。这可以通过几种方式来实现，比如通过返回一个包含一系列字符串的列表，或者是让应用程序本身就是一个能生成多个字符串的生成器（generator），又或者是使应用程序本身是一个类并且这个类的实例是一个可迭代者（iterable）。总之，不论通过什么途径完成，应用程序对象必须总是能返回一个能够生成0个或多个字符串的可迭代对象（iterable）。</p>
<p>服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。更多关于应用程序输出应该如何处理的细节，请阅读下面的 <a href="#buffer">缓冲和流</a> 章节。)</p>
<p>服务器或网关应当将产生的字符串看做是一串二进制字节序列来对待：特别地，它必须确保行的结尾没有被修改。应用程序必须负责确保将那些要传送至 HTTP 客户端的字符串以一种与客户端相匹配的编码方式输出（服务器/网关可能会对 HTTP 附加传输编码，或者为了实现一些类似字节范围传输（byte-range transmission）这样的 HTTP 特性而进行一些转换，更多关于 HTTP 特性的细节请参照下文的 <a href="#HTTP_other">HTTP 的其他特性</a> 章节。)</p>
<p>假如服务器成功调用了 <code>len(iterable)</code> 方法，则它会认为此结果是正确的并且信赖这个结果。也就是说，如果应用程序返回的可迭代者（iterable）字符串提供了一个可用的 <code>__len__()</code> 方法，那么服务器就会认为应用程序<strong>确实</strong>是返回了正确的结果。（关于这个方法在一般情况下是如何被使用的，请阅读下文的 <a href="#content_length">处理Content-Length头信息</a>。)</p>
<p>如果应用程序返回的可迭代对象（iterable）有一个叫做 <code>close()</code> 的方法，则不论当前的请求是正常结束还是由于异常而终止，服务器/网关都<strong>必须</strong>在结束该请求之前调用这个方法。（这么做的目的是为了完成应用程序端的资源释放）这份规范将尝试完善对 <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="external">PEP 325</a> 中生成器的支持，以及其它有 <code>close()</code> 方法的通用可迭代对象（iterable）的支持。</p>
<p>（注意：应用程序<strong>必须</strong>在可迭代对象（iterable）产生第一个报文主体（body）字符串之前请求 <code>start_response()</code> 可调用对象（callable），这样服务器才能在发送任意报文主体（body）内容之前发送响应头。不过，这一调用也可能在可迭代对象（iterable）第一次迭代的时候执行，所以服务器不能假定在它们开始迭代之前 <code>start_response()</code> 已经被调用过了。)</p>
<p>最后要说的是，服务器和网关<strong>不能使用</strong>应用程序返回的可迭代对象（iterable）的任何其他属性，除非是针对服务器或网关的特定类型的实例，比如 <code>wsgi.file_wrapper</code> 返回的『file wrapper』（请阅读 <a href="#optional">可选的平台相关的文件处理</a> 章节)。通常情况下，只有在这里指定的属性，或者通过 <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="external">PEP 234 iteration APIs</a> 访问的属性才是可以接受的。</p>
<p><a name="environ"></a></p>
<h4 id="environ-变量"><a href="#environ-变量" class="headerlink" title="environ 变量"></a><code>environ</code> 变量</h4><p></p>
<p><code>environ</code> 字典被用来包含这些 CGI 环境变量，这些变量可以在参考文献通用网关接口<a name="id2"><a href="#id7">[2]</a></a>中找到。除非是空字符串，否则下面所列出的这些变量都必须指定，如果下面没有特殊说明，如果是空字符串的情况，会被忽略。 </p>
<hr>
<p><code>__REQUEST_METHOD__</code></p>
<hr>
<p>HTTP 的请求方式，比如『GET』 或『POST』。这个参数永远不可能是空字符串，故必须指定。</p>
<hr>
<p><code>__SCRIPT_NAME__</code></p>
<hr>
<p>URL 请求中『路径』的开始部分，对应了应用程序对象，这样应用程序就知道它的虚拟『位置』。如果该应用程序对应服务器根目录的话， 那么 <code>SCRIPT_NAME</code> 的值<strong>可能</strong>为空字符串。</p>
<hr>
<p><code>__PATH_INFO__</code></p>
<hr>
<p>URL 请求中『路径』的剩余部分，指定请求的目标在应用程序内部的虚拟『位置』。如果请求的目标是应用程序根目录并且末尾没有斜杠符号结尾的话，那么 <code>PATH_INFO</code> <strong>可能</strong>是空字符串 。</p>
<hr>
<p><code>__QUERY_STRING__</code></p>
<hr>
<p>URL 请求中紧跟在『?』后面的那部分，它可以为空或不存在。</p>
<hr>
<p><code>__CONTENT_TYPE__</code></p>
<hr>
<p>HTTP 请求中 <code>Content-Type</code> 字段包含的所有内容，它可以为空或不存在。</p>
<hr>
<p><code>__CONTENT_LENGTH__</code></p>
<hr>
<p>HTTP 请求中 <code>Content-Length</code> 字段包含的所有内容，它可以为空或不存在。</p>
<hr>
<p><code>__SERVER_NAME__，__SERVER_PORT__</code></p>
<hr>
<p>这两个变量可以和 <code>SCRIPT_NAME</code>、<code>PATH_INFO</code>  一起构成一个完整的 URL。然而要注意的是，如果有出现 <code>HTTP_HOST</code> ，那么在重建 URL 请求的时候就应当优先使用 <code>HTTP_HOST</code> 而非 <code>SERVER_NAME</code> 。详细内容请阅读下文的 <a href="#URL">URL重构</a> 这一章节 。<code>SERVER_NAME</code> 和 <code>SERVER_PORT</code> 这两个变量永远不可能是空字符串，并且总是必须指定的。</p>
<hr>
<p><code>__SERVER_PROTOCOL__</code></p>
<hr>
<p>客户端发送请求的时候所使用的协议版本。通常是类似『HTTP/1.0』或『HTTP/1.1』这样的字符串，可以被应用程序用来判断如何处理 HTTP 请求报头。（事实上这个变量更应该被叫做 <code>REQUEST_PROTOCOL</code>，因为这个变量代表的是在请求中使用的协议，而且看起来和服务器响应时使用的协议毫无关系。然而，为了保持和 CGI 的兼容性，这里我们还是沿用已有的名字<code>SERVER_PROTOCOL</code>。）</p>
<hr>
<p><code>HTTP_  变量</code></p>
<hr>
<p>这组变量对应着客户端提供的 HTTP 请求报头（即那些名字以 『HTTP_』 开头的变量）。这组变量的存在与否应和 HTTP 请求中相对应的 HTTP 报头保持一致。</p>
<hr>
<p>一个服务器或网关<strong>应该</strong>尽可能多地提供其他可用的 CGI 变量。另外，如果启用了 SSL，服务器或网关也<strong>应该</strong>尽可能地提供可用的 Apache SSL 环境变量<a name="id5"><a href="#id10">[5]</a></a>，比如 <code>HTTPS=on</code> 和 <code>SSL_PROTOCOL</code>。不过要注意的是，假如一个应用程序使用了上述没有列出的变量，那么对于那些不支持相关扩展的服务器来说，就必然要考虑到不可移植的缺点。（比如，不发布文件的 web 服务器就不应提供一个有意义的 <code>DOCUMENT_ROOT</code> 或 <code>PATH_TRANSLATED</code> 变量。）</p>
<p>一个遵循 WSGI 规范的服务器或网关应该在文档中描述它们自己的定义的同时，适当地说明下它们可以提供哪些变量。而应用程序这边则应该对它们要用到的每一个变量的存在性进行检查，并且在当检测到某些变量不存在时要有备用的措施。</p>
<p>注意: 缺失的变量 （比如当没有发生身份验证时的 <code>REMOTE_USER</code> 变量） 应该被排除在 <code>environ</code> 字典之外。同样需要注意的是，CGI 定义的变量，如果有出现的话，那必须是字符串类型。使用任何除了字符串类型以外的 CGI 变量都是违反本规范的。</p>
<p>除了 CGI 定义的变量，<code>environ</code> 字典也<strong>可以</strong>包含任何操作系统相关的环境变量，并且<strong>必须</strong>包含下面这些 WSGI 定义的变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:left">变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wsgi.version</td>
<td style="text-align:left">元组 tuple (1, 0)，代表 WSGI 版本 1.0。</td>
</tr>
<tr>
<td style="text-align:center">wsgi.url_scheme</td>
<td style="text-align:left">应用程序被调用过程中的一个字符串，表示 URL 中的『scheme』部分。正常情况下，它的值是『http』或者『https』，视场合而定。</td>
</tr>
<tr>
<td style="text-align:center">wsgi.input</td>
<td style="text-align:left">一个能被 HTTP 请求主体（body）读取的输入流（类文件对象） （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)</td>
</tr>
<tr>
<td style="text-align:center">wsgi.errors</td>
<td style="text-align:left">输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个『文本模式』的流；举一个例子，应用程序应该用『\n』作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code> 是服务器的主要错误日志。当然也有其它选择，比如 <code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要的话，一个服务器或网关还可以向不同的应用程序提供不同的错误流。</td>
</tr>
<tr>
<td style="text-align:center">wsgi.multithread</td>
<td style="text-align:left">如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为『true』，否则就为『false』。</td>
</tr>
<tr>
<td style="text-align:center">wsgi.multiprocess</td>
<td style="text-align:left">如果相同的应用程序对象同时被其他进程调用，则此参数值应该为『true』；否则就为『false』。</td>
</tr>
<tr>
<td style="text-align:center">wsgi.run_once</td>
<td style="text-align:left">如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为『true』。正常情况下，对于那些基于 CGI（或类似）的网关，这个值只可能是『true』。</td>
</tr>
</tbody>
</table>
<p>最后，这个 <code>environ</code> 字典可能会包含那些服务器定义的变量。这些变量应该用小写，数字，点号及下划线来命名，并且必须定义一个该服务器/网关专有的前缀开头。举个例子，<code>mod_python</code> 在定义变量的时候，就会使用类似 <code>mod_python.some_variable</code> 这样的名字。</p>
<p><a name="input_error"></a></p>
<h5 id="输入和错误流"><a href="#输入和错误流" class="headerlink" title="输入和错误流"></a>输入和错误流</h5><p><br>服务器提供的输入输出流必须提供以下的方法：</p>
<table>
<thead>
<tr>
<th>方法(Method)</th>
<th>流(Stream)</th>
<th>注释(Notes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>read(size)</td>
<td>input</td>
<td>1</td>
</tr>
<tr>
<td>readline()</td>
<td>input</td>
<td>1, 2</td>
</tr>
<tr>
<td>readlines(hint)</td>
<td>input</td>
<td>1, 3</td>
</tr>
<tr>
<td><code>__iter__()</code></td>
<td>input</td>
<td></td>
</tr>
<tr>
<td>flush()</td>
<td>errors</td>
<td>4</td>
</tr>
<tr>
<td>write(str)</td>
<td>errors</td>
<td></td>
</tr>
<tr>
<td>writelines(seq)</td>
<td>errors</td>
</tr>
</tbody>
</table>
<p>除了下面列出的要点外，上表中列出的所有方法的语义在 Python 标准库参考文档里已经写得很具体了。</p>
<ol>
<li>服务器读取的长度不一定非要超过客户端指定的 <code>Content-length</code>， 并且如果应用程序尝试超过那个长度进行读取，则服务器可以模拟一个流结束（end-of-file）条件。而应用程序这边则不应该去尝试读取比指定的 <code>CONTENT_LENGTH</code> 更长的数据。</li>
<li>可选参数 <code>size</code> 是不支持用在 <code>readline()</code> 方法中的，因为它有可能会给开发服务器的开发者们增大困难，所以在实际中它不并常用。</li>
<li>请注意 <code>readlines()</code> 方法中的隐藏参数对于它的调用者和实现者都是可选的。应用程序方可以自由地选择不提供它，同样的，服务器或网关这端也可以自由地选择是否无视它。</li>
<li>由于错误流不能回转（rewound），服务器和网关可以立即选择自由地继续向前写操作（forward write），不需要缓存。在这种情况下，<code>flush()</code> 方法可能就是个空操作(no-op)。不过，一个具备可移植特优点的应用程序千万不能假定这个输出是无缓冲的或假定 flush 是一个空操作。一个可移植的应用程序如果需要确保输出确实已经被写入，则必须调用 <code>flush()</code> 方法。（例如：在多进程下对同一个日志文件写入操作的时候，可以起到最小化数据混杂的作用。）</li>
</ol>
<p>所有遵循此规范的服务器都必须支持上表中所列出的每一个方法。所有遵循此规范的应用程序都不能使用除上表之外的其他方法或属性。特别需要指出的是，应用程序千万不要试图去关闭这些流，就算它们自己有对 <code>close()</code> 方法做处理也不行。</p>
<p><a name="start_response"></a></p>
<h4 id="可调用-start-response"><a href="#可调用-start-response" class="headerlink" title="可调用 start_response()"></a>可调用 <code>start_response()</code></h4><p></p>
<p>传递给应用程序的第二个参数是一个可调用的形式：<code>start_response（status, reponse_headers, exc_info=None）</code>。（同所有的 WSGI 调用类似，它的参数必须是位置参数，而非关键字参数）。 <code>start_response</code> 调用被用来启动一个 HTTP 响应，它必须返回一个 <code>write(body_data)</code> 可调用对象 （具体参考下文的 <a href="#bufferandstreaming">缓冲和流</a> 章节）</p>
<p><code>status</code> 参数是 HTTP 的『status』字符串形式，比如『200 OK』, 『404 Not Found』这样的。也就是说，它是包含了一个状态码和一个原因短语的字符串，用空格分隔并且顺序是状态码在前原因短语在后。<code>status</code> 参数的两头不允许包含其他的字符或空格，（参见 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a>，6.1.1 章节获取更多信息），<code>status</code> 字符串<strong>不能</strong>包含控制字符，末尾也不能有终止符或换行符等其他的组合符号。</p>
<p><code>response_headers</code> 参数是个包含了 <code>（header_name, header_value）</code> 参数列表的元组（Tuple），它必须是一个严格的 Python 列表类型，换句话说，就是对它执行 <code>type(response_headers)</code> 时，返回值必须是 <code>ListType</code> 。如果需要，服务器<strong>可以</strong>随意修改它的内容，每一个 <code>header_name</code> 都必须是合法的 HTTP header 字段名 （参见 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 4.2章节），末尾不能有冒号或其他标点符号。</p>
<p>所有的 <code>header_value</code> 都<strong>不能</strong>包含任何控制字符，如回车或换行符等，中间嵌入或者末尾都不行。（做这样的要求是为了方便那些必须检查响应头的服务器，网关，中间件，使它们将必需的解析工作复杂度降到最低。）  </p>
<p>一般来说，服务器或网关负责确保将正确的头信息发送到客户端，如果应用程序（application）遗漏了必要的头信息（或其他相关的规范信息），则服务器或网关<strong>必须</strong>补上。 比如： <code>HTTP date:</code> 和 <code>Server:</code> 头信息通常是由服务器或网关提供的。 </p>
<p>（这里必须给服务器/网关的作者们提个醒: HTTP 头名称是区分大小写的，所以在检查应用程序提供的头信息时一定要考虑大小写的问题。）</p>
<p>应用程序和中间件禁止使用 HTTP/1.1 的『逐跳路由 （hop-by-hop）』特性或头信息（headers），以及任何 HTTP/1.0 中那些可能会对客户端跟服务器之间的持久连接产生影响的类似特性或头信息。这类特性是现今 Web 服务器的专属负责区域，如果一个应用程序尝试发送这类特性，那么服务器/网关必须将这看作是一个严重错误，并且如果它们是提供给 <code>start_response()</code> 的，则服务器/网关还必须抛出一个异常。 （了解更多『逐跳路由 （hop-by-hop）』的细节和特性，请参阅下面的 <a href="#HTTP_other">HTTP 的其他特性</a> 章节。)</p>
<p><code>start_response</code> 可调用对象<strong>肯定不能</strong>是真实地传送了响应头信息。相反地，它必须储存这类头信息以便服务器/网关用来传送，前提是应用程序返回值的第一次迭代生成了一个非空字符串，或者说在对应用程序的第一次调用中它的 <code>write()</code> 方法可被调用。换句话说，也就是在没有真正的响应体数据可用之前，响应头不能被发送，否则当应用程序到达的时候，可迭代对象都已经被迭代完了。（唯一可能的例外就是当响应头信息里显式地指定了 <code>Content-Length</code> 的值为0。） </p>
<p>响应头信息传输的延迟，是为了确保缓存的和异步的应用程序能够利用出错信息替换掉它们一开始打算的输出，一直到最后一刻。举个例子，在应用程序缓存期间，如果在生成相应内容数据时发生了错误，那么应用程序可能会将响应状态从『200 OK』替换成『500 Internal Error』。</p>
<p>如果有提供 <code>exc_info</code> 参数，则它必须是一个 Python 的 <code>sys.exc_info()</code> 元组（tuple）。该参数只有在 <code>start_response</code> 被一个错误处理程序（error handler）调用时才是必需的。如果提供了 <code>exc_info</code> 参数并且还没有发出任何 HTTP 头信息的请求，那么 <code>start_response</code> 应当使用新提供的 HTTP 响应头去替换掉当前已存储的 HTTP 响应头，从而允许应用程序在错误发生的情况下可以针对输出『改变主意』。</p>
<p>然而，假如提供了 <code>exc_info</code> 参数并且 HTTP 头信息也已经被发送，那么 <code>start_response</code> 必须抛出错误，也必须抛出 <code>exc_info</code> 元组，即： </p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raise exc_info<span class="string">[0]</span>, exc_info<span class="string">[1]</span>, exc_info<span class="string">[2]</span></div></pre></td></tr></table></figure>
<p>这样会使得应用程序捕捉到的异常被重新抛出，并且原则上应该也会终止应用程序。（一旦 HTTP 信息头已经被发送，则应用程序再试图向浏览器发送错误信息是不安全的。）如果它通过 <code>exc_info</code> 参数调用 <code>start_response</code> 的话，应用程序不应当捕获任何由 <code>start_response</code> 抛出的异常。相反，应用程序应该允许类似这样的异常传送回服务器或者网关。更多信息请参考下文的 <a href="#error_handle">错误处理</a> 章节。</p>
<p>当且仅当 <code>exc_info</code> 参数被提供的时候，应用程序有可能多次调用 <code>start_response</code>。更确切的说是，如果 <code>start_response</code> 已经被当前应用程序调用过了，那么没有提供 <code>exc_info</code> 参数的情况下再调用 <code>start_response</code> 将会是一个很严重的错误。（参考上面 CGI 网关示例来帮助理解准确的逻辑。） </p>
<p>注意：实现了 <code>start_response</code> 的服务器，网关，或者中间件应当确保在函数调用期之外没有保存任何指向 <code>exc_info</code> 参数的引用，这样做的目的是为了避免通过回溯（traceback)及有关帧（frames involved）生成一个循环引用（circular reference），最简单的例子可以是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> exc_info:</div><div class="line">         <span class="keyword">try</span>:</div><div class="line">             <span class="comment"># 这里处理 w/exc_info</span></div><div class="line">         <span class="keyword">finally</span>:</div><div class="line">             exc_info = <span class="keyword">None</span>    <span class="comment"># 避免循环引用。</span></div></pre></td></tr></table></figure>
<p><a name="content_length"></a></p>
<h5 id="处理-Content-Length-头信息"><a href="#处理-Content-Length-头信息" class="headerlink" title="处理 Content-Length 头信息"></a>处理 <code>Content-Length</code> 头信息</h5><p></p>
<p>如果应用程序没有提供 <code>Content-Length</code> 头信息，则服务器/网关可以有几种方法来处理它，这些方法当中最简单的就是在响应完成的时候关闭客户端连接。</p>
<p>然而在某些情况下，服务器或网关可能会要么自己生成 <code>Content-Length</code> 头，要么至少避免了关闭客户端连接的需求。如果应用程序没有调用 <code>write()</code> 可迭代对象，返回一个长度 <code>len()</code> 为1的可迭代对象，则服务器可以自动地识别出 <code>Content-Length</code> 的长度，这是通过可迭代对象生成的第一个字符串的长度来判断的。</p>
<p>还有，如果服务器和客户端都支持 HTTP/1.1 中的 『分块传输编码（chunked encoding）』<a name="id3"><a href="#id8">[3]</a> </a>特性，那么服务器可以在每一次调用 <code>write()</code> 方法发送数据块（Chunk）或者由可迭代对象迭代生成的字符串时，由此为每个数据块生成 <code>Content-Length</code> 头。如果它希望这么做的话，这样就可以让服务器保持与客户端的长连接。注意，如果真要这么做，则服务器必须完全遵循 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 规范，要不然就转而寻找其它的策略来处理缺少 <code>Content-Length</code> 的问题。</p>
<p>（注意：应用程序和中间件的输出<strong>一定不能</strong>使用任何类型的传输编码（<code>Transfer-Encoding</code>）技术，比如 chunking 或者 gzipping 这些；因为在『逐跳路由（hop-by-hop）』操作中，这些编码都属于服务器/网关的职权范围。详细信息可以参见下文的 <a href="#HTTP_other">HTTP 的其他特性</a> 章节。）</p>
<p><a name="bufferandstreaming"></a></p>
<h4 id="缓冲和流"><a href="#缓冲和流" class="headerlink" title="缓冲和流"></a>缓冲和流</h4><p></p>
<p>一般而言，应用程序都会选择先缓存（适当大小的）输出再一次性发送的方式来提高吞吐量。现有的 Zope 框架就用的这种常见的处理方法：输出首先会被缓存到 <code>StringIO</code> 或类似的对象里面，然后跟着响应头再一次性被传送出去。  </p>
<p>在 WSGI 中，相应的处理方法是让应用程序简单地返回一个单一元素可迭代对象（single-element iterable）比如列表（List），这个单一元素可迭代对象包含一个单字符串形式的响应体（response body ）。渲染那些文本信息很容易被保存到内存的 HTML 页面，这是一种对于绝大多数应用程序都推荐的工作方式。</p>
<p>然而，对于大文件或专门用途的 HTTP 流媒体（如多部分的『服务器推送』），应用程序或许需要以较小块状的方式提供输出（比如说为了避免加载一个很大的文件到内存中这种情况），还有些时候某些响应体的部分内容可能需要花费很长的时间来生成，这种情况下提前发送该响应体中那些已经生成好的部分还是很有必要的。  </p>
<p>在这种情况下，应用程序通常会返回一个可迭代对象（常见的是生成器迭代器（generator-iterator）），这个可迭代者会以逐块（block-by-block）的方式生成输出。并且这些块有可能会被破坏分成小块，有时是为了跟多块分界线（mulitpart boundaries）（比如『服务器推送』）保持相符，又或者是在一些费时任务（比如读取磁盘文件的另一个块）之前。  </p>
<p>WSGI 服务器/网关和中间件不允许延迟传送任何块；它们要么完整地将所有的块都传送给客户端，要么保证它们会继续向客户端传送块，即使是应用程序正在生成下一个块。一个服务器/网关或者中间件可以以下列三种方案中的任意一种提供保证。  </p>
<ol>
<li>在返回控制权给应用程序之前，发送整个块到操作系统(要求所有的O/S缓存被刷新（flushed）)。  </li>
<li>当应用程序在生成下一个块的时候，使用一个不同的线程来确保当前块能被继续传送。  </li>
<li>（仅使用中间件）来发送整个块到它的父级服务器/网关。  </li>
</ol>
<p>通过提供这样的保证措施，WSGI 就能允许应用程序保证在它们输出数据的过程中在任意点上都不会陷入停滞。这对于确保诸如多部分（multipart）『服务器推送（server push）』流的正常工作是至关重要的，因为在这种情况下多块分界线（multipart boundaries）之间的数据应当被完整地传送至客户端。</p>
<p><a name="middle_block"></a></p>
<h5 id="中间件处理块边界"><a href="#中间件处理块边界" class="headerlink" title="中间件处理块边界"></a>中间件处理块边界</h5><p></p>
<p>为了更好地支持异步应用程序及服务器，中间件组件<strong>一定</strong>不能阻塞迭代，该迭代等待从应用程序的可迭代对象（iterable）中返回多个值。如果中间件需要从应用程序中累积更多的数据才能够生成一个输出，那么它<strong>必须</strong>生成（yield）一个空字符串。</p>
<p>让我们换一种方式来表述这个要求，每一次当下层的应用程序生成了一个值，中间件组件都<strong>必须至少生成一个值</strong>。如果中间件什么值都生成不了，那么它也必须至少生成一个空字符串。</p>
<p>这个要求确保了异步的服务器和应用程序能同谋合作，在同时运行给定数量的应用程序实例时，可以减少所需要的线程数量。</p>
<p>同时也需要注意的是，这样的要求也意味着一旦处于下层的应用程序返回了一个可迭代对象（iterable），中间件就必须尽快地返回一个（iterable）。另外，中间件也不被允许利用 <code>write()</code> 可调用对象（callable）来传输由下层应用程序生成的数据。中间件仅可以使用它父级服务器的 <code>write()</code> 可调用对象（callable）来传送由下层应用程序利用中间件提供的 <code>write()</code> 可调用对象（callable）发送来的数据。</p>
<p><a name="write"></a></p>
<h5 id="可调用-write"><a href="#可调用-write" class="headerlink" title="可调用 write()"></a>可调用 write()</h5><p></p>
<p>一些现有框架的 APIs 与 WSGI 的一个不同处理方式是它们支持无缓存的输出，特别需要指出的是，它们提供一个 <code>write</code> 函数或方法来写一个无缓冲的块或数据，或者它们提供一个缓冲的 <code>write</code> 函数和一个『刷新』（<code>flush</code>）机制来刷新缓冲。  </p>
<p>不幸的是，就 WSGI 这样『可迭代』的应用程序返回值来说，除非使用多线程或其他的机制，否则这样的 APIs 并没有办法实现。</p>
<p>因此为了允许这些框架继续使用这些必要的 APIs，WSGI 中包含了一个特殊的 <code>write()</code> 调用，它由 <code>start_response</code> 可调用对象返回。    </p>
<p>如果有办法避免的话，新的 WSGI 应用程序和框架不应该使用 <code>write()</code> 调用。严格说来，这个 <code>write()</code> 调用是用来支持必要的流 APIs 的。一般来说，应用程序应该通过返回的可迭代对象（iterable）来生成输出，因为这样可以使得 web 服务器在同一个 Python 线程中不同任务之间的交互变得可能，整体上来讲是为服务器提供了更好的吞吐量。</p>
<p>这个 <code>write()</code> 调用是由 <code>start_response</code> 可调用对象返回的，它接受一个唯一的参数：一个将作为部分 HTTP 响应体而被写入的字符串，它被看作是已经被迭代生成后的结果。换句话说，在 <code>writer()</code> 返回前，它必须保证传入的字符串要么已经完全发送给客户端，要么已经在应用程序继续处理的过程当中被缓存用做传输了。  </p>
<p><a name="unicode"></a></p>
<h4 id="Unicode-问题"><a href="#Unicode-问题" class="headerlink" title="Unicode 问题"></a>Unicode 问题</h4><p></p>
<p>HTTP 本身并不对 Unicode 提供直接支持，同样，我们这份接口也不支持 Unicode。所有的编码/解码工作都应当由应用程序端来处理；所有传给服务器或从服务器传出的字符串都必须是 Python 标准的字节字符串而不能是 Unicode 对象。倘若在被要求使用字符串对象的地方使用 Unicode 对象，则会产生不可预料的结果。</p>
<p>也要注意，作为状态或响应头传给 <code>start_response()</code> 方法的字符串在编码方面都<strong>必须</strong>遵循 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 规范。也就是说，它们必须使用 ISO-8859-1 字符集，或者使用 <a href="http://www.faqs.org/rfcs/rfc2047.html" target="_blank" rel="external">RFC 2047 </a>MIME编码。</p>
<p>在 Python 平台上，str 或者 StringType 类型实际上是基于 Unicode的（如jython，ironPython，python 3000，等等），本规范中提到的所有的『字符串』都限制在 ISO-8859-1 编码规范中可表示的代码点（<em>code points，包括\u0000-\u00FF</em>）。如果应用程序提供的字符串包含任何其它的 Unicode 字符或代码点，将有可能会发生严重错误。同样地，服务器和网关也<strong>不能</strong>向应用程序提供任何 Unicode 字符。</p>
<p>再次声明，本规范中提到的所有的字符串都<strong>必须</strong>是 str 类型或 StringType 类型，不能是 unicode 或 UnicodeType 类型。并且，针对本规范中所提到的『字符串』这个词，就算是一些平台允许 str/StringType 对象超过 8 bits 字符，也仅仅是该『字符串』的低位的 8 bits 会被用到。</p>
<p><a name="error_handle"></a></p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p></p>
<p>一般来说，应用程序<strong>应当</strong>自己负责捕获自己的内部错误，并且负责向浏览器输出有用的信息。（由应用程序自己来决定哪些是『有用的信息』）</p>
<p>然而，要显示这样的一条信息，并不是说应用程序真的向浏览器发送了数据，真这样做的话有损坏响应体的风险。因此，WSGI 提供了一种机制，要么允许应用程序发送它自己的错误信息，要么就通过使用传递给 <code>start_response</code> 的 <code>exc_info</code> 参数，自动地终止应用程序。这里有个如何使用它的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 这里是常规的应用程序代码</span></div><div class="line">    status = <span class="string">"200 Froody"</span></div><div class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">"正常的程序体（normal body）放这里"</span>]</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    <span class="comment"># 在这个简陋的『except:』之前，XXX 应该在一个单独的 handler 里捕捉运行时异常，</span></div><div class="line">    <span class="comment"># 譬如 MemoryError，KeyboardInterrupt 这些...</span></div><div class="line">    status = <span class="string">"500 Oops"</span></div><div class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</div><div class="line">    start_response(status, response_headers, sys.exc_info())</div><div class="line">    <span class="keyword">return</span> [<span class="string">"错误的程序体（error body）放在这里"</span>]</div></pre></td></tr></table></figure>
<p>当有异常发生时，如果输出还没有被写入，则对 <code>start_response</code> 的调用将正常返回，然后应用程序会返回一个错误信息体发送至浏览器。然而如果有部分输出已经被发送到浏览器了，那么 <code>start_response</code> 将会重新抛出预备好的异常。这个异常不应当会被应用程序捕获，因此应用程序它会异常终止。服务器/网关会捕获这个（严重）异常并终止响应。  </p>
<p>服务器应当捕获任何迫使应用程序或应用程序迭代返回值终止的异常，并记录日志。如果应用程序出错的时候已经有一部分响应被写入到浏览器了，则服务器或网关可以尝试添加一个错误消息给到输出，当然前提是已经发送了的头信息里有指示一个 <code>text/* content</code> 类型让服务器就知道应该如何干净地做修改。</p>
<p>一些中间件可能会希望提供额外的异常处理服务，或者拦截并替换应用程序的出错信息。在这种情况下，中间件可以选择不重新抛出提供给 <code>start_response</code> 的 <code>exc_info</code>，转而换作是抛出中间件自己专有的异常，或者也可以在存储了所提供的参数之后简单地返回，不包含任何异常。这将会导致应用程序返回它自己的错误信息体可迭代对象（iterable）（或调用 <code>write()</code>  ），然后让中间件来捕获并修改错误输出。以上这些只有在应用程序的开发者们做到下面这些时才可有作用：  </p>
<ol>
<li>每一次当开始一个错误响应的时候，都提供 <code>exc_info</code>。  </li>
<li>当 <code>exc_info</code> 已经提供了的情况下，不要去捕获由 <code>start_response</code> 产生的异常。 </li>
</ol>
<p><a name="HTTP1.1"></a></p>
<h4 id="HTTP-1-1-Expect-Continue机制"><a href="#HTTP-1-1-Expect-Continue机制" class="headerlink" title="HTTP 1.1 Expect/Continue机制"></a><code>HTTP 1.1 Expect/Continue</code>机制</h4><p></p>
<p>那些实现了 HTTP1.1 的服务器/网关，<strong>必须</strong>提供对 HTTP1.1 中『Expect/Continue』机制的透明支持，这可以通过以下几种方式来实现： </p>
<ol>
<li>对含有 <code>Expect: 100-continue</code> 的那些带有 <code>100 Continue</code> 响应的请求做出回应，并正常处理。</li>
<li>正常处理请求，但是额外提供给应用程序一个<code>wsgi.input</code>流，如果应用程序第一次尝试从输入流中读取的时候就发送一个『100 Continue』响应。这个读取请求必须一直保持阻塞状态直到客户端响应请求。  </li>
<li>一直等待，直到客户端确认服务器不支持 <code>expect/continue</code> 特性，然后客户端自己发来请求体。（这个方法较次，不是很推荐。）  </li>
</ol>
<p>注意，以上这些行为的限制不适用于 HTTP 1.0 请求，也不适用于那些往应用程序对象发送的请求。更多关于 HTTP 1.1 Except/Continue 的信息，请参阅 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 的8.2.3章节和10.1.1章节。</p>
<p><a name="HTTP_other"></a></p>
<h4 id="HTTP-的其他特性"><a href="#HTTP-的其他特性" class="headerlink" title="HTTP 的其他特性"></a>HTTP 的其他特性</h4><p></p>
<p>通常来说，服务器和网关应当『尽少干涉』，应当让应用程序对它们自己的输出有100%的控制权。服务器/网关只做一些小的改动并且这些小改动不会影响到应用程序响应的语义（semantics ）。应用程序的开发者总是有可能通过添加中间件来额外提供一些特性的，所以服务器/网关的开发者在实现服务器/网关的时候可以适当偏保守些。在某种意义上说，一个服务器应当将自己看作是一个HTTP『网关服务器（gateway server）』，应用程序则应当将自己看作是一个HTTP 『源服务器（origin server）』（关于这些术语的定义，请参照 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 的1.3章节）</p>
<p>然而，由于 WSGI 服务器和应用程序并不是通过 HTTP 通信的，<a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="external">RFC 2616</a> 中提到的『逐跳路由（hop-by-hop）』并没有应用到 WSGI 内部通信中。因此，WSGI 应用程序一定不能生成任何『逐跳路由（hop-by-hop）』头信息<a name="id4"><a href="#id9">[4]</a></a>，试图使用 HTTP 中要求它们生成这样的报头的特性，或者依赖任何传入的『逐跳路由（hop-by-hop）』 <code>environ</code> 字典中报头。WSGI 服务器必须自己处理所有已经支持的『逐跳路由（hop-by-hop）』头信息，比如为每一个到达的信息做传输解码，如果有的话，解码也要包括那些分块编码（chunked-encoding）的。</p>
<p>如果将这些原则应用到各种各样的 HTTP 特性中去，应该很容易得知：服务器可以通过 <code>If-None-Match</code> 及 <code>If-Modified-Since</code> 请求头，<code>Last-Modified</code> 及 <code>ETag</code> 响应头等方式来处理缓存验证。然而，这并不是必须的，如果应用程序自身支持的话，则应用程序应当自己负责处理缓存验证，因为服务器/网关就没有说必须要做这样的验证。</p>
<p>同样地，服务器可能会对一个应用程序的响应做重编码或传输编码，不过，应用程序应当对自己发送的内容做适当的编码并且不能做传输编码。如果客户端请求需要，则服务器可能以字节范围（byte ranges）的方式传送应用程序的响应，应用程序并没有对字节范围（byte ranges）提供原生支持。再次申明，如果有需要，应用程序则应当自己执行此功能。</p>
<p>注意，这些对应用程序的限制不是说要求每一个应用程序都重新实现一次所有的 HTTP 特性；中间件可以实现许多 HTTP 特性的全部或者一部分，这样便可以让服务器和应用程序作者从一遍又一遍实现这些特性的痛苦中解放出来。 </p>
<p><a name="thread"></a></p>
<h4 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h4><p></p>
<p>除非本身不支持，否则支不支持线程也是取决于服务器自己的。服务器虽然可以同时并行处理多个请求，但也应当提供额外的选择让应用程序可以以单线程的方式运行，这样一来 ，一些不是线程安全的应用程序或框架就可以依旧在这些服务器上运行。</p>
<p><a name="implementandapplication"></a></p>
<h3 id="具体实现-应用程序"><a href="#具体实现-应用程序" class="headerlink" title="具体实现/应用程序"></a>具体实现/应用程序</h3><p></p>
<p><a name="server_api"></a></p>
<h4 id="服务器扩展API"><a href="#服务器扩展API" class="headerlink" title="服务器扩展API"></a>服务器扩展API</h4><p></p>
<p>一些服务器的作者可能希望暴露更多高级的API，让应用程序和框架的作者能用来做更特别的功能。例如，一个基于 <code>mod_python</code> 的网关可能就希望暴露 Apache 部分 API 作为 WSGI 的扩展。</p>
<p>在最简单的情况下，这只需要定义一个 <code>environ</code> 变量，其它的什么都不需要了，比如 <code>mod_python.some_api</code> 。但是，更多情况下，那些可能出现的中间件会就使情况变得复杂的多。比如，一个 API，它提供了访问 <code>environ</code> 变量中出现的同一个 HTTP 报头的功能，如果 <code>environ</code> 变量被中间件修改，则它很可能会返回不一样的值。</p>
<p>通常情况下，任何重复、取代或者绕过部分 WSGI 功能的扩展 API 都会有与中间件组件不兼容的风险。服务器/网关开发者不能寄希望于没人使用中间件，因为有一些框架的作者们明确打算（重新）组织他们的框架，使之几乎完全就像各种中间件一样工作。</p>
<p>所以，为了提供最大的兼容性，提供了扩展 API 来取代部分 WSGI 功能的服务器/网关，必须设计这些 API 以便它们被部分替换过的 API 调用。例如：一个允许访问 HTTP 请求头的扩展 API 需必须要求应用程序传输当前的 <code>environ</code>，以便服务器/网关可以验证那些能被 API 访问的 HTTP 头，验证它们没有被中间件修改过。如果该扩展的 API 不能保证它总是就HTTP报头内容同 <code>environ</code> 达成协议，它就必须拒绝向应用程序提供服务。例如，通过抛出一个错误，返回 None 来代替头信息集合，或者其它任何适合该 API 的东西。</p>
<p>同样地，如果扩展的 API 额外提供了一种方法来写响应数据或头信息，它应当要求 <code>start_response</code> 这个可调用对象在应用程序能获得的扩展的服务之前被传入。如果传入的对象和最开始服务器/网关提供给应用程序的不一样，则它就不能保证正确运转并且必须拒绝给应用程序提供扩展的服务。</p>
<p>这些指南同样适用于中间件，中间件添加类似解析过的 cookies 信息，表单变量，会话 sessions，或者类似 <code>evniron</code>。特别地，这样的中间件提供的这些特性应当像操作 <code>environ</code> 的函数那样，而不仅仅是简单地往 <code>evniron</code> 里面填充值。这样有助于保证来自信息是从 <code>evniron</code> 里计算得来的，在所有中间件完成每一个 URL重写 或对 <code>evniron</code> 做的其它修改之后。</p>
<p>服务器/网关和中间件的开发者们遵守这些『安全扩展』规则是非常重要的，否则以后就可能出现中间件的开发者们为了确保应用程序使用他们扩展的中间件时不被绕过， 而不得不从 <code>environ</code> 中删除一些或者全部的扩展 API 这样的事情。</p>
<p><a name="config"></a></p>
<h4 id="应用程序配置"><a href="#应用程序配置" class="headerlink" title="应用程序配置"></a>应用程序配置</h4><p></p>
<p>这份规范没有定义一个服务器如何选择/获得一个应用程序来调用。因为这和其他一些配置选项一样都是高度取决于服务器的。我们期望那些服务器/网关的作者们能关心并且负责将这些事情文档化：比如如何配置服务器来执行一个特定的应用程序对象，以及需要带什么样的参数（如线程的选项）。</p>
<p>另一方面，Web 框架的作者应当关心这些事情并将它们文档化：比如应该怎样创建一个包装了框架功能的应用程序对象。而已经选定了服务器和应用程序框架的用户，必须将这两者连接起来。然而，现在由于 Web 框架和服务器有了两者之间共同的接口，使得这一切变成了一个机械式的问题，而不再是为了将新的应用程序和服务器配对组合的重大工程了。</p>
<p>最后，一些应用程序，框架，和中间件可能希望使用 <code>evniron</code> 字典来接受一些简单的字符串配置选项。服务器和网关<strong>应当</strong>通过允许应用程序部署者向 <code>evniron</code> 字典里指定特殊的名-值对（name-value pairs）来支持这些。最简单的例子是，由于部署者原则上可以配置这些外部的信息到服务器上，或者在 CGI 的情况下它们可能是通过服务器的配置文件来设置。所以，只从 <code>os.environ</code> 中复制操作系统提供的所有环境变量到<code>environ</code>字典中就可以了。</p>
<p>应用程序本身<strong>应该</strong>尽量保持所需要的变量个数最少，因为并不是所有的服务器都支持简单地配置它们。当然，即使在最槽糕的情况下，部署一个应用程序的人还可以通过创建一个脚本来提供一些必要的选项值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> the_app <span class="keyword">import</span> application</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    environ[<span class="string">'the_app.configval1'</span>] = <span class="string">'something'</span></div><div class="line">    <span class="keyword">return</span> application(environ, start_response)</div></pre></td></tr></table></figure>
<p>但是，大多数现有的应用程序和框架很大可能只需用到 <code>environ</code> 里面的唯一一个配置值，用来指明它们的应用程序或框架特有的配置文件位置。（当然，应用程序应当缓存这些配置，以避免每次调用都重复读取。）</p>
<p><a name="URL"></a></p>
<h4 id="URL-的构建"><a href="#URL-的构建" class="headerlink" title="URL 的构建"></a>URL 的构建</h4><p></p>
<p>如果应用程序希望重建一个请求的完整URL，则可以使用下面的算法，该算法由 lan Bicking 提供：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> quote</div><div class="line">url = environ[<span class="string">'wsgi.url_scheme'</span>]+<span class="string">'://'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> environ.get(<span class="string">'HTTP_HOST'</span>):</div><div class="line">    url += environ[<span class="string">'HTTP_HOST'</span>]</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    url += environ[<span class="string">'SERVER_NAME'</span>]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> environ[<span class="string">'wsgi.url_scheme'</span>] == <span class="string">'https'</span>:</div><div class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'443'</span>:</div><div class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'80'</span>:</div><div class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</div><div class="line"></div><div class="line">url += quote(environ.get(<span class="string">'SCRIPT_NAME'</span>, <span class="string">''</span>))</div><div class="line">url += quote(environ.get(<span class="string">'PATH_INFO'</span>, <span class="string">''</span>))</div><div class="line"><span class="keyword">if</span> environ.get(<span class="string">'QUERY_STRING'</span>):</div><div class="line">    url += <span class="string">'?'</span> + environ[<span class="string">'QUERY_STRING'</span>]</div></pre></td></tr></table></figure>
<p>注意，通过这种方式重建出来的 URL 可能跟客户端真实发过来的 URI 有些许差别。举个例子，服务器的重写规则有可能会对客户端发来的最初请求的 URL 做修改，以便让它看起来更规范。</p>
<p><a name="Python2.2"></a></p>
<h4 id="对-Python2-2-之前的版本的支持"><a href="#对-Python2-2-之前的版本的支持" class="headerlink" title="对 Python2.2 之前的版本的支持"></a>对 Python2.2 之前的版本的支持</h4><p></p>
<p>有些服务器，网关或者应用程序可能希望对 Python2.2 之前的版本提供支持。这对于目标平台是 Jython 来说更是如此，因为在我写这篇文档的时候，还没有一个生产版本的 Jython 2.2。</p>
<p>对于服务器和网关来说，这是相当容易做到的：准备使用 Python 2.2 之前的版本的服务器和网关，只需要简单地限定它们自己只使用标准的『for』来循环迭代应用程序返回来的所有可迭代对象（iterable）即可。这是能在代码级别确保 2.2 之前的版本的迭代器协议(后续会讲)跟『现在的』迭代器协议（参照 <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="external">PEP234</a> ）兼容的唯一方法。</p>
<p>（需要注意的是，这个技巧当然只针对那些由 Python 写的服务器，网关，或者中间件。至于如何正确地在其他语言写的服务器中使用迭代器协议则不在我们这份 PEP 的讨论范围之内。）</p>
<p>不过，对于应用程序这边来说，要提供对 Python2.2 之前的版本的支持则会稍微复杂些：</p>
<ul>
<li><p>由于 Python 2.2 之前，文件并不是可迭代的，故你不能返回一个文件对象并期望它能像一个可迭代对象那样工作。（总体来说，你也不能这么做，因为大部分情况下这样做的表现很糟糕）。可以使用 <code>wsgi.file_wrapper</code> 或者一个应用程序特有的文件包装类。（请参考 <a href="#optional">可选的平台相关的文件处理</a> 章节获取更多关于 <code>wsgi.file_wrapper</code> 的信息，该章节有一个怎么把一个文件包装成一个可迭代对象的例子。）</p>
</li>
<li><p>如果你想返回一个定制加工过的可迭代对象，那么它必须实现 2.2 版本之前的迭代器协议。也就是说，提供一个 <code>__getitem__</code> 方法来接收一个整形的键值，然后在所有数据都取完的时候抛出一个 <code>IndexError</code> 异常。（注意，直接使用内置的序列类型也是可行的，因为它也实现了这个迭代器协议。)</p>
</li>
</ul>
<p>最后，如果中间件也希望对 Python2.2 之前的版本提供支持，迭代应用程序返回的所有值或者由它自己返回一个可迭代对象（又或者是两者都有），那么这些中间件必须遵循以上提到的这些建议。</p>
<p>（另外，为了支持 Python2.2 之前的版本，毫无疑问，任何服务器，网关，应用程序，或者中间件必须只能使用该版本有的语言特性，比如用1和0，而不是 True 和 False，诸如此类。)</p>
<p><a name="optional"></a></p>
<h4 id="可选的平台相关的文件处理"><a href="#可选的平台相关的文件处理" class="headerlink" title="可选的平台相关的文件处理"></a>可选的平台相关的文件处理</h4><p></p>
<p>有些操作环境提供了特殊的高性能文件传输机制，比如 Unix 下的 <code>sendfile()</code> 方法。服务器和网关可以通过 <code>environ</code> 变量中的 <code>wsgi.file_wrapper</code> 这个选项来使用这个机制。应用程序可以使用这样的『文件包装（file wrapper）』来将一个文件或者类文件对象（file-like object ）转换为一个可迭代对象然后返回它。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'wsgi.file_wrapper'</span> <span class="keyword">in</span> environ:</div><div class="line">    <span class="keyword">return</span> environ[<span class="string">'wsgi.file_wrapper'</span>](filelike, block_size)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">return</span> iter(<span class="keyword">lambda</span>: filelike.read(block_size), <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p>如果一个服务器或网关有提供 <code>wsgi.file_wrapper</code> 选项，则它必须是个可调用对象（callable），并且这个可调用者接受一个必要的位置参数，和一个可选的位置参数。第一个参数是将要发送的类文件对象，第二个参数是可选的，表示分块大小（block size）的建议（这个服务器/网关无需使用）。这个可调用者必须返回一个可迭代的对象（iterable object），并且在服务器/网关真正从应用程序那里接收到了一个可迭代者作为返回值之前，不能执行任何的数据传送（否则会阻碍中间件解析或覆盖响应数据（response data））。</p>
<p>至于那个由应用程序提供的被当作是类文件的对象，它则必须拥有一个 <code>read()</code> 方法并接受一个可选的 size 参数。它可能还需要有一个 <code>close()</code> 方法，如果有，那么由 <code>wsgi.file_wrapper</code> 返回的可迭代对象它必须有一个 <code>close()</code> 方法可以调用最初的类文件对象中的 <code>close()</code> 方法。如果这个『类文件』对象还拥有任何与Python内置的文件对象的属性或方法名相同的方法或属性（例如 <code>fileno()</code> ），那么 <code>wsgi.file_warpper</code> 可能会假设这些方法或属性跟 Python 内置的文件对象的语义（semantics）是相同的。</p>
<p>在真实的实现中，任何平台相关的的文件处理都必须发生在应用程序返回之后，接着服务器/网关会去检查一个包装对象（wrapper object）是否有返回。（再次声明，由于存在中间件，错误处理等等类似的东西，所以并不保证任何生成的包装（wrapper）会被真正地使用到。）</p>
<p>除了处理 <code>close()</code> 方法，从语义上讲，应用程序返回一个包装的文件（file wrapper ）应当看起来就像是应用程序返回了一个可迭代者 <code>iter(filelike.read, &#39;&#39;)</code> 一样。换句话说，当传输开始的时候，应当从文件的当前位置开始传输，并且继续直到最后完成。</p>
<p>当然，平台相关的文件传输 API 通常不接受随意的类文件对象，所以，一个 <code>wsgi.file_wrapper</code> 为了判断类文件对象是否适用于支持的平台相关的 API，不得不对提供的对象做一些类似 <code>fileno()</code>（类Unix 平台下）或者是 <code>java.nio.FileChannel</code>（Jython下）的自省检查。</p>
<p>注意：即使对象不适用与特定的平台 API，<code>wsgi.file_wrapper</code> 必须仍旧返回一个包装了的 <code>read()</code> 和 <code>close()</code> 的迭代，因此应用程序使用这文件包装器便可以在不同平台间移植。这里有个简单的平台无关的文件包装类，适应于旧的（2.2之前）和新的 Python，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileWrapper</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filelike, blksize=<span class="number">8192</span>)</span>:</span></div><div class="line">        self.filelike = filelike</div><div class="line">        self.blksize = blksize</div><div class="line">        <span class="keyword">if</span> hasattr(filelike, <span class="string">'close'</span>):</div><div class="line">            self.close = filelike.close</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        data = self.filelike.read(self.blksize)</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> data</div><div class="line">        <span class="keyword">raise</span> IndexError</div></pre></td></tr></table></figure>
<p>这里是一段来自服务器/网关的小程序，它提供了访问一个特定平台的 API 的办法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">environ[<span class="string">'wsgi.file_wrapper'</span>] = FileWrapper</div><div class="line">result = application(environ, start_response)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">if</span> isinstance(result, FileWrapper):</div><div class="line">        <span class="comment"># 检查 result.filelike 是否为可用的 w/platform-specific API，</span></div><div class="line">        <span class="comment"># 如果是，则使用该API来传送结果。</span></div><div class="line">        <span class="comment"># 如果不是，则按正常情况循环处理可迭代者(iterable)。</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> result:</div><div class="line">        <span class="comment"># etc.</span></div><div class="line"></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</div><div class="line">        result.close()</div></pre></td></tr></table></figure>
<p><a name="QA"></a></p>
<h3 id="问题和回答"><a href="#问题和回答" class="headerlink" title="问题和回答"></a>问题和回答</h3><p></p>
<ol>
<li><p>为什么 <code>environ</code> 必须是字典？用子类（subclass）不行吗？<br>用字典的原因是为了最大化地满足在服务器之间的移植性。还有另一种选择就是定义一些字典方法的子集，并以字典的方法作为标准的便捷接口。然而事实上，大多数的服务器可能只需要找到一个合适的字典就足够它们用了，并且框架的作者们往往期待完整可用的字典特性，因为多半情况下是这样的。不过问题是如果有一些服务器选择不用字典，那么尽管这类服务器也『符合』规范，还是会出现互用性的问题。因此强制使用字典的话，就简化了这份规范并且并确保了互用性。<br>注意，以上这些并不妨碍服务器或框架的开发者们向 <code>environ</code> 字典里加入自定义的变量来提供特殊的服务。事实上我们鼓励使用这种方式来提供任意的增值服务。</p>
</li>
<li><p>为什么你既可以调用 <code>write()</code> 又可以生成（yield）字符串/返回一个可迭代对象（iterable）？我们难道不应该只选择一种做法吗？<br>如果我们仅仅使用迭代的做法，那么现存的框架将遭受『推送（push）』可用性的折磨。但是，如果我们只支持通过 <code>write()</code> 推送，那么服务器在传输大文件的时候性能将恶化（如果一个工作线程（worker）没有将所有的输出都发送完成，那么它将无法进行下一个新的请求）。因此，我们做这样的妥协，好处是允许应用程序支持这两种方法，视情况而定，并且比起单纯的 push-only 的方式来说，只会给那些服务器的实现者们增加一点点负担而已。</p>
</li>
<li><p><code>close()</code> 方法是拿来做什么的？<br>在应用程序执行期间，当写动作（writes）完成之后，应用程序可以通过一个 <code>try/finally</code> 代码块来确保资源都被释放了。但是，如果应用程序返回一个可迭代对象（iterable），那么在迭代器被垃圾收集器收集之前任何资源都不会被释放。这里的 <code>close()</code> 惯用法允许应用程序在一个请求完成阶段释放重要资源，并且它向前兼容 <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="external">PEP 325</a> 里关于迭代器的 <code>try/finally</code> 用法。</p>
</li>
<li><p>为什么这个接口要设计地这么初级？我希望添加更多酷炫的功能！（比如cookies， 会话（sessions）， 持久性（persistence），巴拉巴拉巴拉…)<br>记住，这并不是另一个 Python 的 web 框架，这仅仅是一个框架向 web 服务器通信的方法，反之亦然。如果你想拥有上面所说的这些特性，你需要选一个提供了这些特性的框架。并且如果这个框架让你创建一个 WSGI 应用程序，你将可以让它跑在大多数支持 WSGI 的服务器上面。同样的，一些 WSGI 服务器或许会通过在它们的 <code>environ</code> 字典里提供的对象来提供一些额外的服务；可以参阅这些服务器具体的文档了解详情。（当然，使用这类扩展的应用程序将面临着无法移植到其他基于 WSGI 的服务器上的风险。）</p>
</li>
<li><p>为什么使用 CGI 的变量而不是旧的 HTTP 头呢？并且为什么将它们和 WSGI 定义的变量混在一起呢？<br>许多现有的框架很大程度上是建立在 CGI 规范基础上的，并且现有的 web 服务器知道如何生成CGI变量。相比之下，其他表示u接收的 HTTP 信息的方式不仅分散破碎更缺乏市场支持。因此使用 CGI 『标准』看起来是个不错的办法，它能最大化发挥现有的实现。至于将它们同 WSGI 变量混合在一起，那是因为分它们的话会导致需要传入两个字典参数，显然这样做没什么好处。</p>
</li>
<li><p>那关于状态字符串，我们可不可以仅仅使用数字来代替，比如说传入『200』而不是『200 OK』？<br>这样做会使服务器/网关变得复杂化，因为那样的话服务器/网关就需要一个数值状态和相应信息的映射表。相比之下，让应用程序或框架的作者们在他们处理专门的响应代码时顺便输入一些额外的信息则显得要简单地多，并且事实上，经常是现有的框架已经有一个这样的映射表包含这些需要的信息了。总之，权衡之后，我们认为这个让应用程序/框架来负责要比服务器或网关来负责要更适合些。  </p>
</li>
<li>为什么 <code>wsgi.run_once</code> 不能保证 app 仅仅运行一次？<br>因为它仅仅只是建议应用程序应当『装备妥当但不需要经常性地运行（rig for infrequent running）』。这是因为应用程序框架在操作缓存、会话这些东西的时候有多种模式。在『多重运行（Multiple Run）』模式下，框架可能会预先加载缓存，并且在每个请求之后可能不会有写操作，比如写日志或会话数据到硬盘上等操作。在『单运行（single run）』模式下，框架没有预加载，避免了在每一个请求之后刷新（flush）所有必要的写操作。<br>然而，为了验证在后者的模式下应用程序或框架的正确操作，可能会必要地（或是权宜之计）不止一次调用它。因此，一个应用程序不应当仅仅因为设置了 <code>wsgi.run_once</code> 为 True 就认定它肯定不会被再次运行。  </li>
<li>在应用程序代码里使用 Feature X（字典（dictionaries），可调用对象（callables）等等）这些特性显得很丑陋，难道我们不可以使用对象来代替吗？<br>WSGI 中这些所有特性的实现选择都是为了从另外一个特性中解耦合考虑的；将这些特性重新组装到一个封装完好了的对象之中只会在一定程度上增大写服务器/网关的难度，并且在将来希望写一个中间件来只代替/修改一小部分整体功能的时候，难度会上升一个数量级。<br>本质上，中间件希望有个『职责连』的模式，凭借这个模式它可以在一些功能中被看成是一个『handler』，而同时允许其他功能保持不变。这样的要求，在接口想要保持可扩展性的前提下，用普通的 Python 对象是比较难实现的。例如，你必须使用 <code>__getattr__</code> 或者 <code>__getattribut__</code> 的重写（override）来确保这些扩展（比如未来的 WSGI 版本定义的变量）是被通过的。<br>这种类型的代码是出了名的难以保证100%正确的，并且极少人愿意自己重写。他们倾向于简单地复用别人的实现，可是一旦别人修改了实现的另一处地方时他们却未能及时更新自己的拷贝。<br>进一步讲，这种必需的样本代码将是纯碎的消费税，一种纯粹由中间件开发者们承担的开发者消费税，它的目的仅仅是为了能给应用程序框架开发者们支持稍微『漂亮』点儿的API而已。但是，应用框架开发者们往往只会更新一个框架来支持 WSGI，这只占他们所有框架的非常有限的部分。这很可能是他们的第一个（也可能是唯一一个）WSGI实现，因此他们很有可能去实现这份现成的规范。这样，花时间利用对象的属性或诸如此类的东西让这些 API 看起来『更漂亮』，对正在读此文的你们来说，可能就是浪费时间。<br>我们鼓励那些希望在直接的 Web 应用程序编程（相对于 web 框架开发）中有更漂亮的（或是改进的）WSGI 接口的人，鼓励他们去开发 APIs 或者框架来包装 WSGI，使 WSGI 对那些应用程序开发者们更加便利。这样的话，WSGI 就不仅可以在底层维持对服务器或中间件的便利性，同时对应用程序开发者来说又不会显得太『丑陋』。</li>
</ol>
<p><a name="in_discussion"></a></p>
<h3 id="尚在讨论中的提议"><a href="#尚在讨论中的提议" class="headerlink" title="尚在讨论中的提议"></a>尚在讨论中的提议</h3><p></p>
<p>下面这些项都还正在 Web-SIG 或其他地方讨论中，或者说还在 PEP 作者的计划清单中：</p>
<ul>
<li><code>wsgi.input</code> 是否改成一个迭代器而不是一个文件？这对于那些异步应用程序和分块编码（ chunked-encoding）的输入流是有帮助的。   </li>
<li>我们正在讨论可选的扩展，它们将用来暂停一个应用程序输出的迭代，直到输入可用或者发生一个回调事件。</li>
<li>添加一个章节，关于同步 vs 异步应用程序和服务器，相关的线程模型，以及这方面的问题/设计目标。</li>
</ul>
<p><a name="acknowledgements"></a></p>
<h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p></p>
<p>感谢那些 Web-SIG 邮件组里面的人，没有他们周全的反馈，将不可能有我这篇修正草案。我还要特别感谢：   </p>
<ul>
<li><code>mod_python</code> 的作者 Gregory “Grisha” Trubetskoy，是他毫不留情地指出了我的第一版草案没有提供任何比『普通旧版的CGI』有优势的地方，他的批评促进了我去寻找更好的方法。    </li>
<li>Ian Bicking，是他总是唠叨着要我适当地提供多线程（multithreading）及多进程（multiprocess）相关选项，对了，他还不断纠缠我让我提供一种机制可以让服务器向应用程序提供自定义的扩展数据。  </li>
<li>Tony Lownds，是他提出了 <code>start_response</code> 函数的概念，提供给它 status 和 headers 两个参数然后返回一个 write 函数。他的这个想法为我后来设计异常处理功能提供了灵感，尤其是在考虑到中间件重写(overrides)应用程序的错误信息这方面。  </li>
<li>Alan Kennedy, 一个有勇气去尝试实现 <code>WSGI-on-Jython</code>（在我的这份规范定稿之前）的人，他帮助我形成了 <a href="#Python2.2">对Python2.2之前的版本的支持</a> 这一章节，以及可选的 <code>wsgi.file_wrapper</code> 套件。  </li>
<li>Mark Nottingham，是他为这份规范的 HTTP RFC 发行规范做了大量的后期校对工作，特别针对 HTTP/1.1 特性，没有他的指出，我甚至不知道有这东西存在。  </li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><br><a name="id6"><br><a href="#id1">[1]</a>    The Python Wiki “Web Programming” topic ( <a href="http://www.python.org/cgi-bin/moinmoin/WebProgramming" target="_blank" rel="external">http://www.python.org/cgi-bin/moinmoin/WebProgramming</a> )<br></a><br><a name="id7"><br><a href="#id2">[2]</a>    The Common Gateway Interface Specification, v 1.1, 3rd Draft ( <a href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt" target="_blank" rel="external">http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt</a> )<br></a><br><a name="id8"><br><a href="#id3">[3]</a>    “Chunked Transfer Coding” – HTTP/1.1, section 3.6.1 ( <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1" target="_blank" rel="external">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1</a> )<br></a><br><a name="id9"><br><a href="#id4">[4]</a>    “End-to-end and Hop-by-hop Headers” – HTTP/1.1, Section 13.5.1 ( <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1" target="_blank" rel="external">http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1</a> )<br></a><br><a name="id10"><br><a href="#id5">[5]</a>    mod_ssl Reference, “Environment Variables” ( <a href="http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25" target="_blank" rel="external">http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25</a> )<br></a></p>
<p><a name="copyright"></a></p>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p><br>这篇文档属于公共领域。<br>原始文档: <a href="https://hg.python.org/peps/file/tip/pep-0333.txt" target="_blank" rel="external">https://hg.python.org/peps/file/tip/pep-0333.txt</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Web/" rel="tag">#Web</a>
          
            <a href="/tags/Python/" rel="tag">#Python</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/04/Redis 入门指北/" rel="next" title="Redis 入门指北">
                <i class="fa fa-chevron-left"></i> Redis 入门指北
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/26/github-ready-to-go/" rel="prev" title="github, ready to go?">
                github, ready to go? <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/6964284?v=3&s=460"
               alt="Frank" />
          <p class="site-author-name" itemprop="name">Frank</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">175</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">125</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2753500945" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录："><span class="nav-number">1.</span> <span class="nav-text">目录：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序言"><span class="nav-number">2.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#摘要"><span class="nav-number">3.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本原理和目标"><span class="nav-number">4.</span> <span class="nav-text">基本原理和目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规范概述"><span class="nav-number">5.</span> <span class="nav-text">规范概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用程序-框架-端"><span class="nav-number">5.1.</span> <span class="nav-text">应用程序/框架 端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器-网关-端"><span class="nav-number">5.2.</span> <span class="nav-text">服务器/网关 端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间件：可扮演两端角色的组件"><span class="nav-number">5.3.</span> <span class="nav-text">中间件：可扮演两端角色的组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规范细则"><span class="nav-number">6.</span> <span class="nav-text">规范细则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#environ-变量"><span class="nav-number">6.1.</span> <span class="nav-text">environ 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#输入和错误流"><span class="nav-number">6.1.1.</span> <span class="nav-text">输入和错误流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可调用-start-response"><span class="nav-number">6.2.</span> <span class="nav-text">可调用 start_response()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理-Content-Length-头信息"><span class="nav-number">6.2.1.</span> <span class="nav-text">处理 Content-Length 头信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲和流"><span class="nav-number">6.3.</span> <span class="nav-text">缓冲和流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中间件处理块边界"><span class="nav-number">6.3.1.</span> <span class="nav-text">中间件处理块边界</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可调用-write"><span class="nav-number">6.3.2.</span> <span class="nav-text">可调用 write()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unicode-问题"><span class="nav-number">6.4.</span> <span class="nav-text">Unicode 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">6.5.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-1-1-Expect-Continue机制"><span class="nav-number">6.6.</span> <span class="nav-text">HTTP 1.1 Expect/Continue机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-的其他特性"><span class="nav-number">6.7.</span> <span class="nav-text">HTTP 的其他特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程支持"><span class="nav-number">6.8.</span> <span class="nav-text">线程支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现-应用程序"><span class="nav-number">7.</span> <span class="nav-text">具体实现/应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器扩展API"><span class="nav-number">7.1.</span> <span class="nav-text">服务器扩展API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用程序配置"><span class="nav-number">7.2.</span> <span class="nav-text">应用程序配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL-的构建"><span class="nav-number">7.3.</span> <span class="nav-text">URL 的构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对-Python2-2-之前的版本的支持"><span class="nav-number">7.4.</span> <span class="nav-text">对 Python2.2 之前的版本的支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选的平台相关的文件处理"><span class="nav-number">7.5.</span> <span class="nav-text">可选的平台相关的文件处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题和回答"><span class="nav-number">8.</span> <span class="nav-text">问题和回答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尚在讨论中的提议"><span class="nav-number">9.</span> <span class="nav-text">尚在讨论中的提议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#鸣谢"><span class="nav-number">10.</span> <span class="nav-text">鸣谢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献"><span class="nav-number">11.</span> <span class="nav-text">参考文献</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版权声明"><span class="nav-number">12.</span> <span class="nav-text">版权声明</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'knarfeh';
      var disqus_identifier = '2017/01/30/【译】PEP333-Python Web Server Gateway Interface v1.0/';
      var disqus_title = '【译】PEP333-Python Web Server Gateway Interface v1.0';
      var disqus_url = 'http://knarfeh.github.io/2017/01/30/【译】PEP333-Python Web Server Gateway Interface v1.0/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  


  

  <script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
