<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Golang,cryptocurrency,geth," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。">
<meta name="keywords" content="Golang,cryptocurrency,geth">
<meta property="og:type" content="article">
<meta property="og:title" content="go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）">
<meta property="og:url" content="http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/index.html">
<meta property="og:site_name" content="knarfeh&#39;s logbook">
<meta property="og:description" content="阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-27T03:49:03.940Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）">
<meta name="twitter:description" content="阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> go-ethereum 源码笔记（core, eth 模块-链的索引，搜索） | knarfeh's logbook </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-75002639-1', 'auto');
  ga('send', 'pageview');
</script>









  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">knarfeh's logbook</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-10T22:35:09+08:00" content="2018-03-10">
              2018-03-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="事件和日志"><a href="#事件和日志" class="headerlink" title="事件和日志"></a>事件和日志</h3><p>在以太坊中，事件和日志的概念经常被混用可能会让人觉得困惑，所以我们先理清这两者关系。在 Solidity 和 web3.js 里，这个概念叫做 Event，常用中文翻译是事件，它的作用是在智能合约的运行中，将一些比较重要的数据记录到区块链上，在 geth 里称为日志，这些日志与合约地址是相关联的，geth 会不断地对事件，或者说日志进行索引，也会通过暴露 API 的方式让用户可以过滤，查找日志。比较典型的应用场景是，用户在页面上调用了智能合约，在智能合约里发生了一次转账的操作，这时记录一个事件，应用程序通过 web3.js 监听事件，一旦事件发生了，可以触发回调函数，进行下一步处理，比如在 UI 上做出响应。</p>
<p>每一笔交易的收据可能会包含0个到多个日志记录，它们代表着智能合约在运行过程中触发的事件。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>在 geth 中，日志的索引，过滤通过布隆过滤器来实现。</p>
<p>布隆过滤器可以用来判断一个元素是否在一个集合中，对于这种场景，最简单的方式是采用 HashTable 的方式来存储，好处是快速，精确，但会耗费大量的存储空间。1970年布隆提出一种空间复杂度和空间复杂度都很低的数据结构，利用位数组来表示一个集合，键值经过 k 个独立哈希函数后，将对应的值的位数置1，查找时进行同样的哈希计算，如果对应位全为1说明该值存在，它的缺点是有一定的错误率，它不能告诉你某个元素一定在集合内，但它可以告诉你某个元素一定不在集合内或可能在集合内。误算率的大小与数据的数量，布隆过滤器的长度，以及哈希函数有关。</p>
<p>如果想要深入了解布隆过滤器，建议浏览：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a> </li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
</ul>
<h4 id="误算率推导"><a href="#误算率推导" class="headerlink" title="误算率推导"></a>误算率推导</h4><p>假设布隆过滤器有 m 比特，里面有 n 个元素，每个元素对应 k 个哈希函数处理后的比特位，插入一个元素时，哈希函数会把过滤器中的某个比特位置置为1，对于一个特定的位置，如果这个元素经哈希过的 k 个比特位都没有把它置为 1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^k$</p>
<p>如果插入了 n 个元素还没有把某个特定的比特位置为1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>因此，插入了 n 个元素，某个特定比特位置为1的概率为：</p>
<p>$1-\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>对于一个错误识别的元素，经哈希过的 k 个比特位均为1，概率为：</p>
<p>$\left(1-\left[1-\frac{1}{m}\right]^{kn}\right)^k$</p>
<p>有 $\lim_{x\to0}\frac{e^x-1}{x}=1$ ，则 $m\to\infty$时，上述公式近似于：</p>
<p>$\left( 1-e^{\frac{-kn}{m}} \right)^k$</p>
<p>设 $a=e^{\frac{n}{m}}$, 错误识别的概率为：</p>
<p>$f(k) = (1-a^{-k})^{k}$</p>
<p>我们需要知道，在 k 取什么值时，$f(k)$ 可以取到最值。先两边取对数：</p>
<p>$\frac{f’(k)}{f(k)}=\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}$</p>
<p>令导数 $f’(k)$为0，有：</p>
<p>$\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}=0$</p>
<p>$(1-a^{-k})\cdot\ln\left(1-a^{-k}\right)=a^{-k}\cdot\ln{a}^{-k}$</p>
<p>对于 $f(x)=xlnx$，可证，不存在 $x_1+x_2=1$，使得 $f(x_1) = f(x_2)$</p>
<p>可得 $a^{k}=2$</p>
<p>即 $k=\frac{m}{n}\cdot ln{2}$ 时，误判率 $f(k)$ 可取到最小值，为 $2^{-ln 2\cdot\frac{m}{n}}$</p>
<p>还有一个结论，当 $k=\frac{m}{n}\cdot ln{2}$，$\left(1-\frac{1}{m}\right)^{kn}=\frac{1}{2}$ 也就是说某个 bit 位在插入 n 个元素后未被置1的概率为 $\frac{1}{2}$，即空间使用率为 50%，也就是说，要保持错误率低，布隆过滤器的空间使用率应小于 50%。根据空间使用率，我们可以推导 n，k 确定的情况下，要保持错误率最低，所需的最小内存空间（即 m 的大小）是多少，这个值应该为 n*k 的两倍。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>Bigtable 使用布隆过滤器查找不存在的行或列，以减少磁盘查找的 IO 次数</li>
<li>Google Chrome 浏览器使用布隆过滤器加速安全浏览服务</li>
<li>LevelDB, Hbase, Accumulo 等 key-value 数据库使用布隆过滤器加速查询过程，避免很多不必要的磁盘 IO 操作</li>
</ul>
<h2 id="geth-的实现"><a href="#geth-的实现" class="headerlink" title="geth 的实现"></a>geth 的实现</h2><p>geth 的索引，过滤功能包括对交易，区块，区块头，最新日志，特定日志的过滤，代码涉及到 <code>eth/filters</code>, <code>eth/bloombits.go</code>, <code>core/chain_indexer.go</code>, <code>core/bloombits</code> 等模块。内部的实现其实挺复杂，重构一下可能会好很多，深入到这些功能的实现，还是要有章法，采用从上之下的方式是比较好的，否则直接阅读内部实现的话，可能线索会比较错乱，不如先从 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 提供的几个 API 入手，从入口开始剖析。geth 的索引过滤功能底层的实现主要依赖布隆过滤器，读者如果在阅读下文之前就熟悉布隆过滤器自然再好不过，不了解的话可以先从 API 调用入手，在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%EF%BC%89/#%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="external">过滤功能的使用</a>这小节结束后再好好学习相关基础知识以加强理解。</p>
<h3 id="过滤功能的使用"><a href="#过滤功能的使用" class="headerlink" title="过滤功能的使用"></a>过滤功能的使用</h3><p>这里指的使用是指比较高层次的，通过 web3.js 可以直接进行交互的调用。</p>
<p>使用布隆过滤器的代码主要在 <code>eth/filter</code> 文件夹里。</p>
<p><code>eth/filter</code> 模块比较直观地提供了日志过滤的功能，这里我们可以先将布隆过滤器的实现视为黑盒，看看所谓的日志，收据的过滤到底是一个什么功能。</p>
<p>先看 <code>eth/filters/api.go</code> 里的内容。</p>
<h4 id="api-go"><a href="#api-go" class="headerlink" title="api.go"></a>api.go</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> filter <span class="keyword">struct</span> &#123;</div><div class="line">	typ      Type</div><div class="line">	deadline *time.Timer</div><div class="line">	hashes   []common.Hash</div><div class="line">	crit     FilterCriteria</div><div class="line">	logs     []*types.Log</div><div class="line">	s        *Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> PublicFilterAPI <span class="keyword">struct</span> &#123;</div><div class="line">	backend   Backend</div><div class="line">	mux       *event.TypeMux</div><div class="line">	quit      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	chainDb   ethdb.Database</div><div class="line">	events    *EventSystem</div><div class="line">	filtersMu sync.Mutex</div><div class="line">	filters   <span class="keyword">map</span>[rpc.ID]*filter</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>filter</code> 结构体用来存储过滤器的一些元信息，<code>PublicFilterAPI</code> 用来创建和管理这些过滤器，供外部客户端调用，它暴露的 API 在 Backend 里定义，这部分内容在 <code>eth/filters/filter.go</code> 里面，在之后会详细看这部分。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><code>PublicFilterAPI</code> 初始化的逻辑很简单，就一个 New 外加 <code>go api.timeoutLoop()</code> 一行而已，这里不再给出初始化的代码了。由于需要注册 API，同其他 backend 一样，调用 <code>NewPublicFilterAPI</code> 进行服务注册的部分在 <code>eth/backend.go</code> 中，有兴趣的话读者可以自己看看。</p>
<h5 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">timeoutLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	ticker := time.NewTicker(<span class="number">5</span> * time.Minute)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		&lt;-ticker.C</div><div class="line">		api.filtersMu.Lock()</div><div class="line">		<span class="keyword">for</span> id, f := <span class="keyword">range</span> api.filters &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-f.deadline.C:</div><div class="line">				f.s.Unsubscribe()</div><div class="line">				<span class="built_in">delete</span>(api.filters, id)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		api.filtersMu.Unlock()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PublicFilterAPI</code> 初始化时只用了一个 goroutine 来启动 <code>timeoutLoop()</code>，<code>timeoutLoop()</code> 做的事情很简单，对于加入到 <code>PublicFilterAPI</code> 的 filters，每过5分钟检查一次，如果过期了就删除 filter。</p>
<h5 id="增加-filter"><a href="#增加-filter" class="headerlink" title="增加 filter"></a>增加 filter</h5><p><code>PublicFilterAPI</code> 的主循环会处理 <code>filter</code>，那么 <code>filter</code> 是怎么添加的，其实是通过 <code>NewPendingTransactionFilter</code> 来添加，这个 API 也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 直接调用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactionFilter</span><span class="params">()</span> <span class="title">rpc</span>.<span class="title">ID</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		pendingTxs   = <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash)</div><div class="line">		pendingTxSub = api.events.SubscribePendingTxs(pendingTxs)</div><div class="line">	)</div><div class="line"></div><div class="line">	api.filtersMu.Lock()</div><div class="line">	api.filters[pendingTxSub.ID] = &amp;filter&#123;typ: PendingTransactionsSubscription, deadline: time.NewTimer(deadline), hashes: <span class="built_in">make</span>([]common.Hash, <span class="number">0</span>), s: pendingTxSub&#125;</div><div class="line">	api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> ph := &lt;-pendingTxs:</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="keyword">if</span> f, found := api.filters[pendingTxSub.ID]; found &#123;</div><div class="line">					f.hashes = <span class="built_in">append</span>(f.hashes, ph...)</div><div class="line">				&#125;</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">			<span class="keyword">case</span> &lt;-pendingTxSub.Err():</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="built_in">delete</span>(api.filters, pendingTxSub.ID)</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> pendingTxSub.ID</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于非长连接的情况，也就是说对于使用 HTTP 的方式进行过滤的情况，可以使用这个 API，它可以用来创建一个 filter，当有新交易时，会存储到 filter 的哈希池里。</p>
<p>然后客户端可以通过轮询该 filter 来获取过滤的结果。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetFilterChanges</span><span class="params">(id rpc.ID)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	api.filtersMu.Lock()</div><div class="line">	<span class="keyword">defer</span> api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f, found := api.filters[id]; found &#123;</div><div class="line">		<span class="keyword">if</span> !f.deadline.Stop() &#123;</div><div class="line">			&lt;-f.deadline.C</div><div class="line">		&#125;</div><div class="line">		f.deadline.Reset(deadline)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> f.typ &#123;</div><div class="line">		<span class="keyword">case</span> PendingTransactionsSubscription, BlocksSubscription:</div><div class="line">			hashes := f.hashes</div><div class="line">			f.hashes = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnHashes(hashes), <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> LogsSubscription:</div><div class="line">			logs := f.logs</div><div class="line">			f.logs = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnLogs(logs), <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;, fmt.Errorf(<span class="string">"filter not found"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterchanges" target="_blank" rel="external">JSON-RPC</a> 进行调用。</p>
<p>对于长连接的情况，可以使用 rpc 包的发送订阅模式功能，直接调用 <code>NewPendingTransactions</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactions</span><span class="params">(ctx context.Context)</span> <span class="params">(*rpc.Subscription, error)</span></span> &#123;</div><div class="line">	notifier, supported := rpc.NotifierFromContext(ctx)</div><div class="line">	<span class="keyword">if</span> !supported &#123;</div><div class="line">		<span class="keyword">return</span> &amp;rpc.Subscription&#123;&#125;, rpc.ErrNotificationsUnsupported</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	rpcSub := notifier.CreateSubscription()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		txHashes := <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash, <span class="number">128</span>)</div><div class="line">		pendingTxSub := api.events.SubscribePendingTxs(txHashes)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> hashes := &lt;-txHashes:</div><div class="line">				<span class="keyword">for</span> _, h := <span class="keyword">range</span> hashes &#123;</div><div class="line">					notifier.Notify(rpcSub.ID, h)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> &lt;-rpcSub.Err():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-notifier.Closed():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> rpcSub, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是对交易的过滤，此外 <code>PublicFilterAPI</code> 还提供了对区块，区块头，最新日志的过滤，如果有兴趣的话可以看 <code>func (api *PublicFilterAPI) NewBlockFilter()</code>, <code>func (api *PublicFilterAPI) NewHeads</code>, <code>func (api *PublicFilterAPI) Logs</code> 这几个方法的实现。这些只是交易，区块等内容的过滤，对于获取特定条件的日志的功能则在 <code>NewFilter</code>, <code>GetLogs</code>, <code>GetFilterLogs</code>, <code>GetFilterChanges</code> 这几个方法的帮助下完成。比如 <code>GetLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetLogs</span><span class="params">(ctx context.Context, crit FilterCriteria)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filter *Filter</div><div class="line">	<span class="keyword">if</span> crit.BlockHash != <span class="literal">nil</span> &#123;</div><div class="line">		filter = NewBlockFilter(api.backend, *crit.BlockHash, crit.Addresses, crit.Topics)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		begin := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.FromBlock != <span class="literal">nil</span> &#123;</div><div class="line">			begin = crit.FromBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		end := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.ToBlock != <span class="literal">nil</span> &#123;</div><div class="line">			end = crit.ToBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		filter = NewRangeFilter(api.backend, begin, end, crit.Addresses, crit.Topics)</div><div class="line">	&#125;</div><div class="line">	logs, err := filter.Logs(ctx)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> returnLogs(logs), err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以根据开始区块，结束区块，地址，Topics 来获取符合条件的日志。可以看到获取日志主要通过 filter 的 Logs 方法得到，这就引入了 Filter 对象，这部分内容在 <code>eth/filters/filter.go</code> 里。</p>
<h4 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h4><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</div><div class="line">	ChainDb() ethdb.Database</div><div class="line">	EventMux() *event.TypeMux</div><div class="line">	HeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Header, error)</div><div class="line">	GetReceipts(ctx context.Context, blockHash common.Hash) (types.Receipts, error)</div><div class="line">	GetLogs(ctx context.Context, blockHash common.Hash) ([][]*types.Log, error)</div><div class="line"></div><div class="line">	SubscribeNewTxsEvent(<span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- core.ChainEvent) event.Subscription</div><div class="line">	SubscribeRemovedLogsEvent(ch <span class="keyword">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</div><div class="line">	SubscribeLogsEvent(ch <span class="keyword">chan</span>&lt;- []*types.Log) event.Subscription</div><div class="line"></div><div class="line">	BloomStatus() (<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</div><div class="line">	ServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter <span class="keyword">struct</span> &#123;</div><div class="line">	backend Backend</div><div class="line"></div><div class="line">	db         ethdb.Database</div><div class="line">	begin, end <span class="keyword">int64</span></div><div class="line">	addresses  []common.Address</div><div class="line">	topics     [][]common.Hash</div><div class="line"></div><div class="line">	matcher *bloombits.Matcher</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 结构体中定义了 <code>Backend</code> 接口，<code>Backend</code> 接口定义了布隆过滤器实现的接口，这些接口的实现是在 <code>eth/api_backend.go</code> 里的 L212-234，可以说是比较低层次的 API。而 Matcher 是布隆过滤器的 Matcher，这部分我们将在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#Matcher" target="_blank" rel="external">Matcher</a> 进行分析</p>
<h5 id="Filter-的初始化"><a href="#Filter-的初始化" class="headerlink" title="Filter 的初始化"></a>Filter 的初始化</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(backend Backend, begin, end <span class="keyword">int64</span>, addresses []common.Address, topics [][]common.Hash)</span> *<span class="title">Filter</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filters [][][]<span class="keyword">byte</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(addresses))</div><div class="line">		<span class="keyword">for</span> i, address := <span class="keyword">range</span> addresses &#123;</div><div class="line">			filter[i] = address.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, topicList := <span class="keyword">range</span> topics &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(topicList))</div><div class="line">		<span class="keyword">for</span> i, topic := <span class="keyword">range</span> topicList &#123;</div><div class="line">			filter[i] = topic.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	size, _ := backend.BloomStatus()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;Filter&#123;</div><div class="line">		backend:   backend,</div><div class="line">		begin:     begin,</div><div class="line">		end:       end,</div><div class="line">		addresses: addresses,</div><div class="line">		topics:    topics,</div><div class="line">		db:        backend.ChainDb(),</div><div class="line">		matcher:   bloombits.NewMatcher(size, filters),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 Filter 的参数中包含 addresses 或 topics，则都将其加入到 filters 容器中，在 matcher 的阶段会用到。</p>
<h5 id="过滤日志"><a href="#过滤日志" class="headerlink" title="过滤日志"></a>过滤日志</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">Logs</span><span class="params">(ctx context.Context)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	header, _ := f.backend.HeaderByNumber(ctx, rpc.LatestBlockNumber)</div><div class="line">	<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	head := header.Number.Uint64()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f.begin == <span class="number">-1</span> &#123;</div><div class="line">		f.begin = <span class="keyword">int64</span>(head)</div><div class="line">	&#125;</div><div class="line">	end := <span class="keyword">uint64</span>(f.end)</div><div class="line">	<span class="keyword">if</span> f.end == <span class="number">-1</span> &#123;</div><div class="line">		end = head</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		logs []*types.Log</div><div class="line">		err  error</div><div class="line">	)</div><div class="line">	size, sections := f.backend.BloomStatus()</div><div class="line">	<span class="keyword">if</span> indexed := sections * size; indexed &gt; <span class="keyword">uint64</span>(f.begin) &#123;</div><div class="line">		<span class="keyword">if</span> indexed &gt; end &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, end)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, indexed<span class="number">-1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	rest, err := f.unindexedLogs(ctx, end)</div><div class="line">	logs = <span class="built_in">append</span>(logs, rest...)</div><div class="line">	<span class="keyword">return</span> logs, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Logs</code> 会从区块链中找到匹配的 log 项。首先根据最新的区块号拿到最新区块，这样如果没有 end 参数的，搜索的区间的 end 就是最新区块。接着调用 <code>BloomStatus()</code> 拿到索引的状态，需要注意的是，尽管每个区块头都有 logBloom，日志的过滤不会直接依次检索这些区块头的 logBloom，因为遍历区块头的话效率太低了，需要多次的磁盘 IO，geth 会在 LevelDB 里维护另一套索引，以4096个区块为一个 section，在一个 section 内的 logBloom 会存在一起，所以对于位于已索引的区块这一区间的搜索，会调用 <code>indexedLogs</code> 进行搜索，对于在已索引区间外的区块，会调用 <code>unindexedLogs</code> 进行搜索。我们先看 <code>indexedLogs</code> 的实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">indexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	matches := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="number">64</span>)</div><div class="line">	session, err := f.matcher.Start(ctx, <span class="keyword">uint64</span>(f.begin), end, matches)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line">	f.backend.ServiceFilter(ctx, session)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> number, ok := &lt;-matches:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				err := session.Error()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">					f.begin = <span class="keyword">int64</span>(end) + <span class="number">1</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			f.begin = <span class="keyword">int64</span>(number) + <span class="number">1</span></div><div class="line">			header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(number))</div><div class="line">			<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">			<span class="keyword">return</span> logs, ctx.Err()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>indexedLogs</code> 会调用 <code>Matcher 的 Start</code> 方法启动 session，其结果会返回到 matches 这个 channel 里，找到区块后，通过调用 <code>checkMatches</code> 以验证该区块确实在区块链中（因为布隆过滤器有一定几率误判），验证完成后，结果会增加到 logs 这个变量中，直到接收到 Done 消息，然后返回 logs。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">checkMatches</span><span class="params">(ctx context.Context, header *types.Header)</span> <span class="params">(logs []*types.Log, err error)</span></span> &#123;</div><div class="line">	logsList, err := f.backend.GetLogs(ctx, header.Hash())</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> unfiltered []*types.Log</div><div class="line">	<span class="keyword">for</span> _, logs := <span class="keyword">range</span> logsList &#123;</div><div class="line">		unfiltered = <span class="built_in">append</span>(unfiltered, logs...)</div><div class="line">	&#125;</div><div class="line">	logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> logs[<span class="number">0</span>].TxHash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			receipts, err := f.backend.GetReceipts(ctx, header.Hash())</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			unfiltered = unfiltered[:<span class="number">0</span>]</div><div class="line">			<span class="keyword">for</span> _, receipt := <span class="keyword">range</span> receipts &#123;</div><div class="line">				unfiltered = <span class="built_in">append</span>(unfiltered, receipt.Logs...)</div><div class="line">			&#125;</div><div class="line">			logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>checkMatches</code> 做的事情简单来说就是根据 <code>header</code> 的哈希值，从 <code>backend</code> 拿到所有的收据，然后调用 <code>filterLogs</code> 对 topics 一一进行匹配，匹配上了则可以确定该 logs 确实在区块链中（布隆过滤器没有误判）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterLogs</span><span class="params">(logs []*types.Log, fromBlock, toBlock *big.Int, addresses []common.Address, topics [][]common.Hash)</span> []*<span class="title">types</span>.<span class="title">Log</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> ret []*types.Log</div><div class="line">Logs:</div><div class="line">	<span class="keyword">for</span> _, log := <span class="keyword">range</span> logs &#123;</div><div class="line">		<span class="keyword">if</span> fromBlock != <span class="literal">nil</span> &amp;&amp; fromBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; fromBlock.Uint64() &gt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> toBlock != <span class="literal">nil</span> &amp;&amp; toBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; toBlock.Uint64() &lt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &amp;&amp; !includes(addresses, log.Address) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(topics) &gt; <span class="built_in">len</span>(log.Topics) &#123;</div><div class="line">			<span class="keyword">continue</span> Logs</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> i, topics := <span class="keyword">range</span> topics &#123;</div><div class="line">			fmt.Println(topics)</div><div class="line">			match := <span class="built_in">len</span>(topics) == <span class="number">0</span></div><div class="line">			<span class="keyword">for</span> _, topic := <span class="keyword">range</span> topics &#123;</div><div class="line">				<span class="keyword">if</span> log.Topics[i] == topic &#123;</div><div class="line">					match = <span class="literal">true</span></div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !match &#123;</div><div class="line">				<span class="keyword">continue</span> Logs</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ret = <span class="built_in">append</span>(ret, log)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>filterLogs</code> 方法的逻辑很简单，遍历 <code>topics</code>，如果能和 log 中的 Topics 匹配上则添加到需返回的 logs 中。</p>
<p><code>indexedLogs</code> 方法是对有索引的日志的查询，前面有介绍到在 Logs 方法中，还有一个对未索引日志的查询，即 <code>unindexedLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">unindexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> logs []*types.Log</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ; f.begin &lt;= <span class="keyword">int64</span>(end); f.begin++ &#123;</div><div class="line">		header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(f.begin))</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomFilter(header.Bloom, f.addresses, f.topics) &#123;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会根据传入的 <code>end</code>，遍历所有区块，首先通过 header 的 Bloom 判断 topics 是否可能存在，如果有可能存在，直接调用 <code>checkMatches</code> 来查看是否匹配。至此通过对已索引，未索引的日志进行过滤，就可以通过条件获取特定的日志。</p>
<p>以上就是对 geth 过滤功能的概览，可以说是过滤功能的高层次调用，接下来我们将深入这些模块的实现。</p>
<h3 id="创建索引的实现"><a href="#创建索引的实现" class="headerlink" title="创建索引的实现"></a>创建索引的实现</h3><p>要实现布隆过滤器，首先需要给区块链创建索引，这样才能实现快速响应用户的日志搜索功能。这部分代码主要在 <code>core/chain_indexer</code> 模块里。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChainIndexerBackend <span class="keyword">interface</span> &#123;</div><div class="line">	Reset(section <span class="keyword">uint64</span>, prevHead common.Hash) error</div><div class="line">	Process(header *types.Header)</div><div class="line">	Commit() error</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> ChainIndexerChain <span class="keyword">interface</span> &#123;</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- ChainEvent) event.Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ChainIndexer <span class="keyword">struct</span> &#123;</div><div class="line">	chainDb  ethdb.Database</div><div class="line">	indexDb  ethdb.Database</div><div class="line">	backend  ChainIndexerBackend</div><div class="line">	children []*ChainIndexer</div><div class="line"></div><div class="line">	active <span class="keyword">uint32</span></div><div class="line">	update <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	quit   <span class="keyword">chan</span> <span class="keyword">chan</span> error</div><div class="line"></div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	confirmsReq <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	storedSections <span class="keyword">uint64</span></div><div class="line">	knownSections  <span class="keyword">uint64</span></div><div class="line">	cascadedHead   <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	throttling time.Duration</div><div class="line"></div><div class="line">	log  log.Logger</div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要了解一些定义，这部分代码中经常出现的 section 是指一组区块头，而这个一组的数量默认为 4096。</p>
<p><code>ChainIndexerBackend</code> 是一个接口，它定义了处理区块链 section 的方法，这个接口目前有 <code>BloomIndexer</code> 这个实现。其中 <code>Reset(section uint64)</code> 用来初始化一个新的区块链 section，可能会终止任何没有完成的操作；<code>Process(header *types.Header)</code> 对区块链 section 中的下一个区块头进行处理，增加新区块头到 index，调用者需要确保区块头的连续顺序；<code>Commit() error</code> 完成区块链 section 的元数据提交，并将其存储到数据库。</p>
<p>以下是 <code>ChainIndexer</code> 结构体中较重要的一些属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">chainDb</td>
<td style="text-align:center">区块链所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">indexDb</td>
<td style="text-align:center">索引所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">backend</td>
<td style="text-align:center">生成索引的后端，它实现了 <code>ChainIndexerBacken</code> 所定义的接口，这里的实现我们只探讨 <code>eth/bloombits</code> 中的 BloomIndexer，在 light 模式中有其他实现</td>
</tr>
<tr>
<td style="text-align:center">children</td>
<td style="text-align:center">子链的索引，这是为了处理临时分叉的情况</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">事件循环是否开始的标志</td>
</tr>
<tr>
<td style="text-align:center">update</td>
<td style="text-align:center">新生成区块头发送到这个 channel</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">退出事件循环的 channel</td>
</tr>
<tr>
<td style="text-align:center">sectionSize</td>
<td style="text-align:center">索引器会一组一组处理区块头，默认的大小是 4096</td>
</tr>
<tr>
<td style="text-align:center">confirmReq</td>
<td style="text-align:center">处理完成的 section 之前的确认次数</td>
</tr>
<tr>
<td style="text-align:center">storedSections</td>
<td style="text-align:center">已经成功进行索引的 section 的数量</td>
</tr>
<tr>
<td style="text-align:center">knownSections</td>
<td style="text-align:center">已知的 section 数量</td>
</tr>
<tr>
<td style="text-align:center">cascadedHead</td>
<td style="text-align:center">级联到子索引最后一个完成的 section 的区块数</td>
</tr>
<tr>
<td style="text-align:center">throttling</td>
<td style="text-align:center">对磁盘的限制，防止大量区块进行索引</td>
</tr>
</tbody>
</table>
<h4 id="初始化-ChainIndexer"><a href="#初始化-ChainIndexer" class="headerlink" title="初始化 ChainIndexer"></a>初始化 ChainIndexer</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChainIndexer</span><span class="params">(chainDb, indexDb ethdb.Database, backend ChainIndexerBackend, section, confirm <span class="keyword">uint64</span>, throttling time.Duration, kind <span class="keyword">string</span>)</span> *<span class="title">ChainIndexer</span></span> &#123;</div><div class="line">	c := &amp;ChainIndexer&#123;</div><div class="line">		chainDb:     chainDb,</div><div class="line">		indexDb:     indexDb,</div><div class="line">		backend:     backend,</div><div class="line">		update:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</div><div class="line">		quit:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error),</div><div class="line">		sectionSize: section,</div><div class="line">		confirmsReq: confirm,</div><div class="line">		throttling:  throttling,</div><div class="line">		log:         log.New(<span class="string">"type"</span>, kind),</div><div class="line">	&#125;</div><div class="line">	c.loadValidSections()</div><div class="line">	<span class="keyword">go</span> c.updateLoop()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化 <code>ChainIndexer</code> 时，先调用 <code>loadValidSections</code>，从数据库中加载之前处理过的信息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">loadValidSections</span><span class="params">()</span></span> &#123;</div><div class="line">	data, _ := c.indexDb.Get([]<span class="keyword">byte</span>(<span class="string">"count"</span>))</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">8</span> &#123;</div><div class="line">		c.storedSections = binary.BigEndian.Uint64(data[:])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来会以一个 goroutine 的方式进入一个事件循环，它会调用 backend 处理区块链 section。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">updateLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		updating <span class="keyword">bool</span></div><div class="line">		updated  time.Time</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> errc := &lt;-c.quit:</div><div class="line">			errc &lt;- <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-c.update:</div><div class="line">			c.lock.Lock()</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				<span class="keyword">if</span> time.Since(updated) &gt; <span class="number">8</span>*time.Second &#123;</div><div class="line">					<span class="keyword">if</span> c.knownSections &gt; c.storedSections+<span class="number">1</span> &#123;</div><div class="line">						updating = <span class="literal">true</span></div><div class="line">						c.log.Info(<span class="string">"Upgrading chain index"</span>, <span class="string">"percentage"</span>, c.storedSections*<span class="number">100</span>/c.knownSections)</div><div class="line">					&#125;</div><div class="line">					updated = time.Now()</div><div class="line">				&#125;</div><div class="line">				section := c.storedSections</div><div class="line">				<span class="keyword">var</span> oldHead common.Hash</div><div class="line">				<span class="keyword">if</span> section &gt; <span class="number">0</span> &#123;</div><div class="line">					oldHead = c.SectionHead(section - <span class="number">1</span>)</div><div class="line">				&#125;</div><div class="line">				c.lock.Unlock()</div><div class="line">				newHead, err := c.processSection(section, oldHead)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					c.log.Error(<span class="string">"Section processing failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">				&#125;</div><div class="line">				c.lock.Lock()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; oldHead == c.SectionHead(section<span class="number">-1</span>) &#123;</div><div class="line">					c.setSectionHead(section, newHead)</div><div class="line">					c.setValidSections(section + <span class="number">1</span>)</div><div class="line">					<span class="keyword">if</span> c.storedSections == c.knownSections &amp;&amp; updating &#123;</div><div class="line">						updating = <span class="literal">false</span></div><div class="line">						c.log.Info(<span class="string">"Finished upgrading chain index"</span>)</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					c.cascadedHead = c.storedSections*c.sectionSize - <span class="number">1</span></div><div class="line">					<span class="keyword">for</span> _, child := <span class="keyword">range</span> c.children &#123;</div><div class="line">						c.log.Trace(<span class="string">"Cascading chain index update"</span>, <span class="string">"head"</span>, c.cascadedHead)</div><div class="line">						child.newHead(c.cascadedHead, <span class="literal">false</span>)</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					c.log.Debug(<span class="string">"Chain index processing failed"</span>, <span class="string">"section"</span>, section, <span class="string">"err"</span>, err)</div><div class="line">					c.knownSections = c.storedSections</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				time.AfterFunc(c.throttling, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> c.update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</div><div class="line">					<span class="keyword">default</span>:</div><div class="line">					&#125;</div><div class="line">				&#125;)</div><div class="line">			&#125;</div><div class="line">			c.lock.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当索引需要更新时，其他 goroutine 会往 <code>update</code> 这个 channel 发送消息，主要的逻辑代码都在这个 case 分支。当已知的 section 数大于存储的 section 数，这时需要开始索引，先通过调用 <code>SectionHead</code> 拿到上一个 section 的最后一个区块的哈希值，接着调用 <code>processSection</code> 开始新 section 的索引。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">processSection</span><span class="params">(section <span class="keyword">uint64</span>, lastHead common.Hash)</span> <span class="params">(common.Hash, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Reset(section, lastHead); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.setValidSections(<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> number := section * c.sectionSize; number &lt; (section+<span class="number">1</span>)*c.sectionSize; number++ &#123;</div><div class="line">		hash := GetCanonicalHash(c.chainDb, number)</div><div class="line">		<span class="keyword">if</span> hash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"canonical block #%d unknown"</span>, number)</div><div class="line">		&#125;</div><div class="line">		header := GetHeader(c.chainDb, hash, number)</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"block #%d [%x…] not found"</span>, number, hash[:<span class="number">4</span>])</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> header.ParentHash != lastHead &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"chain reorged during section processing"</span>)</div><div class="line">		&#125;</div><div class="line">		c.backend.Process(header)</div><div class="line">		lastHead = header.Hash()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Commit(); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.log.Error(<span class="string">"Section commit failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> lastHead, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只探讨 <code>eth/bloombits</code> 的实现，首先看 <code>Reset</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Reset</span><span class="params">(section <span class="keyword">uint64</span>, lastSectionHead common.Hash)</span> <span class="title">error</span></span> &#123;</div><div class="line">	gen, err := bloombits.NewGenerator(<span class="keyword">uint</span>(b.size))</div><div class="line">	b.gen, b.section, b.head = gen, section, common.Hash&#123;&#125;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的 <code>lastSectionHead</code> 参数其实没有用到，在 light 模式的实现中是有用到的，这里我们先不深究。实际上 reset 方法只是简单的初始化 <code>core/bloombits/generator</code>，这部分我们在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">布隆过滤器的实现</a>这一小结会讨论，先跳过这部分。回到 <code>processSection</code> 方法，如果 <code>Reset</code> 方法返回错误了，我们会重置已经存储的 section。接下来我们遍历当前 section，通过调用 <code>GetCanonicalHash</code> 获得当前区块哈希，然后拿到当前区块链中的 header，通过调用 <code>Process(header)</code> 添加当前的区块索引到布隆过滤器的 bit 数组中。</p>
<p>这部分代码在 eth/bloombits.go 中</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Process</span><span class="params">(header *types.Header)</span></span> &#123;</div><div class="line">	b.gen.AddBloom(<span class="keyword">uint</span>(header.Number.Uint64()-b.section*b.size), header.Bloom)</div><div class="line">	b.head = header.Hash()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 <code>AddBloom</code> 在 <code>core/bloombits/generator.go</code> 中。generator 用来生成基于 section 的布隆过滤器索引数据的对象，其内部的结构是：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Generator <span class="keyword">struct</span> &#123;</div><div class="line">	blooms   [types.BloomBitLength][]<span class="keyword">byte</span></div><div class="line">	sections <span class="keyword">uint</span></div><div class="line">	nextSec  <span class="keyword">uint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>bloom[2048][4096]</code> 这个类型用来存储索引的数据，比如第20个 header 的 <code>logBloom</code> 存储在 <code>bloom[2048][20]</code> 里。<code>sections</code> 指明操作的 section 的数量，<code>nextSec</code> 表示增加一个 bloom 的时候，需要设置的下一个 bit。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Generator)</span> <span class="title">AddBloom</span><span class="params">(index <span class="keyword">uint</span>, bloom types.Bloom)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> b.nextBit &gt;= b.sections &#123;</div><div class="line">		<span class="keyword">return</span> errSectionOutOfBounds</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> b.nextBit != index &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"bloom filter with unexpected index"</span>)</div><div class="line">	&#125;</div><div class="line">	byteIndex := b.nextBit / <span class="number">8</span></div><div class="line">	bitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(<span class="number">7</span>-b.nextBit%<span class="number">8</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; types.BloomBitLength; i++ &#123;</div><div class="line">		bloomByteIndex := types.BloomByteLength - <span class="number">1</span> - i/<span class="number">8</span></div><div class="line">		bloomBitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(i%<span class="number">8</span>)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (bloom[bloomByteIndex] &amp; bloomBitMask) != <span class="number">0</span> &#123;</div><div class="line">			b.blooms[i][byteIndex] |= bitMask</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	b.nextBit++</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AddBloom</code> 增加一个区块的 bit 数组。当 <code>nextBit</code> 超过 sections 时，返回超出 section 最大数量的错误，确保 <code>nextBit</code> 始终等于 index，即 bloom 在 section 里的下标，通过 <code>nextBit/8</code> 得到需要设置的 byte 位置，接着就是根据 <code>BloomBitLength</code> 变量，生成一个 bloom 数据。</p>
<h3 id="过滤功能的实现"><a href="#过滤功能的实现" class="headerlink" title="过滤功能的实现"></a>过滤功能的实现</h3><p>前面创建索引的时候有涉及到布隆过滤器的一部分功能，接下来我们来深入探讨一下布隆过滤器功能的实现。这部分代码主要在 <code>core/bloombits</code> 里。<code>core/bloombits</code> 目录下，逻辑代码都在 <code>generator.go</code>，<code>matcher.go</code>，<code>scheduler.go</code> 中，其中 generator 生成基于 section 的布隆过滤器索引数据的对象，matcher 用来匹配查询操作，scheduler 基于 section 的布隆过滤器的单个 bit 值检索进行调度。上文已经介绍了 <code>generator.go</code> 的功能，我们继续来看 <code>scheduler.go</code> 和 <code>matcher.go</code>。</p>
<h4 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h4><p>scheduler 用来调度检索操作，作为调度器，它还承担删除重复数据，缓存结果的功能，以保证在复杂的过滤条件下降低 IO 的开销。</p>
<h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type request struct &#123;</div><div class="line">	section uint64</div><div class="line">	bit     uint</div><div class="line">&#125;</div><div class="line">type response struct &#123;</div><div class="line">	cached []byte</div><div class="line">	done   chan struct&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">type scheduler struct &#123;</div><div class="line">	bit       uint</div><div class="line">	responses map[uint64]*response</div><div class="line">	lock      sync.Mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>request</code> 表示一个布隆检索任务。其中<code>section</code> 表示区块段号，每段 4096 个区块，bit 代表检索的是布隆过滤器的哪一位(一共2048位)。在同一个 section 的 logBloom 会存储在一起，对于每个 section，用一个二维数组 <code>A[2048][4096]</code> 来存储，上文已简略提到，第一维2048代表布隆过滤器的长度为2048个字节，第二位4096表示一个 section 里的所有区块，每个位置按照顺序代表其中一个区块。<code>response</code> 表示当前调度的请求的状态，该属性会在 scheduler 被引用。每产生一个请求，都会生成一个 <code>response</code> 对象来表示这个请求的状态，cached 会用来缓存这个 section 的结果。</p>
<p><code>scheduler</code> 的 bit 用来表示请求的是布隆过滤器的哪一个 bit 位(0-2047)，而 <code>response</code> 记录当前正在进行的请求或已经缓存的结果。</p>
<p><code>scheduler</code> 的 <code>run</code> 方法是调度逻辑代码的入口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">run</span><span class="params">(sections <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	pend := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(dist))</div><div class="line"></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> s.scheduleRequests(sections, dist, pend, quit, wg)</div><div class="line">	<span class="keyword">go</span> s.scheduleDeliveries(pend, done, quit, wg)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中参数 <code>sections</code> 是需要检索的区块段的 channel，<code>dist</code> 是输出通道，表示从本地检索还是从网络中检索，往这个 channel 发送请求，结果可以从 done 通道中拿到。<code>pend := make(chan uint64, cap(dist))</code> 在请求和响应之间创建一个与分发通道大小相同的转发器通道。</p>
<p>先看 <code>scheduleRequests</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleRequests</span><span class="params">(reqs <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pend)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> section, ok := &lt;-reqs:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			unique := <span class="literal">false</span></div><div class="line"></div><div class="line">			s.lock.Lock()</div><div class="line">			<span class="keyword">if</span> s.responses[section] == <span class="literal">nil</span> &#123;</div><div class="line">				s.responses[section] = &amp;response&#123;</div><div class="line">					done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">				&#125;</div><div class="line">				unique = <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Unlock()</div><div class="line">			<span class="keyword">if</span> unique &#123;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> dist &lt;- &amp;request&#123;bit: s.bit, section: section&#125;:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> pend &lt;- section:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>schedulerRequests</code> 会从 reqs 这个 channel 接收到 section 消息，然后将接收到的 section 封装成 request 发送到 dist 这个 channel，构建对象 <code>response[section]</code>，接着 section 还会发送给 pend 队列，<code>run</code> 方法调用的 <code>scheduleDeliveries</code> 会进行处理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleDeliveries</span><span class="params">(pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> idx, ok := &lt;-pend:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Lock()</div><div class="line">			res := s.responses[idx]</div><div class="line">			s.lock.Unlock()</div><div class="line"></div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-res.done:</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> done &lt;- res.cached:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleDelivers</code> 接收到 <code>pend</code> 消息后，会阻塞在 <code>response[section].done</code> 上。接着等待外部调用 <code>deliver</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">deliver</span><span class="params">(sections []<span class="keyword">uint64</span>, data [][]<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	s.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> s.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, section := <span class="keyword">range</span> sections &#123;</div><div class="line">		<span class="keyword">if</span> res := s.responses[section]; res != <span class="literal">nil</span> &amp;&amp; res.cached == <span class="literal">nil</span> &#123; </div><div class="line">			res.cached = data[i]</div><div class="line">			<span class="built_in">close</span>(res.done)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 deliver 方法，section 的 <code>request</code> 请求结果会写入 <code>response[section].cached</code>，然后关闭 <code>response[section].done</code> 这个 channel 。</p>
<p><code>scheduleDelivers</code> 接收到 <code>response[section].done</code> 信息后，<code>response[section].cached</code> 会发送到 <code>done</code> 这个channel，至此，一次检索的调度就结束了。</p>
<p>在下面的 Matcher 中，distributor 就有调用 schedule 的 deliver 方法的例子。</p>
<h4 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h4><p>Matcher 完成真正的匹配工作，对 filter 进行二进制的与/或操作。</p>
<h5 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> partialMatches <span class="keyword">struct</span> &#123;</div><div class="line">	section <span class="keyword">uint64</span></div><div class="line">	bitset  []<span class="keyword">byte</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Retrieval <span class="keyword">struct</span> &#123;</div><div class="line">	Bit      <span class="keyword">uint</span></div><div class="line">	Sections []<span class="keyword">uint64</span></div><div class="line">	Bitsets  [][]<span class="keyword">byte</span></div><div class="line"></div><div class="line">	Context context.Context</div><div class="line">	Error   error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Matcher <span class="keyword">struct</span> &#123;</div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	filters    [][]bloomIndexes</div><div class="line">	schedulers <span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler</div><div class="line"></div><div class="line">	retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	counters   <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	retrievals <span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval</div><div class="line">	deliveries <span class="keyword">chan</span> *Retrieval</div><div class="line">	running <span class="keyword">uint32</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>partialMatches</code> 表示部分匹配的结果，<code>Retrieval</code> 表示一次区块布隆过滤器的检索工作，在使用过程中，该对象会被发送给 <code>eth/bloombits.go</code> 中的 <code>startBloomHandlers</code> 来处理，该方法从数据库中加载布隆过滤器索引，然后放在 Bitsets 里返回（待确认）。Matcher 是一个操作调度器（scheduler）和匹配器（matcher）的流水线系统，它会对比特流进行二进制的与/或操作，对数据内容进行检索，创建可能的区块。</p>
<p>构造 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMatcher</span><span class="params">(sectionSize <span class="keyword">uint64</span>, filters [][][]<span class="keyword">byte</span>)</span> *<span class="title">Matcher</span></span> &#123;</div><div class="line">	m := &amp;Matcher&#123;</div><div class="line">		sectionSize: sectionSize,</div><div class="line">		schedulers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler),</div><div class="line">		retrievers:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		counters:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		retrievals:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval),</div><div class="line">		deliveries:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Retrieval),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(filter) == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		bloomBits := <span class="built_in">make</span>([]bloomIndexes, <span class="built_in">len</span>(filter))</div><div class="line">		<span class="keyword">for</span> i, clause := <span class="keyword">range</span> filter &#123;</div><div class="line">			<span class="keyword">if</span> clause == <span class="literal">nil</span> &#123;</div><div class="line">				bloomBits = <span class="literal">nil</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			bloomBits[i] = calcBloomIndexes(clause)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomBits != <span class="literal">nil</span> &#123;</div><div class="line">			m.filters = <span class="built_in">append</span>(m.filters, bloomBits)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, bloomIndexLists := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		<span class="keyword">for</span> _, bloomIndexList := <span class="keyword">range</span> bloomIndexLists &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomIndex := <span class="keyword">range</span> bloomIndexList &#123;</div><div class="line">				m.addScheduler(bloomIndex)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> m</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewMatcher</code> 根据传入的 filters 分别进行初始化操作，接着可以在可以在 <code>Start</code> 中创建对应数量的 schedule，subMatch。</p>
<p>启动 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">Start</span><span class="params">(ctx context.Context, begin, end <span class="keyword">uint64</span>, results <span class="keyword">chan</span> <span class="keyword">uint64</span>)</span> <span class="params">(*MatcherSession, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> atomic.SwapUint32(&amp;m.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"matcher already running"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> atomic.StoreUint32(&amp;m.running, <span class="number">0</span>)</div><div class="line">	session := &amp;MatcherSession&#123;</div><div class="line">		matcher: m,</div><div class="line">		quit:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		kill:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		ctx:     ctx,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, scheduler := <span class="keyword">range</span> m.schedulers &#123;</div><div class="line">		scheduler.reset()</div><div class="line">	&#125;</div><div class="line">	sink := m.run(begin, end, <span class="built_in">cap</span>(results), session)</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> res, ok := &lt;-sink:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				sectionStart := res.section * m.sectionSize</div><div class="line"></div><div class="line">				first := sectionStart</div><div class="line">				<span class="keyword">if</span> begin &gt; first &#123;</div><div class="line">					first = begin</div><div class="line">				&#125;</div><div class="line">				last := sectionStart + m.sectionSize - <span class="number">1</span></div><div class="line">				<span class="keyword">if</span> end &lt; last &#123;</div><div class="line">					last = end</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> i := first; i &lt;= last; i++ &#123;</div><div class="line">					next := res.bitset[(i-sectionStart)/<span class="number">8</span>]</div><div class="line">					<span class="keyword">if</span> next == <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">if</span> i%<span class="number">8</span> == <span class="number">0</span> &#123;</div><div class="line">							i += <span class="number">7</span></div><div class="line">						&#125;</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> bit := <span class="number">7</span> - i%<span class="number">8</span>; next&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> results &lt;- i:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> session, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Start</code> 方法首先启动一个 session，这个 session 会被返回，它可以用来管理日志过滤的生命周期，调用者会将它作为 <code>ServiceFilter</code> 的参数，根据 <code>bloomFilterThreads</code> 这个常数值（默认为3），启动 <code>bloomFilterThreads</code> 个 session 的 <code>Multiplex</code>，该方法会不断地从 distributor 领取任务，将任务投递给 bloomRequest 队列，从队列中获取结果，然后投递给 distributor，这个 Multiplex 非常重要。</p>
<p>接下来会调用 run 方法，该方法会返回一个 channel，该 channel 会一直返回搜索的结果，直到返回一个退出的信号，<code>Start</code> 方法才会结束，对于过滤的结果，其中包括 section 和 bitmap，bitmap 表明了 section 中哪些区块可能存在值，这时需要遍历这个 bitmap，找到被置位的区块，然后把区块号返回到 results 通道。接下来我们看 <code>run</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">run</span><span class="params">(begin, end <span class="keyword">uint64</span>, buffer <span class="keyword">int</span>, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	source := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, buffer)</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(source)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> i := begin / m.sectionSize; i &lt;= end/m.sectionSize; i++ &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> source &lt;- &amp;partialMatches&#123;i, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0xff</span>&#125;, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))&#125;:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	next := source</div><div class="line">	dist := <span class="built_in">make</span>(<span class="keyword">chan</span> *request, buffer)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, bloom := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		next = m.subMatch(next, dist, bloom, session)</div><div class="line">	&#125;</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> m.distributor(dist, session)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>run 方法会创建一个子匹配器的流水线，一个用于地址集合，一个用于 topic 集合。之所以称为流水线是因为它会一个一个地调用子匹配器，之前的子匹配器找到了匹配的区块后才会调用下一个子匹配器，接收到的结果会与自身结果匹配后结合，发到下一个子匹配器。最终返回一个接收结果的接收器通道。该方法首先起一个 go routine, 构造 subMatch 的第一个输入源，这个源的 bitset 字段是 0xff，表示完全匹配，这个结果会作为第一个子匹配器的输入。在结尾还会用新线程的方式调用 <code>distributor</code>，这个方法我们之后再谈，接下来我们看 <code>subMatch</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">subMatch</span><span class="params">(source <span class="keyword">chan</span> *partialMatches, dist <span class="keyword">chan</span> *request, bloom []bloomIndexes, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	sectionSources := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	sectionSinks := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	<span class="keyword">for</span> i, bits := <span class="keyword">range</span> bloom &#123;</div><div class="line">		<span class="keyword">for</span> j, bit := <span class="keyword">range</span> bits &#123;</div><div class="line">			sectionSources[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(source))</div><div class="line">			sectionSinks[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">			m.schedulers[bit].run(sectionSources[i][j], dist, sectionSinks[i][j], session.quit, &amp;session.pend)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	process := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(process)</div><div class="line"></div><div class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">				<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">					<span class="built_in">close</span>(bitSource)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-source:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">					<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> bitSource &lt;- subres.section:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> process &lt;- subres:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-process:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">var</span> orVector []<span class="keyword">byte</span></div><div class="line">				<span class="keyword">for</span> _, bloomSinks := <span class="keyword">range</span> sectionSinks &#123;</div><div class="line">					<span class="keyword">var</span> andVector []<span class="keyword">byte</span></div><div class="line">					<span class="keyword">for</span> _, bitSink := <span class="keyword">range</span> bloomSinks &#123;</div><div class="line">						<span class="keyword">var</span> data []<span class="keyword">byte</span></div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> data = &lt;-bitSink:</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">if</span> andVector == <span class="literal">nil</span> &#123;</div><div class="line">							andVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">							<span class="built_in">copy</span>(andVector, data)</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							bitutil.ANDBytes(andVector, andVector, data)</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">						orVector = andVector</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						bitutil.ORBytes(orVector, orVector, andVector)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">					orVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> subres.bitset != <span class="literal">nil</span> &#123;</div><div class="line">					bitutil.ANDBytes(orVector, orVector, subres.bitset)</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> bitutil.TestBytes(orVector) &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">						<span class="keyword">return</span></div><div class="line">					<span class="keyword">case</span> results &lt;- &amp;partialMatches&#123;subres.section, orVector&#125;:</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> results</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>subMatch 会创建一个子匹配器，用于过滤一组 address 或 topic，在组内会进行 bit 位的或操作，然后将上一个结果与当前过滤结果进行位的与操作，如果结果不全为空，结果传递到下一个子匹配器。每个 address/topic 的匹配通过获取属于该 address/topics 的三个布隆过滤器位索引的给定部分以及这些向量二进制做与的运算。</p>
<p>注意这里的 bloom 参数的类型是 <code>[]bloomIndexes</code>，首先根据这个值创建相应个数的 schedulers，调用其对应的 run 方法。前面我们有介绍 schedulers 的 run 方法，它的作用是根据后端的实现（从硬盘或网络中）执行过滤操作，结果可以通过调用 scheduler 的 deliver 获得。</p>
<p>我们继续看上面提到的 <code>distributor</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">distributor</span><span class="params">(dist <span class="keyword">chan</span> *request, session *MatcherSession)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> session.pend.Done()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		requests   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>][]<span class="keyword">uint64</span>)</div><div class="line">		unallocs   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]<span class="keyword">struct</span>&#123;&#125;)</div><div class="line">		retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		allocs   <span class="keyword">int</span></div><div class="line">		shutdown = session.quit</div><div class="line">	)</div><div class="line">	assign := <span class="function"><span class="keyword">func</span><span class="params">(bit <span class="keyword">uint</span>)</span></span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievers:</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			retrievers = m.retrievers</div><div class="line">			unallocs[bit] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-shutdown:</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			shutdown = <span class="literal">nil</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-session.kill:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> req := &lt;-dist:</div><div class="line">			queue := requests[req.bit]</div><div class="line">			index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= req.section &#125;)</div><div class="line">			requests[req.bit] = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;req.section&#125;, queue[index:]...)...)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</div><div class="line">				assign(req.bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-retrievers:</div><div class="line">			bit, best := <span class="keyword">uint</span>(<span class="number">0</span>), <span class="keyword">uint64</span>(math.MaxUint64)</div><div class="line">			<span class="keyword">for</span> idx := <span class="keyword">range</span> unallocs &#123;</div><div class="line">				<span class="keyword">if</span> requests[idx][<span class="number">0</span>] &lt; best &#123;</div><div class="line">					bit, best = idx, requests[idx][<span class="number">0</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">delete</span>(unallocs, bit)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(unallocs) == <span class="number">0</span> &#123;</div><div class="line">				retrievers = <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.counters:</div><div class="line">			fetcher &lt;- <span class="keyword">uint</span>(<span class="built_in">len</span>(requests[&lt;-fetcher]))</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievals:</div><div class="line">			task := &lt;-fetcher</div><div class="line">			<span class="keyword">if</span> want := <span class="built_in">len</span>(task.Sections); want &gt;= <span class="built_in">len</span>(requests[task.Bit]) &#123;</div><div class="line">				task.Sections = requests[task.Bit]</div><div class="line">				<span class="built_in">delete</span>(requests, task.Bit)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				task.Sections = <span class="built_in">append</span>(task.Sections[:<span class="number">0</span>], requests[task.Bit][:want]...)</div><div class="line">				requests[task.Bit] = <span class="built_in">append</span>(requests[task.Bit][:<span class="number">0</span>], requests[task.Bit][want:]...)</div><div class="line">			&#125;</div><div class="line">			fetcher &lt;- task</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requests[task.Bit]) &gt; <span class="number">0</span> &#123;</div><div class="line">				assign(task.Bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> result := &lt;-m.deliveries:</div><div class="line">			<span class="keyword">var</span> (</div><div class="line">				sections = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">				bitsets  = <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Bitsets))</div><div class="line">				missing  = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">			)</div><div class="line">			<span class="keyword">for</span> i, bitset := <span class="keyword">range</span> result.Bitsets &#123;</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(bitset) == <span class="number">0</span> &#123;</div><div class="line">					missing = <span class="built_in">append</span>(missing, result.Sections[i])</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				sections = <span class="built_in">append</span>(sections, result.Sections[i])</div><div class="line">				bitsets = <span class="built_in">append</span>(bitsets, bitset)</div><div class="line">			&#125;</div><div class="line">			m.schedulers[result.Bit].deliver(sections, bitsets)</div><div class="line">			allocs--</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(missing) &gt; <span class="number">0</span> &#123;</div><div class="line">				queue := requests[result.Bit]</div><div class="line">				<span class="keyword">for</span> _, section := <span class="keyword">range</span> missing &#123;</div><div class="line">					index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= section &#125;)</div><div class="line">					queue = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;section&#125;, queue[index:]...)...)</div><div class="line">				&#125;</div><div class="line">				requests[result.Bit] = queue</div><div class="line"></div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="built_in">len</span>(missing) &#123;</div><div class="line">					assign(result.Bit)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &amp;&amp; shutdown == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>distributor 接收来自 scheduler 的请求，首先根据 <code>dist</code> 参数，进入下面的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">case req := &lt;-dist:</div><div class="line">	// New retrieval request arrived to be distributed to some fetcher process</div><div class="line">	queue := requests[req.bit]</div><div class="line">	index := sort.Search(len(queue), func(i int) bool &#123; return queue[i] &gt;= req.section &#125;)</div><div class="line">	requests[req.bit] = append(queue[:index], append([]uint64&#123;req.section&#125;, queue[index:]...)...)</div><div class="line"></div><div class="line">	// If it&apos;s a new bit and we have waiting fetchers, allocate to them</div><div class="line">	if len(queue) == 0 &#123;</div><div class="line">		assign(req.bit)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果是新的 bit，通过 assign 指派给等待的 fetcher。这时通过 <code>Multiplex</code>, <code>AllocateSections</code> 的作用，最终会进入到 <code>case fetcher := &lt;-m.retrievals:</code> 分支。回顾一下 <code>Multiplex</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (s *MatcherSession) Multiplex(batch int, wait time.Duration, mux chan chan *Retrieval) &#123;</div><div class="line">	for &#123;</div><div class="line">		bit, ok := s.AllocateRetrieval()</div><div class="line">		if !ok &#123;</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">		if s.PendingSections(bit) &lt; batch &#123;</div><div class="line">			select &#123;</div><div class="line">			case &lt;-s.quit:</div><div class="line">				// Session terminating, we can&apos;t meaningfully service, abort</div><div class="line">				s.AllocateSections(bit, 0)</div><div class="line">				s.DeliverSections(bit, []uint64&#123;&#125;, [][]byte&#123;&#125;)</div><div class="line">				return</div><div class="line"></div><div class="line">			case &lt;-time.After(wait):</div><div class="line">				// Throttling up, fetch whatever&apos;s available</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sections := s.AllocateSections(bit, batch)</div><div class="line">		request := make(chan *Retrieval)</div><div class="line"></div><div class="line">		select &#123;</div><div class="line">		case &lt;-s.quit:</div><div class="line">			s.DeliverSections(bit, sections, make([][]byte, len(sections)))</div><div class="line">			return</div><div class="line"></div><div class="line">		case mux &lt;- request:</div><div class="line">			request &lt;- &amp;Retrieval&#123;Bit: bit, Sections: sections, Context: s.ctx&#125;</div><div class="line"></div><div class="line">			result := &lt;-request</div><div class="line">			if result.Error != nil &#123;</div><div class="line">				s.err.Store(result.Error)</div><div class="line">				s.Close()</div><div class="line">			&#125;</div><div class="line">			s.DeliverSections(result.Bit, result.Sections, result.Bitsets)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Multiplex 会不断领取任务，投递给 bloomRequest 队列，从队列中获取结果后，又通过 <code>DeliverSections</code> 发送给 deliveries 这个 channel，从而调用 schedulers 的 deliver 方法，在前面 schedule 的讲解中，我们知道这个结果会发到 <code>done</code> 这个 channel 中，这个结果最终会被 subMatch 接收(查看 scheduler 的 run 方法)，一层层发送给最后一个 subMath，最终返回 results。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ethereum/go-ethereum/issues/1897" target="_blank" rel="external">issues 1897, eth_listTransactions</a></li>
<li><a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="external">【原】布隆过滤器 (Bloom Filter) 详解</a></li>
<li><a href="http://dmod.eu/deca/ft_gateway.cfm.pdf" target="_blank" rel="external">Space/Time Trade-offs in Hash Coding with Allowable Errors </a></li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Bloom filter wiki</a></li>
<li><a href="https://web.stanford.edu/~balaji/papers/bloom.pdf" target="_blank" rel="external">Bloom Filters: Design Innovations and Novel Applications</a></li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang/" rel="tag">#Golang</a>
          
            <a href="/tags/cryptocurrency/" rel="tag">#cryptocurrency</a>
          
            <a href="/tags/geth/" rel="tag">#geth</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/10/go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）/" rel="next" title="go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）">
                <i class="fa fa-chevron-left"></i> go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/20/Telegram Bot 的长轮询 VS Webhook/" rel="prev" title="Telegram Bot 的长轮询 VS Webhook">
                Telegram Bot 的长轮询 VS Webhook <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/6964284?v=3&s=460"
               alt="Frank" />
          <p class="site-author-name" itemprop="name">Frank</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">363</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">133</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-globe"></i> Twitter
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件和日志"><span class="nav-number">1.1.</span> <span class="nav-text">事件和日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">1.2.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#误算率推导"><span class="nav-number">1.2.1.</span> <span class="nav-text">误算率推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">1.2.2.</span> <span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#geth-的实现"><span class="nav-number">2.</span> <span class="nav-text">geth 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤功能的使用"><span class="nav-number">2.1.</span> <span class="nav-text">过滤功能的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#api-go"><span class="nav-number">2.1.1.</span> <span class="nav-text">api.go</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#超时检测"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">超时检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增加-filter"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">增加 filter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter-go"><span class="nav-number">2.1.2.</span> <span class="nav-text">filter.go</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构-1"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Filter-的初始化"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">Filter 的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过滤日志"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">过滤日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建索引的实现"><span class="nav-number">2.2.</span> <span class="nav-text">创建索引的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-ChainIndexer"><span class="nav-number">2.2.1.</span> <span class="nav-text">初始化 ChainIndexer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤功能的实现"><span class="nav-number">2.3.</span> <span class="nav-text">过滤功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduler"><span class="nav-number">2.3.1.</span> <span class="nav-text">scheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构-2"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Matcher"><span class="nav-number">2.3.2.</span> <span class="nav-text">Matcher</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构-3"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">数据结构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">3.</span> <span class="nav-text">References</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'knarfeh';
      var disqus_identifier = '2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/';
      var disqus_title = 'go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）';
      var disqus_url = 'http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  


  

  <script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
