<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="cryptocurrency,Golang,geth," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之">
<meta name="keywords" content="cryptocurrency,Golang,geth">
<meta property="og:type" content="article">
<meta property="og:title" content="go-ethereum 源码笔记（trie 模块-MPT 的实现）">
<meta property="og:url" content="http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/index.html">
<meta property="og:site_name" content="Frank&#39;s Notes">
<meta property="og:description" content="默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/trie_example.png">
<meta property="og:image" content="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/worldstatetrie.png">
<meta property="og:updated_time" content="2018-09-18T18:23:30.552Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go-ethereum 源码笔记（trie 模块-MPT 的实现）">
<meta name="twitter:description" content="默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之">
<meta name="twitter:image" content="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/trie_example.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> go-ethereum 源码笔记（trie 模块-MPT 的实现） | Frank's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-75002639-1', 'auto');
  ga('send', 'pageview');
</script>









  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Frank's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-twitter">
          <a href="/twitter" rel="section">
            
              <i class="menu-item-icon fa fa-coffee fa-fw"></i> <br />
            
            Twitter
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                go-ethereum 源码笔记（trie 模块-MPT 的实现）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-10T22:35:02+08:00" content="2018-03-10">
              2018-03-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之前，读者应该对默克尔树，帕特里夏树这两个数据结构有一定了解，这些是阅读源代码的基础知识，这里只做概述。下面我们先分别介绍这两种数据结构。</p>
<a id="more"></a>
<h2 id="Merkle-Tree-默克尔树"><a href="#Merkle-Tree-默克尔树" class="headerlink" title="Merkle Tree 默克尔树"></a>Merkle Tree 默克尔树</h2><p>默克尔树即哈希树，它是一种树形数据结构，由一组叶结点，一组中间节点和一个根节点构成。最下面的叶结点包含基础数据，每个中间节点是它的子节点的哈希值，根节点是他的子节点的哈希值，表示默克尔树的根部。它的作用是对大容量的数据进行快速比对。对于一个数据集，我们可以将其分成多个小的数据集，存在叶子节点上，默克尔树的根节点存储的哈希值就表示这个数据集的哈希值，当更新、添加或删除树节点时，都需要更新节点的哈希值，根节点的哈希值也会有所不同，这样可以用根节点到数据节点这一路径的数据来证明数据的正确性，而这个数据量相比于整个数据集来说是很小的。</p>
<p>举两个实际的例子，你就能很好的理解默克尔树的作用。</p>
<h3 id="Dynano-数据库"><a href="#Dynano-数据库" class="headerlink" title="Dynano 数据库"></a>Dynano 数据库</h3><p>在 Amazon 的 Dynamo 数据库中，大量使用到默克尔树。场景是这样的：为了保证 Dynamo 集群中的数据存储的持久性，一台机器上的数据在其他机器上存有备份，也就是副本。副本经常需要同步，保证数据的一致，这时候需要对数据进行比对，找到不一致的地方。网络传输时间是这个过程的瓶颈，我们需要尽可能减少数据传输量。比对两台机器的数据，传输不一致的数据当然是最佳选择，如何比对？首先应该想到的是应该比对哈希值，避免之间传输数据带来的巨大传输量，其次，用二分法能更快的找到差异数据，如果能想到这两点，我们就和 Merkle 想的一样了。在每台机器对每个区间的数据构建默克尔树，比对数据时，从根节点开始比较，如果一致，表明两个副本一致，否则就遍历这颗二叉树，定位到差异数据的复杂度是 $O(log(n))$。</p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种中心索引式的 P2P 文件分析通信协议。进行 P2P 下载时，先从中心索引服务器获取一个扩展名为 torrent 的索引文件，torrent 文件包含了共享文件的信息，包括文件名，大小，文件的 Hash 和指向 Tracker 的 URL，当我们使用 BitTorrent 下载文件时有几个步骤：</p>
<ol>
<li>客户端 A 根据下载的种子文件得出资源的目标服务器地址，然后与目标服务器地址建立连接，进行数据块下载。</li>
<li>当一个数据块下载完成后，客户端 A 会计算该数据块的摘要，然后用这个摘要与先前种子文件里的摘要进行对比，如果一致，表示这个数据块下载成功，否则，重新下载。</li>
<li>当一个数据块下载成功，客户端 A 会与其他下载资源的客户端进行通信，告知它们它已经成功下载了一个数据库，其他客户端需要下载这个数据块时，会去客户端 A 下载。</li>
</ol>
<p>如果不采用默克尔树，可以采取 hash list 的方式，即将文件分成一个一个的数据块后，分别对其取 hash，这带来一个问题是，torrent 文件应该是越小越好，否则会对种子文件服务器造成很大的负载压力，要想要 torrent 文件很小，那么数据块就应该分得足够大，但数据块足够大的话，客户端下载完一个数据块后校验发现数据块无效，重新传输代价又很大。引入默克尔树可以解决这个问题，将所有数据块构造成默克尔树之后，种子文件可以只存放根节点的哈希值。当出现传输错误时可以使用二分查找快速找到出错的数据块，然后重新传输，</p>
<p>从上述的两个例子可以看到引入默克尔树的意义，默克尔树将哈希表和二叉树的结合起来，由根节点，中间节点和叶子节点组成，叶子节点存的是数据或哈希值，中间节点是它的两个孩子的哈希值，根节点也是它的两个孩子的哈希值，它表示这一组数据的指纹。根据哈希表和二叉树的特点我们可以知道，叶子节点数据的任何变动，都可以通过父节点体现，而通过二叉树，可以很快定位到变更的数据。</p>
<p>因此，默克尔树的典型应用场景有：</p>
<ul>
<li>快速比较大量数据：如果两个默克尔树的根节点的值相同，意味着它们代表的值相同</li>
<li>可以快速定位到变更的数据，复杂度是 $O(log(n))$</li>
<li>零知识证明</li>
</ul>
<h2 id="Patricia-帕特里夏树"><a href="#Patricia-帕特里夏树" class="headerlink" title="Patricia 帕特里夏树"></a>Patricia 帕特里夏树</h2><p>要搞懂帕特里夏树，首先要先搞懂字典树。</p>
<h3 id="trie-字典树"><a href="#trie-字典树" class="headerlink" title="trie 字典树"></a><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie 字典树</a></h3><p>也称前缀树，单词查找树，键树。它用来保存关联数组，其中的键通常是字符串，键不直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串。并不是所有节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>trie 的思想是用空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。如下图就是一个 trie 树。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/trie_example.png" alt="trie"></p>
<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>字符串检索</li>
</ul>
<p>Trie 树可以用来查询字符串，判断一个字符串是否存在于某个字符串集合。</p>
<ul>
<li>词频统计</li>
</ul>
<p>实现词频统计时，节点结构有一个字段来记录该节点表示的单词的个数。</p>
<ul>
<li>字符串排序</li>
</ul>
<p>一次插入字符串到 Trie 树的过程就是一次排序的过程，先序输出 Trie 树的所有关键字就可以得到有序的字符串。</p>
<ul>
<li>前缀匹配</li>
</ul>
<p>在搜索引擎中，使用 Trie 前缀可以找到所有以某个字符串为前缀的字符串集合。</p>
<p>Trie 的插入和查询效率都是 $O(m)$，其中 m 是待插入/查询的字符串的长度。相比于哈希查找，Trie 树中不同的关键字不会产生冲突，而且查询共同前缀的 key 时很高效，如果是使用哈希查找，需要遍历整个哈希表，时间效率为 $O(n)$，n 为哈希表的数据总数；但 Trie 的缺点是空间消耗比较大，如果是直接查找，效率是 $O(m)$，并且有 m 次 IO 的开销，对于磁盘的压力也很大，而哈希表的查找效率是 $O(1)$。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Trie 在 redisearch 中有<a href="https://github.com/RedisLabsModules/RediSearch/blob/master/src/trie/trie.c" target="_blank" rel="external">实现</a>，用来实现搜索提示。</p>
<p>弄清原理后，可以尝试自己动手实现一下，在 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="external">leetcode</a> 上有相关题目。</p>
<h3 id="PatriciaTrie-帕特里夏树"><a href="#PatriciaTrie-帕特里夏树" class="headerlink" title="PatriciaTrie 帕特里夏树"></a>PatriciaTrie 帕特里夏树</h3><p>又叫做基数树，压缩前缀树或紧凑前缀树（compact prefix tree)，是一种更节省空间的前缀树。它与 Trie 的区别是，如果某个节点只有一个子树，那么这个子树跟父节点合并，这样可以缩短 Trie 里不必要的深度，节约存储空间，加快搜索节点的速度。</p>
<p>帕特里夏树的诞生是因为 Trie 有一定的缺陷，Trie 树会给每个字符串分配一个节点，如果有很多很长的，又没有公共节点的字符串就会使得 Trie 退化成一个数组，如果以太坊直接使用的是 Trie 话，有可能造成严重的存储空间的浪费，导致 Dos 攻击。</p>
<h2 id="Merkle-Patricia-Tree-默克尔-帕特里夏树"><a href="#Merkle-Patricia-Tree-默克尔-帕特里夏树" class="headerlink" title="Merkle Patricia Tree 默克尔-帕特里夏树"></a>Merkle Patricia Tree 默克尔-帕特里夏树</h2><p>Merkle Patricia Tree 默克尔-帕特里夏树是一种融合了默克尔树和前缀树两种结构优点的，经过改良的数据结构，在以太坊中用来组织交易信息、账户状态及其变更、收据相关的数据，为我们提供一个高效地、易更新的、且代表整个状态树的『指纹』。</p>
<p>每一个以太坊的区块头包含3颗 MPT 树，分别是：</p>
<ul>
<li>交易树 txTrie<br>用来存储交易数据。路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后才生成，在挖矿结束后不会再更新。</li>
<li>状态树 stateTrie<br>世界状态存储的地方，存储了所有账户的信息，包括余额，交易次数，EVM 指令（合约数据）等等，每次交易执行，stateTrie 都会变化，这部分内容我们将在 <a href="#TODO">go-ethereum 源码笔记（core 模块-状态管理）</a> 这一篇进行探讨。路径是 <code>sha3(ethereumAddress)</code>，值是 <code>rlp(ethereumAccount)</code>，其中 <code>ethereumAccount</code> 是一个列表 <code>[nonce,balance,storageRoot,codeHash]</code>，而 <code>storageRoot</code> 是另一个独立的帕特里树，每个账户都有一个独立的帕特里夏树，它用来存储所有的合约数据。参考 <a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a>。</li>
<li>收据树 receiptTrie<br>路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后生成，在挖矿结束后不会再更新。</li>
</ul>
<h2 id="Geth-的-MPT"><a href="#Geth-的-MPT" class="headerlink" title="Geth 的 MPT"></a>Geth 的 MPT</h2><p>MPT 在以太坊中作为键值存储的数据结构，使得插入，查找，删除的复杂度为 <code>O(log(n))</code>，并且能获得默克尔树的全部特性。</p>
<p>根据<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">以太坊官方博客</a>所描述的，MPT 使得轻节点可以实现以下的查询：</p>
<ul>
<li>这笔交易被包含在特定的区块中了吗？</li>
<li>这笔交易在过去的30天中，发出 X 类型事件的所有实例(例如，一个众筹合约完成了它的目标)</li>
<li>目前我的账户余额是多少</li>
<li>这个账户是否存在</li>
<li>假设在这个合约中运行这笔交易，它的输出是什么</li>
</ul>
<p>其实第1种情况可以由交易树处理，第2种情况可以由收据树处理，第3，4，5中情况可以由状态树来处理，计算前4个查询任务相当简单，服务器找到对象，获取默克尔分支，将分支回复给客户端。<br>对于第5种查询任务，利用状态树实现，这种方式称为默克尔状态转换证明。轻节点想要得到一个可信的结果，这个问题相当于，如果在根 S 的状态树上运行交易 T，其结果状态树将是根为 S’，log 为 L，输出为 O’。为推断这个证明，服务器创建一个假的区块，状态设为 S，请求这笔交易时假装是轻客户端，请求这笔交易时，需要客户端确定一个账户的余额，然后这个假的轻客户端会发出一个余额查询请求，服务器会回应这些请求，也会将这些请求中的数据合并以一个证明的方式发送给轻节点，轻节点这时会进行验证，将服务器提供的证明作为数据库使用，如果客户端验证的结果和服务器提供的是一样的，客户端就接受这个证明。看起来这种方式跟默克尔证明没有本质区别，都很好的利用了默克尔树的特性。</p>
<p>接下来我们换个角度，根据默克尔树和帕特里夏树两种结构的特性来说明 MPT 在以太坊中起到的作用。</p>
<h3 id="默克尔树的作用"><a href="#默克尔树的作用" class="headerlink" title="默克尔树的作用"></a>默克尔树的作用</h3><h4 id="轻节点扩展"><a href="#轻节点扩展" class="headerlink" title="轻节点扩展"></a>轻节点扩展</h4><p>MPT 实现了默克尔树，所以能提供一个默克尔证明这个功能，而通过默克尔证明我们可以实现区块链的轻节点扩展。</p>
<h5 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h5><p>在以太坊中，全节点是指维护整个区块链数据的节点，这包括整个区块链中的区块头，所有交易信息，账户状态，交易收据信息。随着时间推移，整个区块链数据量会非常大，这使得在 PC 或移动设备上运行全节点的可能性很小。中本聪的论文中描述了这种情况，并利用默克尔树来解决这个问题。我们可以运行一种节点，这个节点只维护区块链中所有的区块头信息，这种节点就叫做轻节点。</p>
<h5 id="默克尔证明"><a href="#默克尔证明" class="headerlink" title="默克尔证明"></a>默克尔证明</h5><p>默克尔证明是指一个轻节点向一个全节点发起一次证明请求，询问完整的默克尔树中是否存在一个指定的节点（这里指的是树的节点），全节点会向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证其存在性。这里利用了哈希函数的特性保证了这个验证是真实可靠的。</p>
<p>当我们需要验证某笔交易确实存在于区块链时，轻节点不需要维护区块的信息，当它需要验证时，可以向全节点请求一条默克尔树的路径，该路径实际上是从根节点到叶子节点的所有节点的哈希值列表，轻节点收到这条路径后，一层层地计算根哈希，再与本地的根哈希匹配，如果匹配成功了则说明这笔交易是存在的。哈希操作是不可逆的，所以不存在一个所谓的恶意节点可以伪造一条假的路径使得计算的根哈希与轻节点的根哈希是一致的。有人可能会有疑问，为什么不直接向网络中的某个全节点请求交易数据是否在区块链中，如果这样做的话，就不能保证安全性了，区块链的美妙之处在于，上面存的数据是全网的共识，除非受到 51% 攻击，否则区块链的数据是完全可信的，这与中心化的数据库不同。如果是直接向网络中某节点或某些节点请求数据，可能这些节点都是恶意节点，不能保证安全性。需要说明的是，轻节点尽管没有参与维护整个区块链数据，它也是去中心化的，因为它所拿到的区块头数据是经过了全网共识的，所以有足够的安全保障。</p>
<h3 id="帕特里树的作用"><a href="#帕特里树的作用" class="headerlink" title="帕特里树的作用"></a>帕特里树的作用</h3><ul>
<li>存储任意长度的 key-value 键值对数据</li>
<li>快速索引根据哈希存储的数据集</li>
<li>引入了几种节点类型来提高效率，包括空节点，叶子节点，扩展节点，分支节点</li>
</ul>
<h2 id="MPT-在-geth-中的实现细节"><a href="#MPT-在-geth-中的实现细节" class="headerlink" title="MPT 在 geth 中的实现细节"></a>MPT 在 geth 中的实现细节</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在以太坊中，MPT 有四种类型的树节点，目的是压缩整体树高、降低操作复杂度。树节点可以分为以下四类：</p>
<ul>
<li>空节点</li>
<li>分支节点</li>
<li>叶子节点</li>
<li>扩展节点</li>
</ul>
<p>这些是黄皮书中的定义，在 geth 的实现中，上述概念有不同的结构与之对应。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="keyword">node</span> <span class="title">interface</span> &#123;</div><div class="line">	fstring(<span class="keyword">string</span>) <span class="keyword">string</span></div><div class="line">	cache() (hashNode, bool)</div><div class="line">	canUnload(cachegen, cachelimit uint16) bool</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> (</div><div class="line">	fullNode struct &#123;</div><div class="line">		Children [<span class="number">17</span>]<span class="keyword">node</span></div><div class="line">		<span class="title">flags</span>    nodeFlag</div><div class="line">	&#125;</div><div class="line">	shortNode struct &#123;</div><div class="line">		Key   []byte</div><div class="line">		Val   <span class="keyword">node</span></div><div class="line">		<span class="title">flags</span> nodeFlag</div><div class="line">	&#125;</div><div class="line">	hashNode  []byte</div><div class="line">	valueNode []byte</div><div class="line">)</div><div class="line">...</div><div class="line"><span class="keyword">type</span> nodeFlag struct &#123;</div><div class="line">	hash  hashNode</div><div class="line">	gen   uint16</div><div class="line">	dirty bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下图是一个世界状态的例子（摘自 <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" target="_blank" rel="external">Ethereum block architecture</a>）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/worldstatetrie.png" alt="worldstatetrie"></p>
<h4 id="fullNode"><a href="#fullNode" class="headerlink" title="fullNode"></a>fullNode</h4><p>fullNode 是一个可以携带多个子节点的节点。它有一个 node 数组类型的成员变量 Children，数组的前16个空位分别对应十六进制的0-9a-f，对于每个子节点，根据其 key 值的十六进制表示一一对应，Children 数组的第17位，fullNode 用来存储数据。</p>
<p>对应黄皮书中的分支节点。</p>
<h4 id="shortNode"><a href="#shortNode" class="headerlink" title="shortNode"></a>shortNode</h4><p>shortNode 是一个仅有一个子节点的节点。成员变量 Val 指向一个子节点，成员变量 Key 是一个由任意长度的字符串，这体现了压缩前缀树的特点，通过合并只有一个子节点的父节点和其子节点来缩短 Trie 的深度。</p>
<p>对应黄皮书里的扩展节点和叶子节点，通过 <code>shortNode.Val</code> 的类型来对应。</p>
<h4 id="valueNode"><a href="#valueNode" class="headerlink" title="valueNode"></a>valueNode</h4><p>valueNode 在 MPT 结构中存储真正的数据。充当 MPT 的叶子节点，不带子节点。</p>
<p>valueNode 是一个字节数组，但是它实现了 <code>fstring(string) string</code>, <code>cache() (hashNode, bool)</code>, <code>canUnload(cachegen, cachelimit uint16) bool</code> 这三个接口（实际上 fullNode，shortNode，hashNode 也实现了这三个接口），因此可以作为 fullNode，shortNode 中的 <code>node</code> 使用。valueNode 可以承接数据，携带的的是数据的 RLP 哈希值，长度为 32 byte，RLP 编码的值存在 LevelDB 里。</p>
<h4 id="hashNode"><a href="#hashNode" class="headerlink" title="hashNode"></a>hashNode</h4><p>hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存。遍历 MPT 时有时会遇到一个 hashNode，表明原来的 node 需要动态加载，hashNode 以 nodeFlag 结构体的成员 hash 的形式存在，如果 fullNode 或 shortNode 的成员变量发生变化，那么就需要更新它的 hashNode，在增删改的过程结束了都会调用 <code>trie.Hash()</code>，整个 MPT 自底向上变量，对所有清空的 hashNode 重新赋值，最终得到根节点的 hashNode，也就是整个 MPT 结构的哈希值。</p>
<p>结合之前讲过的基础知识，可以看到 fullNode 体现了 Trie 的特点，shortNode 实现了 PatriciaTrie 的特性（当然也实现了 Trie 的特性），hashNode 既实现了 MPT 节点的动态加载，也实现了默克尔树的功能。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Trie-的基本操作"><a href="#Trie-的基本操作" class="headerlink" title="Trie 的基本操作"></a>Trie 的基本操作</h4><p>我们首先将 Trie 看做一个黑盒，看看它具体暴露了什么接口，对全局有个总体的把握之后再深入其对应的细节。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"trie.New called without a database"</span>)</div><div class="line">	&#125;</div><div class="line">	trie := &amp;Trie&#123;</div><div class="line">		db:           db,</div><div class="line">		originalRoot: root,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (root != common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</div><div class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		trie.root = rootnode</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <code>New</code> 函数进行初始化，参数 root 是一个哈希值，如果哈希值不为空，说明数据中已存在 <code>Trie</code> 结构，调用 <code>trie.resolveHash</code> 方法来加载整个 Trie 树，如果 root 为空，新建 Trie 返回。</p>
<p>下面我们看看 Trie 结构的增删改查的过程，需要注意的是，MPT 是一棵树，这些数据结构的操作都是递归调用的过程，因此参数的上下文应该是当前这棵树下的含义。</p>
<h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">insert</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>, value node)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> v, ok := n.(valueNode); ok &#123;</div><div class="line">			<span class="keyword">return</span> !bytes.Equal(v, value.(valueNode)), value, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, value, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123;</div><div class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</div><div class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.<span class="built_in">copy</span>()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[<span class="number">0</span>]] = nn</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, n, n))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数 node 是当前插入的根节点，prefix 是当前已经处理的 key(即 Patricia 树中节点共有的前缀)，key 是待处理的部分，完整的 key 应该是 prefix + key，value 是需要插入的值。返回的名为 dirty 的布尔值在 commit 阶段指明该树是否需要重新进行哈希计算。</p>
<p>如果当前根节点类型为 shortNode(当前节点为叶子节点或扩展节点)，首先通过 <code>prefixLen</code> 方法计算公共前缀。</p>
<p>如果公共前缀长度等于 key 的长度，那么说明插入的 key 和待插入的树的 key 一样，这时分两种情况。</p>
<ul>
<li>如果 value 也一样，那么返回 false，即 dirty 为 false。</li>
<li>如果 value 不一样，实际上这是一个 <code>update</code> 的操作，这时返回的 dirty 为 true。</li>
</ul>
<p>如果公共前缀不完全匹配，又分两种情况。</p>
<ul>
<li>如果匹配长度为 0 的话，返回的是一个 fullNode，这个 fullNode 有两个 shortNode 类型的子节点，一个子节点即当前的根节点，另一个为以要插入的值为 node 的 shortNode；</li>
<li>匹配长度大于零，这时公共节点提取出来形成一个独立的 shortNode(扩展节点)，这个 shortNode 的 Val 是 fullNode，fullNode 的两个子节点，一个即当前的根节点，另一个为以要插入的值为 node 的 shortNode</li>
</ul>
<p>这部分逻辑是当前根节点类型为 shortNode 的情况，可以看到这里实际上是帕特里夏树的体现，对于 Trie 进行空间使用率的优化，如果一个父节点只有一个子节点，那么这个父节点将与其子节点合并，这样可以缩短搜索深度。</p>
<p>对于当前根节点类型为 fullNode 的情况，直接往对应的孩子节点调用 insert 方法，insert 方法会返回插入后的根节点，然后将该孩子指向这个返回的根节点即可。</p>
<p>对于当前根节点类型为 nil 的情况，即要插入的 Trie 是空的，直接返回一个 shortNode，Val 字段即为要插入的 node。</p>
<p>对于当前节点为 hashNode 的情况，表明要插入的当前根节点还在数据库中，没有加载到内存中，首先调用 <code>t.resolveHash(n, prefix)</code> 方法进行加载，在调用 insert 方法进行插入。</p>
<p>以上就是插入一个新节点的全部逻辑，基本上概括了帕特里夏树的特点，删，改，查的操作实际上大同小异，因此接下来的讲解会简略一点。</p>
<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := t.TryDelete(key); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryDelete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	t.root = n</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">delete</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		<span class="keyword">if</span> matchlen &lt; <span class="built_in">len</span>(n.Key) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(key) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		dirty, child, err := t.<span class="built_in">delete</span>(n.Val, <span class="built_in">append</span>(prefix, key[:<span class="built_in">len</span>(n.Key)]...), key[<span class="built_in">len</span>(n.Key):])</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> child := child.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;concat(n.Key, child.Key...), child.Val, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, child, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		dirty, nn, err := t.<span class="built_in">delete</span>(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:])</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.<span class="built_in">copy</span>()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[<span class="number">0</span>]] = nn</div><div class="line">		</div><div class="line">		pos := <span class="number">-1</span></div><div class="line">		<span class="keyword">for</span> i, cld := <span class="keyword">range</span> n.Children &#123;</div><div class="line">			<span class="keyword">if</span> cld != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">if</span> pos == <span class="number">-1</span> &#123;</div><div class="line">					pos = i</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					pos = <span class="number">-2</span></div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> pos &gt;= <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> pos != <span class="number">16</span> &#123;</div><div class="line">				cnode, err := t.resolve(n.Children[pos], prefix)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> cnode, ok := cnode.(*shortNode); ok &#123;</div><div class="line">					k := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(pos)&#125;, cnode.Key...)</div><div class="line">					<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;k, cnode.Val, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;[]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(pos)&#125;, n.Children[pos], t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> valueNode:</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.<span class="built_in">delete</span>(rn, prefix, key)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v (%v)"</span>, n, n, key))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除的真正逻辑在 <code>delete(n node, prefix, key []byte) (bool, node, error)</code> 这个方法里，其中参数 key 是通过 <code>keybytesToHex</code> 获得的 hex 编码。删除的过程也是递归调用，其中 node，prefix，key 参数意义与插入时的参数一致。</p>
<p>对于 shortNode 情况，首先进行 key 的匹配，如果匹配的长度小于根节点的 key 的长度，意味着要删除的节点不在这颗树上，返回 false 以及根节点，不做任何操作；如果匹配的长度正好等于 key 的长度，意味着完全匹配，返回 true 以及 nil(表明该节点已经被删除)。</p>
<p>如果匹配的长度等于根节点的 key 的长度，并且小于参数 key 的长度，那么意味着要删除的节点是该树的子节点，需要删除的是根树的一颗子树，那么继续递归调用。</p>
<p>对于删除 fullNode 的情况，如果 fullNode 删除后有两个及以上的子节点，删除后返回根节点即可，如果删除后只有一个子节点，那么需要将该根节点变成 shortNode 返回。</p>
<p>对于删除 hashNode 的情况，先加载节点到内存中再递归调用删除操作。</p>
<h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Update</span><span class="params">(key, value []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := t.TryUpdate(key, value); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryUpdate</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(value) != <span class="number">0</span> &#123;</div><div class="line">		_, n, err := t.insert(t.root, <span class="literal">nil</span>, k, valueNode(value))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新的操作，如果 value 长度不为零，即 value 不为空的话，直接调用插入操作，如果为空，则删除根节点。</p>
<h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	res, err := t.TryGet(key)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryGet</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	value, newroot, didResolve, err := t.tryGet(t.root, key, <span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">		t.root = newroot</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value, err</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">tryGet</span><span class="params">(origNode node, key []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, newnode node, didResolve <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> valueNode:</div><div class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">			n = n.<span class="built_in">copy</span>()</div><div class="line">			n.Val = newnode</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> value, n, didResolve, err</div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">			n = n.<span class="built_in">copy</span>()</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">			n.Children[key[pos]] = newnode</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> value, n, didResolve, err</div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		child, err := t.resolveHash(n, key[:pos])</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err</div><div class="line">		&#125;</div><div class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</div><div class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, origNode, origNode))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询的操作，实际上最终查的还是 valueNode，根据 key，根据 pos 指示的 key 位置跟根节点的 Key 属性值进行匹配，递归调用即可，与上述的操作很类似。</p>
<h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><p>提交阶段会将内存中的所有 trie 写入到数据库中。在这期间会根据 dirty 值做一件非常重要的事情，如果 dirty 置为 true 了，表明其代表的父节点有改动需要提交，hashNode 的成员 hash 设为空，需重新进行计算得到 hashNode 的哈希值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Commit</span><span class="params">(onleaf LeafCallback)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"commit called on trie with nil database"</span>)</div><div class="line">	&#125;</div><div class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	t.root = cached</div><div class="line">	t.cachegen++</div><div class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">hashRoot</span><span class="params">(db *Database, onleaf LeafCallback)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	h := newHasher(t.cachegen, t.cachelimit, onleaf)</div><div class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</div><div class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hash</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> n.canUnload(h.cachegen, h.cachelimit) &#123;</div><div class="line">			cacheUnloadCounter.Inc(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !dirty &#123;</div><div class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	collapsed, cached, err := h.hashChildren(n, db)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	hashed, err := h.store(collapsed, db, force)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	cachedHash, _ := hashed.(hashNode)</div><div class="line">	<span class="keyword">switch</span> cn := cached.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">			cn.flags.dirty = <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">			cn.flags.dirty = <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hashed, cached, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hashChildren</span><span class="params">(original node, db *Database)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> n := original.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</div><div class="line">		collapsed.Key = hexToCompact(n.Key)</div><div class="line">		cached.Key = common.CopyBytes(n.Key)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</div><div class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> original, original, err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</div><div class="line">			<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123;</div><div class="line">				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> original, original, err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</div><div class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> n, original, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提交 MPT 时，会调用 <code>Trie.hashRoot</code> 从根节点开始折叠，而 <code>hashRoot</code> 会调用 <code>trie/hasher.go</code> 里的 <code>hash</code> 方法，<code>hash</code> 方法和 <code>hashChildren</code> 方法会递归调用遍历整个 MPT，大致逻辑是：如果 node 没有子节点，直接返回；如果 node 是 shortNode，将 <code>valueNode</code> 作为参数调用 <code>hash</code> 方法；如果 node 是 fullNode，对其每个子节点调用 <code>hash</code> 方法。最终将这个 node 作为参数调用 <code>store</code> 方法，获得 RLP 编码，并进行哈希计算，获取哈希值，也就是 MPT 根节点的哈希值。</p>
<h4 id="Trie-的序列化和反序列化"><a href="#Trie-的序列化和反序列化" class="headerlink" title="Trie 的序列化和反序列化"></a>Trie 的序列化和反序列化</h4><p>上一篇文章 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</a> 介绍了 geth 里是怎么进行序列化和反序列化的，而通过上文我们知道了 MPT 有一个折叠和动态加载节点的过程，这个过程需要通过 rlp 模块进行序列化和反序列化，与 LevelDB 进行交互，我们来具体看看这个过程是怎么实现的。</p>
<h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">store</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash &#123;</div><div class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	h.tmp.Reset()</div><div class="line">	<span class="keyword">if</span> err := rlp.Encode(&amp;h.tmp, n); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"encode error: "</span> + err.Error())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.tmp) &lt; <span class="number">32</span> &amp;&amp; !force &#123;</div><div class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	hash, _ := n.cache()</div><div class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</div><div class="line">		hash = h.makeHashNode(h.tmp)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">		hash := common.BytesToHash(hash)</div><div class="line"></div><div class="line">		db.lock.Lock()</div><div class="line">		db.insert(hash, h.tmp, n)</div><div class="line">		db.lock.Unlock()</div><div class="line"></div><div class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="keyword">case</span> *shortNode:</div><div class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok &#123;</div><div class="line">					h.onleaf(child, hash)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> *fullNode:</div><div class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</div><div class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</div><div class="line">						h.onleaf(child, hash)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hash, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面有提到 store 方法，它通过调用 <code>rlp.Encode</code> 对节点进行 RLP 编码，然后计算哈希值，通过 <code>db.insert</code> 将其插入数据库，需注意的是分别对 shortNode，fullNode 调用的 <code>onleaf</code>方法，它用来存储外部的 MPT，如果没有猜错的话，它应该是用来存储账户相关内容的，待验证。</p>
<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">resolveHash</span><span class="params">(n hashNode, prefix []<span class="keyword">byte</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	cacheMissCounter.Inc(<span class="number">1</span>)</div><div class="line"></div><div class="line">	hash := common.BytesToHash(n)</div><div class="line">	<span class="keyword">if</span> node := t.db.node(hash, t.cachegen); node != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> node, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, &amp;MissingNodeError&#123;NodeHash: hash, Path: prefix&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">node</span><span class="params">(hash common.Hash, cachegen <span class="keyword">uint16</span>)</span> <span class="title">node</span></span> &#123;</div><div class="line">	db.lock.RLock()</div><div class="line">	node := db.nodes[hash]</div><div class="line">	db.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> node.obj(hash, cachegen)</div><div class="line">	&#125;</div><div class="line">	enc, err := db.diskdb.Get(hash[:])</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || enc == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mustDecodeNode(hash[:], enc, cachegen)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustDecodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>, cachegen <span class="keyword">uint16</span>)</span> <span class="title">node</span></span> &#123;</div><div class="line">	n, err := decodeNode(hash, buf, cachegen)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"node %x: %v"</span>, hash, err))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>, cachegen <span class="keyword">uint16</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</div><div class="line">	&#125;</div><div class="line">	elems, _, err := rlp.SplitList(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"decode error: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">switch</span> c, _ := rlp.CountValues(elems); c &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">		n, err := decodeShort(hash, elems, cachegen)</div><div class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">"short"</span>)</div><div class="line">	<span class="keyword">case</span> <span class="number">17</span>:</div><div class="line">		n, err := decodeFull(hash, elems, cachegen)</div><div class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">"full"</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid number of list elements: %v"</span>, c)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到，在遍历的过程中，如果遇到了 hashNode，需要动态加载这个节点，这个方法就是 resolve。resolve 方法会调用 <code>trie/database.go</code> 的 <code>node</code> 方法，先从内存里拿，否则从硬盘里拿，接着调用 <code>trie/node.go</code> 的 <code>mustDecodeNode</code>，<code>mustDecodeNode</code> 是 <code>decodeNode</code> 的简单封装，在这里可以看到调用 rlp 模块进行反序列化的过程，根据 RLP 的 list 的长度来判断这个编码是什么节点，如果是2那么就是 shortNode，如果是17就是 fullNode，根据节点的不同调用相应的 decode 方法。</p>
<h4 id="默克尔证明-1"><a href="#默克尔证明-1" class="headerlink" title="默克尔证明"></a>默克尔证明</h4><p>前面已经介绍了默克尔证明的原理，而且我们现在也有了 MPT 的基础，这里我们直接看默克尔证明的代码。默克尔证明的相关逻辑主要在 <code>trie/proof.go</code> 里。</p>
<h5 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.Putter)</span> <span class="title">error</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	nodes := []node&#123;&#125;</div><div class="line">	tn := t.root</div><div class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(key) &gt; <span class="number">0</span> &amp;&amp; tn != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">				tn = <span class="literal">nil</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				tn = n.Val</div><div class="line">				key = key[<span class="built_in">len</span>(n.Key):]</div><div class="line">			&#125;</div><div class="line">			nodes = <span class="built_in">append</span>(nodes, n)</div><div class="line">		<span class="keyword">case</span> *fullNode:</div><div class="line">			tn = n.Children[key[<span class="number">0</span>]]</div><div class="line">			key = key[<span class="number">1</span>:]</div><div class="line">			nodes = <span class="built_in">append</span>(nodes, n)</div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			<span class="keyword">var</span> err error</div><div class="line">			tn, err = t.resolveHash(n, <span class="literal">nil</span>)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	hasher := newHasher(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">for</span> i, n := <span class="keyword">range</span> nodes &#123;</div><div class="line">		n, _, _ = hasher.hashChildren(n, <span class="literal">nil</span>)</div><div class="line">		hn, _ := hasher.store(n, <span class="literal">nil</span>, <span class="literal">false</span>)</div><div class="line">		<span class="keyword">if</span> hash, ok := hn.(hashNode); ok || i == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> fromLevel &gt; <span class="number">0</span> &#123;</div><div class="line">				fromLevel--</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				enc, _ := rlp.EncodeToBytes(n)</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					hash = crypto.Keccak256(enc)</div><div class="line">				&#125;</div><div class="line">				proofDb.Put(hash, enc)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Prove</code> 方法用来获取指定 key 的默克尔证明。这个方法会遍历整个 MPT，获取从根节点到叶子节点这条路径上的所有节点的 hash 值列表。对于 key 不匹配的情况，则会返回一个最长匹配的列表。</p>
<h5 id="VerifyProof"><a href="#VerifyProof" class="headerlink" title="VerifyProof"></a>VerifyProof</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyProof</span><span class="params">(rootHash common.Hash, key []<span class="keyword">byte</span>, proofDb DatabaseReader)</span> <span class="params">(value []<span class="keyword">byte</span>, nodes <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	wantHash := rootHash</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</div><div class="line">		buf, _ := proofDb.Get(wantHash[:])</div><div class="line">		<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">"proof node %d (hash %064x) missing"</span>, i, wantHash)</div><div class="line">		&#125;</div><div class="line">		n, err := decodeNode(wantHash[:], buf, <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">"bad proof node %d: %v"</span>, i, err)</div><div class="line">		&#125;</div><div class="line">		keyrest, cld := get(n, key)</div><div class="line">		<span class="keyword">switch</span> cld := cld.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			key = keyrest</div><div class="line">			<span class="built_in">copy</span>(wantHash[:], cld)</div><div class="line">		<span class="keyword">case</span> valueNode:</div><div class="line">			<span class="keyword">return</span> cld, i + <span class="number">1</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(tn node, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, node)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			tn = n.Val</div><div class="line">			key = key[<span class="built_in">len</span>(n.Key):]</div><div class="line">		<span class="keyword">case</span> *fullNode:</div><div class="line">			tn = n.Children[key[<span class="number">0</span>]]</div><div class="line">			key = key[<span class="number">1</span>:]</div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			<span class="keyword">return</span> key, n</div><div class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">			<span class="keyword">return</span> key, <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> valueNode:</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VerifyProof</code> 方法以 roothash，key，proof 证明为参数，验证 key 是否存在于 MPT 的某条路径里，如果 key 确实存在，返回这个节点的索引 i，err 字段是 nil，否则返回 error。</p>
<h4 id="MPT-安全性"><a href="#MPT-安全性" class="headerlink" title="MPT 安全性"></a>MPT 安全性</h4><h5 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h5><p>MPT 存储的 key-value 值没有长度限制，虽然说使用的是 Patricia Trie，仍然会有整棵树深度越来越深的问题，这可能会导致查询节点需要多次 IO，影响效率；导致 Dos 攻击。<br>以太坊中里，与 MPT 交互时，key 还会进行一次 sha3 的哈希计算，这样一来，key 的长度是固定的32字节，可以避免树里出现很深的路径，同时也实现了 key 的加密存储。</p>
<p>这部分代码在 <code>trie/secure_trie.go</code>，<code>trie/hasher.go</code>，<code>crypto/sha3</code> 里面，没有什么特别的，基本上就是对增删改查的操作做了一层加 keccak256 算法的封装。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>前文介绍过分支节点，以太坊想要在效率和存储空间上达到一个平衡，所以 fullNode 只有17个孩子节点，这个值是与16进制有关的，MPT 的 key 值实际上有三种编码方法，Raw 编码，Hex 编码，HP 编码，Raw 编码即原始的字节数组，这种方式的问题是它的一个字节的范围很大，fullNode 的子树这么多会影响检索效率，当树节点需要存储到数据库时，会根据16进制来进行编码，Hex 编码和 HP 编码没本质区别，可以理解为 Hex 编码是存在于内存的中间形式，在以太坊的黄皮书了介绍的是 Hex Prefix Encoding，即 HP 编码。我们一一来看。</p>
<h5 id="Raw-编码（keybytes-encoding）"><a href="#Raw-编码（keybytes-encoding）" class="headerlink" title="Raw 编码（keybytes encoding）"></a>Raw 编码（keybytes encoding）</h5><p>原生的 key 字节数组，不做修改，这种方式是 MPT 对外提供 API 的默认方式，如果数据需要插入到树里，Raw 编码需要转换为 Hex 编码。</p>
<h5 id="Hex-编码（hex-encoding）"><a href="#Hex-编码（hex-encoding）" class="headerlink" title="Hex 编码（hex encoding）"></a>Hex 编码（hex encoding）</h5><p>Hex 编码用于对内存里的树节点 key 进行编码，当树节点需要持久化到数据库时，Hex 编码被转换为 HP 编码。</p>
<p>具体来说，这个编码的每个字节包含 key 的半个字节，尾部加一个 byte 的『终结符』16，表示这是 hex 格式。节点被加载到内存时 key 使用的是这种编码，因为方便访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></div><div class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</div><div class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</div><div class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></div><div class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></div><div class="line">	&#125;</div><div class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></div><div class="line">	<span class="keyword">return</span> nibbles</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是 Raw 编码转换为 Hex 编码的代码。</p>
<h5 id="HP-编码（compact-encoding）"><a href="#HP-编码（compact-encoding）" class="headerlink" title="HP 编码（compact encoding）"></a>HP 编码（compact encoding）</h5><p>全称是 Hex Prefix 编码，hex 编码解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但这种方式有数据冗余的问题，对于 shortNode，目前 hex 格式下的 key，长度会是原来 keybytes 格式下的两倍，这一点对于节点的哈希计算影响很大，compact 编码用于对 hex 格式进行优化。compact encoding 的主要思路是将 Hex 格式字符串先恢复到 keybytes 格式，同时加入当前编码的标记位，表示奇偶不同长度的 hex 格式。</p>
<p>具体来说，compact 编码首先会将 hex 尾部标记的 byte 去掉，然后将原来 hex 编码的包含的 key 的半个字节（称为 nibble）一一合并为1 byte，最后如果 hex 格式编码有效长度为奇数，在头部增加 0011xxxx，其中 xxxx 为第一个 nibble，否则在头部增加 00100000。节点在写入数据库时使用的是 compact 编码，因为可以节约磁盘。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func hexToCompact(<span class="built_in">hex</span> []<span class="built_in">byte</span>) []<span class="built_in">byte</span> &#123;</div><div class="line">	terminator := <span class="built_in">byte</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> hasTerm(<span class="built_in">hex</span>) &#123;</div><div class="line">		terminator = <span class="number">1</span></div><div class="line">		<span class="built_in">hex</span> = <span class="built_in">hex</span>[:len(<span class="built_in">hex</span>)<span class="number">-1</span>]</div><div class="line">	&#125;</div><div class="line">	buf := make([]<span class="built_in">byte</span>, len(<span class="built_in">hex</span>)/<span class="number">2</span>+<span class="number">1</span>)</div><div class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span></div><div class="line">	<span class="keyword">if</span> len(<span class="built_in">hex</span>)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</div><div class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> </div><div class="line">		buf[<span class="number">0</span>] |= <span class="built_in">hex</span>[<span class="number">0</span>]</div><div class="line">		<span class="built_in">hex</span> = <span class="built_in">hex</span>[<span class="number">1</span>:]</div><div class="line">	&#125;</div><div class="line">	decodeNibbles(<span class="built_in">hex</span>, buf[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">return</span> buf</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果该节点有 value，则 teerminator 为1，其中 <code>buf[0] = terminator &lt;&lt; 5</code> 表示，如果是叶子节点，<code>buf[0]</code> 为 00100000，否则为 00000000，接下来的 <code>if len(hex)&amp;1 == 1</code> if 判断表示 hex 长度为奇数的情况，这时将 buf[0] 赋值为 0011xxxx，其中 xxxx 为 hex[0] 的值，即第一个 nibble 的值，最后调用 <code>decodeNibbles</code>，将两个两个的 nibble 字节合并为一个字节。以上就是 HP 编码的整个过程。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie</a></li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">leetcode, 208. Implement Trie(Prefix Tree)</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a></li>
<li><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">merkling-in-ethereum</a></li>
<li><a href="https://github.com/ethereumjs/merkle-patricia-tree" target="_blank" rel="external">ethereumjs/merkle-patricia-tree</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cryptocurrency/" rel="tag">#cryptocurrency</a>
          
            <a href="/tags/Golang/" rel="tag">#Golang</a>
          
            <a href="/tags/geth/" rel="tag">#geth</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/10/go-ethereum 源码笔记（rlp 模块-序列化与反序列化）/" rel="next" title="go-ethereum 源码笔记（rlp 模块-序列化与反序列化）">
                <i class="fa fa-chevron-left"></i> go-ethereum 源码笔记（rlp 模块-序列化与反序列化）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/10/go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）/" rel="prev" title="go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）">
                go-ethereum 源码笔记（accounts, transaction 模块-账户和转账） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/6964284?v=3&s=460"
               alt="Frank" />
          <p class="site-author-name" itemprop="name">Frank</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">181</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">129</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2753500945" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Merkle-Tree-默克尔树"><span class="nav-number">1.</span> <span class="nav-text">Merkle Tree 默克尔树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynano-数据库"><span class="nav-number">1.1.</span> <span class="nav-text">Dynano 数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BitTorrent"><span class="nav-number">1.2.</span> <span class="nav-text">BitTorrent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Patricia-帕特里夏树"><span class="nav-number">2.</span> <span class="nav-text">Patricia 帕特里夏树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trie-字典树"><span class="nav-number">2.1.</span> <span class="nav-text">trie 字典树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用范围"><span class="nav-number">2.1.1.</span> <span class="nav-text">应用范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例"><span class="nav-number">2.1.2.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PatriciaTrie-帕特里夏树"><span class="nav-number">2.2.</span> <span class="nav-text">PatriciaTrie 帕特里夏树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Merkle-Patricia-Tree-默克尔-帕特里夏树"><span class="nav-number">3.</span> <span class="nav-text">Merkle Patricia Tree 默克尔-帕特里夏树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Geth-的-MPT"><span class="nav-number">4.</span> <span class="nav-text">Geth 的 MPT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默克尔树的作用"><span class="nav-number">4.1.</span> <span class="nav-text">默克尔树的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轻节点扩展"><span class="nav-number">4.1.1.</span> <span class="nav-text">轻节点扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#轻节点"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">轻节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默克尔证明"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">默克尔证明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#帕特里树的作用"><span class="nav-number">4.2.</span> <span class="nav-text">帕特里树的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MPT-在-geth-中的实现细节"><span class="nav-number">5.</span> <span class="nav-text">MPT 在 geth 中的实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">5.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fullNode"><span class="nav-number">5.1.1.</span> <span class="nav-text">fullNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shortNode"><span class="nav-number">5.1.2.</span> <span class="nav-text">shortNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#valueNode"><span class="nav-number">5.1.3.</span> <span class="nav-text">valueNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashNode"><span class="nav-number">5.1.4.</span> <span class="nav-text">hashNode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">5.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Trie-的基本操作"><span class="nav-number">5.2.1.</span> <span class="nav-text">Trie 的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">删</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#改"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提交"><span class="nav-number">5.2.1.6.</span> <span class="nav-text">提交</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trie-的序列化和反序列化"><span class="nav-number">5.2.2.</span> <span class="nav-text">Trie 的序列化和反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#store"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">store</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#resolve"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">resolve</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默克尔证明-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">默克尔证明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#proof"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">proof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VerifyProof"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">VerifyProof</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MPT-安全性"><span class="nav-number">5.2.4.</span> <span class="nav-text">MPT 安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#哈希计算"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">哈希计算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编码"><span class="nav-number">5.2.5.</span> <span class="nav-text">编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Raw-编码（keybytes-encoding）"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">Raw 编码（keybytes encoding）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hex-编码（hex-encoding）"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">Hex 编码（hex encoding）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HP-编码（compact-encoding）"><span class="nav-number">5.2.5.3.</span> <span class="nav-text">HP 编码（compact encoding）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">6.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'knarfeh';
      var disqus_identifier = '2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/';
      var disqus_title = 'go-ethereum 源码笔记（trie 模块-MPT 的实现）';
      var disqus_url = 'http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  


  

  <script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
