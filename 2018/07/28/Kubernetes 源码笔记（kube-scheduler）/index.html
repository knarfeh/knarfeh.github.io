<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Golang,k8s,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0">






<meta name="description" content="kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。 一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。">
<meta name="keywords" content="Golang,k8s">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes 源码笔记（kube-scheduler）">
<meta property="og:url" content="http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kube-scheduler）/index.html">
<meta property="og:site_name" content="knarfeh&#39;s logbook">
<meta property="og:description" content="kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。 一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube_scheduler_algo.png">
<meta property="og:updated_time" content="2020-04-02T03:51:40.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kubernetes 源码笔记（kube-scheduler）">
<meta name="twitter:description" content="kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。 一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。">
<meta name="twitter:image" content="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube_scheduler_algo.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Kubernetes 源码笔记（kube-scheduler） | knarfeh's logbook </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-75002639-1', 'auto');
  ga('send', 'pageview');
</script>









  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">knarfeh's logbook</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Kubernetes 源码笔记（kube-scheduler）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-28T00:15:08+08:00" content="2018-07-28">
              2018-07-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/28/Kubernetes 源码笔记（kube-scheduler）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/28/Kubernetes 源码笔记（kube-scheduler）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。</p>
<p>一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。</p>
<a id="more"></a>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>kube-scheduler 会对 pod, node 进行 Watch，当 kube-scheduler 监测到未被调度的 pod（spec.nodeName 为空），它会取出这个 pod，然后根据内部设定的调度算法选择合适的 node，通过 api-server 写回到 etcd，这时该 pod 就绑定到了该 node 上，之后 kubelet 会读取到这一信息，在相应的 node 上运行 pod。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul>
<li>客户端通过 api-server 创建 pod，相关数据存储到 etcd</li>
<li>kube-scheduler 通过 NodeLister 获取所有节点信息</li>
<li>将 scheduled pods 和 assume pods 合并到 pods，作为所有已调度 Pod 信息</li>
<li>从 pods 中整理出 node-pods 的对应关系表 nodeNameToInfo</li>
<li>过滤掉不合适的节点（Predicates 预选）</li>
<li>给剩下的节点依次打分（Priorities 优选）</li>
<li>若分数相同，在节点中随机选择一个节点，否则选择分数最高的节点调用 api 进行 pod 和 node 的绑定。结果存储到 etcd 里</li>
</ul>
<h2 id="调度策略和算法"><a href="#调度策略和算法" class="headerlink" title="调度策略和算法"></a>调度策略和算法</h2><p>k8s 里的调度策略和算法包括预选（predicates），优选（priorities）两个步骤。通俗来说其实就是过滤和评分。</p>
<p>借助下图可以方便理解(来自 <a href="http://dockone.io/article/2885" target="_blank" rel="noopener">DockOne微信分享（一四九）：Kubernetes调度详解</a>)</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube_scheduler_algo.png" alt="kube_scheduler_algo"></p>
<h3 id="Predicates-预选"><a href="#Predicates-预选" class="headerlink" title="Predicates 预选"></a>Predicates 预选</h3><p>根据配置的 Predicates Policies（默认为 DefaultProvider 中定义的 default predicates policies 集合）来过滤掉不满足 Policies 的 Nodes，避免资源冲突，节点超载。</p>
<p>典型的 Predicates 算法有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GeneralPredicates</td>
<td style="text-align:center">包含一些基本的筛选规则，主要考虑资源问题，比如 CPU，内存是否足够，端口是否冲突，selector 是否匹配</td>
</tr>
<tr>
<td style="text-align:center">NoDiskConflict</td>
<td style="text-align:center">Pod 所需的卷是否与节点已存在的卷冲突，比如如果节点已经挂载了某个卷，其他同样使用这个卷的 Pod 不能再调度到这个主机。</td>
</tr>
<tr>
<td style="text-align:center">NoVolumeZoneCOnflict</td>
<td style="text-align:center">但集群跨可用区部署时，检查 node 所在的 zone 是否满足 Pod 对硬盘的要求</td>
</tr>
<tr>
<td style="text-align:center">MaxEBSVolumeCount</td>
<td style="text-align:center">部署在 AWS 时，检查 node 是否挂载了太多 EBS 卷</td>
</tr>
<tr>
<td style="text-align:center">MaxGCEPDVolumeCount</td>
<td style="text-align:center">部署在 GCE 时，检查 node 是否挂载了太多 PD 卷</td>
</tr>
<tr>
<td style="text-align:center">PodToleratesNodeTaints</td>
<td style="text-align:center">检查 Pod 是否能够容忍 node 上所有的 taints</td>
</tr>
<tr>
<td style="text-align:center">CheckNodeMemoryPressure</td>
<td style="text-align:center">当 Pod QoS 为 besteffort 时，检查 node 剩余内存量，排除内存压力过大的 node</td>
</tr>
<tr>
<td style="text-align:center">MatchInterPodAffinity</td>
<td style="text-align:center">检查 node 是否满足 pod 的亲和性、反亲和性需求</td>
</tr>
<tr>
<td style="text-align:center">HostName</td>
<td style="text-align:center">节点需满足 PodSpec 的 NodeName 字段指定的主机名</td>
</tr>
<tr>
<td style="text-align:center">CheckNodeDiskPressure</td>
<td style="text-align:center">判断节点是否已经处于磁盘压力状态</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>predicates 相关的算法在 <code>pkg/scheduler/algorithm/predicates/predicates.go</code> 中。</p>
<h3 id="Priorities-优选"><a href="#Priorities-优选" class="headerlink" title="Priorities 优选"></a>Priorities 优选</h3><p>根据配置的 Priorities Policies（默认为 DefaultProvider 中定义的 default priorities policies 集合）给预选的 Nodes 打分排名，得分最高的 Node 为最合适的 Node，该 Pod 会绑定到这个 Node。如果得分有并列的情况，则从中选择一个 Node。</p>
<p>典型的 Priority 算法有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LeastRequestedPriority</td>
<td style="text-align:center">按 node 计算资源（CPU/MEM）剩余量排序，挑选最空闲的 node</td>
</tr>
<tr>
<td style="text-align:center">BalancedResourceAllocation</td>
<td style="text-align:center">补充 LeastRequestedPriority，在 CPU 和 MEM 的剩余量中取平衡</td>
</tr>
<tr>
<td style="text-align:center">SelectorSpreadPriority</td>
<td style="text-align:center">同一个 Service/RC 下的 Pod 应该尽可能地分散在集群里。Node 上运行的同个 Service/RC 下的 Pod 数目越少，分数越高</td>
</tr>
<tr>
<td style="text-align:center">NodeAffinityPriority</td>
<td style="text-align:center">按 soft(preferred) NodeAffinity 规则匹配情况排序，规则命中越高，分数越高</td>
</tr>
<tr>
<td style="text-align:center">TaintTolerationPriority</td>
<td style="text-align:center">按 Pod tolerations 与 node taints 的匹配情况排序，越多 taints 不匹配，分数越低</td>
</tr>
<tr>
<td style="text-align:center">InterPodAffinityPriority</td>
<td style="text-align:center">按 soft(preferred) Pod Affinity/Anti-Affinity 规则匹配情况排序，规则命中越多，分数越高/低</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>priorities 相关的算法在 <code>pkg/scheduler/algorithm/priorities/</code> 目录下。</p>
<p>最终主机的得分由以下公式计算得到：</p>
<p><code>finalScoreNode = (weight1 * priorityFunc1) + (weight2 * priorityFunc2) + … + (weightn * priorityFuncn)</code></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>分析的代码是基于 v1.12.2-beta.0 版本的。之前很长一段时间，Scheduler 的源码在 plugin 目录下，不过 v1.12.2-beta.0 版本的入口程序在 <code>cmd/kube-scheduler/scheduler.go</code> 里。同 Kubernetes 的其他组件类似，先通过 <code>command := app.NewSchedulerCommand()</code> 获取 cobra 的 command 对象然后执行，实际的运行过程在 <code>cmd/kube-scheduler/app/server.go</code> 中。</p>
<h3 id="总体逻辑"><a href="#总体逻辑" class="headerlink" title="总体逻辑"></a>总体逻辑</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c schedulerserverconfig.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	algorithmprovider.ApplyFeatureGates()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Configz registration ...</span></span><br><span class="line">	</span><br><span class="line">	schedulerConfig, err := NewSchedulerConfig(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create the scheduler ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare the event broadcaster ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start up the healthz server ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start all informers</span></span><br><span class="line">	<span class="keyword">go</span> c.PodInformer.Informer().Run(stopCh)</span><br><span class="line">	c.InformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all caches to sync before scheduling </span></span><br><span class="line">	c.InformerFactory.WaitForCacheSync(stopCh)</span><br><span class="line">	controller.WaitForCacheSync(<span class="string">"scheduler"</span>, stopCh, c.PodInformer.Informer().HasSynced)</span><br><span class="line"></span><br><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		sched.Run()</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.TODO())</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			cancel()</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// If leader election is enabled, run via LeaderElector until done and exit</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	run(ctx)</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"finished without leader elect"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Run</code> 方法会根据传入的上下文参数初始化一个 <code>schedulerConfig</code> 对象，根据配置创建 Scheduler 对象，启动所有的 informer，最后运行 Scheduler 的核心逻辑 <code>run</code> 方法，这是一个死循环，直到从通道接收到退出的消息才会退出。它会一直调用 <code>pkg/scheduler/scheduler.go</code> 中 Scheduler 的 <code>Run</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !sched.config.WaitForCacheSync() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.config.StopEverything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>scheduleOne</code> 方法为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pod := sched.config.NextPod()</span><br><span class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		glog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Synchronously attempt to find a fit for the pod.</span></span><br><span class="line">	start := time.Now()</span><br><span class="line">	suggestedHost, err := sched.schedule(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;</span><br><span class="line">			preemptionStartTime := time.Now()</span><br><span class="line">			sched.preempt(pod, fitError)</span><br><span class="line">			metrics.PreemptionAttempts.Inc()</span><br><span class="line">			metrics.SchedulingAlgorithmPremptionEvaluationDuration.Observe(metrics.SinceInMicroseconds(preemptionStartTime))</span><br><span class="line">			metrics.SchedulingLatency.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</span><br><span class="line">	assumedPod := pod.DeepCopy()</span><br><span class="line"></span><br><span class="line">	allBound, err := sched.assumeVolumes(assumedPod, suggestedHost)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = sched.assume(assumedPod, suggestedHost)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !allBound &#123;</span><br><span class="line">			err = sched.bindVolumes(assumedPod)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err := sched.bind(assumedPod, &amp;v1.Binding&#123;</span><br><span class="line">			ObjectMeta: metav1.ObjectMeta&#123;Namespace: assumedPod.Namespace, Name: assumedPod.Name, UID: assumedPod.UID&#125;,</span><br><span class="line">			Target: v1.ObjectReference&#123;</span><br><span class="line">				Kind: <span class="string">"Node"</span>,</span><br><span class="line">				Name: suggestedHost,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		metrics.E2eSchedulingLatency.Observe(metrics.SinceInMicroseconds(start))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Errorf(<span class="string">"Internal error binding pod: (%v)"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scheduleOne</code> 被 <code>Run</code> 方法调用，每次调度一个 pod。首先调用 NextPod，从未调度的队列中取出一个应该被调度的 Pod。接着进行节点的选择。</p>
<h4 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h4><p>其中 <code>suggestedHost, err := sched.schedule(pod)</code> 这一行调用了实现的 scheduling 算法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	host, err := sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		pod = pod.DeepCopy()</span><br><span class="line">		sched.config.Error(pod, err)</span><br><span class="line">		sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</span><br><span class="line">		sched.config.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</span><br><span class="line">			Type:    v1.PodScheduled,</span><br><span class="line">			Status:  v1.ConditionFalse,</span><br><span class="line">			Reason:  v1.PodReasonUnschedulable,</span><br><span class="line">			Message: err.Error(),</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> host, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule</code> 可以用来返回一个最合适的 node，在 <code>scheduleOne</code> 中我们可以看到，接下来调用 <code>bind</code> 进行 pod 与 node 的绑定就行了。其中 <code>sched.config.Algorithm.Schedule</code> 会调用调度的真正算法。以上就是 kube-scheduler 的基本逻辑，接下来我们深入到其中需要注意的细节。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h4 id="获取配置信息"><a href="#获取配置信息" class="headerlink" title="获取配置信息"></a>获取配置信息</h4><p>在上述的 <code>Run</code> 方法中，进入 Scheduler 的核心逻辑前的初始化很重要，因为需要初始化 Node，Pod 等的 Informer 方法，确定 Predicate 阶段和 Priority 阶段所需的调度算法，根据接口进行相应的初始化。某种意义上这也是一个依赖注入的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerConfig</span><span class="params">(s schedulerserverconfig.CompletedConfig)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> storageClassInformer storageinformers.StorageClassInformer</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) &#123;</span><br><span class="line">		storageClassInformer = s.InformerFactory.Storage().V1().StorageClasses()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	configurator := factory.NewConfigFactory(&amp;factory.ConfigFactoryArgs&#123;</span><br><span class="line">		SchedulerName:                  s.ComponentConfig.SchedulerName,</span><br><span class="line">		Client:                         s.Client,</span><br><span class="line">		NodeInformer:                   s.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">		PodInformer:                    s.PodInformer,</span><br><span class="line">		PvInformer:                     s.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">		PvcInformer:                    s.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">		ReplicationControllerInformer:  s.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">		ReplicaSetInformer:             s.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		StatefulSetInformer:            s.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">		ServiceInformer:                s.InformerFactory.Core().V1().Services(),</span><br><span class="line">		PdbInformer:                    s.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">		StorageClassInformer:           storageClassInformer,</span><br><span class="line">		HardPodAffinitySymmetricWeight: s.ComponentConfig.HardPodAffinitySymmetricWeight,</span><br><span class="line">		EnableEquivalenceClassCache:    utilfeature.DefaultFeatureGate.Enabled(features.EnableEquivalenceClassCache),</span><br><span class="line">		DisablePreemption:              s.ComponentConfig.DisablePreemption,</span><br><span class="line">		PercentageOfNodesToScore:       s.ComponentConfig.PercentageOfNodesToScore,</span><br><span class="line">		BindTimeoutSeconds:             *s.ComponentConfig.BindTimeoutSeconds,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	source := s.ComponentConfig.AlgorithmSource</span><br><span class="line">	<span class="keyword">var</span> config *scheduler.Config</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">		sc, err := configurator.CreateFromProvider(*source.Provider)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler using provider %q: %v"</span>, *source.Provider, err)</span><br><span class="line">		&#125;</span><br><span class="line">		config = sc</span><br><span class="line">	<span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">		policy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> source.Policy.File != <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// Use policy config file define policy ...</span></span><br><span class="line">		<span class="keyword">case</span> source.Policy.ConfigMap != <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// Use ConfigMap define policy ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		sc, err := configurator.CreateFromConfig(*policy)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler from policy: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		config = sc</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unsupported algorithm source: %v"</span>, source)</span><br><span class="line">	&#125;</span><br><span class="line">	config.Recorder = s.Recorder</span><br><span class="line"></span><br><span class="line">	config.DisablePreemption = s.ComponentConfig.DisablePreemption</span><br><span class="line">	<span class="keyword">return</span> config, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>NewSchedulerConfig</code> 方法中，有两种方式来创建 scheduler.Config, 这是由配置决定的。用户可以编写 policy 文件，决定调度器可以使用哪些 predicates 和 priorities 算法。这些算法在 <code>pkg/scheduler/algorithm</code> 中定义；也可以根据 algorithm provider 决定，最终都是为了获取 predicates 和 priorities 的方法的集合。以默认的 algorithm provider 为例，<code>CreateFromProvider</code> 接口在 <code>pkg/scheduler/scheduler.go</code> 中定义，实现是在 <code>pkg/scheduler/factory/factory.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configFactory)</span> <span class="title">CreateFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</span><br><span class="line">	glog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler from algorithm provider '%v'"</span>, providerName)</span><br><span class="line">	provider, err := GetAlgorithmProvider(providerName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.CreateFromKeys(provider.FitPredicateKeys, provider.PriorityFunctionKeys, []algorithm.SchedulerExtender&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configFactory)</span> <span class="title">CreateFromKeys</span><span class="params">(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</span><br><span class="line">	glog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler with fit predicates '%v' and priority functions '%v'"</span>, predicateKeys, priorityKeys)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.GetHardPodAffinitySymmetricWeight() &lt; <span class="number">1</span> || c.GetHardPodAffinitySymmetricWeight() &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100"</span>, c.GetHardPodAffinitySymmetricWeight())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	predicateFuncs, err := c.GetPredicates(predicateKeys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priorityConfigs, err := c.GetPriorityFunctionConfigs(priorityKeys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priorityMetaProducer, err := c.GetPriorityMetadataProducer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	predicateMetaProducer, err := c.GetPredicateMetadataProducer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.enableEquivalenceClassCache &#123;</span><br><span class="line">		c.equivalencePodCache = equivalence.NewCache()</span><br><span class="line">		glog.Info(<span class="string">"Created equivalence class cache"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	algo := core.NewGenericScheduler(</span><br><span class="line">		c.schedulerCache,</span><br><span class="line">		c.equivalencePodCache,</span><br><span class="line">		c.podQueue,</span><br><span class="line">		predicateFuncs,</span><br><span class="line">		predicateMetaProducer,</span><br><span class="line">		priorityConfigs,</span><br><span class="line">		priorityMetaProducer,</span><br><span class="line">		extenders,</span><br><span class="line">		c.volumeBinder,</span><br><span class="line">		c.pVCLister,</span><br><span class="line">		c.alwaysCheckAllPredicates,</span><br><span class="line">		c.disablePreemption,</span><br><span class="line">		c.percentageOfNodesToScore,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	podBackoff := util.CreateDefaultPodBackoff()</span><br><span class="line">	<span class="keyword">return</span> &amp;scheduler.Config&#123;</span><br><span class="line">		SchedulerCache: c.schedulerCache,</span><br><span class="line">		Ecache:         c.equivalencePodCache,</span><br><span class="line">		NodeLister:          &amp;nodeLister&#123;c.nodeLister&#125;,</span><br><span class="line">		Algorithm:           algo,</span><br><span class="line">		GetBinder:           c.getBinderFunc(extenders),</span><br><span class="line">		PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">		PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">		WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">		&#125;,</span><br><span class="line">		NextPod: <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c.getNextPod()</span><br><span class="line">		&#125;,</span><br><span class="line">		Error:          c.MakeDefaultErrorFunc(podBackoff, c.podQueue),</span><br><span class="line">		StopEverything: c.StopEverything,</span><br><span class="line">		VolumeBinder:   c.volumeBinder,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CreateFromKeys</code> 会根据定义的 predicate 和 priority 的 key 生成一个 scheduler。主要的调度算法都在 <code>pkg/scheduler/core/generic_scheduler.go</code> 中定义。</p>
<h4 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	trace := utiltrace.New(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</span><br><span class="line">	<span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodes, err := nodeLister.List()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used for all fit and priority funcs.</span></span><br><span class="line">	err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace.Step(<span class="string">"Computing predicates"</span>)</span><br><span class="line">	startPredicateEvalTime := time.Now()</span><br><span class="line">	filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</span><br><span class="line">			Pod:              pod,</span><br><span class="line">			NumAllNodes:      <span class="built_in">len</span>(nodes),</span><br><span class="line">			FailedPredicates: failedPredicateMap,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	metrics.SchedulingAlgorithmPredicateEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPredicateEvalTime))</span><br><span class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.PredicateEvaluation).Observe(metrics.SinceInSeconds(startPredicateEvalTime))</span><br><span class="line"></span><br><span class="line">	trace.Step(<span class="string">"Prioritizing"</span>)</span><br><span class="line">	startPriorityEvalTime := time.Now()</span><br><span class="line">	<span class="comment">// When only one node after predicate, just use it.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">1</span> &#123;</span><br><span class="line">		metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</span><br><span class="line">		<span class="keyword">return</span> filteredNodes[<span class="number">0</span>].Name, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</span><br><span class="line">	priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</span><br><span class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.PriorityEvaluation).Observe(metrics.SinceInSeconds(startPriorityEvalTime))</span><br><span class="line"></span><br><span class="line">	trace.Step(<span class="string">"Selecting host"</span>)</span><br><span class="line">	<span class="keyword">return</span> g.selectHost(priorityList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，调度分为几个关键的步骤，首先从 cache 中获取可调度的 nodes，接着预选，筛除不合适的 node，然后优选打分，选出最合适的 node，如果选出了多个 node，则使用 round-robin 算法选出一个 node 作为最终的结果。</p>
<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">findNodesThatFit</span><span class="params">(pod *v1.Pod, nodes []*v1.Node)</span> <span class="params">([]*v1.Node, FailedPredicateMap, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> filtered []*v1.Node</span><br><span class="line">	failedPredicateMap := FailedPredicateMap&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(g.predicates) == <span class="number">0</span> &#123;</span><br><span class="line">		filtered = nodes</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		allNodes := <span class="keyword">int32</span>(g.cache.NodeTree().NumNodes)</span><br><span class="line">		numNodesToFind := g.numFeasibleNodesToFind(allNodes)</span><br><span class="line"></span><br><span class="line">		filtered = <span class="built_in">make</span>([]*v1.Node, numNodesToFind)</span><br><span class="line">		errs := errors.MessageCountMap&#123;&#125;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			predicateResultLock sync.Mutex</span><br><span class="line">			filteredLen         <span class="keyword">int32</span></span><br><span class="line">			equivClass          *equivalence.Class</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">		meta := g.predicateMetaProducer(pod, g.cachedNodeInfoMap)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> g.equivalenceCache != <span class="literal">nil</span> &#123;</span><br><span class="line">			equivClass = equivalence.NewClass(pod)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">var</span> nodeCache *equivalence.NodeCache</span><br><span class="line">			nodeName := g.cache.NodeTree().Next()</span><br><span class="line">			<span class="keyword">if</span> g.equivalenceCache != <span class="literal">nil</span> &#123;</span><br><span class="line">				nodeCache, _ = g.equivalenceCache.GetNodeCache(nodeName)</span><br><span class="line">			&#125;</span><br><span class="line">			fits, failedPredicates, err := podFitsOnNode(</span><br><span class="line">				pod,</span><br><span class="line">				meta,</span><br><span class="line">				g.cachedNodeInfoMap[nodeName],</span><br><span class="line">				g.predicates,</span><br><span class="line">				g.cache,</span><br><span class="line">				nodeCache,</span><br><span class="line">				g.schedulingQueue,</span><br><span class="line">				g.alwaysCheckAllPredicates,</span><br><span class="line">				equivClass,</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				predicateResultLock.Lock()</span><br><span class="line">				errs[err.Error()]++</span><br><span class="line">				predicateResultLock.Unlock()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> fits &#123;</span><br><span class="line">				length := atomic.AddInt32(&amp;filteredLen, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span> length &gt; numNodesToFind &#123;</span><br><span class="line">					cancel()</span><br><span class="line">					atomic.AddInt32(&amp;filteredLen, <span class="number">-1</span>)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					filtered[length<span class="number">-1</span>] = g.cachedNodeInfoMap[nodeName].Node()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				predicateResultLock.Lock()</span><br><span class="line">				failedPredicateMap[nodeName] = failedPredicates</span><br><span class="line">				predicateResultLock.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		workqueue.ParallelizeUntil(ctx, <span class="number">16</span>, <span class="keyword">int</span>(allNodes), checkNode)</span><br><span class="line"></span><br><span class="line">		filtered = filtered[:filteredLen]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, errors.CreateAggregateFromMessageCountMap(errs)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filtered) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(g.extenders) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, extender := <span class="keyword">range</span> g.extenders &#123;</span><br><span class="line">			<span class="keyword">if</span> !extender.IsInterested(pod) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			filteredList, failedMap, err := extender.Filter(pod, filtered, g.cachedNodeInfoMap)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> extender.IsIgnorable() &#123;</span><br><span class="line">					glog.Warningf(<span class="string">"Skipping extender %v as it returned error %v and has ignorable flag set"</span>,</span><br><span class="line">						extender, err)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> failedNodeName, failedMsg := <span class="keyword">range</span> failedMap &#123;</span><br><span class="line">				<span class="keyword">if</span> _, found := failedPredicateMap[failedNodeName]; !found &#123;</span><br><span class="line">					failedPredicateMap[failedNodeName] = []algorithm.PredicateFailureReason&#123;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				failedPredicateMap[failedNodeName] = <span class="built_in">append</span>(failedPredicateMap[failedNodeName], predicates.NewFailureReason(failedMsg))</span><br><span class="line">			&#125;</span><br><span class="line">			filtered = filteredList</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(filtered) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> filtered, failedPredicateMap, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Predicate 是预选的过程。其中 <code>checkNode</code> 方法会调用 <code>podFitsOnNode</code>，应用所有配置的预选 Policy 对 Node 进行检查。接着 <code>workqueue.ParallelizeUntil(ctx, 16, int(allNodes), checkNode)</code> 以16个为一批，根据 node 的数量并发检查 node。其中 Extender 是调度算法的一种扩展，也属于自定义调度器的一种方式，如果配置了 <code>Extender</code>，则执行 <code>Extender</code> 的 <code>Filter</code> 再次筛选。 </p>
<h5 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrioritizeNodes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulercache.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">	meta <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	priorityConfigs []algorithm.PriorityConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">	extenders []algorithm.SchedulerExtender,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(schedulerapi.HostPriorityList, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(priorityConfigs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(extenders) == <span class="number">0</span> &#123;</span><br><span class="line">		result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">			hostPriority, err := EqualPriorityMap(pod, meta, nodeNameToInfo[nodes[i].Name])</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			result = <span class="built_in">append</span>(result, hostPriority)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		mu   = sync.Mutex&#123;&#125;</span><br><span class="line">		wg   = sync.WaitGroup&#123;&#125;</span><br><span class="line">		errs []error</span><br><span class="line">	)</span><br><span class="line">	appendError := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">		mu.Lock()</span><br><span class="line">		<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">		<span class="keyword">if</span> priorityConfig.Function != <span class="literal">nil</span> &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				<span class="keyword">var</span> err error</span><br><span class="line">				results[index], err = config.Function(pod, nodeNameToInfo, nodes)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					appendError(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(i, priorityConfig)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			results[i] = <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="built_in">len</span>(nodes))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processNode := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		nodeInfo := nodeNameToInfo[nodes[index].Name]</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">			<span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				appendError(err)</span><br><span class="line">				results[i][index].Host = nodes[index].Name</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	workqueue.Parallelize(<span class="number">16</span>, <span class="built_in">len</span>(nodes), processNode)</span><br><span class="line">	<span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">		<span class="keyword">if</span> priorityConfig.Reduce == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">if</span> err := config.Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				appendError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</span><br><span class="line">					glog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, pod.Name, hostPriority.Host, config.Name, hostPriority.Score)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i, priorityConfig)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> schedulerapi.HostPriorityList&#123;&#125;, errors.NewAggregate(errs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, schedulerapi.HostPriority&#123;Host: nodes[i].Name, Score: <span class="number">0</span>&#125;)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">			result[i].Score += results[j][i].Score * priorityConfigs[j].Weight</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(extenders) != <span class="number">0</span> &amp;&amp; nodes != <span class="literal">nil</span> &#123;</span><br><span class="line">		combinedScores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nodeNameToInfo))</span><br><span class="line">		<span class="keyword">for</span> _, extender := <span class="keyword">range</span> extenders &#123;</span><br><span class="line">			<span class="keyword">if</span> !extender.IsInterested(pod) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ext algorithm.SchedulerExtender)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				prioritizedList, weight, err := ext.Prioritize(pod, nodes)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				mu.Lock()</span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> *prioritizedList &#123;</span><br><span class="line">					host, score := (*prioritizedList)[i].Host, (*prioritizedList)[i].Score</span><br><span class="line">					combinedScores[host] += score * weight</span><br><span class="line">				&#125;</span><br><span class="line">				mu.Unlock()</span><br><span class="line">			&#125;(extender)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">			result[i].Score += combinedScores[result[i].Host]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">			glog.V(<span class="number">10</span>).Infof(<span class="string">"Host %s =&gt; Score %d"</span>, result[i].Host, result[i].Score)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Priority</code> 是优选的过程，<code>processNode</code> 用于对 node 遍历所有的 priorities policy，获取该 node 对于所有 policy 的分数。同 predicate 类似，以16个 goroutine 为一组，根据 nodes 数量，并发执行这些算法，最后对得分进行加权得到最终的分数。</p>
<h5 id="选择节点-1"><a href="#选择节点-1" class="headerlink" title="选择节点"></a>选择节点</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">selectHost</span><span class="params">(priorityList schedulerapi.HostPriorityList)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(priorityList) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"empty priorityList"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxScores := findMaxScores(priorityList)</span><br><span class="line">	ix := <span class="keyword">int</span>(g.lastNodeIndex % <span class="keyword">uint64</span>(<span class="built_in">len</span>(maxScores)))</span><br><span class="line">	g.lastNodeIndex++</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> priorityList[maxScores[ix]].Host, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 Predicates 预选阶段和 Priorities 优选阶段后，我们需要选择一个最终的节点，首先根据分数进行排序，如果分数最高的节点有多个，则根据最高分数的个数进行 round-robin 选择。<code>findMaxScores</code> 用来构造按照分数进行排列的优先列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxScores</span><span class="params">(priorityList schedulerapi.HostPriorityList)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	maxScoreIndexes := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(priorityList)/<span class="number">2</span>)</span><br><span class="line">	maxScore := priorityList[<span class="number">0</span>].Score</span><br><span class="line">	<span class="keyword">for</span> i, hp := <span class="keyword">range</span> priorityList &#123;</span><br><span class="line">		<span class="keyword">if</span> hp.Score &gt; maxScore &#123;</span><br><span class="line">			maxScore = hp.Score</span><br><span class="line">			maxScoreIndexes = maxScoreIndexes[:<span class="number">0</span>]</span><br><span class="line">			maxScoreIndexes = <span class="built_in">append</span>(maxScoreIndexes, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> hp.Score == maxScore &#123;</span><br><span class="line">			maxScoreIndexes = <span class="built_in">append</span>(maxScoreIndexes, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxScoreIndexes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 <code>scheduleOne</code> 方法，获取最终的候选节点后，首先进行 Volume 的分配，绑定，最后通过 <code>bind</code> 方法进行最后的 pod 和 node 的绑定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(assumed *v1.Pod, b *v1.Binding)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	bindingStart := time.Now()</span><br><span class="line">	err := sched.config.GetBinder(assumed).Bind(b)</span><br><span class="line">	<span class="keyword">if</span> err := sched.config.SchedulerCache.FinishBinding(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Errorf(<span class="string">"scheduler cache FinishBinding failed: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to bind pod: %v/%v"</span>, assumed.Namespace, assumed.Name)</span><br><span class="line">		<span class="keyword">if</span> err := sched.config.SchedulerCache.ForgetPod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Errorf(<span class="string">"scheduler cache ForgetPod failed: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		sched.config.Error(assumed, err)</span><br><span class="line">		sched.config.Recorder.Eventf(assumed, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Binding rejected: %v"</span>, err)</span><br><span class="line">		sched.config.PodConditionUpdater.Update(assumed, &amp;v1.PodCondition&#123;</span><br><span class="line">			Type:   v1.PodScheduled,</span><br><span class="line">			Status: v1.ConditionFalse,</span><br><span class="line">			Reason: <span class="string">"BindingRejected"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metrics.BindingLatency.Observe(metrics.SinceInMicroseconds(bindingStart))</span><br><span class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.Binding).Observe(metrics.SinceInSeconds(bindingStart))</span><br><span class="line">	sched.config.Recorder.Eventf(assumed, v1.EventTypeNormal, <span class="string">"Scheduled"</span>, <span class="string">"Successfully assigned %v/%v to %v"</span>, assumed.Namespace, assumed.Name, b.Target.Name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched.config.GetBinder(assumed).Bind(b)</code> 中的 Bind 的实现在 <code>pkg/scheduler/factory/factory.go</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *binder)</span> <span class="title">Bind</span><span class="params">(binding *v1.Binding)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to bind %v to %v"</span>, binding.Name, binding.Target.Name)</span><br><span class="line">	<span class="keyword">return</span> b.Client.CoreV1().Pods(binding.Namespace).Bind(binding)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scheduler 最后会向 apiserver 发送 Binding 对象，如果绑定失败，执行回滚操作。至此，调度过程结束，运行 Pod 的工作将交给绑定的 Node 上的 kubelet。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="自定义调度"><a href="#自定义调度" class="headerlink" title="自定义调度"></a>自定义调度</h3><p>如果默认的调度器不满足要求，可以部署自定义的调度器，在部署的时候可以通过 <code>podSpec.schedulerName</code> 来选择使用哪一个调度器。Kubernetes 的调度器以插件化的形式实现，方便用户对调度定制和二次开发。</p>
<h4 id="定制-Predicates-和-Priority"><a href="#定制-Predicates-和-Priority" class="headerlink" title="定制 Predicates 和 Priority"></a>定制 Predicates 和 Priority</h4><p>启动 kube-schduler 的时候可以使用 <code>--policy-config-file</code> 或 <code>--policy-configmap</code>参数指定调度策略。</p>
<h4 id="自定义-Predicates-和-Priority"><a href="#自定义-Predicates-和-Priority" class="headerlink" title="自定义 Predicates 和 Priority"></a>自定义 Predicates 和 Priority</h4><p>以 Predicates 为例，<code>pkg/scheduler/types.go</code> 中定义了 Predicate 应该实现的接口：<code>type FitPredicate func(pod *v1.Pod, meta PredicateMetadata, nodeInfo *schedulercache.NodeInfo) (bool, []PredicateFailureReason, error)</code>。</p>
<p>要实现自定义的 Predicates 的话，可以在 <code>pkg/scheduler/algorithm/predicates/predicates.go</code> 中实现自己的算法。然后在 <code>pkg/scheduler/algorithm/algorithmprovider/defaults/defauts.go</code> 中的 <code>defaultPredicates</code> 进行注册，通过 <code>--policy-config-file</code> 或 <code>--policy-configmap</code> 写入该方法名即可。</p>
<h4 id="编写自己的调度器组件"><a href="#编写自己的调度器组件" class="headerlink" title="编写自己的调度器组件"></a>编写自己的调度器组件</h4><p>从代码中可以了解到，只要命名空间不发生冲突，Kubernetes 集群中允许同时运行多个 Scheduler，可以参考文档：<a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/" target="_blank" rel="noopener">Configure Multiple Schedulers</a>。在下面的给出的 KubeCon 链接中，有几个有意思的 Scheduler 也可以参考一下。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://youtu.be/4TaHQgG9wEg?t=380" target="_blank" rel="noopener">Building a Kubernetes Scheduler using Custom Metrics - Mateo Burillo, Sysdig</a></li>
<li><a href="https://sysdig.com/blog/kubernetes-scheduler/" target="_blank" rel="noopener">How to write a custom Kubernetes scheduler using your monitoring metrics</a></li>
<li><a href="https://coreos.com/blog/improving-kubernetes-scheduler-performance.html" target="_blank" rel="noopener">Improving Kubernetes Scheduler Performance</a></li>
<li><a href="https://youtu.be/mepNec5OpjY?t=509" target="_blank" rel="noopener">KubeCon + CloudNativeCon 2018: Kubernetes Advanced Scheduling — For Heating Showers</a></li>
<li><a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/" target="_blank" rel="noopener">Configure Multiple Schedulers</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33470869" target="_blank" rel="noopener">kubernetes的kube-scheduler性能将提升40%</a></li>
<li><a href="http://dockone.io/article/2885" target="_blank" rel="noopener">DockOne微信分享（一四九）：Kubernetes调度详解</a></li>
<li><a href="https://www.youtube.com/watch?v=bbPcb2JuJPw" target="_blank" rel="noopener">Kubernetes Scheduling Features or How Can I Make the System Do What I Want? [I] - Marek Grabowski</a></li>
<li><a href="https://groups.google.com/forum/#!topic/kubernetes-sig-scheduling/kdRqO818ApI" target="_blank" rel="noopener">Proposal to refactor Scheduler，邮件列表：Scheduler 重构计划</a></li>
<li><a href="https://gist.githubusercontent.com/misterikkit/16c7c36311f1f4029305348cc3f40654/raw/e00ae760a9e1997231ce4668cd4c83ffdef19c48/scheduler.png" target="_blank" rel="noopener">Scheduler architecture</a></li>
<li><a href="https://medium.com/@dominik.tornow/the-kubernetes-scheduler-cd429abac02f" target="_blank" rel="noopener">The Kubernetes Scheduler</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang/" rel="tag">#Golang</a>
          
            <a href="/tags/k8s/" rel="tag">#k8s</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/28/Kubernetes 源码笔记（kube-proxy）/" rel="next" title="Kubernetes 源码笔记（kube-proxy）">
                <i class="fa fa-chevron-left"></i> Kubernetes 源码笔记（kube-proxy）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/25/KubeCon 视频 2020-VSC/" rel="prev" title="KubeCon 视频 2020-VSC">
                KubeCon 视频 2020-VSC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/6964284?v=3&s=460" alt="Frank">
          <p class="site-author-name" itemprop="name">Frank</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">404</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">207</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/knarfeh" target="_blank">
                  
                    <i class="fa fa-globe"></i> Twitter
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本流程"><span class="nav-number">2.</span> <span class="nav-text">基本流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度策略和算法"><span class="nav-number">3.</span> <span class="nav-text">调度策略和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicates-预选"><span class="nav-number">3.1.</span> <span class="nav-text">Predicates 预选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Priorities-优选"><span class="nav-number">3.2.</span> <span class="nav-text">Priorities 优选</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码解析"><span class="nav-number">4.</span> <span class="nav-text">代码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总体逻辑"><span class="nav-number">4.1.</span> <span class="nav-text">总体逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">4.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择节点"><span class="nav-number">4.1.2.</span> <span class="nav-text">选择节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#细节"><span class="nav-number">4.2.</span> <span class="nav-text">细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取配置信息"><span class="nav-number">4.2.1.</span> <span class="nav-text">获取配置信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度逻辑"><span class="nav-number">4.2.2.</span> <span class="nav-text">调度逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Predicate"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">Predicate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Priority"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">Priority</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择节点-1"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">选择节点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展"><span class="nav-number">5.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义调度"><span class="nav-number">5.1.</span> <span class="nav-text">自定义调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定制-Predicates-和-Priority"><span class="nav-number">5.1.1.</span> <span class="nav-text">定制 Predicates 和 Priority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义-Predicates-和-Priority"><span class="nav-number">5.1.2.</span> <span class="nav-text">自定义 Predicates 和 Priority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写自己的调度器组件"><span class="nav-number">5.1.3.</span> <span class="nav-text">编写自己的调度器组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">6.</span> <span class="nav-text">References</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'knarfeh';
      var disqus_identifier = '2018/07/28/Kubernetes 源码笔记（kube-scheduler）/';
      var disqus_title = 'Kubernetes 源码笔记（kube-scheduler）';
      var disqus_url = 'http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kube-scheduler）/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  


  

  <script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>
