<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knarfeh&#39;s logbook</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://knarfeh.github.io/"/>
  <updated>2018-12-01T06:30:42.850Z</updated>
  <id>http://knarfeh.github.io/</id>
  
  <author>
    <name>Frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 源码笔记（kube-scheduler）</title>
    <link href="http://knarfeh.github.io/2018/07/28/Kubernetes%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88kube-scheduler%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kube-scheduler）/</id>
    <published>2018-07-27T16:15:07.000Z</published>
    <updated>2018-12-01T06:30:42.850Z</updated>
    
    <content type="html"><![CDATA[<p>kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。</p>
<p>一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。</p>
<a id="more"></a>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>kube-scheduler 会对 pod, node 进行 Watch，当 kube-scheduler 监测到未被调度的 pod（spec.nodeName 为空），它会取出这个 pod，然后根据内部设定的调度算法选择合适的 node，通过 api-server 写回到 etcd，这时该 pod 就绑定到了该 node 上，之后 kubelet 会读取到这一信息，在相应的 node 上运行 pod。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul>
<li>客户端通过 api-server 创建 pod，相关数据存储到 etcd</li>
<li>kube-scheduler 通过 NodeLister 获取所有节点信息</li>
<li>将 scheduled pods 和 assume pods 合并到 pods，作为所有已调度 Pod 信息</li>
<li>从 pods 中整理出 node-pods 的对应关系表 nodeNameToInfo</li>
<li>过滤掉不合适的节点（Predicates 预选）</li>
<li>给剩下的节点依次打分（Priorities 优选）</li>
<li>若分数相同，在节点中随机选择一个节点，否则选择分数最高的节点调用 api 进行 pod 和 node 的绑定。结果存储到 etcd 里</li>
</ul>
<h2 id="调度策略和算法"><a href="#调度策略和算法" class="headerlink" title="调度策略和算法"></a>调度策略和算法</h2><p>k8s 里的调度策略和算法包括预选（predicates），优选（priorities）两个步骤。通俗来说其实就是过滤和评分。</p>
<p>借助下图可以方便理解(来自 <a href="http://dockone.io/article/2885" target="_blank" rel="external">DockOne微信分享（一四九）：Kubernetes调度详解</a>)</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube_scheduler_algo.png" alt="kube_scheduler_algo"></p>
<h3 id="Predicates-预选"><a href="#Predicates-预选" class="headerlink" title="Predicates 预选"></a>Predicates 预选</h3><p>根据配置的 Predicates Policies（默认为 DefaultProvider 中定义的 default predicates policies 集合）来过滤掉不满足 Policies 的 Nodes，避免资源冲突，节点超载。</p>
<p>典型的 Predicates 算法有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GeneralPredicates</td>
<td style="text-align:center">包含一些基本的筛选规则，主要考虑资源问题，比如 CPU，内存是否足够，端口是否冲突，selector 是否匹配</td>
</tr>
<tr>
<td style="text-align:center">NoDiskConflict</td>
<td style="text-align:center">Pod 所需的卷是否与节点已存在的卷冲突，比如如果节点已经挂载了某个卷，其他同样使用这个卷的 Pod 不能再调度到这个主机。</td>
</tr>
<tr>
<td style="text-align:center">NoVolumeZoneCOnflict</td>
<td style="text-align:center">但集群跨可用区部署时，检查 node 所在的 zone 是否满足 Pod 对硬盘的要求</td>
</tr>
<tr>
<td style="text-align:center">MaxEBSVolumeCount</td>
<td style="text-align:center">部署在 AWS 时，检查 node 是否挂载了太多 EBS 卷</td>
</tr>
<tr>
<td style="text-align:center">MaxGCEPDVolumeCount</td>
<td style="text-align:center">部署在 GCE 时，检查 node 是否挂载了太多 PD 卷</td>
</tr>
<tr>
<td style="text-align:center">PodToleratesNodeTaints</td>
<td style="text-align:center">检查 Pod 是否能够容忍 node 上所有的 taints</td>
</tr>
<tr>
<td style="text-align:center">CheckNodeMemoryPressure</td>
<td style="text-align:center">当 Pod QoS 为 besteffort 时，检查 node 剩余内存量，排除内存压力过大的 node</td>
</tr>
<tr>
<td style="text-align:center">MatchInterPodAffinity</td>
<td style="text-align:center">检查 node 是否满足 pod 的亲和性、反亲和性需求</td>
</tr>
<tr>
<td style="text-align:center">HostName</td>
<td style="text-align:center">节点需满足 PodSpec 的 NodeName 字段指定的主机名</td>
</tr>
<tr>
<td style="text-align:center">CheckNodeDiskPressure</td>
<td style="text-align:center">判断节点是否已经处于磁盘压力状态</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>predicates 相关的算法在 <code>pkg/scheduler/algorithm/predicates/predicates.go</code> 中。</p>
<h3 id="Priorities-优选"><a href="#Priorities-优选" class="headerlink" title="Priorities 优选"></a>Priorities 优选</h3><p>根据配置的 Priorities Policies（默认为 DefaultProvider 中定义的 default priorities policies 集合）给预选的 Nodes 打分排名，得分最高的 Node 为最合适的 Node，该 Pod 会绑定到这个 Node。如果得分有并列的情况，则从中选择一个 Node。</p>
<p>典型的 Priority 算法有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LeastRequestedPriority</td>
<td style="text-align:center">按 node 计算资源（CPU/MEM）剩余量排序，挑选最空闲的 node</td>
</tr>
<tr>
<td style="text-align:center">BalancedResourceAllocation</td>
<td style="text-align:center">补充 LeastRequestedPriority，在 CPU 和 MEM 的剩余量中取平衡</td>
</tr>
<tr>
<td style="text-align:center">SelectorSpreadPriority</td>
<td style="text-align:center">同一个 Service/RC 下的 Pod 应该尽可能地分散在集群里。Node 上运行的同个 Service/RC 下的 Pod 数目越少，分数越高</td>
</tr>
<tr>
<td style="text-align:center">NodeAffinityPriority</td>
<td style="text-align:center">按 soft(preferred) NodeAffinity 规则匹配情况排序，规则命中越高，分数越高</td>
</tr>
<tr>
<td style="text-align:center">TaintTolerationPriority</td>
<td style="text-align:center">按 Pod tolerations 与 node taints 的匹配情况排序，越多 taints 不匹配，分数越低</td>
</tr>
<tr>
<td style="text-align:center">InterPodAffinityPriority</td>
<td style="text-align:center">按 soft(preferred) Pod Affinity/Anti-Affinity 规则匹配情况排序，规则命中越多，分数越高/低</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>priorities 相关的算法在 <code>pkg/scheduler/algorithm/priorities/</code> 目录下。</p>
<p>最终主机的得分由以下公式计算得到：</p>
<p><code>finalScoreNode = (weight1 * priorityFunc1) + (weight2 * priorityFunc2) + … + (weightn * priorityFuncn)</code></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>分析的代码是基于 v1.12.2-beta.0 版本的。之前很长一段时间，Scheduler 的源码在 plugin 目录下，不过 v1.12.2-beta.0 版本的入口程序在 <code>cmd/kube-scheduler/scheduler.go</code> 里。同 Kubernetes 的其他组件类似，先通过 <code>command := app.NewSchedulerCommand()</code> 获取 cobra 的 command 对象然后执行，实际的运行过程在 <code>cmd/kube-scheduler/app/server.go</code> 中。</p>
<h3 id="总体逻辑"><a href="#总体逻辑" class="headerlink" title="总体逻辑"></a>总体逻辑</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c schedulerserverconfig.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	algorithmprovider.ApplyFeatureGates()</div><div class="line">	</div><div class="line">	<span class="comment">// Configz registration ...</span></div><div class="line">	</div><div class="line">	schedulerConfig, err := NewSchedulerConfig(c)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Create the scheduler ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Prepare the event broadcaster ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Start up the healthz server ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Start all informers</span></div><div class="line">	<span class="keyword">go</span> c.PodInformer.Informer().Run(stopCh)</div><div class="line">	c.InformerFactory.Start(stopCh)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for all caches to sync before scheduling </span></div><div class="line">	c.InformerFactory.WaitForCacheSync(stopCh)</div><div class="line">	controller.WaitForCacheSync(<span class="string">"scheduler"</span>, stopCh, c.PodInformer.Informer().HasSynced)</div><div class="line"></div><div class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</div><div class="line">		sched.Run()</div><div class="line">		&lt;-ctx.Done()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ctx, cancel := context.WithCancel(context.TODO())</div><div class="line">	<span class="keyword">defer</span> cancel()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-stopCh:</div><div class="line">			cancel()</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	</div><div class="line">	<span class="comment">// If leader election is enabled, run via LeaderElector until done and exit</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line"></div><div class="line">	run(ctx)</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"finished without leader elect"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Run</code> 方法会根据传入的上下文参数初始化一个 <code>schedulerConfig</code> 对象，根据配置创建 Scheduler 对象，启动所有的 informer，最后运行 Scheduler 的核心逻辑 <code>run</code> 方法，这是一个死循环，直到从通道接收到退出的消息才会退出。它会一直调用 <code>pkg/scheduler/scheduler.go</code> 中 Scheduler 的 <code>Run</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !sched.config.WaitForCacheSync() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.config.StopEverything)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>scheduleOne</code> 方法为：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</div><div class="line">	pod := sched.config.NextPod()</div><div class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</div><div class="line">		sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">		glog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line"></div><div class="line">	<span class="comment">// Synchronously attempt to find a fit for the pod.</span></div><div class="line">	start := time.Now()</div><div class="line">	suggestedHost, err := sched.schedule(pod)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;</div><div class="line">			preemptionStartTime := time.Now()</div><div class="line">			sched.preempt(pod, fitError)</div><div class="line">			metrics.PreemptionAttempts.Inc()</div><div class="line">			metrics.SchedulingAlgorithmPremptionEvaluationDuration.Observe(metrics.SinceInMicroseconds(preemptionStartTime))</div><div class="line">			metrics.SchedulingLatency.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</div><div class="line">	assumedPod := pod.DeepCopy()</div><div class="line"></div><div class="line">	allBound, err := sched.assumeVolumes(assumedPod, suggestedHost)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = sched.assume(assumedPod, suggestedHost)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> !allBound &#123;</div><div class="line">			err = sched.bindVolumes(assumedPod)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		err := sched.bind(assumedPod, &amp;v1.Binding&#123;</div><div class="line">			ObjectMeta: metav1.ObjectMeta&#123;Namespace: assumedPod.Namespace, Name: assumedPod.Name, UID: assumedPod.UID&#125;,</div><div class="line">			Target: v1.ObjectReference&#123;</div><div class="line">				Kind: <span class="string">"Node"</span>,</div><div class="line">				Name: suggestedHost,</div><div class="line">			&#125;,</div><div class="line">		&#125;)</div><div class="line">		metrics.E2eSchedulingLatency.Observe(metrics.SinceInMicroseconds(start))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Errorf(<span class="string">"Internal error binding pod: (%v)"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleOne</code> 被 <code>Run</code> 方法调用，每次调度一个 pod。首先调用 NextPod，从未调度的队列中取出一个应该被调度的 Pod。接着进行节点的选择。</p>
<h4 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h4><p>其中 <code>suggestedHost, err := sched.schedule(pod)</code> 这一行调用了实现的 scheduling 算法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	host, err := sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		pod = pod.DeepCopy()</div><div class="line">		sched.config.Error(pod, err)</div><div class="line">		sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</div><div class="line">		sched.config.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</div><div class="line">			Type:    v1.PodScheduled,</div><div class="line">			Status:  v1.ConditionFalse,</div><div class="line">			Reason:  v1.PodReasonUnschedulable,</div><div class="line">			Message: err.Error(),</div><div class="line">		&#125;)</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> host, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>schedule</code> 可以用来返回一个最合适的 node，在 <code>scheduleOne</code> 中我们可以看到，接下来调用 <code>bind</code> 进行 pod 与 node 的绑定就行了。其中 <code>sched.config.Algorithm.Schedule</code> 会调用调度的真正算法。以上就是 kube-scheduler 的基本逻辑，接下来我们深入到其中需要注意的细节。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h4 id="获取配置信息"><a href="#获取配置信息" class="headerlink" title="获取配置信息"></a>获取配置信息</h4><p>在上述的 <code>Run</code> 方法中，进入 Scheduler 的核心逻辑前的初始化很重要，因为需要初始化 Node，Pod 等的 Informer 方法，确定 Predicate 阶段和 Priority 阶段所需的调度算法，根据接口进行相应的初始化。某种意义上这也是一个依赖注入的过程。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerConfig</span><span class="params">(s schedulerserverconfig.CompletedConfig)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> storageClassInformer storageinformers.StorageClassInformer</div><div class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) &#123;</div><div class="line">		storageClassInformer = s.InformerFactory.Storage().V1().StorageClasses()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	configurator := factory.NewConfigFactory(&amp;factory.ConfigFactoryArgs&#123;</div><div class="line">		SchedulerName:                  s.ComponentConfig.SchedulerName,</div><div class="line">		Client:                         s.Client,</div><div class="line">		NodeInformer:                   s.InformerFactory.Core().V1().Nodes(),</div><div class="line">		PodInformer:                    s.PodInformer,</div><div class="line">		PvInformer:                     s.InformerFactory.Core().V1().PersistentVolumes(),</div><div class="line">		PvcInformer:                    s.InformerFactory.Core().V1().PersistentVolumeClaims(),</div><div class="line">		ReplicationControllerInformer:  s.InformerFactory.Core().V1().ReplicationControllers(),</div><div class="line">		ReplicaSetInformer:             s.InformerFactory.Apps().V1().ReplicaSets(),</div><div class="line">		StatefulSetInformer:            s.InformerFactory.Apps().V1().StatefulSets(),</div><div class="line">		ServiceInformer:                s.InformerFactory.Core().V1().Services(),</div><div class="line">		PdbInformer:                    s.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</div><div class="line">		StorageClassInformer:           storageClassInformer,</div><div class="line">		HardPodAffinitySymmetricWeight: s.ComponentConfig.HardPodAffinitySymmetricWeight,</div><div class="line">		EnableEquivalenceClassCache:    utilfeature.DefaultFeatureGate.Enabled(features.EnableEquivalenceClassCache),</div><div class="line">		DisablePreemption:              s.ComponentConfig.DisablePreemption,</div><div class="line">		PercentageOfNodesToScore:       s.ComponentConfig.PercentageOfNodesToScore,</div><div class="line">		BindTimeoutSeconds:             *s.ComponentConfig.BindTimeoutSeconds,</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	source := s.ComponentConfig.AlgorithmSource</div><div class="line">	<span class="keyword">var</span> config *scheduler.Config</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</div><div class="line">		sc, err := configurator.CreateFromProvider(*source.Provider)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler using provider %q: %v"</span>, *source.Provider, err)</div><div class="line">		&#125;</div><div class="line">		config = sc</div><div class="line">	<span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</div><div class="line">		policy := &amp;schedulerapi.Policy&#123;&#125;</div><div class="line">		<span class="keyword">switch</span> &#123;</div><div class="line">		<span class="keyword">case</span> source.Policy.File != <span class="literal">nil</span>:</div><div class="line">			<span class="comment">// Use policy config file define policy ...</span></div><div class="line">		<span class="keyword">case</span> source.Policy.ConfigMap != <span class="literal">nil</span>:</div><div class="line">			<span class="comment">// Use ConfigMap define policy ...</span></div><div class="line">		&#125;</div><div class="line">		sc, err := configurator.CreateFromConfig(*policy)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler from policy: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		config = sc</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unsupported algorithm source: %v"</span>, source)</div><div class="line">	&#125;</div><div class="line">	config.Recorder = s.Recorder</div><div class="line"></div><div class="line">	config.DisablePreemption = s.ComponentConfig.DisablePreemption</div><div class="line">	<span class="keyword">return</span> config, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>NewSchedulerConfig</code> 方法中，有两种方式来创建 scheduler.Config, 这是由配置决定的。用户可以编写 policy 文件，决定调度器可以使用哪些 predicates 和 priorities 算法。这些算法在 <code>pkg/scheduler/algorithm</code> 中定义；也可以根据 algorithm provider 决定，最终都是为了获取 predicates 和 priorities 的方法的集合。以默认的 algorithm provider 为例，<code>CreateFromProvider</code> 接口在 <code>pkg/scheduler/scheduler.go</code> 中定义，实现是在 <code>pkg/scheduler/factory/factory.go</code> 中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configFactory)</span> <span class="title">CreateFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</div><div class="line">	glog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler from algorithm provider '%v'"</span>, providerName)</div><div class="line">	provider, err := GetAlgorithmProvider(providerName)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c.CreateFromKeys(provider.FitPredicateKeys, provider.PriorityFunctionKeys, []algorithm.SchedulerExtender&#123;&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configFactory)</span> <span class="title">CreateFromKeys</span><span class="params">(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</div><div class="line">	glog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler with fit predicates '%v' and priority functions '%v'"</span>, predicateKeys, priorityKeys)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c.GetHardPodAffinitySymmetricWeight() &lt; <span class="number">1</span> || c.GetHardPodAffinitySymmetricWeight() &gt; <span class="number">100</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100"</span>, c.GetHardPodAffinitySymmetricWeight())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	predicateFuncs, err := c.GetPredicates(predicateKeys)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	priorityConfigs, err := c.GetPriorityFunctionConfigs(priorityKeys)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	priorityMetaProducer, err := c.GetPriorityMetadataProducer()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	predicateMetaProducer, err := c.GetPredicateMetadataProducer()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c.enableEquivalenceClassCache &#123;</div><div class="line">		c.equivalencePodCache = equivalence.NewCache()</div><div class="line">		glog.Info(<span class="string">"Created equivalence class cache"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	algo := core.NewGenericScheduler(</div><div class="line">		c.schedulerCache,</div><div class="line">		c.equivalencePodCache,</div><div class="line">		c.podQueue,</div><div class="line">		predicateFuncs,</div><div class="line">		predicateMetaProducer,</div><div class="line">		priorityConfigs,</div><div class="line">		priorityMetaProducer,</div><div class="line">		extenders,</div><div class="line">		c.volumeBinder,</div><div class="line">		c.pVCLister,</div><div class="line">		c.alwaysCheckAllPredicates,</div><div class="line">		c.disablePreemption,</div><div class="line">		c.percentageOfNodesToScore,</div><div class="line">	)</div><div class="line"></div><div class="line">	podBackoff := util.CreateDefaultPodBackoff()</div><div class="line">	<span class="keyword">return</span> &amp;scheduler.Config&#123;</div><div class="line">		SchedulerCache: c.schedulerCache,</div><div class="line">		Ecache:         c.equivalencePodCache,</div><div class="line">		NodeLister:          &amp;nodeLister&#123;c.nodeLister&#125;,</div><div class="line">		Algorithm:           algo,</div><div class="line">		GetBinder:           c.getBinderFunc(extenders),</div><div class="line">		PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</div><div class="line">		PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</div><div class="line">		WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</div><div class="line">		&#125;,</div><div class="line">		NextPod: <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> c.getNextPod()</div><div class="line">		&#125;,</div><div class="line">		Error:          c.MakeDefaultErrorFunc(podBackoff, c.podQueue),</div><div class="line">		StopEverything: c.StopEverything,</div><div class="line">		VolumeBinder:   c.volumeBinder,</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CreateFromKeys</code> 会根据定义的 predicate 和 priority 的 key 生成一个 scheduler。主要的调度算法都在 <code>pkg/scheduler/core/generic_scheduler.go</code> 中定义。</p>
<h4 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	trace := utiltrace.New(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</div><div class="line">	<span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	nodes, err := nodeLister.List()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Used for all fit and priority funcs.</span></div><div class="line">	err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	trace.Step(<span class="string">"Computing predicates"</span>)</div><div class="line">	startPredicateEvalTime := time.Now()</div><div class="line">	filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</div><div class="line">			Pod:              pod,</div><div class="line">			NumAllNodes:      <span class="built_in">len</span>(nodes),</div><div class="line">			FailedPredicates: failedPredicateMap,</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	metrics.SchedulingAlgorithmPredicateEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPredicateEvalTime))</div><div class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.PredicateEvaluation).Observe(metrics.SinceInSeconds(startPredicateEvalTime))</div><div class="line"></div><div class="line">	trace.Step(<span class="string">"Prioritizing"</span>)</div><div class="line">	startPriorityEvalTime := time.Now()</div><div class="line">	<span class="comment">// When only one node after predicate, just use it.</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">1</span> &#123;</div><div class="line">		metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</div><div class="line">		<span class="keyword">return</span> filteredNodes[<span class="number">0</span>].Name, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</div><div class="line">	priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">	&#125;</div><div class="line">	metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</div><div class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.PriorityEvaluation).Observe(metrics.SinceInSeconds(startPriorityEvalTime))</div><div class="line"></div><div class="line">	trace.Step(<span class="string">"Selecting host"</span>)</div><div class="line">	<span class="keyword">return</span> g.selectHost(priorityList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如前所述，调度分为几个关键的步骤，首先从 cache 中获取可调度的 nodes，接着预选，筛除不合适的 node，然后优选打分，选出最合适的 node，如果选出了多个 node，则使用 round-robin 算法选出一个 node 作为最终的结果。</p>
<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">findNodesThatFit</span><span class="params">(pod *v1.Pod, nodes []*v1.Node)</span> <span class="params">([]*v1.Node, FailedPredicateMap, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filtered []*v1.Node</div><div class="line">	failedPredicateMap := FailedPredicateMap&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(g.predicates) == <span class="number">0</span> &#123;</div><div class="line">		filtered = nodes</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		allNodes := <span class="keyword">int32</span>(g.cache.NodeTree().NumNodes)</div><div class="line">		numNodesToFind := g.numFeasibleNodesToFind(allNodes)</div><div class="line"></div><div class="line">		filtered = <span class="built_in">make</span>([]*v1.Node, numNodesToFind)</div><div class="line">		errs := errors.MessageCountMap&#123;&#125;</div><div class="line">		<span class="keyword">var</span> (</div><div class="line">			predicateResultLock sync.Mutex</div><div class="line">			filteredLen         <span class="keyword">int32</span></div><div class="line">			equivClass          *equivalence.Class</div><div class="line">		)</div><div class="line"></div><div class="line">		ctx, cancel := context.WithCancel(context.Background())</div><div class="line"></div><div class="line">		meta := g.predicateMetaProducer(pod, g.cachedNodeInfoMap)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> g.equivalenceCache != <span class="literal">nil</span> &#123;</div><div class="line">			equivClass = equivalence.NewClass(pod)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">var</span> nodeCache *equivalence.NodeCache</div><div class="line">			nodeName := g.cache.NodeTree().Next()</div><div class="line">			<span class="keyword">if</span> g.equivalenceCache != <span class="literal">nil</span> &#123;</div><div class="line">				nodeCache, _ = g.equivalenceCache.GetNodeCache(nodeName)</div><div class="line">			&#125;</div><div class="line">			fits, failedPredicates, err := podFitsOnNode(</div><div class="line">				pod,</div><div class="line">				meta,</div><div class="line">				g.cachedNodeInfoMap[nodeName],</div><div class="line">				g.predicates,</div><div class="line">				g.cache,</div><div class="line">				nodeCache,</div><div class="line">				g.schedulingQueue,</div><div class="line">				g.alwaysCheckAllPredicates,</div><div class="line">				equivClass,</div><div class="line">			)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				predicateResultLock.Lock()</div><div class="line">				errs[err.Error()]++</div><div class="line">				predicateResultLock.Unlock()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> fits &#123;</div><div class="line">				length := atomic.AddInt32(&amp;filteredLen, <span class="number">1</span>)</div><div class="line">				<span class="keyword">if</span> length &gt; numNodesToFind &#123;</div><div class="line">					cancel()</div><div class="line">					atomic.AddInt32(&amp;filteredLen, <span class="number">-1</span>)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					filtered[length<span class="number">-1</span>] = g.cachedNodeInfoMap[nodeName].Node()</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				predicateResultLock.Lock()</div><div class="line">				failedPredicateMap[nodeName] = failedPredicates</div><div class="line">				predicateResultLock.Unlock()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		workqueue.ParallelizeUntil(ctx, <span class="number">16</span>, <span class="keyword">int</span>(allNodes), checkNode)</div><div class="line"></div><div class="line">		filtered = filtered[:filteredLen]</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, errors.CreateAggregateFromMessageCountMap(errs)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filtered) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(g.extenders) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">for</span> _, extender := <span class="keyword">range</span> g.extenders &#123;</div><div class="line">			<span class="keyword">if</span> !extender.IsInterested(pod) &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			filteredList, failedMap, err := extender.Filter(pod, filtered, g.cachedNodeInfoMap)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">if</span> extender.IsIgnorable() &#123;</div><div class="line">					glog.Warningf(<span class="string">"Skipping extender %v as it returned error %v and has ignorable flag set"</span>,</div><div class="line">						extender, err)</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">for</span> failedNodeName, failedMsg := <span class="keyword">range</span> failedMap &#123;</div><div class="line">				<span class="keyword">if</span> _, found := failedPredicateMap[failedNodeName]; !found &#123;</div><div class="line">					failedPredicateMap[failedNodeName] = []algorithm.PredicateFailureReason&#123;&#125;</div><div class="line">				&#125;</div><div class="line">				failedPredicateMap[failedNodeName] = <span class="built_in">append</span>(failedPredicateMap[failedNodeName], predicates.NewFailureReason(failedMsg))</div><div class="line">			&#125;</div><div class="line">			filtered = filteredList</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(filtered) == <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> filtered, failedPredicateMap, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Predicate 是预选的过程。其中 <code>checkNode</code> 方法会调用 <code>podFitsOnNode</code>，应用所有配置的预选 Policy 对 Node 进行检查。接着 <code>workqueue.ParallelizeUntil(ctx, 16, int(allNodes), checkNode)</code> 以16个为一批，根据 node 的数量并发检查 node。其中 Extender 是调度算法的一种扩展，也属于自定义调度器的一种方式，如果配置了 <code>Extender</code>，则执行 <code>Extender</code> 的 <code>Filter</code> 再次筛选。 </p>
<h5 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrioritizeNodes</span><span class="params">(</span></span></div><div class="line">	pod *v1.Pod,</div><div class="line">	nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulercache.NodeInfo,</div><div class="line">	meta <span class="keyword">interface</span>&#123;&#125;,</div><div class="line">	priorityConfigs []algorithm.PriorityConfig,</div><div class="line">	nodes []*v1.Node,</div><div class="line">	extenders []algorithm.SchedulerExtender,</div><div class="line">) <span class="params">(schedulerapi.HostPriorityList, error)</span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(priorityConfigs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(extenders) == <span class="number">0</span> &#123;</div><div class="line">		result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</div><div class="line">			hostPriority, err := EqualPriorityMap(pod, meta, nodeNameToInfo[nodes[i].Name])</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			result = <span class="built_in">append</span>(result, hostPriority)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		mu   = sync.Mutex&#123;&#125;</div><div class="line">		wg   = sync.WaitGroup&#123;&#125;</div><div class="line">		errs []error</div><div class="line">	)</div><div class="line">	appendError := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</div><div class="line">		mu.Lock()</div><div class="line">		<span class="keyword">defer</span> mu.Unlock()</div><div class="line">		errs = <span class="built_in">append</span>(errs, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</div><div class="line">		<span class="keyword">if</span> priorityConfig.Function != <span class="literal">nil</span> &#123;</div><div class="line">			wg.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</div><div class="line">				<span class="keyword">defer</span> wg.Done()</div><div class="line">				<span class="keyword">var</span> err error</div><div class="line">				results[index], err = config.Function(pod, nodeNameToInfo, nodes)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					appendError(err)</div><div class="line">				&#125;</div><div class="line">			&#125;(i, priorityConfig)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			results[i] = <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="built_in">len</span>(nodes))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	processNode := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">		nodeInfo := nodeNameToInfo[nodes[index].Name]</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</div><div class="line">			<span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				appendError(err)</div><div class="line">				results[i][index].Host = nodes[index].Name</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	workqueue.Parallelize(<span class="number">16</span>, <span class="built_in">len</span>(nodes), processNode)</div><div class="line">	<span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</div><div class="line">		<span class="keyword">if</span> priorityConfig.Reduce == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">			<span class="keyword">if</span> err := config.Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</div><div class="line">				appendError(err)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</div><div class="line">				<span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</div><div class="line">					glog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, pod.Name, hostPriority.Host, config.Name, hostPriority.Score)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;(i, priorityConfig)</div><div class="line">	&#125;</div><div class="line">	wg.Wait()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> schedulerapi.HostPriorityList&#123;&#125;, errors.NewAggregate(errs)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</div><div class="line">		result = <span class="built_in">append</span>(result, schedulerapi.HostPriority&#123;Host: nodes[i].Name, Score: <span class="number">0</span>&#125;)</div><div class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> priorityConfigs &#123;</div><div class="line">			result[i].Score += results[j][i].Score * priorityConfigs[j].Weight</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(extenders) != <span class="number">0</span> &amp;&amp; nodes != <span class="literal">nil</span> &#123;</div><div class="line">		combinedScores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nodeNameToInfo))</div><div class="line">		<span class="keyword">for</span> _, extender := <span class="keyword">range</span> extenders &#123;</div><div class="line">			<span class="keyword">if</span> !extender.IsInterested(pod) &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			wg.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ext algorithm.SchedulerExtender)</span></span> &#123;</div><div class="line">				<span class="keyword">defer</span> wg.Done()</div><div class="line">				prioritizedList, weight, err := ext.Prioritize(pod, nodes)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				mu.Lock()</div><div class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> *prioritizedList &#123;</div><div class="line">					host, score := (*prioritizedList)[i].Host, (*prioritizedList)[i].Score</div><div class="line">					combinedScores[host] += score * weight</div><div class="line">				&#125;</div><div class="line">				mu.Unlock()</div><div class="line">			&#125;(extender)</div><div class="line">		&#125;</div><div class="line">		wg.Wait()</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</div><div class="line">			result[i].Score += combinedScores[result[i].Host]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</div><div class="line">			glog.V(<span class="number">10</span>).Infof(<span class="string">"Host %s =&gt; Score %d"</span>, result[i].Host, result[i].Score)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Priority</code> 是优选的过程，<code>processNode</code> 用于对 node 遍历所有的 priorities policy，获取该 node 对于所有 policy 的分数。同 predicate 类似，以16个 goroutine 为一组，根据 nodes 数量，并发执行这些算法，最后对得分进行加权得到最终的分数。</p>
<h5 id="选择节点-1"><a href="#选择节点-1" class="headerlink" title="选择节点"></a>选择节点</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">selectHost</span><span class="params">(priorityList schedulerapi.HostPriorityList)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(priorityList) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"empty priorityList"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	maxScores := findMaxScores(priorityList)</div><div class="line">	ix := <span class="keyword">int</span>(g.lastNodeIndex % <span class="keyword">uint64</span>(<span class="built_in">len</span>(maxScores)))</div><div class="line">	g.lastNodeIndex++</div><div class="line"></div><div class="line">	<span class="keyword">return</span> priorityList[maxScores[ix]].Host, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过 Predicates 预选阶段和 Priorities 优选阶段后，我们需要选择一个最终的节点，首先根据分数进行排序，如果分数最高的节点有多个，则根据最高分数的个数进行 round-robin 选择。<code>findMaxScores</code> 用来构造按照分数进行排列的优先列表。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxScores</span><span class="params">(priorityList schedulerapi.HostPriorityList)</span> []<span class="title">int</span></span> &#123;</div><div class="line">	maxScoreIndexes := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(priorityList)/<span class="number">2</span>)</div><div class="line">	maxScore := priorityList[<span class="number">0</span>].Score</div><div class="line">	<span class="keyword">for</span> i, hp := <span class="keyword">range</span> priorityList &#123;</div><div class="line">		<span class="keyword">if</span> hp.Score &gt; maxScore &#123;</div><div class="line">			maxScore = hp.Score</div><div class="line">			maxScoreIndexes = maxScoreIndexes[:<span class="number">0</span>]</div><div class="line">			maxScoreIndexes = <span class="built_in">append</span>(maxScoreIndexes, i)</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> hp.Score == maxScore &#123;</div><div class="line">			maxScoreIndexes = <span class="built_in">append</span>(maxScoreIndexes, i)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> maxScoreIndexes</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到 <code>scheduleOne</code> 方法，获取最终的候选节点后，首先进行 Volume 的分配，绑定，最后通过 <code>bind</code> 方法进行最后的 pod 和 node 的绑定。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(assumed *v1.Pod, b *v1.Binding)</span> <span class="title">error</span></span> &#123;</div><div class="line">	bindingStart := time.Now()</div><div class="line">	err := sched.config.GetBinder(assumed).Bind(b)</div><div class="line">	<span class="keyword">if</span> err := sched.config.SchedulerCache.FinishBinding(assumed); err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"scheduler cache FinishBinding failed: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to bind pod: %v/%v"</span>, assumed.Namespace, assumed.Name)</div><div class="line">		<span class="keyword">if</span> err := sched.config.SchedulerCache.ForgetPod(assumed); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Errorf(<span class="string">"scheduler cache ForgetPod failed: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		sched.config.Error(assumed, err)</div><div class="line">		sched.config.Recorder.Eventf(assumed, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Binding rejected: %v"</span>, err)</div><div class="line">		sched.config.PodConditionUpdater.Update(assumed, &amp;v1.PodCondition&#123;</div><div class="line">			Type:   v1.PodScheduled,</div><div class="line">			Status: v1.ConditionFalse,</div><div class="line">			Reason: <span class="string">"BindingRejected"</span>,</div><div class="line">		&#125;)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	metrics.BindingLatency.Observe(metrics.SinceInMicroseconds(bindingStart))</div><div class="line">	metrics.SchedulingLatency.WithLabelValues(metrics.Binding).Observe(metrics.SinceInSeconds(bindingStart))</div><div class="line">	sched.config.Recorder.Eventf(assumed, v1.EventTypeNormal, <span class="string">"Scheduled"</span>, <span class="string">"Successfully assigned %v/%v to %v"</span>, assumed.Namespace, assumed.Name, b.Target.Name)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sched.config.GetBinder(assumed).Bind(b)</code> 中的 Bind 的实现在 <code>pkg/scheduler/factory/factory.go</code> 中。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *binder)</span> <span class="title">Bind</span><span class="params">(binding *v1.Binding)</span> <span class="title">error</span></span> &#123;</div><div class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to bind %v to %v"</span>, binding.Name, binding.Target.Name)</div><div class="line">	<span class="keyword">return</span> b.Client.CoreV1().Pods(binding.Namespace).Bind(binding)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scheduler 最后会向 apiserver 发送 Binding 对象，如果绑定失败，执行回滚操作。至此，调度过程结束，运行 Pod 的工作将交给绑定的 Node 上的 kubelet。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="自定义调度"><a href="#自定义调度" class="headerlink" title="自定义调度"></a>自定义调度</h3><p>如果默认的调度器不满足要求，可以部署自定义的调度器，在部署的时候可以通过 <code>podSpec.schedulerName</code> 来选择使用哪一个调度器。Kubernetes 的调度器以插件化的形式实现，方便用户对调度定制和二次开发。</p>
<h4 id="定制-Predicates-和-Priority"><a href="#定制-Predicates-和-Priority" class="headerlink" title="定制 Predicates 和 Priority"></a>定制 Predicates 和 Priority</h4><p>启动 kube-schduler 的时候可以使用 <code>--policy-config-file</code> 或 <code>--policy-configmap</code>参数指定调度策略。</p>
<h4 id="自定义-Predicates-和-Priority"><a href="#自定义-Predicates-和-Priority" class="headerlink" title="自定义 Predicates 和 Priority"></a>自定义 Predicates 和 Priority</h4><p>以 Predicates 为例，<code>pkg/scheduler/types.go</code> 中定义了 Predicate 应该实现的接口：<code>type FitPredicate func(pod *v1.Pod, meta PredicateMetadata, nodeInfo *schedulercache.NodeInfo) (bool, []PredicateFailureReason, error)</code>。</p>
<p>要实现自定义的 Predicates 的话，可以在 <code>pkg/scheduler/algorithm/predicates/predicates.go</code> 中实现自己的算法。然后在 <code>pkg/scheduler/algorithm/algorithmprovider/defaults/defauts.go</code> 中的 <code>defaultPredicates</code> 进行注册，通过 <code>--policy-config-file</code> 或 <code>--policy-configmap</code> 写入该方法名即可。</p>
<h4 id="编写自己的调度器组件"><a href="#编写自己的调度器组件" class="headerlink" title="编写自己的调度器组件"></a>编写自己的调度器组件</h4><p>从代码中可以了解到，只要命名空间不发生冲突，Kubernetes 集群中允许同时运行多个 Scheduler，可以参考文档：<a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/" target="_blank" rel="external">Configure Multiple Schedulers</a>。在下面的给出的 KubeCon 链接中，有几个有意思的 Scheduler 也可以参考一下。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://youtu.be/4TaHQgG9wEg?t=380" target="_blank" rel="external">Building a Kubernetes Scheduler using Custom Metrics - Mateo Burillo, Sysdig</a></li>
<li><a href="https://sysdig.com/blog/kubernetes-scheduler/" target="_blank" rel="external">How to write a custom Kubernetes scheduler using your monitoring metrics</a></li>
<li><a href="https://coreos.com/blog/improving-kubernetes-scheduler-performance.html" target="_blank" rel="external">Improving Kubernetes Scheduler Performance</a></li>
<li><a href="https://youtu.be/mepNec5OpjY?t=509" target="_blank" rel="external">KubeCon + CloudNativeCon 2018: Kubernetes Advanced Scheduling — For Heating Showers</a></li>
<li><a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/" target="_blank" rel="external">Configure Multiple Schedulers</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33470869" target="_blank" rel="external">kubernetes的kube-scheduler性能将提升40%</a></li>
<li><a href="http://dockone.io/article/2885" target="_blank" rel="external">DockOne微信分享（一四九）：Kubernetes调度详解</a></li>
<li><a href="https://www.youtube.com/watch?v=bbPcb2JuJPw" target="_blank" rel="external">Kubernetes Scheduling Features or How Can I Make the System Do What I Want? [I] - Marek Grabowski</a></li>
<li><a href="https://groups.google.com/forum/#!topic/kubernetes-sig-scheduling/kdRqO818ApI" target="_blank" rel="external">Proposal to refactor Scheduler，邮件列表：Scheduler 重构计划</a></li>
<li><a href="https://gist.githubusercontent.com/misterikkit/16c7c36311f1f4029305348cc3f40654/raw/e00ae760a9e1997231ce4668cd4c83ffdef19c48/scheduler.png" target="_blank" rel="external">Scheduler architecture</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kube-scheduler 运行在 Kubernetes 的管理节点（Master 节点）上，负责完成从 Pod 到 Node 的调度过程。Scheduler 会跟踪集群中所有 Node 的资源利用情况，并采取合适的调度策略，确保调度的均衡性，避免集群中的某些节点过载。&lt;/p&gt;
&lt;p&gt;一言以蔽之，kube-scheduler 用来为 Pod 找到一个合适的 Node。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 源码笔记（kube-proxy）</title>
    <link href="http://knarfeh.github.io/2018/07/28/Kubernetes%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88kube-proxy%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kube-proxy）/</id>
    <published>2018-07-27T16:15:06.000Z</published>
    <updated>2018-11-27T05:36:22.377Z</updated>
    
    <content type="html"><![CDATA[<p>kube-proxy 运行在 Kubernetes 集群的计算节点上，负责 Service 的负载均衡及服务代理。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>kube-proxy 工作的核心的流程是从 kube-apiserver 同步 service 和 endpoint 的信息，然后将其更新到 iptables。从 1.11 版本开始，基于 IPVS 的负载均衡已经 GA 了，可以预见的是未来 k8s 会主推 IPVS 模式。</p>
<p>kube-proxy 目前有3种常见的 proxyMode，分别是 userspace，iptables，ipvs，还有一种是 Windows 平台的 kernelspace。其中 userspace mode 是 v1.0 及以前版本的默认模式。从 v1.1 版本开始，增加了 iptables mode，在 v1.3版本中正式替代了 userspace 模式成为默认模式（需要 iptables 的版本&gt;= 1.4.11）。在实践中，社区发现 iptables 的扩展性和性能都不佳，毕竟 iptables 是为防火墙设计的，它的特性并不适合当做大规模服务的负载均衡，华为贡献了基于 IPVS 实现 kube-proxy 的特性。IPVS 是 LVS 的负载均衡模块，同样基于 netfilter，但比 iptables 性能更好，具备更好的可扩展性，鉴于 IPVS 是 kube-proxy 的未来趋势，在阅读 kube-proxy 源码的时候可以着重看这部分。</p>
<p>下面我们分别来看 kube-proxy 的三种模式的实现。对于 userspace，iptables 这两种模式，本文只做简述，对于 ipvs 模式，会结合其设计文档，代码进行分析。</p>
<h3 id="userspace-mode"><a href="#userspace-mode" class="headerlink" title="userspace mode"></a>userspace mode</h3><p>基于用户态的 proxy，service 的请求会先从用户空间进入内核 iptables，然后再回到用户空间，由 kube-proxy 完成后端 endpoints 的选择和代理工作，这种方式流量从用户空间进出内核带来的性能损耗比较大。原理如下图：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube-proxy-userspace-mode.png" alt="kube-proxy-userspace-mode"></p>
<h4 id="实例（该例摘自-kubernetes入门之kube-proxy实现原理）："><a href="#实例（该例摘自-kubernetes入门之kube-proxy实现原理）：" class="headerlink" title="实例（该例摘自 kubernetes入门之kube-proxy实现原理）："></a>实例（该例摘自 <a href="https://xuxinkun.github.io/2016/07/22/kubernetes-proxy/" target="_blank" rel="external">kubernetes入门之kube-proxy实现原理</a>）：</h4><p>现在有一个 service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ kubectl get service</div><div class="line">NAME             LABELS                                    SELECTOR              IP(S)            PORT(S)</div><div class="line">kubernetes       component=apiserver,provider=kubernetes   &lt;none&gt;                10.254.0.1       443/TCP</div><div class="line">ssh-service1     name=ssh,role=service                     ssh-service=true      10.254.132.107   2222/TCP</div></pre></td></tr></table></figure>
<p>这个 service 的 cluster ip 是 10.254.132.107。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ kubectl describe service ssh-service1 </div><div class="line">Name:           ssh-service1</div><div class="line">Namespace:      default</div><div class="line">Labels:         name=ssh,role=service</div><div class="line">Selector:       ssh-service=true</div><div class="line">Type:           LoadBalancer</div><div class="line">IP:         10.254.132.107</div><div class="line">Port:           &lt;unnamed&gt;   2222/TCP</div><div class="line">NodePort:       &lt;unnamed&gt;   30239/TCP</div><div class="line">Endpoints:      &lt;none&gt;</div><div class="line">Session Affinity:   None</div><div class="line">No events.</div></pre></td></tr></table></figure>
<p>这时候 iptables 的规则是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo iptables -S -t nat</div><div class="line">...</div><div class="line">-A KUBE-NODEPORT-CONTAINER -p tcp -m comment --comment &quot;default/ssh-service1:&quot; -m tcp --dport 30239 -j REDIRECT --to-ports 36463</div><div class="line">-A KUBE-NODEPORT-HOST -p tcp -m comment --comment &quot;default/ssh-service1:&quot; -m tcp --dport 30239 -j DNAT --to-destination 10.0.0.5:36463</div><div class="line">-A KUBE-PORTALS-CONTAINER -d 10.254.132.107/32 -p tcp -m comment --comment &quot;default/ssh-service1:&quot; -m tcp --dport 2222 -j REDIRECT --to-ports 36463</div><div class="line">-A KUBE-PORTALS-HOST -d 10.254.132.107/32 -p tcp -m comment --comment &quot;default/ssh-service1:&quot; -m tcp --dport 2222 -j DNAT --to-destination 10.0.0.5:36463</div></pre></td></tr></table></figure>
<p>这个 node 的 ip 是 10.0.0.5，那么访问 10.0.0.5:30239 就会被转发到本机的 36463 端口，在访问 10.254.132.107:2222 时，也会转发到 36463 端口，36463 端口是由 kube-proxy 监听的，流量接着会被导到后端的 pod 上。</p>
<h3 id="iptables-mode"><a href="#iptables-mode" class="headerlink" title="iptables mode"></a>iptables mode</h3><p>iptables 的方式是完全通过内核的 iptables 实现 service 的代理和 LB，这是 v1.2 及以后版本的默认模式，原理如下图：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kube-proxy-iptables-mode.png" alt="kube-proxy-iptables-mode"></p>
<p>这种方式通过 iptable NAT 完成转发，也有一定的性能损耗；此外，iptables 没有增量更新的功能，如果更新一条规则需要整体刷新，时间长，而且对服务的稳定性也有影响；iptable 是串行的，一个 node 上如果有很多的 iptables 规则，流量需要经过所有的匹配再进行转发，在服务规模比较大的情况下对时间、CPU、内存都有比较大的消耗。这导致的一个结果是，大型企业将 k8s 用于生产时，不会直接 kube-proxy 作为服务代理，而是使用 NodePort 或使用 externalIP（比如这篇<a href="https://jishu.io/kubernetes/ipvs-loadbalancer-for-kubernetes/" target="_blank" rel="external">文章中的例子</a>），或自己开发，配置负载均衡代替 kube-proxy。</p>
<h4 id="示例（该例摘自-kubernetes入门之kube-proxy实现原理）"><a href="#示例（该例摘自-kubernetes入门之kube-proxy实现原理）" class="headerlink" title="示例（该例摘自 kubernetes入门之kube-proxy实现原理）"></a>示例（该例摘自 <a href="https://xuxinkun.github.io/2016/07/22/kubernetes-proxy/" target="_blank" rel="external">kubernetes入门之kube-proxy实现原理</a>）</h4><p>创建 mysql-service 的 service：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    name: mysql</div><div class="line">    role: service</div><div class="line">  name: mysql-service</div><div class="line">spec:</div><div class="line">  ports:</div><div class="line">    - port: 3306</div><div class="line">      targetPort: 3306</div><div class="line">      nodePort: 30964</div><div class="line">  type: NodePort</div><div class="line">  selector:</div><div class="line">    mysql-service: &quot;true&quot;</div></pre></td></tr></table></figure>
<p>这个服务的 cluster ip 是 10.254.162.44，代理的两个 pod 的 ip 是 192.168.125.129 和192.168.125.131，再看  iptables</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ iptables -S -t nat</div><div class="line">...</div><div class="line">-A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</div><div class="line">-A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</div><div class="line">-A POSTROUTING -m comment --comment &quot;kubernetes postrouting rules&quot; -j KUBE-POSTROUTING</div><div class="line">-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000</div><div class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp --dport 30964 -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp --dport 30964 -j KUBE-SVC-67RL4FN6JRUPOJYM</div><div class="line">-A KUBE-SEP-ID6YWIT3F6WNZ47P -s 192.168.125.129/32 -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-SEP-ID6YWIT3F6WNZ47P -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp -j DNAT --to-destination 192.168.125.129:3306</div><div class="line">-A KUBE-SEP-IN2YML2VIFH5RO2T -s 192.168.125.131/32 -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-SEP-IN2YML2VIFH5RO2T -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp -j DNAT --to-destination 192.168.125.131:3306</div><div class="line">-A KUBE-SERVICES -d 10.254.162.44/32 -p tcp -m comment --comment &quot;default/mysql-service: cluster IP&quot; -m tcp --dport 3306 -j KUBE-SVC-67RL4FN6JRUPOJYM</div><div class="line">-A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</div><div class="line">-A KUBE-SVC-67RL4FN6JRUPOJYM -m comment --comment &quot;default/mysql-service:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-ID6YWIT3F6WNZ47P</div><div class="line">-A KUBE-SVC-67RL4FN6JRUPOJYM -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-SEP-IN2YML2VIFH5RO2T</div></pre></td></tr></table></figure>
<p>如果通过 node 的 30964 端口访问，匹配的是下面两条链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp --dport 30964 -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp --dport 30964 -j KUBE-SVC-67RL4FN6JRUPOJYM</div></pre></td></tr></table></figure>
<p>如果直接访问 cluster ip (10.254.162.44)，匹配的是下面的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A KUBE-SERVICES -d 10.254.162.44/32 -p tcp -m comment --comment &quot;default/mysql-service: cluster IP&quot; -m tcp --dport 3306 -j KUBE-SVC-67RL4FN6JRUPOJYM</div></pre></td></tr></table></figure>
<p>上述的两种匹配都会跳转到 KUBE-SVC-67RL4FN6JRUPOJYM 的链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A KUBE-SVC-67RL4FN6JRUPOJYM -m comment --comment &quot;default/mysql-service:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-ID6YWIT3F6WNZ47P</div><div class="line">-A KUBE-SVC-67RL4FN6JRUPOJYM -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-SEP-IN2YML2VIFH5RO2T</div></pre></td></tr></table></figure>
<p>50% 的概率匹配 KUBE-SEP-ID6YWIT3F6WNZ47P，50% 的概率匹配 KUBE-SEP-IN2YML2VIFH5RO2T。</p>
<p>KUBE-SEP-ID6YWIT3F6WNZ47P 的作用是通过 DNAT 发送到192.168.125.129的3306端口，KUBE-SEP-IN2YML2VIFH5RO2T 同理，发送的是192.168.125.131的3306端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-A KUBE-SEP-ID6YWIT3F6WNZ47P -s 192.168.125.129/32 -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-SEP-ID6YWIT3F6WNZ47P -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp -j DNAT --to-destination 192.168.125.129:3306</div><div class="line">-A KUBE-SEP-IN2YML2VIFH5RO2T -s 192.168.125.131/32 -m comment --comment &quot;default/mysql-service:&quot; -j KUBE-MARK-MASQ</div><div class="line">-A KUBE-SEP-IN2YML2VIFH5RO2T -p tcp -m comment --comment &quot;default/mysql-service:&quot; -m tcp -j DNAT --to-destination 192.168.125.131:3306</div></pre></td></tr></table></figure>
<h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>如果是使用 Kubernetes 1.8 或更高版本，可以使用 ipvs 模式，它是对 iptables 的替换。ipvs 模式下增加规则是增量式的，不会强制全量刷新，匹配服务时也不会进行串行匹配，而是通过一定规则进行哈希匹配，以找到相应的规则。</p>
<p>相比于 iptables，它具备更高的性能和稳定性。下图是华为云提供的压测数据：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/ipvs_vs_iptables.png" alt="ipvs_vs_iptables"></p>
<p>IPVS 是 LVS 的一个核心软件模块，所以我们先介绍 LVS。LVS 是 Linux VIrtual Server 的缩写，这是由<a href="https://baike.baidu.com/item/%E7%AB%A0%E6%96%87%E5%B5%A9" target="_blank" rel="external">章文嵩博士</a>发起的项目，目前已经合并到了 Linux 内核中。</p>
<p>IPVS 是 LVS 的 IP 负载均衡模块，安装在 LVS 集群作为负载均衡的主节点。</p>
<p>LVS 集群中有 Director 和 Real Server 两个角色，有三种类型的 IP 地址：</p>
<ul>
<li>Director Virtual IP，调度器用于与客户端通信的 IP 地址，简称为 VIP</li>
<li>Director IP，调度器用于与 Real Server 通信的 IP 地址，简称为 DIP</li>
<li>Real IP，后端主机与调度器通信的 IP 地址，简称为 RIP</li>
</ul>
<p>LVS 有三种调度模式：</p>
<h4 id="LVS-NAT-Network-Address-Transform"><a href="#LVS-NAT-Network-Address-Transform" class="headerlink" title="LVS-NAT Network Address Transform"></a>LVS-NAT Network Address Transform</h4><p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/lvs-nat.jpg" alt="lvs-nat"></p>
<h4 id="LVS-TUN-IPTuneling"><a href="#LVS-TUN-IPTuneling" class="headerlink" title="LVS-TUN IPTuneling"></a>LVS-TUN IPTuneling</h4><p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/lvs-tun.jpg" alt="lvs-tun"></p>
<h4 id="LVS-DR-Direct-Routing"><a href="#LVS-DR-Direct-Routing" class="headerlink" title="LVS-DR Direct Routing"></a>LVS-DR Direct Routing</h4><p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/lvs-dr.jpg" alt="lvs-dr"></p>
<p>目前 kube-proxy 的实现选择的是 NAT 模式。</p>
<p>LVS 有十种调度算法：</p>
<h4 id="静态方法，根据算法本身进行轮询调度"><a href="#静态方法，根据算法本身进行轮询调度" class="headerlink" title="静态方法，根据算法本身进行轮询调度"></a>静态方法，根据算法本身进行轮询调度</h4><ul>
<li>RR, Round Robin</li>
<li>WRR，Wrighted RR</li>
<li>SH，SourceIP Hash</li>
<li>DH，Destination Hash</li>
</ul>
<h4 id="动态方法，根据算法以及-RS-的当前负载状态进行调度"><a href="#动态方法，根据算法以及-RS-的当前负载状态进行调度" class="headerlink" title="动态方法，根据算法以及 RS 的当前负载状态进行调度"></a>动态方法，根据算法以及 RS 的当前负载状态进行调度</h4><ul>
<li>LC，least connections</li>
<li>WLC，Weighted Least Connection</li>
<li>SED，Shortest Expection Delay</li>
<li>NQ，Never Queue</li>
<li>LBLC，Locality-Based Least Connection</li>
<li>LBLCR，Locality-Based Least Connections withReplication</li>
</ul>
<p>kube-proxy 可以通过 <code>--ipvs-scheduler</code> 参数选择调度算法，默认情况下是 Round Robin 算法。</p>
<p>关于 LVS 的详细介绍，可以查阅 <a href="http://www.linuxvirtualserver.org/zh/lvs1.html" target="_blank" rel="external">Linux服务器集群系统（一）</a>。</p>
<p>创建一个 service 后，k8s 会在每个节点上创建一个网卡，同时绑定在 Service IP（VIP）上，这时内核会认为 VIP 就是本机 IP，通过 socket 调用，创建 IPVS 的 virtual server 和 real server，分别对应 k8s 的 Service 和 Endpoints。socket 的调用由 docker 公司的 <a href="https://github.com/docker/libnetwork/blob/master/ipvs/ipvs.go" target="_blank" rel="external">libnetwork</a> 库完成。</p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>了解了 kube-proxy 的原理，再阅读代码就很容易理解了。代码版本是 v1.12.2-beta.0。</p>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h3><p><code>Run</code> 方法在 <code>cmd/kube-proxy/proxy.go</code> 中。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(o.WriteConfigTo) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> o.writeConfigFile()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	proxyServer, err := NewProxyServer(o)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> proxyServer.Run()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑很简单。首先通过 <code>NewProxyServer</code> 构造一个 <code>ProxyServer</code>，然后调用它的 <code>Run</code> 方法来运行。</p>
<h3 id="初始化-ProxyServer"><a href="#初始化-ProxyServer" class="headerlink" title="初始化 ProxyServer"></a>初始化 ProxyServer</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProxyServer</span><span class="params">(</span></span></div><div class="line">	config *proxyconfigapi.KubeProxyConfiguration,</div><div class="line">	cleanupAndExit <span class="keyword">bool</span>,</div><div class="line">	cleanupIPVS <span class="keyword">bool</span>,</div><div class="line">	scheme *runtime.Scheme,</div><div class="line">	master <span class="keyword">string</span>) <span class="params">(*ProxyServer, error)</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> config == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"config is required"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c, err := configz.New(proxyconfigapi.GroupName); err == <span class="literal">nil</span> &#123;</div><div class="line">		c.Set(config)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protocol := utiliptables.ProtocolIpv4</div><div class="line">	<span class="keyword">if</span> net.ParseIP(config.BindAddress).To4() == <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">0</span>).Infof(<span class="string">"IPv6 bind address (%s), assume IPv6 operation"</span>, config.BindAddress)</div><div class="line">		protocol = utiliptables.ProtocolIpv6</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> iptInterface utiliptables.Interface</div><div class="line">	<span class="keyword">var</span> ipvsInterface utilipvs.Interface</div><div class="line">	<span class="keyword">var</span> kernelHandler ipvs.KernelHandler</div><div class="line">	<span class="keyword">var</span> ipsetInterface utilipset.Interface</div><div class="line">	<span class="keyword">var</span> dbus utildbus.Interface</div><div class="line"></div><div class="line">	<span class="comment">// Create a iptables utils.</span></div><div class="line">	execer := exec.New()</div><div class="line"></div><div class="line">	dbus = utildbus.New()</div><div class="line">	iptInterface = utiliptables.New(execer, dbus, protocol)</div><div class="line">	kernelHandler = ipvs.NewLinuxKernelHandler()</div><div class="line">	ipsetInterface = utilipset.New(execer)</div><div class="line">	canUseIPVS, _ := ipvs.CanUseIPVSProxier(kernelHandler, ipsetInterface)</div><div class="line">	<span class="keyword">if</span> canUseIPVS &#123;</div><div class="line">		ipvsInterface = utilipvs.New(execer)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// We omit creation of pretty much everything if we run in cleanup mode</span></div><div class="line">	<span class="keyword">if</span> cleanupAndExit &#123;</div><div class="line">		<span class="keyword">return</span> &amp;ProxyServer&#123;</div><div class="line">			execer:         execer,</div><div class="line">			IptInterface:   iptInterface,</div><div class="line">			IpvsInterface:  ipvsInterface,</div><div class="line">			IpsetInterface: ipsetInterface,</div><div class="line">			CleanupAndExit: cleanupAndExit,</div><div class="line">		&#125;, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	client, eventClient, err := createClients(config.ClientConnection, master)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Create event recorder</span></div><div class="line">	hostname, err := utilnode.GetHostname(config.HostnameOverride)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	eventBroadcaster := record.NewBroadcaster()</div><div class="line">	recorder := eventBroadcaster.NewRecorder(scheme, v1.EventSource&#123;Component: <span class="string">"kube-proxy"</span>, Host: hostname&#125;)</div><div class="line"></div><div class="line">	nodeRef := &amp;v1.ObjectReference&#123;</div><div class="line">		Kind:      <span class="string">"Node"</span>,</div><div class="line">		Name:      hostname,</div><div class="line">		UID:       types.UID(hostname),</div><div class="line">		Namespace: <span class="string">""</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> healthzServer *healthcheck.HealthzServer</div><div class="line">	<span class="keyword">var</span> healthzUpdater healthcheck.HealthzUpdater</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.HealthzBindAddress) &gt; <span class="number">0</span> &#123;</div><div class="line">		healthzServer = healthcheck.NewDefaultHealthzServer(config.HealthzBindAddress, <span class="number">2</span>*config.IPTables.SyncPeriod.Duration, recorder, nodeRef)</div><div class="line">		healthzUpdater = healthzServer</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> proxier proxy.ProxyProvider</div><div class="line">	<span class="keyword">var</span> serviceEventHandler proxyconfig.ServiceHandler</div><div class="line">	<span class="keyword">var</span> endpointsEventHandler proxyconfig.EndpointsHandler</div><div class="line"></div><div class="line">	proxyMode := getProxyMode(<span class="keyword">string</span>(config.Mode), iptInterface, kernelHandler, ipsetInterface, iptables.LinuxKernelCompatTester&#123;&#125;)</div><div class="line">	nodeIP := net.ParseIP(config.BindAddress)</div><div class="line">	<span class="keyword">if</span> nodeIP.IsUnspecified() &#123;</div><div class="line">		nodeIP = getNodeIP(client, hostname)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> proxyMode == proxyModeIPTables &#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> proxyMode == proxyModeIPVS &#123;</div><div class="line">		glog.V(<span class="number">0</span>).Info(<span class="string">"Using ipvs Proxier."</span>)</div><div class="line">		proxierIPVS, err := ipvs.NewProxier(</div><div class="line">			iptInterface,</div><div class="line">			ipvsInterface,</div><div class="line">			ipsetInterface,</div><div class="line">			utilsysctl.New(),</div><div class="line">			execer,</div><div class="line">			config.IPVS.SyncPeriod.Duration,</div><div class="line">			config.IPVS.MinSyncPeriod.Duration,</div><div class="line">			config.IPVS.ExcludeCIDRs,</div><div class="line">			config.IPTables.MasqueradeAll,</div><div class="line">			<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</div><div class="line">			config.ClusterCIDR,</div><div class="line">			hostname,</div><div class="line">			nodeIP,</div><div class="line">			recorder,</div><div class="line">			healthzServer,</div><div class="line">			config.IPVS.Scheduler,</div><div class="line">			config.NodePortAddresses,</div><div class="line">		)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		metrics.RegisterMetrics()</div><div class="line">		proxier = proxierIPVS</div><div class="line">		serviceEventHandler = proxierIPVS</div><div class="line">		endpointsEventHandler = proxierIPVS</div><div class="line">		glog.V(<span class="number">0</span>).Info(<span class="string">"Tearing down inactive rules."</span>)</div><div class="line">		<span class="comment">// TODO this has side effects that should only happen when Run() is invoked.</span></div><div class="line">		userspace.CleanupLeftovers(iptInterface)</div><div class="line">		iptables.CleanupLeftovers(iptInterface)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		glog.V(<span class="number">0</span>).Info(<span class="string">"Using userspace Proxier."</span>)</div><div class="line">		<span class="comment">// ...</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	iptInterface.AddReloadFunc(proxier.Sync)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;ProxyServer&#123;</div><div class="line">		Client:                 client,</div><div class="line">		EventClient:            eventClient,</div><div class="line">		IptInterface:           iptInterface,</div><div class="line">		IpvsInterface:          ipvsInterface,</div><div class="line">		IpsetInterface:         ipsetInterface,</div><div class="line">		execer:                 execer,</div><div class="line">		Proxier:                proxier,</div><div class="line">		Broadcaster:            eventBroadcaster,</div><div class="line">		Recorder:               recorder,</div><div class="line">		ConntrackConfiguration: config.Conntrack,</div><div class="line">		Conntracker:            &amp;realConntracker&#123;&#125;,</div><div class="line">		ProxyMode:              proxyMode,</div><div class="line">		NodeRef:                nodeRef,</div><div class="line">		MetricsBindAddress:     config.MetricsBindAddress,</div><div class="line">		EnableProfiling:        config.EnableProfiling,</div><div class="line">		OOMScoreAdj:            config.OOMScoreAdj,</div><div class="line">		ResourceContainer:      config.ResourceContainer,</div><div class="line">		ConfigSyncPeriod:       config.ConfigSyncPeriod.Duration,</div><div class="line">		ServiceEventHandler:    serviceEventHandler,</div><div class="line">		EndpointsEventHandler:  endpointsEventHandler,</div><div class="line">		HealthzServer:          healthzServer,</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码的基本流程是：</p>
<ol>
<li>创建 iptables 的接口 <code>iptInterface</code> 以及 ipvs 的接口 <code>ipvsInterface</code></li>
<li>根据上面的字段初始化 ProxyServer</li>
<li>创建健康检查服务</li>
<li>初始化 <code>serviceEventHandler</code> 和 <code>endpointsEventHandler</code>，用于定义 service 和 endpoints 的发生变化后的处理方法。</li>
<li>根据 proxyMode 进入不同的分支</li>
<li>如果是使用 ipvs 模式，调用 <code>./pkg/proxy/ipvs/proxier.go</code> 的 <code>NewProxier</code> 进行初始化。iptable, userspace 模式同理</li>
</ol>
<p>需要注意的是调用 <code>NewProxier</code> 过程中，有 <code>proxier.syncRunner = async.NewBoundedFrequencyRunner(&quot;sync-runner&quot;, proxier.syncProxyRules, minSyncPeriod, syncPeriod, burstSyncs)</code> 这么一行，用来初始化 <code>syncRunner</code>，这里很重要，在下面我们会看到。</p>
<h3 id="运行-ProxyServer"><a href="#运行-ProxyServer" class="headerlink" title="运行 ProxyServer"></a>运行 ProxyServer</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProxyServer)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// glog ...</span></div><div class="line">	<span class="comment">// remove iptables rules and exit</span></div><div class="line">	<span class="keyword">if</span> s.CleanupAndExit &#123;</div><div class="line">		encounteredError := userspace.CleanupLeftovers(s.IptInterface)</div><div class="line">		encounteredError = iptables.CleanupLeftovers(s.IptInterface) || encounteredError</div><div class="line">		encounteredError = ipvs.CleanupLeftovers(s.IpvsInterface, s.IptInterface, s.IpsetInterface, s.CleanupIPVS) || encounteredError</div><div class="line">		<span class="keyword">if</span> encounteredError &#123;</div><div class="line">			<span class="keyword">return</span> errors.New(<span class="string">"encountered an error while tearing down rules."</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// TODO(vmarmol): Use container config for this.</span></div><div class="line">	<span class="keyword">var</span> oomAdjuster *oom.OOMAdjuster</div><div class="line">	<span class="keyword">if</span> s.OOMScoreAdj != <span class="literal">nil</span> &#123;</div><div class="line">		oomAdjuster = oom.NewOOMAdjuster()</div><div class="line">		<span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="keyword">int</span>(*s.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.V(<span class="number">2</span>).Info(err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.ResourceContainer) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := resourcecontainer.RunInResourceContainer(s.ResourceContainer); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Warningf(<span class="string">"Failed to start in resource-only container %q: %v"</span>, s.ResourceContainer, err)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"Running in resource-only container %q"</span>, s.ResourceContainer)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> s.Broadcaster != <span class="literal">nil</span> &amp;&amp; s.EventClient != <span class="literal">nil</span> &#123;</div><div class="line">		s.Broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: s.EventClient.Events(<span class="string">""</span>)&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Start up a healthz server if requested</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Start up a metrics server if requested</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Tune conntrack, if requested</span></div><div class="line">	<span class="comment">// Conntracker is always nil for windows</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">	informerFactory := informers.NewSharedInformerFactory(s.Client, s.ConfigSyncPeriod)</div><div class="line"></div><div class="line">	serviceConfig := config.NewServiceConfig(informerFactory.Core().V1().Services(), s.ConfigSyncPeriod)</div><div class="line">	serviceConfig.RegisterEventHandler(s.ServiceEventHandler)</div><div class="line">	<span class="keyword">go</span> serviceConfig.Run(wait.NeverStop)</div><div class="line"></div><div class="line">	endpointsConfig := config.NewEndpointsConfig(informerFactory.Core().V1().Endpoints(), s.ConfigSyncPeriod)</div><div class="line">	endpointsConfig.RegisterEventHandler(s.EndpointsEventHandler)</div><div class="line">	<span class="keyword">go</span> endpointsConfig.Run(wait.NeverStop)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> informerFactory.Start(wait.NeverStop)</div><div class="line"></div><div class="line">	s.birthCry()</div><div class="line"></div><div class="line">	s.Proxier.SyncLoop()</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果运行时带了 <code>CleanupAndExit</code> 参数，清理所有的 iptables，ipvs 的规则然后退出。OOM adjuster 和 ResourceContainer 目前都没有完整实现，先跳过，接着启动健康检查服务，metrics 服务器，用于监控，最后启动 informer，注册 service，endpoint 的监听事件，这两个 handler 都是之前注册的 <code>proxierIPVS</code>，当监听到 service，endpoint 的变化，就会触发响应的方法，注意到 <code>ProxyServer</code> 中定义的 <code>ServiceEventHandler</code> 和 <code>EndpointsEventHandler</code> 分别是 <code>ServiceHandler</code>，<code>EndpointsHandler</code> 类型，实际上定义的是一个接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ServiceHandler <span class="keyword">interface</span> &#123;</div><div class="line">	OnServiceAdd(service *v1.Service)</div><div class="line">	OnServiceUpdate(oldService, service *v1.Service)</div><div class="line">	OnServiceDelete(service *v1.Service)</div><div class="line">	OnServiceSynced()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> EndpointsHandler <span class="keyword">interface</span> &#123;</div><div class="line">	OnEndpointsAdd(endpoints *v1.Endpoints)</div><div class="line">	OnEndpointsUpdate(oldEndpoints, endpoints *v1.Endpoints)</div><div class="line">	OnEndpointsDelete(endpoints *v1.Endpoints)</div><div class="line">	OnEndpointsSynced()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>pkg/proxy/ipvs/proxier.go</code> 的 <code>Proxier</code> 中实现了这些方法，可以一一对照查看。<code>Run</code> 方法最后会调用 <code>s.Proxier.SyncLoop</code>，也属于 Proxier 的实现，这些都在 <code>pkg/proxy/ipvs</code> 模块里。</p>
<h4 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h4><p>以监听到增加 service 的事件为例，我们看看 Proxier 会做什么。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceAdd</span><span class="params">(service *v1.Service)</span></span> &#123;</div><div class="line">	proxier.OnServiceUpdate(<span class="literal">nil</span>, service)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">OnServiceUpdate</span><span class="params">(oldService, service *v1.Service)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123;</div><div class="line">		proxier.syncRunner.Run()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Update 方法在 <code>pkg/proxy/service.go</code> 中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sct *ServiceChangeTracker)</span> <span class="title">Update</span><span class="params">(previous, current *v1.Service)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	svc := current</div><div class="line">	<span class="keyword">if</span> svc == <span class="literal">nil</span> &#123;</div><div class="line">		svc = previous</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> svc == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	namespacedName := types.NamespacedName&#123;Namespace: svc.Namespace, Name: svc.Name&#125;</div><div class="line"></div><div class="line">	sct.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> sct.lock.Unlock()</div><div class="line"></div><div class="line">	change, exists := sct.items[namespacedName]</div><div class="line">	<span class="keyword">if</span> !exists &#123;</div><div class="line">		change = &amp;serviceChange&#123;&#125;</div><div class="line">		change.previous = sct.serviceToServiceMap(previous)</div><div class="line">		sct.items[namespacedName] = change</div><div class="line">	&#125;</div><div class="line">	change.current = sct.serviceToServiceMap(current)</div><div class="line">	<span class="keyword">if</span> reflect.DeepEqual(change.previous, change.current) &#123;</div><div class="line">		<span class="built_in">delete</span>(sct.items, namespacedName)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(sct.items) &gt; <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上只是对比 Service 的变化，然后将其存在一个 Map 数据结构中，最后 <code>OnServiceUpdate</code> 会调用 <code>proxier.syncRunner.Run()</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bfr *BoundedFrequencyRunner)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> bfr.run &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Run</code> 方法会发送一个信号到 <code>BoundedFrequencyRunner</code> 的 run 这个 channel。还记得 <code>Run</code> 方法的最后，我们调用了 <code>SyncLoop</code> 方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">SyncLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> proxier.healthzServer != <span class="literal">nil</span> &#123;</div><div class="line">		proxier.healthzServer.UpdateTimestamp()</div><div class="line">	&#125;</div><div class="line">	proxier.syncRunner.Loop(wait.NeverStop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Loop</code> 方法在 <code>pkg/util/async/bounded_frequency_runner.go</code> 中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bfr *BoundedFrequencyRunner)</span> <span class="title">Loop</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"%s Loop running"</span>, bfr.name)</div><div class="line">	bfr.timer.Reset(bfr.maxInterval)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-stop:</div><div class="line">			bfr.stop()</div><div class="line">			glog.V(<span class="number">3</span>).Infof(<span class="string">"%s Loop stopping"</span>, bfr.name)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> &lt;-bfr.timer.C():</div><div class="line">			bfr.tryRun()</div><div class="line">		<span class="keyword">case</span> &lt;-bfr.run:</div><div class="line">			bfr.tryRun()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会不停的运行，定期地执行 <code>tryRun</code> 方法，当接收到 run 事件时，也会调用 <code>tryRun</code> 方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bfr *BoundedFrequencyRunner)</span> <span class="title">tryRun</span><span class="params">()</span></span> &#123;</div><div class="line">	bfr.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> bfr.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> bfr.limiter.TryAccept() &#123;</div><div class="line">		bfr.fn()</div><div class="line">		bfr.lastRun = bfr.timer.Now()</div><div class="line">		bfr.timer.Stop()</div><div class="line">		bfr.timer.Reset(bfr.maxInterval)</div><div class="line">		glog.V(<span class="number">3</span>).Infof(<span class="string">"%s: ran, next possible in %v, periodic in %v"</span>, bfr.name, bfr.minInterval, bfr.maxInterval)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 <code>tryRun</code> 方法会调用 <code>bfr.fn()</code>，这个回调函数其实就是在 <code>proxier.syncRunner = async.NewBoundedFrequencyRunner(&quot;sync-runner&quot;, proxier.syncProxyRules, minSyncPeriod, syncPeriod, burstSyncs)</code> 注册的，也就是说所有的这些定期执行，通过事件触发执行的方法，最终会调用 <code>syncProxyRules</code>。</p>
<p>这个方法特别长，借助设计文档里的伪代码可以帮助理解（有一些增改）：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">syncProxyRules</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 当服务或 endpoint 更新时，调用这个方法</span></div><div class="line">    <span class="comment">// 同步 ipvs 规则或 iptables(如 mark，comment）。确保机器上有 kube-ipvs0 网卡，ipvs 需要在上面绑定地址，如果没有的话创建一个新的。确保有 ipset，用于批量设置 iptables 规则。</span></div><div class="line">    <span class="keyword">for</span> svcName, svcInfo := <span class="keyword">range</span> proxier.serviceMap &#123;</div><div class="line">      <span class="comment">// 处理 service 类型是 clusterIP 情况</span></div><div class="line">      <span class="comment">// 从 svcInfo 中获取 ClusterIP 等信息，设置粘滞会话的类型，过期时间等信息</span></div><div class="line">      <span class="comment">// 将 clusterIP 与虚拟网卡绑定，调用 libnetwork API 创建 VirtualServer</span></div><div class="line">      <span class="comment">// 通过调用 syncEndpoint，更新 RealServer</span></div><div class="line"></div><div class="line">      <span class="comment">// 处理 service 类型是 externalIPs 情况</span></div><div class="line">      <span class="comment">// 创建一条 SNAT 规则，数据包转发给 external IP（端口转发），构建 ipvs VirtualServer，地址是 external IP</span></div><div class="line">      <span class="comment">// 设置粘滞会话信息</span></div><div class="line">      <span class="comment">// 调用 libnetwork API 创建 VirtualServer，RealServer</span></div><div class="line"></div><div class="line">      <span class="comment">// 处理 service 类型是 load-balancer ingress 情况</span></div><div class="line">	    <span class="keyword">for</span> _, ingress := <span class="keyword">range</span> svcInfo.LoadBalancerStatus.Ingress &#123;</div><div class="line">		    <span class="keyword">if</span> ingress.IP != <span class="string">""</span> &#123;</div><div class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(svcInfo.LoadBalancerSourceRanges) != <span class="number">0</span> &#123;</div><div class="line">            install specific iptables</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 构建 ipvs 的 VirtualServer</span></div><div class="line">          <span class="comment">// 设置粘滞会话信息</span></div><div class="line">          <span class="comment">// 调用 libnetwork API 创建 VirtualServer，RealServer</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 处理 service 类型是 nodeports 情况</span></div><div class="line">      <span class="keyword">if</span> svcInfo.NodePort != <span class="number">0</span> &#123;</div><div class="line">		    fall back on iptables, recruit existing iptables proxier implementation</div><div class="line">		    <span class="comment">// 用 iptable 解决</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 清理工作，调用 libnet API 清理不需要的 ipvs 规则，清理不需要的网卡，service 地址的绑定，清理不需要的 iptables 链规则。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上巨长的 <code>syncProxyRules</code> 方法就是 kube-proxy 创建负载均衡的主要逻辑，其中 service 和 endpoint 的结果可以从之前保存的 Map 中拿到。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/kubernetes/kubernetes/tree/release-1.12/pkg/proxy/ipvs" target="_blank" rel="external">Kubernetes IPVS</a></li>
<li><a href="https://github.com/kubernetes/community/blob/39a6b946b0a1b213207acb5361661940a378d0d0/keps/sig-network/0011-ipvs-proxier.md" target="_blank" rel="external">Kubernetes/community ipvs 设计文档</a></li>
<li><a href="http://www.linuxvirtualserver.org/zh/lvs1.html" target="_blank" rel="external">Linux服务器集群系统（一）</a></li>
<li><a href="https://www.jianshu.com/p/8a61de3f8be9" target="_blank" rel="external">LVS原理介绍</a></li>
<li><a href="https://github.com/docker/libnetwork/blob/master/ipvs/netlink.go" target="_blank" rel="external">libnetwork/ipvs/netlink.go</a></li>
<li><a href="https://xuxinkun.github.io/2016/07/22/kubernetes-proxy/" target="_blank" rel="external">kubernetes入门之kube-proxy实现原理</a></li>
<li><a href="https://www.youtube.com/watch?v=4-pawkiazEg" target="_blank" rel="external">Scale Kubernetes to Support 50,000 Services [I] - Haibin Xie &amp; Quinton Hoole</a></li>
<li><a href="https://docs.google.com/presentation/d/1BaIAywY2qqeHtyGZtlyAp89JIZs59MZLKcFLxKE6LyM/edit?usp=sharing" target="_blank" rel="external">Slides of Scale Kubernetes to Support 50,000 Services [I] - Haibin Xie &amp; Quinton Hoole</a></li>
<li><a href="https://github.com/kubernetes/community/pull/692" target="_blank" rel="external">support ipvs mode for kube-proxy #692</a></li>
<li><a href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/" target="_blank" rel="external">IPVS-Based In-Cluster Load Balancing Deep Dive</a></li>
<li><a href="https://www.yangcs.net/posts/kube-router/" target="_blank" rel="external">Kube-router 实战-使用 Kube-router 作为 Kubernetes 负载均衡器</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kube-proxy 运行在 Kubernetes 集群的计算节点上，负责 Service 的负载均衡及服务代理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>KubeCon 视频</title>
    <link href="http://knarfeh.github.io/2018/07/28/KubeCon%20%E8%A7%86%E9%A2%91/"/>
    <id>http://knarfeh.github.io/2018/07/28/KubeCon 视频/</id>
    <published>2018-07-27T16:15:05.000Z</published>
    <updated>2018-12-01T15:53:15.752Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 KubeCon 的视频，囫囵吞枣，感觉吸收了不到一成，但是感觉功力大增。</p>
<p>看 KubeCon，可以学习跟 Kubernetes 相关的各种解决方案，了解 CNCF 下的各个项目的进展，跟着核心开发者深入每个子项目的架构，原理，这些自然不用说，更有意思的一点是，可以通过这个窗口看到世界各地各行各业的动态，这是 KubeCon 特别的地方，因为 Kubernetes 是基础架构，来宣讲的基本都是架构师，布道师，这和 React Conf 之类的专注于一个技术点的会议是不一样的。举个例子，有一个分享是欧洲的一个公司借助 kube-scheduler 议题向大家介绍他们公司的案例，他们把服务器安装在每一户的家里，将这些机器组成一个 Kubernetes 集群，当集群运行一个 job 时，服务器就会加热，用户使用热水时就能省电，平时在家里也可以起到增温的作用，而他们公司也可以省一些机房，电费等运维费用，他们的工作内容就是借助这个 Kubernetes 集群，通过自定义调度算法，增加整个系统的利用率。对于这种系统，以前我也略有耳闻，在真的看到这样的公司的分享时，还是觉得奇妙有趣，好像思路打开了一样，同时，我还学习了怎么写一个自定义的 Kubernetes 调度算法，这样的分享怎么可能不讨人喜欢呢。</p>
<p>这么多视频，你要问我记住了多少？呵呵呵呵</p>
<a id="more"></a>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/%E6%88%91%E8%BF%99%E4%B8%8B%E5%85%A8%E5%BF%98%E4%BA%86.png" alt="我这下全忘了"></p>
<p>当然没有全部看完。有的视频基本只是打广告而已，有的是需要倍速播放的，如果是在线看的话效率就太低了，所以我先用 youtube-dl 把视频都下载下来了，利用 Mac 的系统标签做了一下记录。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/%E7%B3%96%E7%B3%96%E5%B8%AE%E6%88%91%E4%BB%AC%E8%AE%B0%E7%9D%80.gif" alt="糖糖先记下来"></p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/kubecon-2018-copenhagen.png" alt="kubecon-2018-copenhagen"></p>
<p>然而 Youtube 是没有这个功能的，这些视频有好几百个，太占磁盘了，迟早要删，但我又不想丢掉这些标签，毕竟可以作为一个索引，以后有类似问题的时候可以查阅。想要看 KubeCon 全部视频但抓不到重点的朋友也可以<strong>参考</strong>我的记录，根据自身情况分配精力。其中黄色🌕表示应该看第二遍，黑色⚫表示还没看完，红色🔴表示有信息需要再挖掘，蓝色🔵表示可以看第二遍，灰色(没有灰色的 emoji 表情，这里用的是白色⚪)表示看过了。</p>
<p>最开始的想法是截图，图片的体验当然不好，不能搜索还占带宽，后来找 presentation 的时候发现了 <a href="https://github.com/cncf/presentations" target="_blank" rel="external">cncf/presentations</a> 这个仓库，于是就用表格的方式了，加上了一列，记录我打的 tag。</p>
<p>会不定期更新，但不保证这里的记录包括全部的 CNCF 的视频。</p>
<h2 id="Shanghai-‘18-KubeCon-CloudNativeCon"><a href="#Shanghai-‘18-KubeCon-CloudNativeCon" class="headerlink" title="Shanghai ‘18: KubeCon + CloudNativeCon"></a><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2OK087kzLgc4jTPVbZjuNfs" target="_blank" rel="external">Shanghai ‘18: KubeCon + CloudNativeCon</a></h2><h2 id="Copenhagen-‘18-KubeCon-CloudNativeCon"><a href="#Copenhagen-‘18-KubeCon-CloudNativeCon" class="headerlink" title="Copenhagen ‘18: KubeCon + CloudNativeCon"></a><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2N8GdbjmhVU65KYm_68qBmo" target="_blank" rel="external">Copenhagen ‘18: KubeCon + CloudNativeCon</a></h2><table>
<thead>
<tr>
<th>Topic</th>
<th style="text-align:center">YouTube</th>
<th style="text-align:center">Tencent</th>
<th style="text-align:center">🌕 ⚫ 🔴 🔵 ⚪</th>
</tr>
</thead>
<tbody>
<tr>
<td>主题演讲：生产环境Kubernetes停运事件的剖析<br>Keynote: Anatomy of a Production Kubernetes Outage - Oliver Beattie, Head of Engineering, Monzo Bank</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OUYTNywPk-s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0660sas15s.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生景观简介（任何技术水平）<br>Cloud Native Landscape Intro – Dan Kohn, Cloud Native Computing Foundation (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_CFgSksTT54" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0660hnt8eg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>OpenStack的SIG介绍（任何技术水平）<br>OpenStack SIG Intro – Chris Hoge, OpenStack Foundation, &amp; David Lyle, Intel (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_A7G5cpU4Xw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0660jlcyrz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes政策工作组简介（任何技术水平）<br>Kubernetes Policy WG Intro – Zhipeng Huang, Huawei (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YprD0zoWXX0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0660mj20xg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用eBPF做低开销跟踪来观测Kubernetes应用和服务<br>Low-Overhead Tracing Using eBPF for Observability into Kubernetes Apps and Services - Gaurav Gupta</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ug3lYZdN0Bk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0660g3iw71.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯可扩展的监控Apache Spark<br>Scalable Monitoring Using Prometheus with Apache Spark - Diane Feddema &amp; Zak Hassan, Red Hat Inc</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oNBpZFhL94s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0660red54c.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>如何从几乎任何导出普罗米修斯指标<br>How to Export Prometheus Metrics from Just About Anything - Matt Layher, DigitalOcean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zk09Mbu0YQk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p06603xoy60.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给开发的普罗米修斯（初级技术水平）<br>Prometheus for Devs - Hubert Ströbitzer, Freelancer (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZHCSmYvA_sg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0660ruu3f5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Istio和OpenCenus作实际和有用的延时分析<br>Practical and Useful Latency Analysis using Istio and OpenCenus - Varun Talwar &amp; Morgan McLean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Nxqd7y78h7Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0660dt4i89.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：软件的社区<br>Keynote: Software’s Community - Dave Zolotusky, Software Engineer, Spotify</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=c_Pz6rhVfME" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06606amjbp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：跳过焦虑发作 - Kubernetes打造安全应用<br>Keynote: Skip the Anxiety Attack - Build Secure Apps with Kubernetes, Jason McGee</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=f0qWkCn04pw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l066035hmow.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：迁移150+微服务来Kubernetes的挑战<br>Keynote: The Challenges of Migrating 150+ Microservices to Kubernetes, Sarah Wells</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=H06qrNmGqyE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0660lwf6rb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：加快Kubernetes原生应用程序<br>Keynote: Accelerating Kubernetes Native Applications - Brandon Philips, CTO of CoreOS, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8iQRJXJHiZ8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0660k5k5fh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes项目更新<br>Keynote: Kubernetes Project Update - Aparna Sinha, Group Product Manager, Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2eAOx8E6-5Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0660l7xlnx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：容器原生开发和运维经验：正变得越来越容易和快速<br>Keynote: Container-Native Dev-and-ops Experience: It’s Getting Easier, Fast. - Ralph Squillace</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0sh2aWdfBxA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f06601q70rk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：谷歌云的云原生观测及安全<br>Keynote: Cloud Native Observability &amp; Security from Google Cloud - Craig Box, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8fSNDxA_irY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0660gijj49.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：CNCF最终用户奖<br>Keynote: CNCF End User Awards - Presented by Chris Aniszczyk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EJfsxbitiYI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0660atyjt9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：普罗米修斯2.0 - 云原生监控的下一个规模<br>Keynote: Prometheus 2.0 – The Next Scale of Cloud Native Monitoring - Fabian Reinartz</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nDalewt4BOw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0660z3w53a.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SPIFFE项目介绍（任何技术水平）<br>SPIFFE Project Intro - Andrew Jessup &amp; Emiliano Berenbaum, Scytale, Inc. (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0LSaNrOabH4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0660tab1d6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>TUF/Notary项目介绍（任何技术水平）<br>TUF / Notary Project Intro – David Lawrence, Docker, &amp; Justin Cappos, NYU, TUF (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=rHMOC6UH1Pg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0694joalug.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenTracing项目介绍（任何技术水平）<br>OpenTracing Project Intro – Priyanka Sharma &amp; Ted Young, LightStep (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_jCXx2BX7nI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0660u4i01d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Jenkins X：简单在K8s做CI/CD（中级技术水平）<br>Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uHe7R_iZSLU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0660db8428.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>持续交付您的Kubernetes基础设施<br>Continuously Deliver your Kubernetes Infrastructure - Mikkel Larsen, Zalando SE</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1xHmCrd8Qn8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0660ge5cu2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>没有Docker构建Docker镜像（中级技术水平）<br>Building Docker Images Without Docker - Matt Rickard, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qhykcC94ukg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0660193ri5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Rook项目介绍（任何技术水平）<br>Rook Project Intro – Bassam Tabbara, Tony Allen &amp; Jared Watts, Upbound (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=To1ldyb_9NA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0660j09rlq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>不断发展一个持续交付工作流程<br>Evolving a Continuous Delivery Workflow - Gard Rimestad &amp; Øyvind Ingebrigtsen Øvergaard</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cen3dULhE1E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0660jjotwd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>持续交付遇到定制Kubernetes控制器<br>Continuous Delivery Meets Custom Kubernetes Controller - Suneeta Mall &amp; Simon Cochrane</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kBS_Wd41R8k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0660l8oq91.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Git-push工作流程（使用GIT中的钩）用于应用程序部署<br>Git-push Workflows (using git hooks) for Deploying Applications - Tanmai Gopal &amp; Vamshi Surabhi Rao</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gDGT4Gf_4JM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0660akypf7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kubernetes在中国支持$8万亿卡支付<br>Kubernetes on Supporting $8 Trillion Card Payments in China - Xin Zhang &amp; Deyuan Deng</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OS5DKWffn9s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0660locsmy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>阿迪达斯全球推出Kubernetes的旅程<br>The Journey of Adidas to a Global Kubernetes Rollout - Daniel Eichten &amp; Oliver Thylmann</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dwDhHt1Llb8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0662zrokw5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>介绍在Booking.com使用基于Envoy的服务网格<br>Introducing Envoy-Based Service Mesh at Booking.com - Ivan Kruglov, Booking.com</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Pus2ytdEfrQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x06621iqyzm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio服务网格的性能和规模<br>Performance and Scale @ Istio Service Mesh - Fawad Khaliq, Laurent Demailly &amp; Surya V Duggirala</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=G4F5aRFEXnU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0662meva4j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Istio构建混合云<br>Building Hybrid Clouds with Istio - Allan Naim, Google &amp; Rohit Agarwalla, Cisco</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=bLJL53UIcqI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0662ozn3cr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>在交通控制系统使用Envoy更换NGINX<br>Replacing NGINX with Envoy in a Traffic Control System - Mark McBride, Turbine Labs, Inc</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MO_0bwcNEZY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n06620y0tzv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SRv6LB：利用IPv6、分段路由和VPP<br>SRv6LB: Leveraging IPv6, Segment Routing, and VPP - Pierre Pfister &amp; Mark Townsley</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RRKUeyFaqEA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0662ab5bqd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>未开发的服务能力 - 没有服务网格的L7负载平衡<br>The Untapped Power of Services - L7 Load Balancing Without a Service Mesh - Damien Lespiau</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PQnTBUr174M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0662n00tsb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用协议缓冲器和gRPC做高效的IoT（初级技术水平）<br>Efficient IoT with Protocol Buffers and gRPC - Vladimir Vivien, {code} (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=c9z_o5lu0dI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0662coegwz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>gRPC服务Brokerless REST接口<br>A Brokerless REST Interface for gRPC Services - Roman Zimine, Turbonomic</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eQvrr9U4I8o" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0662xz2n11.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>提高您的Kubernetes工作负载安全<br>Improving your Kubernetes Workload Security - Samuel Ortiz &amp; Fabian Deutsch</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=T_NxDXAdbfo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a06622e1v9o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>到底无根容器的航线（任何技术水平）<br>The Route To Rootless Containers - Ed King, Pivotal &amp; Julz Friedman, IBM (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=j4GO2d3YjmE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e066206oltd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生身份管理<br>Cloud Native Identity Management - Andreas Zitzelsberger &amp; Andrew Jessup</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eCLTdSp4JzE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0662gqkvap.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Notary和TUF保护您的Kubernetes交付管道<br>Securing your Kubernetes Delivery Pipelines with Notary and TUF - Liam White &amp; Michael Hough</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JK70k_B87mw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0662i19krx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>自动缩放SIG简介（任何技术水平）<br>SIG Autoscaling Intro – Marcin Wielgus, Google, &amp; Solly Ross, Red Hat (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oJyjW8Vz314" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0662xwyy42.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>仪器仪表SIG简介（任何技术水平）<br>SIG Instrumentation Intro – Frederic Branczyk, CoreOS, &amp; Piotr Szczesniak, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Qly7CMHmrV4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0662n0kbnw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯项目介绍（任何技术水平）<br>Prometheus Project Intro – Julius Volz, Prometheus (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=sYMTY-SciUQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0662szz77g.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes一致性工作组简介（任何技术水平）<br>Kubernetes Conformance WG Intro – William Denniss, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cImwp_826JU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0662l13yho.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>AWS SIG更新（任何技术水平）<br>SIG AWS Update - Justin Santa Barbara, FathomDB (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yzWXuAZwJaw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0662kemfz5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>服务目录SIG简介（任何技术水平）<br>SIG Service-Catalog Intro – Doug Davis, Michael Kibbe &amp; Morgan Bauer (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2tycz5_Bp-E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0662vwj5hx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Jaeger项目介绍（任何技术水平）<br>Jaeger Project Intro - Juraci Kröhling, Red Hat (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=D7XakRQaEk0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0662knp2d5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>贡献体验SIG介绍（任何技术水平）<br>SIG Contributor Experience Intro – Paris Pittman, Google &amp; Elsie Phillips, CoreOS (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=e3VKszwIokk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0662nb5mx4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>谁什么如何：通过DevStats了解Kubernetes发展<br>Who What How: Understanding Kubernetes Development through DevStats - Josh Berkus &amp; Łukasz Gryglicki</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=D3CMuxQymR8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0662tpug9k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ ⚫</td>
</tr>
<tr>
<td>开源和利用社会媒体通讯建设在线社区<br>Open Source and Building Online Communities using Social Media and Communications - Kim McMahon</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=V0qaU512zrg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0662zt2077.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：CNCF 20-20愿景<br>Keynote: CNCF 20-20 Vision - Alexis Richardson, Founder &amp; CEO, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qUK-F40oLVQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s06640fav8r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：从创新到生产<br>Keynote: From Innovation to Production - Dirk Hohndel, VP &amp; Chief Open Source Officer, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=X8E_FQ7CHiE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0664bm0pro.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：CERN的经验<br>Keynote: CERN Experiences - Ricardo Rocha &amp; Clenimar Filemon</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2PRGUOxL36M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a06647v8j77.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：重新思考微服务的网络<br>Keynote: Re-thinking Networking for Microservices - Lew Tucker, VP/CTO Cloud Computing</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Qk2ZdHnHh0Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s066424xdhb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：CNCF项目更新<br>Keynote: CNCF Project Update - Liz Rice, Colin Sullivan, Andrew Jessup, Sugu Sougoumarane</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=C1kwY0N4PUk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y066417ymvu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：开幕致辞和你的代码有多好？<br>Keynote: Opening Remarks &amp; How Good is Your Code? - Dan Kohn, Executive Dir., CNCF</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=S4SKOHmVD1U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0664omhwoq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Containerd，这对我来讲是什么意思（任何技术水平）<br>Containerd, What Does it Mean for Me - Scott Coulton, Puppet (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dBm9n_nq-Uc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0664ka2vh6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>所有不同的容器运行引擎是怎么回事了？<br>What’s Up With All The Different Container Runtimes? - Ricardo Aravena, Branch Metrics</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lHv0LVEIPk8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0664f8xhv1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕 🔴</td>
</tr>
<tr>
<td>系统设计进化：从不可靠的RPC到容错性好的Linkerd<br>Evolving Systems Design: From Unreliable rpc to Resilience with Linkerd - Edward Wilde, Form3</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2EqkvPqk7JU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0664shh001.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio配置介绍（初级技术水平）<br>Introduction to Istio Configuration - Joy Zhang, Google (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=x1Tyw8dFKjI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p06647duuz2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes中建立镜像溯源和安全<br>Establishing Image Provenance and Security in Kubernetes - Adrian Mouat, Container Solutions</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zs-6YEUrJAM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0664lnb7ho.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过开放建立开源社区实现创新<br>Building an Open Source Community to Achieve Innovation-Through-Openness - Jonas Rosland</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QhG_ZFTZ7kk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0665edtn0k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>自动化和Kubernetes贡献者体验<br>Automation and the Kubernetes Contributor Experience - Aaron Crickenberger, Samsung SDS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=BsIC7gPkH5M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0665al5qic.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>我们如何建造Contour以及你可以学习我们的哪些经验<br>How We Built Contour, and What You Can Learn From Our Experience - Dave Cheney, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4usXJE0EwHo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0665erorkq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Diffy - 服务中预测与抢占回归<br>Diffy - Predicting and Preempting Regressions in Services - Puneet Khanduri &amp; Prashant Khanduri</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=adjhYJeX3c4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r06650crri8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OSS跟踪生态的调查（初级技术水平）<br>A Survey of the OSS Tracing Ecosystem - Ben Sigelman &amp; Ted Young, LightStep (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-zLPPYYH_F8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0665od97ky.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SAFE工作组简介（任何技术水平）<br>SAFE WG Intro – Jeyappragash J J, padme.io, &amp; Ray Colline, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=DRtl8wK9FwE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s06655airao.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>集群生命周期SIG简介（任何技术水平）<br>SIG Cluster Lifecycle Intro – Justin Santa Barbara, FathomDB &amp; Lucas Käldström (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GmD1KYsRD4Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0665e28y5z.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>多集群SIG简介（任何技术水平）<br>SIG Multi-Cluster Intro – Christian Bell, Madhu C.S., &amp; Nikhil Jindal, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vGZo5DaThQU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f06652ie72b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Envoy项目介绍（任何技术水平）<br>Envoy Project Intro – Matt Klein &amp; Jose Nino, Lyft (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RUPgiHqUAZg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0665o26hrg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CLI SIG简介（任何技术水平）<br>SIG CLI Intro - Phil Wittrock &amp; Mengqi Yu, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ak95fTtqMNU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j06650nq83v.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kubeflow简介（任何技术水平）<br>Kubeflow Intro – Michał Jastrzębski &amp; Ala Raddaoui, Intel (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NrDpQks0e98" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r066570g14p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上gRPC的负载平衡（中级技术水平）<br>gRPC Load Balancing on Kubernetes - Jan Tattermusch, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=F2znfxn_5Hg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0665lnoywi.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ ⚫</td>
</tr>
<tr>
<td>使大数据处理轻便：Apache Beam和gRPC的故事<br>Making Big Data Processing Portable. The Story of Apache Beam and gRPC - Ismaël Mejía</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7iALa6sFgb8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q06653rxpwo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>多样午餐（Diversity Lunch）<br>Diversity Lunch</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WFlFmhKSnv0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d066578q1nj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过CNI插件在AWS容器使用云原生联网<br>Cloud Native Networking for Containers in AWS using CNI Plugins - Anirudh Aithal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tsc17ZuV5iU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0665vnmu81.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在DigitalOcean布Kubernetes全球容器网络<br>Global Container Networks on Kubernetes at DigitalOcean - Andrew Sy Kim, DigitalOcean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tHAkey-sZ9g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u066518mkue.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>“丝绸之路”道：从头开始构建CNI插件<br>The “Silk” Road: Building a CNI Plugin from Scratch - Usha Ramachandran &amp; Angela Chin</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RdpDvpA--nw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0665ko76pb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kubernetes和CNI：我们在哪里以及下一步是什么<br>Kubernetes and the CNI: Where We Are and What’s Next - Casey Callendrello, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Vn6KYkNevBQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0665rgh4yu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕 🔴</td>
</tr>
<tr>
<td>让Ingress-Nginx为你工作和社区（任何技术水平）<br>Make Ingress-Nginx Work for you, and the Community - Fernando Diaz, IBM (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GDm-7BlmPPg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0665cdjv75.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>揭示你Kubernetes最深入的指标<br>Reveal Your Deepest Kubernetes Metrics - Bob Cotton, Freshtracks.io</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1oJXMdVi0mM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0668ly9kjn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes记录入门（任何技术水平）<br>Getting Started with Logging in Kubernetes - Eduardo Silva, Treasure Data (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7qL5wkAaSh4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0668jqc6gw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>TSDB：过去、现在和未来<br>TSDB: The Past, Present and the Future - Goutham Veeramachaneni, IIT Hyderabad</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0UvKEHFNu4Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0668y0okup.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>我们如何使用Jaeger和普罗米修斯提供快如闪电的用户查询<br>How We Used Jaeger and Prometheus to Deliver Lightning-Fast User Queries - Bryan Boreham</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qg0ENOdP1Lo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u06689ayrq7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯指标进行Pod异常检测和驱逐<br>Pod Anomaly Detection and Eviction using Prometheus Metrics - David Benque &amp; Cedric Lamoriniere</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=HIB_haT1z5M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0668tisp8e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯自动缩放你的Kubernetes工作负载<br>Autoscale your Kubernetes Workload with Prometheus - Frederic Branczyk, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VQFoc0ukCvI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0668egsoql.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>谁打毙了集群？Kubernetes的审核记录<br>Who Shot the Cluster? - Audit Logging in Kubernetes - Marian Lobur &amp; Mik Vyatskov, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gDZxQBo-Zdc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f06681q4drz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes集群注册表赋能多集群入口<br>Multicluster Ingress Powered by Kubernetes Cluster Registry - Greg Harmon &amp; Nikhil Jindal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nCON0U2dZ_w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0668ft70pz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过系统调用的故事探索容器机制<br>Exploring Container Mechanisms Through the Story of a Syscall - Alban Crequy, Kinvolk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1Tl-NURLoq4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0668e34jf5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>了解在etcd和Kubernetes的分布式共识<br>Understanding Distributed Consensus in etcd and Kubernetes - Laura Frank, CloudBees</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=n9VKAKwBj_0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0668iapkg7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>管理Kubernetes：你需要知道关于第2日的<br>Managing Kubernetes: What You Need to Know About Day 2 - Craig Tracey, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0TBelL8UBQU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h066860h4yb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>Fluentd项目介绍<br>Fluentd Project Intro – Eduardo Silva &amp; Masahiro Nakagawa, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=BtGOTIkxnGE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0668upihmq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>存储工作组简介<br>Storage WG Intro – Ben Hindman, Mesosphere, Clint Kitson, VMware &amp; Quinton Hoole, Huawei</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9Vt1B4vBvy8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e06686strye.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes过度设计我的家（任何技术水平）<br>Over-engineering my home with Kubernetes - Matthias Grüter, Spotify (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=z2h6Gx0dFog" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0668t5m31q.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：我希望知道关于Fluentd和Kubernetes<br>Lightning Talk: What I Wish I’d Known about Fluentd with Kubernetes - Bryan Boreham, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=BQuBnXp31ZA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0668bxfbet.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：Istio示例（初级技术水平）<br>Lightning Talk: Istio by Example - Josef Adersberger, QAware (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LYeAgVaJrm0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06943oqsuk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ 🔵</td>
</tr>
<tr>
<td>使用Envoy V2API扩展Istio服务网格<br>Extending Istio Service Mesh w/Envoy v2 APIs - Dmitri Chtchourov &amp; Tim Swanson</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yq-c3H1Cd1A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r06681phm7e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过CNI插件在AWS容器使用云原生网络<br>Cloud Native Networking for Containers in AWS using CNI Plugins - Anirudh Aithal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tsc17ZuV5iU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0668sooapb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>项目管理SIG简介<br>SIG PM Intro - Ihor Dvoretskyi, Cloud Native Computing Foundation &amp; Aparna Sinha, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Yj9IvSOC2I0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w06682qzcrn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Linkerd简介（任何技术水平）<br>Linkerd Intro – Andrew Seigner, Buoyant.io &amp; George Miranda (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VAcvFMRd27I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0668r8yqzv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Minikube简介（任何技术水平）<br>Minikube Intro – Dan Lorenc, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4x0CZmF_U5o" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0668pu0hh1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>服务目录SIG深潜<br>SIG Service-Catalog Deep Dive – Doug Davis, Michael Kibbe &amp; Morgan Bauer</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=knKSSKMkdHY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g066804ippl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubespray简介（任何技术水平）<br>Kubespray Intro – Antoine Legrand, Red Hat, &amp; Matthew Mosesohn, Virtustream (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hSMGlnXE-Q8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0668y4ga4g.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>存储（K8S）SIG简介（任何技术水平）<br>SIG Storage (K8s) Intro - Saad Ali, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GvrTl2T-Tts" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0668tge0ig.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>rkt深潜（中级技术水平）<br>rkt Deep Dive – Alban Crequy &amp; Iago López Galeiras, Kinvolk (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=n9eCJ_zjrKg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0669er8yzi.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>NATS简介（任何技术水平）<br>NATS Intro – Colin Sullivan &amp; Waldemar Quevedo, Synadia (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Y9bDY_oE80w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0669zuosli.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SPIFFE深潜<br>SPIFFE Deep Dive - Andrew Jessup, Emiliano Berenbaum, Scytale, Inc., &amp; Neel Shah, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=sXwFB34BBrM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0669vki6w4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>rkt简介（任何技术水平）<br>rkt Intro – Alban Crequy &amp; Iago López Galeiras, Kinvolk (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=D8uMQDw4hVY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0669u41nq4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>调度SIG深潜<br>SIG Scheduling Deep Dive – Bobby Salamat &amp; Jonathan Basseri, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_fja_lLFpfc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0669x5v7op.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕 🔴</td>
</tr>
<tr>
<td>Kubeflow深潜（中级技术水平）<br>Kubeflow Deep Dive – David Aronchick &amp; Jeremy Lewi, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=86GD1VzSnks" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r066995sfju.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Source2Image简介（任何技术水平）<br>Source2Image Intro – Ben Parees, Red Hat &amp; Matt Moore, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=fCV4dr_36cM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a06691ok1ka.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯深潜（中级技术水平）<br>Prometheus Deep Dive – Julius Volz, Prometheus, &amp; Max Inden, Red Hat (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UAAT0tRmXP8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0669wpjzos.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>多集群SIG深潜<br>SIG Multi-Cluster Deep Dive – Christian Bell, Madhu C.S., &amp; Nikhil Jindal, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=q27rbaX5Jis" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0669494uv6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Jaeger项目深潜（中级技术水平）<br>Jaeger Project Deep Dive - Juraci Kröhling, Red Hat (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tFZAHWl8y_I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0669ixcz4a.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CNI简介（任何技术水平）<br>CNI Intro – Bryan Boreham, Weaveworks, &amp; Casey Callendrello, CoreOS (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7CeYAIlUY6s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0669bcf3ka.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
<tr>
<td>云原生景观深潜<br>Cloud Native Landscape Deep Dive – Dan Kohn, Cloud Native Computing Foundation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_s9Ho5pylB4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0669bfugo9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>资源管理工作组深潜（中级技术水平）<br>Resource Management WG Deep Dive – Vishnu Kannan, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Oielqj7wIng" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0669gqq90w.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>应用SIG简介（任何技术水平）<br>SIG Apps Intro – Janet Kuo &amp; Kenneth Owens, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=fZ9Bf7iEekU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0669pxwjj0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ 🔴</td>
</tr>
<tr>
<td>CNCF跨云持续集成简介<br>CNCF Cross-Cloud CI Intro – Denver Williams &amp; Taylor Carpenter</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wb7aCAk1VFU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0669n1bshn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>NATS深潜（中级技术水平）<br>NATS Deep Dive – Colin Sullivan &amp; Waldemar Quevedo, Synadia (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MAKYz8oPRyw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0669ejuaxh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>贡献者体验SIG深潜<br>SIG Contributor Experience Deep Dive – Paris Pittman, Google &amp; Tim Pepper, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2oPHolzhZHc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0669chrqle.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>CoreDNS简介（任何技术水平）<br>CoreDNS Intro – Miek Gieben, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZFEa2pDpvws" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0669temw8d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>发布SIG简介（任何技术水平）<br>SIG Release Intro – Jaice Singer DuMars &amp; Caleb Miles, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3HZVVR2ukKI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0669zcga0w.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OCI BoF（任何技术水平）<br>OCI BoF - Alban Crequy, Kinvolk &amp; Chris Aniszczyk, CNCF (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4Kna9fjWmHk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0669p35kv8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>VMware SIG简介（任何技术水平）<br>VMware SIG Intro – Fabio Rapposelli &amp; Steve Wong, VMware (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zn8NekAMJzs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0669j8a8ur.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes和TensorFlow建立围棋AI<br>Building a Go AI with Kubernetes and TensorFlow - Andrew Jackson &amp; Josh Hoak, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QR8tAyzkTdE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0671nlfxny.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Linkerd和Conduit观测和调试云原生应用程序<br>Observability and Debugging Cloud-Native Apps using Linkerd &amp; Conduit - Franziska von der Goltz</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RC_9ywj0yz8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0671j7mxy9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：问我们什么也可以：微服务和服务网<br>Panel Discussion: Ask Us Anything: Microservices and Service Mesh - Moderated by Jason McGee</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uWi-Fe4Rzhg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0671ynz4br.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Envoy内部深潜（高级技术水平）<br>Envoy Internals Deep Dive - Matt Klein, Lyft (Advanced Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gQF23Vw0keg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0671jwpswf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>GitOps搭配Istio - 代码一样的管理Istio配置<br>GitOps for Istio - Manage Istio Config like Code - Varun Talwar &amp; Alexis Richardson</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VkKMf23ZokY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0671ilw8dj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>服务网格如何帮助我们建立生产级别的云原生服务<br>How a Service Mesh Helped Us Build Production Cloud-Native Services - Israel Sotomayor</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VoYAtCVz3Ig" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i06714l3dra.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>如何交付服务网格到生产环境而没有被炒<br>How to Get a Service Mesh Into Prod without Getting Fired - William Morgan, Buoyant, Inc</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XA1aGpYzpYg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v06717jzucv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>权利：可以理解的容器安全控制<br>Entitlements: Understandable Container Security Controls - Justin Cormack &amp; Nassim Eddequiouaq</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Jbqxsli2tRw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l06714puy5h.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>案例分析：容器如何使安全性和法规遵从瞬间更容易<br>Case study: How Containers Makes Security and Compliance Instantly Easier - John Morello</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=I8tGZXPuIo0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f06713hj0ll.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OPA：云原生政策引擎（中级技术水平）<br>OPA: The Cloud Native Policy Engine - Torin Sandall, Styra (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XEHeexPpgrA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0671h2ocnf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用微服务大规模实现安全<br>Achieving High Security at Scale with Microservices - Zachary Arnold &amp; Austin Adams</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1YCIOEW5nGw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o067155bgv4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>集群如牛：如何无缝跨Kubernetes集群迁移应用程序<br>Clusters as Cattle: How to Seamlessly Migrate Apps Across Kubernetes Clusters - Andy Goldstein</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5kMz2oJgV0A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0671ukr0j0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>不使用联邦进行Kubernetes多群集操作<br>Kubernetes Multi-Cluster Operations without Federation - Rob Szumski, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zVOIk7nO_ts" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0671cy3fjf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>101种方法打断和恢复Kubernetes集群<br>101 Ways to “Break and Recover” Kubernetes Cluster - Suresh Visvanathan &amp; Nandhakumar Venkatachalam</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=likHm-KHGWQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0671ncprn5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>来自剧本的故事（任何技术水平）<br>Stories from the Playbook - Tina Zhang &amp; Fred van den Driessche, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=N2JUGnwinbQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0671fh98do.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>建立cert-manager：迁移成千上万的用户到CRD<br>Building cert-manager: Migrating Thousands of Users from kube-lego to use CRDs - James Munnelly</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TuIycZeiNZM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0672t3jy0u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>YAML是给计算机的；ksonnet是给人的（任何技术水平）<br>YAML is for Computers. ksonnet is for Humans - Bryan Liles, Heptio (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FjdS21McgpE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0672uled1k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Brigade建立事件驱动的管道<br>Building Event-Driven Pipelines with Brigade - Brian Redmond, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yhfc0FKdFc8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0672vdpumt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>构建应用程序以增加采用Kubernetes，让生活更轻松<br>Building Applications to Increase Kubernetes Adoption, and Make Life Easier - Kate Kuchin, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=X2icFkQMg60" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w06721y5y9p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>编写云原生应用程序的挑战<br>Challenges to Writing Cloud Native Applications - Vallery Lancey, Checkfront</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=di6oFceM_CQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0672vqtt6j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用服务目录快乐Helming（中级技术水平）<br>Happy Helming with Service Catalog - Jeremy Rickard, Microsoft (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SuicCBXJRPg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0672p8djtm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从PaaS到K8s：结合K8s的力量和最具创新的特点<br>From PaaS to Kubernetes: Combining the Power of Kubernetes with the Most Innovative Features</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hLlGUSh_yAI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0672kozs3q.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>水平Pod自动配置器重装 - 基于自定义指标缩放<br>Horizontal Pod Autoscaler Reloaded - Scale on Custom Metrics - Maciej Pytel &amp; Solly Ross</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1xm_ccAYO90" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0672s4n5ze.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用自定义度量构建Kubernetes调度程序<br>Building a Kubernetes Scheduler using Custom Metrics - Mateo Burillo, Sysdig</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4TaHQgG9wEg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0672564jcn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>给CRD编写Kubernetes控制器：挑战、方法和解决方案<br>Writing Kubernetes Controllers for CRDs: Challenges, Approaches and Solutions - Alena Prokharchyk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7wdUa4Ulwxg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0672i1pbci.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>来自未来的Kubernetes风格的API（任何技术水平）<br>Kubernetes-style APIs of the Future - Daniel Smith, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=S2U8GNHewpk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0672lnk1vs.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>大家来编写Kubernetes控制器（初级技术水平）<br>Writing Kube Controllers for Everyone - Maciej Szulik, Red Hat (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AUNPLQVxvmw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0672rvtx8m.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>使用Kubernetes自定义资源定义减少样板代码<br>Reducing Boilerplate With Kubernetes Custom Resource Definitions - James Bowes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5VGJOW4QA3Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0672dqvalj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>可扩展简介（任何技术水平）<br>Scalability Intro – Shyam Jeedigunta, Google &amp; Bob Wise, Samsung SDS (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8cJ-zaLOVXc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06727084ra.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：无服务器，没有那么FaaS<br>Keynote: Serverless, Not So FaaS - Kelsey Hightower, Kubernetes Community Member, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_1-5YFfJCqM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0672r5kevg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>存储工作组深潜<br>Storage WG Deep Dive – Ben Hindman, Mesosphere, Clint Kitson, VMware &amp; Quinton Hoole, Huawei</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Nks3qOx8YcI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0672w38i7d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes政策工作组深潜（中级技术水平）<br>Kubernetes Policy WG Deep Dive - Zhipeng Huang, Huawei (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SpCjXqDTCgU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0672o9ws28.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>盒子里有什么东西？Kubernetes中的资源管理<br>What’s in the Box? Resource Management in Kubernetes - Louise Daly &amp; Ivan Coughlan, Intel</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7CWH3KRk01U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0672d62l0y.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上的合规数据管理和机器学习<br>Compliant Data Management and Machine Learning on Kubernetes - Daniel Whitenack, Pachyderm</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eOzl-LFqYFM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s06729lfxdh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>把你的数据管道带到机器学习的时代<br>Bringing Your Data Pipeline into The Machine Learning Era - Chris Gaun &amp; Jörg Schad, Mesosphere</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=f_-3rQoudnc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0672o7rahf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes提供GPU即服务的路径（中级技术水平）<br>The Path to GPU as a Service in Kubernetes - Renaud Gaubert, NVIDIA (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8JGduez-8S0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0672quss7o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubeflow构建ML产品<br>Building ML Products With Kubeflow - Jeremy Lewi, Google &amp; Stephan Fabel, Canonical</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=sC8Ce9vUggo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0672h28jil.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Istio观察和故障排除您的微服务<br>Observing and Troubleshooting your Microservices with Istio - Isaiah Snell-feikema &amp; Douglas Reid</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TSEqxsctXVc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0672sxyxxz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Linux内核加快Envoy（高级技术水平）<br>Accelerating Envoy with the Linux Kernel - Thomas Graf, Covalent (Advanced Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ER9eIXL2_14" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0672ujfdpq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio告诉我，我的服务响应时间过长，现在该怎么办？<br>Istio Tells me my Service has Slow Response Time, Now What? - Endre Sara &amp; Enlin Xu</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZF-_LN9XYiQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0672vqn2hd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>拉伸网格（任何技术水平）<br>Stretching the Mesh - John Joyce &amp; Robert Li, Cisco Systems (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jM6ovJAWCvs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l068171tceh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s、Istio和Envoy进行金丝雀部署（初级技术水平）<br>Canary Deploys with Kubernetes, Istio and Envoy - Jason Yee, Datadog (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MGLDRKiXNf0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a06816lkn0i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio - 天气公司之旅（任何技术水平）<br>Istio - The Weather Company’s Journey - Nick Nellis &amp; Fabio Oliveira, IBM (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0fKi3NeCsSE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k06810v1jv4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes实行多租户：当今最佳实践和未来方向<br>Multi-Tenancy in Kubernetes: Best Practices Today, and Future Directions - David Oppenheimer</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=xygE8DbwJ7c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0681nn0kzc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>TL; DR NIST容器安全标准（初级技术水平）<br>TL;DR NIST Container Security Standards - Elsie Phillips, CoreOS (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AqoDQaeuLXY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0681v9cp56.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes运行安全：如果容器变坏会发生什么？<br>Kubernetes Runtime Security: What Happens if a Container Goes Bad? - Jen Tong &amp; Maya Kaczorowski</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=X7mBjas9vtE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0681annwry.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>黑客指南：Kubernetes和云（中级技术水平）<br>A Hacker’s Guide to Kubernetes and the Cloud - Rory McCune, NCC Group PLC (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dxKpCO2dAy8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0681gb8us0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>从Kubelet到Istio：K8s网络安全揭秘<br>From Kubelet to Istio: Kubernetes Network Security Demystified - Andrew Martin, ControlPlane</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Uocf67aD5QQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0681v501nl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>保障Pod的安全（高级技术水平）<br>Secure Pods - Tim Allclair, Google (Advanced Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GLwmJh-j3rs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0681sd297n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ 🔵</td>
</tr>
<tr>
<td>在裸机集群建设Kubernetes<br>Building a Kubernetes on Bare-Metal Cluster - Alexandros Kosiaris &amp; Guiseppe Lavagetto</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7rqvRwfZHF4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g06812w2nnj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kubernetes里面资源管理（QoS）：来自实实战的教训<br>Inside Kubernetes Resource Management (QoS) – Mechanics and Lessons from the Field - Michael Gasch</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8-apJyr2gi0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0681rvh3e5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>亚马逊EKS介绍（初级技术水平）<br>Introducing Amazon EKS - Brandon Chavis &amp; Arun Gupta, AWS (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FmubBIw_wSs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06815q4k1b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用Kubernetes进行云爆发<br>Cloudbursting with Kubernetes - Irfan Ur Rehman &amp; Quinton Hoole, Huawei Technologies</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AGQL4ItB3NM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0681zbhfa8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>“生产就绪”对Kubernetes集群的真正含义是什么？<br>What Does “Production Ready” Really Mean for a Kubernetes Cluster? - Lucas Käldström</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EjSiZgGdRqk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0668xamr1v.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ ⚫</td>
</tr>
<tr>
<td>Kubernetes 101：DIY工作坊（初级技术水平）<br>Kubernetes 101: DIY Workshop - Bridget Kromhout, Microsoft (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=mYsp_cGY2O0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0681896h7g.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes构建给机器人的PaaS<br>Building a PaaS for Robotics with Kubernetes - Dhananajay Sathe, Rapyuta Robotics</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qMlgVr6qqzc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0682ip4jpg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>为什么在你的真空机器人运行kubelet（不）是一个好主意<br>Why Running kubelet on your Vacuum Robot is (not) a Good Idea - Christian Simon, Jetstack</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ea0UzDpk6PE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0682v0fkv1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes高级调度<br>Kubernetes Advanced Scheduling - Robert Carosi, Ad van der Veer &amp; Boris Mattijssen</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=q8MFm2jwXpA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b06820h97lb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>Kubernetes作为互联家庭的一个抽象层<br>Kubernetes as an Abstraction Layer for a Connected Home - Scott Nichols, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=l9g3-cnaBR4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v06821scp1t.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes建立容错的资源控制器<br>Building a Fault-Tolerant Resources Controller on Kubernetes - Morgan Bauer &amp; Srinivas Brahmaroutu</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=v2gAcKKDf9Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0682lqhh8i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>一切你需要知道如何在Kubernetes使用GPU<br>Everything you Need to Know about using GPUs with Kubernetes - Rohit Agarwal, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=KplFFvj3XRk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0682fb9245.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>控制器：用于扩展您的基础设施的lambda函数<br>Controllers: Lambda Functions for Extending your Infrastructure - Ross Guarino &amp; Terin Stock</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TM-2GgQ6Q2A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0682szw8ak.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubectl插件101<br>Kubectl Plugins 101 - Jonathan Berkhahn, IBM &amp; Carolyn Van Slyck, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PZmTPRRfW5M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0682e8xqn0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>监控：从最黑暗的角落跟随信息<br>Monitoring: Follow the Data from the Darkest Corners - Piotr Szczesniak &amp; Frederic Branczyk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FAqwXX3Zt9s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0682werb94.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用kubectl运行你的终端到终端的测试<br>Using kubectl to Run your End-to-End Tests - Amit Kumar Das &amp; Uday Kiran, MayaData</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YU9J4KH8X14" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0682xwjpia.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>仪器仪表SIG深潜<br>SIG Instrumentation Deep Dive – Frederic Branczyk, CoreOS, &amp; Piotr Szczesniak, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SzLLzKWH2Gk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0682sf5jox.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OPA深潜（中级技术水平）<br>Open Policy Agent Deep Dive – Tim Hinrichs &amp; Torin Sandall, Styra (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4mBJSIhs2xQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n06827wzzvp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：现代应用安全需要容器<br>Panel Discussion: Modern App Security Requires Containers – Moderated by Sean Michael Kerner</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=6bwt9SMLnmg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0682br6ss0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>containerd深潜（中级技术水平）<br>containerd Deep Dive – Stephen Day, Docker (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3AynH3c0F8M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n068252jyqm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
<tr>
<td>Linkerd深潜（中级技术水平）<br>Linkerd Deep Dive – George Miranda &amp; Thomas Rampelberg (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=j0Kosjecx70" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l06820n3jyk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenTracing项目深潜<br>OpenTracing Project Deep Dive – Priyanka Sharma &amp; Ted Young, LightStep</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ySR_FVNX4bQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0682213mjo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SAFE工作组深潜（中级技术水平）<br>SAFE WG Deep Dive – Ray Colline, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RTYJ-yggDxs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0682reo44i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混沌工程工作组深潜（中级技术水平）<br>Chaos Engineering WG Deep Dive – Sylvain Hellegouarch, ChaosIQ (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Q6e3N7trcFI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0682tnaa35.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>应用程序定义工作组简介（任何技术水平）<br>WG App Def - Intro – Antoine Legrand, Red Hat &amp; Gareth Rushgrove, Docker (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=I3BU9pkTgRE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c06823ah409.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenStack SIG深潜<br>OpenStack SIG Deep Dive – Chris Hoge, OpenStack Foundation &amp; David Lyle, Intel</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=l03heU_uG1s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0682ielecu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>边缘计算和Kubernetes BOF（任何技术水平）<br>Edge Computing and Kubernetes BOF - Matthew Caulfield, Cisco (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=w_BvR8hZYe4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0685v6jz3k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CI/CD BoF：快速交付优质（任何技术水平）<br>CI/CD BoF: Delivering Quality Quickly - Brice Fernandes &amp; Marc Carré, Weaveworks (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EheNmDFP19Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0685iqe5is.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CNCF跨云持续集成深潜<br>CNCF Cross-Cloud CI Deep Dive – Denver Williams &amp; Taylor Carpenter</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=m-WK-pOs5TA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j06856yogah.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Fluentd深潜<br>Fluentd Deep Dive – Eduardo Silva &amp; Masahiro Nakagawa, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TqW-b60AiNk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0685yn4ta5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Source2Image深潜（中级技术水平）<br>Source2Image Deep Dive – Ben Parees, Red Hat &amp; Matt Moore, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AUx2e3BqBU8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0685klmja6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>kops介绍（任何技术水平）<br>kops Intro – Justin Santa Barbara, FathomDB (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9CwkpEVDNMM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0685glyjdz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Envoy深潜（中级技术水平）<br>Envoy Deep Dive – Matt Klein, Lyft (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=odRR94jhNbU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x06728hc9zj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>TUF/Notary深潜<br>TUF / Notary Deep Dive – David Lawrence, Docker &amp; Justin Cappos, NYU, TUF</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_WFLEtDCMxA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0685gh46xc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Rook深潜<br>Rook Deep Dive – Bassam Tabbara, Tony Allen &amp; Jared Watts, Upbound</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yknGKzJw7_k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q06858hwlca.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio多集群网格扩张BOF（任何技术水平）<br>Istio Multi-Cluster Mesh Expansion BOF - Sven Mawson, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_seY39zvgA4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0685evgd33.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes一致性深潜（中级技术水平）<br>Kubernetes Conformance Deep Dive – William Denniss, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LAGhshWmJAs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0686l081h8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>API机械SIG深潜（中级技术水平）<br>SIG API Machinery Deep Dive – Stefan Schimanski, Red Hat (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XsFH7OEIIvI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0686d4jsb8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>测试SIG深潜（中级技术水平）<br>SIG Testing Deep Dive – Sen Lu, Google &amp; Cole Wagner (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=M32NIHRKaOI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j06863zbtgj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SIG发布深潜（中级技术水平）<br>SIG Release Deep Dive – Jaice Singer DuMars &amp; Caleb Miles, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nJEzNLHsS1s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s068629suds.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>节点SIG深潜（中级技术水平）<br>SIG Node Deep Dive – Dawn Chen, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=I4AchBfe49U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06863a8xq0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>自动缩放SIG深潜（中级技术水平）<br>SIG Autoscaling Deep Dive – Marcin Wielgus, Google, &amp; Solly Ross, Red Hat (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=s2RKAYm9oJg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06698v9hdl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CoreDNS深潜（中级技术水平）<br>CoreDNS Deep Dive – Miek Gieben, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZnW3k6m5AY8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0686kr8bcc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>集群生命周期SIG：kubeadm深潜<br>SIG Cluster Lifecycle: kubeadm Deep Dive – Alexander Kanevskiy, Timothy St. Clair &amp; Luke Marsden</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3w5sZSxh4RI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0686fhcwll.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>多租户工作组深潜（中级技术水平）<br>Multi-Tenancy WG Deep Dive – David Oppenheimer, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Vi3ptlNjZJE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0686zkq1qx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：Kubernetes现场办公时间！<br>Panel: Kubernetes Office Hours Live! - Jorge Castro &amp; Ilya Dmitrichenko,</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=M4L1nBaGhXI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0686tjlz9p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CLI SIG深潜（中级技术水平）<br>SIG CLI Deep Dive - Phil Wittrock, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=M2n08jsRRYs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y06861uj32j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>无服务器API和计算的合流（中级技术水平）<br>Convergence of Serverless APIs &amp; Compute - Sarah Allen, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=c4ShcwgrKL4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r06864xxeeq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenWhisk：K8s构建生产就绪的无服务器堆栈<br>Apache OpenWhisk: Building a Production-Ready Serverless Stack on/for Kubernetes - David Grove</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uPohj7qoigY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x06868iptbv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上运行全球规模的FaaS<br>Operating a Global-Scale FaaS on Top of Kubernetes - Chad Arimura &amp; Matt Stephenson, Oracle</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SZL1N-2E3wI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c06862n1k4d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>无服务器和事件驱动的未来（中级技术水平）<br>The Serverless and Event-Driven Future - Austen Collins, Serverless (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TZPPjAv12KU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0686aca02f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>为跑在K8s上的普罗米修斯微服务应用喂养实战数据<br>Feeding Realworld Data into Prometheus Microservice Apps on Kubernetes - Burkhard Noltensmeier</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1rwBeDVdjyY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0686gw0bgj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯进行声明式的多集群监控<br>Declarative Multi-Cluster Monitoring with Prometheus - Matthias Loibl, Loodse &amp; Frederic Branczyk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=IpGfmmJ2hcw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0686ysmtez.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大规模的进行联邦普罗米修斯监测<br>Federated Prometheus Monitoring at Scale - Nandhakumar Venkatachalam &amp; LungChih Tung</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zm43VM7nKdU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0686z371ze.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Jsonnet打包仪表板、警报和出口商<br>Using Jsonnet to Package Together Dashboards, Alerts and Exporters - Tom Wilkie</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=b7-DtFfsL6E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0686kdoei2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>集成普罗米修斯和InfluxDB（中级技术水平）<br>Integrating Prometheus and InfluxDB - Paul Dix, InfluxData (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=6UjVX-RTFmo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06865pj54u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>除了OpenTracing（中级技术水平）<br>Beyond OpenTracing - Allison Richardet, Asteris, LLC (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5uGGgMn2iq4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0686mdlu8t.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Vitess和K8s Operator（中级技术水平）<br>Vitess and a Kubernetes Operator - Sugu Sougoumarane, YouTube (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=paOiIkASDjg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0686gdybg0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes基于政策的卷快照管理<br>Policy-Based Volume Snapshots Management in Kubernetes - Jing Xu, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_ZcooWc7Iyc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0686se0h2a.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s能够在任何地方运行，但是你的数据能吗？（初级技术水平）<br>Kubernetes Runs Anywhere, but Does your Data? - Jared Watts, Upbound (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Ot66g1WzXEU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0686q5ur11.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>容器存储接口：现在和未来<br>Container Storage Interface: Present and Future - Jie Yu, Mesosphere, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ktwY1anKN58" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0686fker2i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes本地存储提供扩展存储服务<br>Using Kubernetes Local Storage for Scale-Out Storage Services - Michelle Au &amp; Ian Chakeres</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eqkgiPppZN8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c06865uhz63.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes存储行话101（初级技术水平）<br>Kubernetes Storage Lingo 101 - Saad Ali, Google (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uSxlgK1bCuA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0686ipq9xk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：闭幕致辞<br>Keynote: Closing Remarks – Kelsey Hightower, Google &amp; Liz Rice, Aqua Security</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ehXiPfJR_3E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0686z0ud26.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：摸着石头过河<br>Keynote: Crossing the River by Feeling the Stones - Simon Wardley, Researcher, Leading Edge Forum</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=xlNYYy8pzB4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0686q6lvoc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：使用Kubernetes在生产环境缩放深度学习模型<br>Keynote: Scaling Deep Learning Models in Production Using Kubernetes - Sahil Dua</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gcij93d9st8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k068667okiw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：拿着剪刀奔跑<br>Keynote: Running with Scissors - Liz Rice, Technology Evangelist, Aqua Security</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ltrV-Qmh3oY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0686m0dwlo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes上运行Kubeflow ML<br>Keynote: Kubeflow ML on Kubernetes - David Aronchick &amp;  Vishnu Kannan</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=I6iMznIYwM8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0686n79lir.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>把云原生应用程序带到网络边缘<br>Bringing Cloud-Native Applications to the Edge of the Network - Megan O’Keefe &amp; Steve Louie</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UR8N6mIAFlM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s06863ir85m.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>gRPC简介（任何技术水平）<br>gRPC Intro – Jayant Kolhe &amp; Sree Kuchibhotla, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OZ_Qmklc4zE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0686p615rb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>gRPC深潜（中级技术水平）<br>gRPC Deep Dive – Sree Kuchibhotla &amp; Jayant Kolhe, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=S7WIYLcPS1Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0689ouj8do.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
<tr>
<td>Kubernetes自动化GPU的基础设施<br>Automating GPU Infrastructure for Kubernetes - Lucas Servén Marín, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=i6V4KPh_D5g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0689m999b6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Seldon和Kubeflow进行大规模ML模型服务<br>Serving ML Models at Scale with Seldon and Kubeflow - Clive Cox, Seldon.io</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=pDlapGtecbY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0689njxlyv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes轻松部署SQL流处理<br>Deploying SQL Stream Processing in Kubernetes with Ease - Andrew Stevenson &amp; Antonios Chalkiopoulos</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9TOoThIKafo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0689f075nm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>ksonnet、Ark和Sonobuoy征服Kubeflow<br>Conquering a Kubeflow Kubernetes Cluster with ksonnet, Ark, &amp; Sonobuoy - Kris Nova &amp; David Aronchick</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=givpqZ2IchI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0689vrh7s5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：混沌工程实践（中级技术水平）<br>Lightning Talk: Chaos Engineering In Practice - Paul Jones, Capgemini UK (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZnQA6o0jkUo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0689m45btt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：你为什么要真正重视K8S安全最佳实践<br>Lightning Talk: Why you Should Really Pay Attention to K8S Security Best Practices - Benjy Portnoy</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=DYDoGYWk_rk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0689rvmcs6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：kube-start-stop调度K8s资源的缩放<br>Lightning Talk: Schedule the Scaling of Your Kubernetes Resources Using kube-start-stop - Lili Cosic</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=KUzCCMLwEoU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0689op1qfb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：桌面GUI工具帮助你部署第一个Kubernetes<br>Lightning Talk: A Desktop GUI for your First Kubernetes Deployment - Alessandro Pilotti</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wfHUic14z20" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0689hznpek.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：Kubernetes正在火速成长（任何技术水平）<br>Lightning Talk: Kubernetes is Blowing Up - Ron Miller, TechCrunch (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VlL2c9eewIc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0689q251ue.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：使用服务发现缩放分布式深度学习<br>Lightning Talk: Scaling Distributed Deep Learning with Service Discovery - Yong Tang</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WBAP91g7Yd0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0689fjasaa.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：在OpenStack的云供应商环境运行K8s的提示<br>Lightning Talk: Tips for Operating Kubernetes with OpenStack Cloud Provider - Yang Yu &amp; Yifeng Xiao</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=q0noZh5_HEY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0689g5msvo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：使用gRPC扩展Kubernetes<br>Lightning Talk: Extending Kubernetes with gRPC - Vladimir Vivien, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JTzJPko5Shc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0689fybcbg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：TSDB：普罗米修斯背后的引擎<br>Lightning Talk: TSDB: The Engine behind Prometheus - Goutham Veeramachaneni, IIT Hyderabad</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_529xDFDzI0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y06895n9lqa.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：跑在Kubernetes上FaaS的现状<br>Lightning Talk: The State Of FaaS on Kubernetes - Michael Hausenblas, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=w4msKFfGZlQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0689c7zrph.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：kube-rbac-proxy（任何技术水平）<br>Lightning Talk: I Got your RBAC - kube-rbac-proxy - Frederic Branczyk, CoreOS (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LSJpzks0elc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j06897tdmwf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>闪电讲座：不一刀切，如何调整Kubernetes集群大小<br>Lightning Talk: Not One Size Fits All, How to Size Kubernetes Clusters - Jeff Sloyer, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZzFjPqCibMc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0690mcdl1c.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大规模容器隔离（介绍gVisor）<br>Container Isolation at Scale (Introducing gVisor) - Dawn Chen &amp; Zhengyu He, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=pWyJahTWa4I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0690uerx6n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：塑造云原生的未来<br>Keynote: Shaping the Cloud Native Future - Abby Kearns, Executive Director, Cloud Foundry Foundation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_e8hi57hw40" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e069036u8cy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在无服务器世界组合函数<br>Function Composition in a Serverless World - Erwin van Eyk &amp; Timirah James, Platform9</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4_Szfs7eBnk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0690c9gpv8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Habitat Builder：云原生应用程序自动化<br>Habitat Builder: Cloud Native Application Automation - Elliott Davis &amp; Fletcher Nichol, Chef.io</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5idV8kbyN8M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0690u9rzz1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes和税收：在挪威税务总局所学到的<br>Kubernetes and Taxes: Lessons Learned at the Norwegian Tax Administration - Bjarte S. Karlsen</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VZbDJXUwLbg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0690v4grcp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混沌工程工作组简介（任何技术水平）<br>Chaos Engineering WG Intro – Sylvain Hellegouarch, ChaosIQ (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nfY7BM9KO0g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0690bs6ns8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CRI：容器运行环境的二次繁荣<br>CRI: The Second Boom of Container Runtimes - Harry Zhang &amp; Xu Wang, HyperHQ</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gVqa1cNIZT0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0690npm2nm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕 🔴</td>
</tr>
<tr>
<td>当我已经有了Cloud Foundry为什么需要K8s？<br>Why Do I Need Kubernetes When I Already Have Cloud Foundry? - Sanjay Patil, SAP</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=KvfYtca74EI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0690bewp1u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>我们如何使用Kubernetes编排每月7M+的构建<br>How we Orchestrate 7M+ Builds/Month with Kubernetes - Danielle Tomlinson</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=b8NQO_vFAYo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0690mkt706.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>containerd简介（任何技术水平）<br>containerd Intro – Stephen Day, Docker (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=I0xU6nxnZLY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0690uhwt2f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕 🔴</td>
</tr>
<tr>
<td>你有没有想过为什么我们在这里？（初级技术水平）<br>You Ever Wonder Why We’re Here? - Sarah Christoff, Cloudreach (Beginner Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZHYFDV3XKQ4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0690zi8oo5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Telepresence在K8s享受无缝开发环境<br>Seamless Development Environments on Kubernetes using Telepresence - Ara Pulido</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8Dl8U-AbJN0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0690qonwv8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Grafeas社区聚会BOF（任何技术水平）<br>Grafeas Community Meetup BOF - Wendy Dembowski, Google (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Rmpu6HEKTJA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0690cfay4h.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在企业中建设云原生文化<br>Building a Cloud Native Culture in an Enterprise - Deep Kapadia &amp; Tony Li</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Tm4VfJtOHt8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u069017fwtn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>缩放指导非传统贡献者的举措<br>Scaling Non-Traditional Contributor Mentoring Initiatives - Paris Pittman, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7-uqMbBd15k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0690sjqocr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kata容器：参与Kata社区<br>Kata Containers: Getting Involved with the Kata Community - Anne Bertucio &amp; Samuel Ortiz</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=bUOIJBUPPck" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0690qyfgpa.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>小组讨论：容器在企业云战略的角色<br>Panel Discussion: Containers in Enterprise Cloud Strategy - Moderated by Anni Lai, Huawei</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JXomJ5n3JAU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0690qa2dny.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从数据中心到云原生<br>From Data Centers to Cloud Native - Dave Zolotusky &amp; James Wen, Spotify</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dpJAE3k04hc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0690ld561b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>一个参与k8s发布过程新人的洞察<br>Insights From a k8s Newcomer Working Within the Release Process - Tim Pepper</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=goAph8A20gQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x06908pftyy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>用containerd的Snapshotters控制文件系统<br>Take Control of your Filesystems with containerd’s Snapshotters - Stephen Day, Docker, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ebynv9XxrLk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0690f4ht9z.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>AWS/kops深潜/黑客会议<br>AWS / kops Deep Dive / Hacking Session – Justin Santa Barbara, FathomDB</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=HCESuFSSTb8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0690gnj6om.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>应用SIG深潜（中级技术水平）<br>SIG Apps Deep Dive – Janet Kuo &amp; Kenneth Owens, Google (Intermediate Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nN3MuZ6_WsA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0690954gcx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>无服务器工作组BoF（任何技术水平）<br>Serverless WG BoF - Doug Davis, IBM (Any Skill Level)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nMKITmMWP9U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0681uw6lnv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：闭幕致辞<br>Keynote: Closing Remarks - Liz Rice, Technology Evangelist, Aqua Security</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cpwnB9TbRiQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0690wbem62.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过Kubernetes接入控制器应用最小特权<br>Applying Least Privileges through Kubernetes Admission Controllers - Benjy Portnoy, Aqua Security</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7mgBxr4D-xs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h06909rwtdy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通过Kubernetes对象保护无服务器功能<br>Securing Serverless Functions via Kubernetes Objects - Sebastien Goasguen, Bitnami</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qs0909rJUt8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0694tajnhl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Grafeas和in-toto完全保护软件供应链<br>Completely Securing the Software Supply Chain using Grafeas + in-toto - Lukas Puehringer</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=05zN-YQxEAM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0694p44p4l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Understand and Troubleshoot the “Magic” of Kubernetes Networking - Minhan Xia &amp; Rohit Ramkumar-knIJEzTd3kc</td>
<td style="text-align:center"><a href="#TODO">Video</a></td>
<td style="text-align:center"><a href="TODO">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
</tbody>
</table>
<h2 id="CloudNativeCon-KubeCon-2017-Berlin"><a href="#CloudNativeCon-KubeCon-2017-Berlin" class="headerlink" title="CloudNativeCon + KubeCon 2017 - Berlin"></a><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2PAavlbv0iZkod4IVh_iGqV" target="_blank" rel="external">CloudNativeCon + KubeCon 2017 - Berlin</a></h2><table>
<thead>
<tr>
<th>Topic</th>
<th style="text-align:center">YouTube</th>
<th style="text-align:center">Tencent</th>
<th style="text-align:center">🌕 ⚫ 🔴 🔵 ⚪</th>
</tr>
</thead>
<tbody>
<tr>
<td>会前致欢迎词<br>Pre-Conference Welcome Remarks - Michelle Noorali, Deis and 2017 Program Co-Chair</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FYCYtAaU9Xw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07265krf3x.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：Fluentd项目更新<br>Keynote: Fluentd Project Update - Eduardo Silva, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qQgBPqY7K9k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0726wdum5i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：OpenTracing项目更新<br>Keynote: OpenTracing Project Update - Priyanka Sharma, LightStep</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=H9ZHXzfbUWY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0726yg8gff.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Linkerd项目更新<br>Keynote: Linkerd Project Update - Oliver Gould, Buoyant</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3I30__0-H30" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0726q23qdm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：gRPC项目更新<br>Keynote: gRPC Project Update - Varun Talwar, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QpqDlL4x9U8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e072623fond.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：CoreDNS项目更新<br>Keynote: CoreDNS Project Update - Miek Gieben, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dN4klmE7JNI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0726gijkig.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题讨论：移动到现代化的基础设施<br>Keynote Panel: Moving to the Modern Infrastructure - moderated by Michelle Noorali</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Cfg48kS1hz4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g07269etkn9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>快闪讲座：Kubernetes简介<br>Lightning Talk: Kubes 4 Nubes - Tom Brown, OpenAI</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GGyq6-h8_VI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0726q7rlly.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>快闪讲座：Kubernetes前5用来监控的指标<br>Lightning Talk: The Top 5 Kubernetes Metrics to Monitor - Jorge Salamero Sanz, Sysdig</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dgkUVggy4ec" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x07261jdjs4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>快闪讲座：使用AppController加强Helm<br>Lightning Talk: Boosting Helm with AppController - Maciej Kwiek, Mirantis Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7TjsBBnvHMM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y07265rit7b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>快闪讲座：在Kubernetes的BGP路由<br>Lightning Talk: BGP Routing in Kubernetes - Pankaj Sehgal, Tata Consultancy Services</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jHe1qANS_2I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0726ecoxvy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>快闪讲座：在电信环境中使用云原生<br>Lightning Talk: Using Cloud-Native in Telco-Environments - Marcus Brunner, Swisscom</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=iadqRlLyEJw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0726atmnxw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>快闪讲座：僵尸Kubernetes！使节点复活<br>Lightning Talk: Zombie Kubernetes!: Making Nodes Rise From The Dead - Michael Johnston</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gXB5Stkn7iQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0726n4rikd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>快闪讲座：使用Fluentd和K8s作灵活的日志记录管道<br>Lightning Talk: Flexible Logging Pipelines with Fluentd and Kubernetes - Jakob Karalus, codecentric</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FABYwvizXOQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0726ln5eg5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>快闪讲座：云原生设计模式<br>Lightning Talk: Cloud Native Design Patterns - Bilgin Ibryam, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=L_XP_G3wVbU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0726cbfvt7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>主题演讲：开场致辞<br>Keynote: Opening Remarks - Dan Kohn, Executive Director, Cloud Native Computing Foundation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ejkCc7zAfo4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0726juqhot.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes仍是困难（对开发者）<br>Keynote: Kubernetes is Still Hard (for Developers) - Michelle Noorali, Software Engineer, Deis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=aOQwyN0bTk4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0726ybio22.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：飞利浦色相灯泡是开通过Kubernetes打开的<br>Keynote: Your Philips Hue Light Bulbs Are Turned On By Kubernetes - Mark van Straten</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lLBdC40qby4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0726w416wh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：使用CoreOS Quay轻松部署复杂的应用<br>Keynote: The Kubernetes Application Registry: Easily Deploying Complex Applications with CoreOS Quay</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lp05rkUJKOY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0726ra1dht.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes作为后台<br>Keynote: Backstage with Kubernetes - Chen Goldberg, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FccAGOZqInk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0726kil9bk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：普罗米修斯：从柏林到成功<br>Keynote: Prometheus: From Berlin to Bonanza - Brian Brazil, CEO, Robust Perception</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uV_sh7_lVw8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0726902q4r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：323日环游（云原生）世界<br>Keynote: Around the (Cloud Native) World in 323 Days - Andy Randall, CEO, Tigera</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-hYYA1OyfZs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0726nusjlu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：构建基础架构赋能未来的AI<br>Keynote: Building the Infrastructure that Powers the Future of AI - Vicki Cheung &amp; Jonas Schneider</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=v4N3Krzb8Eg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0726e0i9lb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：红帽推动Kubernetes/容器安全前进<br>Keynote: Red Hat is Driving Kubernetes/Container Security Forward - Clayton Coleman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9DliJjhhZuc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0726l73p5d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes1.6和开源路线图<br>Keynote: Kubernetes1.6 and the Open Source Roadmap - Aparna Sinha</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OIsCwc7qfTU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07267eqngt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Introduction to rkt介绍<br>Introduction to rkt - Brandon Philips, CTO, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JgUEXKTSVXw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v072737pkwd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Containerd介绍<br>Introduction to Containerd - Patrick Chanezon, Member of Technical Staff, Docker, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9xiMrJOmqb8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0727aju2je.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：什么是云原生，我为什么要在乎？<br>Keynote: What is Cloud Native and Why Should I Care? - Alexis Richardson, CEO of Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TKYAI19OE-c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0727c3lrxb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：在企业的云原生：生产、最佳实践和创新<br>Keynote: Cloud Native in the Enterprise: Production, Best Practice and Innovation - Dr. Ying Xiong</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2mMnAp8nCoA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0727unaw01.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：缩放K8s：我们怎样成长10倍的用户群？<br>Keynote: Scaling Kubernetes: How do we grow the <em>Kubernetes</em> user base by 10x? - Joe Beda</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4iAYIhD2mKM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0727k2octt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes联邦<br>Keynote: Kubernetes Federation - Kelsey Hightower, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kwOvOLnFYck" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g07278kdzkq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>缩放Kubernetes支持50000个服务<br>Scale Kubernetes to Support 50,000 Services [I] - Haibin Xie &amp; Quinton Hoole</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4-pawkiazEg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07274m9pjl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>编写自定义控制器：扩展群集的功能<br>Writing a Custom Controller: Extending the Functionality of Your Cluster [I] - Aaron Levy</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_BuqPMlXfpE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i07270muse4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>Kubernetes集群联邦：如何编写联合控制器<br>Kubernetes Cluster Federation: How to Write a Federated Controller? [A] - Madhu C.S.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yIZ-tmPrLFE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0727nk8g8s.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>将Kubernetes引入Salesforce<br>Bringing Kubernetes into Salesforce [B] - Steve Sandke, Salesforce</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=D7TjzmzvPco" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0727tvhhfb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用kubeadm自动缩放多平台Kubernetes集群<br>Autoscaling a Multi-Platform Kubernetes Cluster Built with kubeadm [I] - Lucas Käldström</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZdzKQwMjg2w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0727hatb4n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云计算可以从神经科学学会什么：大脑如何建筑“云应用”<br>What Cloud Computing Can Learn from Neuroscience: How the Brain Architects ‘Cloud Applications’</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=sGW64SO-o_c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0727smhzcq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>网络包在Kubernetes的生命<br>Life of a Packet [I] - Michael Rubin, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0Omvgd7Hg1I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0727o7vofx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>与关键应用前往、并通过我们的第一个黑色星期五<br>Getting To, and Through, Our First Black Friday with Critical Apps [I] - Arnaldo Pereira</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FUPHU0O6y4g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0727snfd0h.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Go SDK编程Kubernetes<br>Programming Kubernetes with the Go SDK [I] - Aaron Schlesinger, Deis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qiB4RxCDC8o" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0727gxomwh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>康拉德电子案例研究 - 从静态基础架构到持续交付和云<br>Case Study Conrad Electronic – From a Static Infrastructure to Continuous Delivery and the Cloud</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hsxlkpJ0-14" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e07270wg8s3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生转型：Ticketmaster如何改变文化和加速<br>Cloud Native Transformation: How Ticketmaster is Changing Culture and Speeding Up - Bindi Belanger</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Y60O_ndnsyk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0727606r0b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>负载测试Kubernetes：生产环境如何优化集群资源配置<br>Load Testing Kubernetes: How to Optimize Your Cluster Resource Allocation in Production [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_l8yIqMpWT0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p07273ehleg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8SNIff - 直到Pod的端至端加密<br>K8SNIff - End-to-End Encryption Till the Pod [A] - Sebastian Scheele &amp; Jason Murray, Loodse GmbH</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3nNIyaJ1gBs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0727gm3dxj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>思科的Devnet使用云原生：转化到云原生的案例研究<br>Cisco’s Devnet Goes Cloud Native: A Case Study on Transforming to Cloud Native [I] - Matt Johnson</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YcehNLj6lXo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p07272ersar.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>深入Helm：先进的DevOps<br>Delve into Helm: Advanced DevOps [I] - Lachlan Evenson &amp; Adam Reese, Deis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cZ1S2Gp47ng" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0727sxl7nc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Fission：Kubernetes上的无服务器功能框架<br>Fission: a Serverless Function Framework on Kubernetes [B] - Soam Vasani, Platform9 Systems, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9hiOn9YJzFw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0727ey0h0d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubeless在Kubernetes上作无服务器<br>Serverless on Kubernetes with Kubeless [A] - Sebastien Goasguen, Bitnami &amp; Nguyen Anh-Tu, Skippbox</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1QZ6x_8h8qY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0727kvqfib.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s上构建使用GPU和CPU的分布式TensorFlow<br>Building Distributed TensorFlow Using Both GPU and CPU on Kubernetes [I] - Zeyu Zheng</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yFXNASK0cPk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0727tqhzww.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Sched.net：具备网络意识的Kubernetes调度器<br>Sched.net: A Network-Aware Kubernetes Scheduler [I] - Akash Gangil &amp; Salvatore Orlando, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WWJ7AeEiaqc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0728lgnmbf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CRI的成功：把基于hypervisor的容器带到K8s<br>Success of CRI: Bringing Hypervisor Based Container to Kubernetes [I] - Lei Zhang, HyperHQ</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=phN1Ru0aDa4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0728ar1vl3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>大象在自动化：使用Helm部署PostgreSQL的HA群集<br>Elephants on Automatic: HA Clustered PostgreSQL with Helm [I] - Josh Berkus &amp; Oleksii Kliukin</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=CftcVhFMGSY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0728pylar8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubeception盗梦空间：我们如何在K8s运行K8s<br>How We Run Kubernetes in Kubernetes, aka Kubeception [I] - Timo Derstappen, Giant Swarm</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Nq5uIIT5mOw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0728mk8lah.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes第2天：群集操作<br>Kubernetes Day 2: Cluster Operations [I] - Brandon Philips, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=U1zR0eDQRYQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0728fcm1yh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>机器崛起的近况<br>Rise of the Machines [B] - Anne Currie, Microscaling Systems</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3Aa5S2_rOcs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0728btv09i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯集成长期存储<br>Integrating Long-Term Storage with Prometheus [A] - Julius Volz, Prometheus</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MuHkckZg5L0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r07285mldb3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从外部负载平衡转到consul和ingress<br>Switching From External Load Balancing to consul &amp; ingress [I] - Dan Wilson, Concur</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gsf__yuWCF8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0728qd4k4y.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>IPVS有利于规模的私有云负载平衡<br>IPVS for Scaled Private Cloud Load Balancing [I] - Kimberly Messimer, Comcast VIPER</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=KJ-A8LYriGI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0728q1ecfq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kubernetes定义的监控<br>Kubernetes-Defined Monitoring [I] - Gianluca Borello, Sysdig</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ncSn3_9bfIQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0728n2rs3d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在裸机上的高可用Kubernetes<br>High Availability Kubernetes on Bare Metal [A] - Muhammad Kamran Azeem &amp; Henrik Høegh, Praqma</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ojZT1sKCGQs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0728hb5wy7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>独立于网络的访问控制列表：为什么安全不应取决于你的网络<br>Network-independent ACLs: Why Security Shouldn’t Depend on Your Network [I] - Bernard Van De Walle</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wm7rj2zhXM0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0728henc5f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>建立信任：如何保护您的Kubernetes集群<br>Building for Trust: How to Secure Your Kubernetes Cluster [I] - Alexander Mohr &amp; Jess Frazelle</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YRR-kZub0cA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f07287hz4sn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>分布式日志和容器的使用模式<br>The Patterns of Distributed Logging and Containers [I] - Satoshi Tagomori, Treasure Data, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TIg9Yi2eGqM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0728w2wbk6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Groovy，我的应用管道有Docker<br>Groovy, There’s a Docker in My Application Pipeline [B] - Kris Buytaert, Inuits</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zlmVGmpt_Po" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r07285k3aw2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Habitat简化容器运维<br>Simplifying Container Operations with Habitat [B] - Michael Ducy, Chef</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=bpt-JHEkVs8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07435l2kx7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>我们如何构建Twitter的计算平台激励更高的资源利用率<br>How We Built a Chargeback System for Twitter’s Compute Platform (Mesos/Aurora)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5D3IKZTCG48" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0743x1qy64.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>不安全的容器？持续防御开源漏洞<br>Insecure Containers? Continuous Defense Against Open Source Exploits [A] - Andrew Martin</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MP09j2RdgPE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a074372orov.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Containerd：通用的容器运行引擎<br>Containerd: The Universal Container Runtime [I] - Justin Cormack, Docker</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cfhnioURGdE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0743knqs7f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Lastminute.com机房的故事：内部完全部署K8s<br>Tales from Lastminute.com Machine Room: Our Journey Towards a Full On-Premise Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=iShh33WaoHw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0743ni1rjl.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：OCI和容器标准化的未来<br>Panel: The Open Container Initiative (OCI) and the Future of Container Standardization [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Tev5NMr0hxU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0743dps8yf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生策略：从古希腊到容器编排<br>Cloud Native Strategy - From Ancient Greece to Container Orchestration</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=c2I77fERJqI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0743j63blj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：在云原生平台利用开放服务代理API<br>Panel: Leveraging the Open Service Broker API in Cloud Native Platforms [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Bt0pxicf7_A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e07431n4fc4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes缩放机构<br>Scaling Organizations Using Kubernetes [I] - Richard Fliam, Comcast VIPER</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-EFkL9JmbL0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0743gdc770.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes赋能公共基础设施<br>Powering Public Infrastructure with Kubernetes [B] - Jan Willies, Accenture</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RBUtNSXRHG4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0743qgmz74.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>GoEuro从开发到正式采用Kubernetes<br>Kubernetes from Dev to Prod at GoEuro [I] - Subhas Dandapani, GoEuro</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kLTqcM_FTCw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0743wjozm0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给每个拉入请求一个临时环境：打造自己的控制器！<br>A Staging Environment Per Pull Request: Building Our Own Controller! [B] - Kamal Marhubi, Heap</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AX9ms2kmaJ0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0743knspmk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s：在Windows上开发，在Linux上部署<br>Kubernetes: Developing on Windows, Deploying on Linux [B] - Rodrigue Cloutier, Ubisoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=CWxYKernSBI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f07433kz4n1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>只许成功：Monzo使用K8s和Linkerd处理真金白银<br>When Failure is Not an Option: Processing Real Money at Monzo with Kubernetes and Linkerd [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wBgBwNZo_EE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0743b96om2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes运行工作负载<br>Running Workloads in Kubernetes [B] - Janet Kuo, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=spHPCc82ACs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n07439vov2p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s Operators：使用软件管理复杂软件<br>Kubernetes Operators: Managing Complex Software with Software [I] - Josh Wood &amp; Jesus Carrillo</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cj5uk1uje_Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0743jm44a6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Steward：Kubernetes原生的服务代理<br>Steward, the Kubernetes-Native Service Broker [A] - Gabe Monroy, Deis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PNPVDKrbgsE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0743slujgo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>DigitalOcean的K8s：构建下一代平台<br>Kubernetes at DigitalOcean: Building a Platform for the Future [B] - Joonas Bergius, DigitalOcean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Jhfd5FjYimU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q07435pruy1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>谷歌云如何大规模托管和管理Kubernetes<br>How Google Cloud Hosts and Manages Kubernetes at Scale [I] - David Aronchick, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NVUJ6jbiX1M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0743z7h11e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes搭配LXD/LXC<br>Leverage LXD/LXC with Kubernetes [A] - Lin Sun, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=DXnrOgPt1Cs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0743y8vd9h.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>KubeVirt：K8s、虚拟化和你的未来的数据中心<br>KubeVirt - Kubernetes, Virtualization and Your Future Data Center [I] - Itamar Heim &amp; Fabian Deutsch</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=0dob7KsJizg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07436qj4lg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Grafana是不够的：给普罗米修斯DIY用户界面<br>Grafana is Not Enough: DIY User Interfaces for Prometheus [I] - David Kaltschmidt, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=bfSMDERvkZY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0743y2yavs.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>理解和扩展普罗米修斯AlertManager<br>Understanding and Extending Prometheus AlertManager [I] - Lee Calcote, SolarWinds</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jpb6fLQOgn4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0745baq6vf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生环境的警报<br>Alerting in Cloud Native Environments [I] - Fabian Reinartz, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cR9Fp6hwTLE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0745yywo7u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>二进制协议：现状<br>Binary Protocols - The Current State of Affairs [I] - Jason Smith, Container Solutions</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dAx8bDQjOrU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0745go3d7j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯计数<br>Counting with Prometheus [I] - Brian Brazil, Robust Perception</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=67Ulrq6DxwA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0745rkcb3l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Alertmanager走在高可用性的道路上<br>Alertmanager on Its Way to High Availability [A] - Frederic Branczyk, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XQdEVY2l2e0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0745ovhtiy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenTracing和容器：深度、广度和跟踪的未来<br>OpenTracing and Containers: Depth, Breadth, and the Future of Tracing [I] - Priyanka Sharma</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=CUjTw7k_0RQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0745zystd6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从跟踪分布式微服务洞察运营和业务状况<br>Operational and Business Insights from Tracing Distributed Microservices [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=dmMWaTZE5gQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0745bia35j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Loki：一个Go编写开源的Zipkin和普罗米修斯的混搭<br>Loki: An OpenSource Zipkin / Prometheus Mashup, Written in Go [I] - Tom Wilkie, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Bmzx-5uExPM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07456nrhjd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>OpenTracing不仅仅是跟踪：测量两次，仪器测试一次<br>OpenTracing Isn’t Just Tracing: Measure Twice, Instrument Once [B] - Priyanka Sharma &amp; Ted Young</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NyySNe6Rr_g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0745cgf4na.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>360°监测你的服务<br>360° Monitoring of Your Services [I] - Philipp Krenn, Elastic</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4TLJOc1EeI8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0745kwqne0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>系统调用的五十种色调<br>50 Shades of System Calls [I] - Jorge Salamero Sanz, Sysdig</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=b_bVPtZl2Ic" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0745i2d1pm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在云原生架构超级快速的实时数据处理<br>Super Fast Real-time Data Processing on Cloud-Native Architecture [I] - Yaron Haviv, iguazio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ujuWt6mvIig" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z07453yldlw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在7个星期从Heroku到云原生<br>From Heroku to Cloud Native in 7 Weeks [B] - Ivan Pedrazas, Soho House</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uuh69fMqnko" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0748qdphxe.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>构建云原生的SQL数据库<br>Building a Cloud-Native SQL Database [I] - Alex Robinson, Cockroach Labs</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=rNXcvZCo448" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0748jx841o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Go + 微服务 = Go套件<br>Go + Microservices = Go Kit [I] - Peter Bourgon, Go Kit</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NX0sHF8ZZgw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0748e5s9re.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>大规模地管理微服务的生命周期<br>Managing Lifecycle of Microservices at Scale [I] - Micheal Benedict, Pinterest</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LZkp-4piI3I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0748uxbh52.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从静态的基础设施迁移，同时保持持续交付学到的经验教训<br>Lessons Learned From Maintaining Continuous Delivery While Migrating From a Static Infrastructure</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UJneVIAv9rc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o074864tclh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes做审计：现在和未来<br>Audit in Kubernetes Now, and in the Future [B] - Maciej Szulik, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4SXjS69X8pg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q074868cuyo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes构建存储集群<br>Building a Storage Cluster with Kubernetes [I] - Bassam Tabbara, Quantum Corp.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=6p0GKjrYzg4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x07483793bq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在火山口与安全发布过程疯狂地跳舞<br>Dance Madly on the Lip of a Volcano with Security Release Processes [I] - Jess Frazelle &amp; Brandon Philips</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=sNjylW8FV9A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0748nn1vgb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的自动缩放<br>Autoscaling in Kubernetes [I] - Marcin Wielgus, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=m3Ma3G14dJ0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0748ef6d1x.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>开放服务代理API和Kubernetes服务目录<br>The Open Service Broker API and the Kubernetes Service Catalog [B] - Paul Morie &amp; Chip Childers</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=p35hOAAsxrQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0748sc9jic.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes调度功能，或如何使系统做我想做的？<br>Kubernetes Scheduling Features or How Can I Make the System Do What I Want? [I] - Marek Grabowski</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=bbPcb2JuJPw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t07486ojlgt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>铁幕背后：从浏览器获取度量到普罗米修斯<br>Behind the Iron Curtain: Getting Metrics From the Browser into Prometheus [I] - Tom Wilkie</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5S-0bJAtpMc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l07480bib20.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给开发者的运维：使用普罗米修斯监控您的Java应用程序<br>Ops for Developers - Monitor Your Java Application with Prometheus [I] - Alexander Schwartz</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zgka3GFjqjA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c074872yg5r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>监测我的套接：在多语言的开源微服务使用普罗米修斯<br>Monitor My Socks: Using Prometheus in a Polyglot Open Source Microservices</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=U_nQObcAxSk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0748cs9a2d.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯高性能配置<br>Configuring Prometheus for High Performance [A] - Björn Rabenstein, SoundCloud Ltd.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hPC60ldCGm8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0748ks3mua.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯：无名英雄<br>Prometheus: The Unsung Heroes [I] - Alejandro Ramirez, Swisscom Directories AG</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lo0Y1QyGh0k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0748cds9dh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给Kubernetes重建您的团队<br>Reworking Your Team for Kubernetes [B] - Hans Kieserman, Yahoo</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=a6xboDAOIMk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0748hfgslg.html" target="_blank" rel="external">视频</a></td>
</tr>
</tbody>
</table>
<h2 id="KubeCon-CloudNativeCon-2017-Austin"><a href="#KubeCon-CloudNativeCon-2017-Austin" class="headerlink" title="KubeCon + CloudNativeCon 2017 - Austin"></a><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2P-3-xqvmWaZbbI1sW-ulZb" target="_blank" rel="external">KubeCon + CloudNativeCon 2017 - Austin</a></h2><table>
<thead>
<tr>
<th>Topic</th>
<th style="text-align:center">YouTube</th>
<th style="text-align:center">Tencent</th>
<th style="text-align:center">🌕 ⚫ 🔴 🔵 ⚪</th>
</tr>
</thead>
<tbody>
<tr>
<td>主题演讲：建设者的社区：CloudNativeCon开幕致辞<br>Keynote: A Community of Builders: CloudNativeCon Opening Keynote - Dan Kohn</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Z3aBWkNXnhw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0711cq3zmg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：CNCF项目更新<br>Keynote: CNCF Project Updates - Michelle Noorali, Senior Software Engineer, Microsoft Azure</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zPOlDe-J9ZA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0711gxgwwx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kata容器介绍<br>Keynote: Introducing Kata Containers - Imad Sousou, VP, Intel Corporation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=pqoDF4QCRy8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0711y9s7cf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：云原生持续交付：Spinnaker和科技背后的文化<br>Keynote: Cloud Native CD: Spinnaker and the Culture Behind the Tech - Dianne Marsh, Netflix</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=mfFtfaulCtg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0711fyenhd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：在AWS的云原生<br>Keynote: Cloud Native at AWS - Adrian Cockcroft, Amazon Web Services</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5U-6sxR5DaQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0711a32ov1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：服务网格和观测<br>Keynote: Service Meshes and Observability - Ben Sigelman, Co-founder &amp; CEO, Lightstep</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RGT5XHH_Gis" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0711ex3qe0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：可以有1亿个开发者使用Kubernetes吗？<br>Keynote: Can 100 Million Developers Use Kubernetes? - Alexis Richardson, CEO, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=21l8v6eObcc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0711z7cx8r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>2017社区奖<br>Community Awards</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=DllNMIY4HzU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r07116v7ego.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：K8s这工作太辛苦：构建新工具、模式与范式来民主化<br>Keynote: Kubernetes: This Job is Too Hard: Building New Tools, Patterns and Paradigms to Democratize</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gCQfFXSHSxw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m07113gy3qy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：Kubernetes、云原生和公共云<br>Panel: Kubernetes, Cloud Native and the Public Cloud [B] - Moderated by Dan Kohn</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=aYOqB3QUILY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0711vna9jp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio：编织服务网格<br>Istio: Weaving the Service Mesh [I] - Shriram Rajagopalan, IBM &amp; Louis Ryan, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WFEllbmRI8U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0711o5z1nf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Box使用Kubernetes持续交付<br>Continuous Delivery with Kubernetes at Box [I] - Greg Lyons, Box</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WQJ61CVthBM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c07110i6q9s.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>微服务、服务网格和CI/CD管道：使各项一起工作<br>Microservices, Service Mesh, and CI/CD Pipelines: Making It All Work Together [I] - Brian Redmond</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UbLG_qUyCgM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0711sccu9n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Netflix如何解决跨云授权<br>How Netflix Is Solving Authorization Across Their Cloud [I] - Manish Mehta &amp; Torin Sandall, Netflix</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=R6tUNpRpdnY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0711b59k8u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>好的、坏的和丑的：迁移数以百计的旧应用程序到K8s<br>The Good, the Bad &amp; the Ugly of Migrating Hundreds of Legacy Applications to Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yB6Zl8nqqqE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a07117m8udz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>容器运行环境和镜像格式标准 - “OCI-认证”这意味着什么<br>Container Runtime and Image Format Standards - What it Means to be “OCI-Certified” [I] - Jeff Borek</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-BfhZiJzLeA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0711qod6si.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕⚫</td>
</tr>
<tr>
<td>嵌入Containerd运行环境获得乐趣和利润<br>Embedding the Containerd Runtime for Fun and Profit [I] - Phil Estes, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Z4ZMhEhrL-4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0711uqpk6y.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kata容器：基于虚拟机管理程序的容器运行环境<br>Kata Containers: Hypervisor-Based Container Runtime - Xu Wang, HyperHQ &amp; Samuel Ortiz, Intel</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VupUc88FV9Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0711mebltg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CRI-O：提供K8s运行容器时所有需求，仅此而已<br>CRI-O: All the Runtime Kubernetes Needs, and Nothing More - Mrunal Patel, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NVa8xR4Eyj8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0711ppi3ac.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
<tr>
<td>使用Moby建立专门的容器系统：一些用例<br>Building Specialized Container-Based Systems with Moby: A Few Use Cases [I] - Patrick Chanezon</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kDp22YkD6WY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0711uit3ne.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>当你遇到困难，找TUF去！<br>When the Going Gets Tough, Get TUF Going! [I] - David Lawrence &amp; Ashwini Oruganti, Docker</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JfAil-15YJw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0711tf109j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>打造更好容器：容器生成工具的调查<br>Building Better Containers: A Survey of Container Build Tools [I] - Michael Ducy, Chef</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5D_SqLv92V8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c07118uc5qw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>如果你不监控您的基础架构，你不拥有它！夺回控制多谢普罗米修斯<br>“If you Don’t Monitor your Infrastructure, you Don’t Own it!” Regain Control Thanks to Prometheus</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MNc3046o-Og" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0711ecsu8b.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Fluentd和分布式日志<br>Fluentd and Distributed Logging [I] - Masahiro Nakagawa, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XZMGCQ96C80" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m07113a1s5i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>RED（请求率、错误和持续时间）方法：如何检测你的服务<br>The RED Method: How To Instrument Your Services [B] - Tom Wilkie, Kausal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TJLpYXbnfQ4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0711knbfnd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你想监控时也得到一些跟踪？<br>Would You Like Some Tracing With Your Monitoring? - Yuri Shkuro, Uber Technologies</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1NDq86kbvbU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0711iblkkv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Elastic获得全栈可视性：日志、度量和跟踪<br>Full Stack Visibility with Elastic: Logs, Metrics and Traces - Carlos Pérez-Aradros, Elastic</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SzX5tTY-vPM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q07118sox7f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>容器和微服务的统一监控<br>Unified Monitoring of Containers and Microservices [I] - Nishant Sahay, Wipro Limited</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YBVipwfH5cQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0711qxfx3n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>应用程序意向分析有利容器安全<br>The Power of Application Intent Analysis for Container Security [I] - John Morello, Twistlock</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eHpO2cI-aOM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0711ah09k7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>SPIFFE介绍：云原生环境中对身份的开放标准<br>Introducing SPIFFE: An Open Standard for Identity in Cloud Native Environments [I] - Evan Gilman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ikmxZdZRTio" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t07113umnwq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混合云的IAM：下一代安全模型来创建可互操作的云<br>IAM on Hybrid Cloud: Next Generation Security Model to Create an Interoperable Cloud [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nXcXssv1rUs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0711hjbe7i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>建立安全、多协议和多租户面向Internet服务的集群<br>Building a Secure, Multi-Protocol and Multi-Tenant Cluster for Internet-Facing Services [A]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tFdcrncaxD4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0711q4ipux.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大规模建立可信赖容器<br>Establishing Container Trust at Scale [I] - Tim Mackey, Black Duck Software</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uB20VT5UclI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0711yvjufm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>我们在推特如何构建框架解决服务所有权和提高基础设施利用率<br>How We Built a Framework at Twitter to Solve Service Ownership &amp; Improve Infrastructure Utilization</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=C6Tv8brYGwo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0711eny7tf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Lyft是如何部署Envoy<br>The Mechanics of Deploying Envoy at Lyft - Matt Klein, Lyft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=IeJDjq-COjk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0711j6c00m.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes、元数据和你<br>Kubernetes, Metadata and You [I] - Liz Rice, Aqua Security &amp; Gareth Rushgrove, Puppet</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AcM3IRB8FJ0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0711o8ol7c.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>实践排队理论：在云原生领域性能建模<br>Queueing Theory, In Practice: Performance Modelling in Cloud-Native Territory [I] - Eben Freeman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yf6wSsOFqdI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07112gyhbu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生日志记录101<br>Cloud Native Logging 101 [B] - Eduardo Silva, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=szN_e9VZ8ZA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0711tsklax.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用K8s和Envoy自下而上采用微服务工作流程<br>Bottoms-Up Adoption of a Microservices Workflow Using Kubernetes &amp; Envoy - Rafael Schloming</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=GfrPVlRx5Gk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0711y9n34e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>运行云原生基础设施的真正成本<br>The True Costs of Running Cloud Native Infrastructure [B] - Dmytro Dyachuk, Pax Automa</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NElaNl1Kwkw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z07112sbh1l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Pinterest从虚拟机到容器的旅程<br>Pinterest’s Journey from VMs to Containers [I] - Michael Benedict, Pinterest</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YNAa0ZFkRo8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d07112m61t5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>针对API和微服务场景，DevOps友好的文件发布<br>DevOps Friendly Doc Publishing for APIs &amp; Microservices - Amanda Whaley, Cisco DevNet</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=57moZYJstdU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07119a5z41.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用容器持续集成和持续交付<br>Using Containers for Continuous Integration and Continuous Delivery [I] - Carlos Sanchez, CloudBees</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nclm5KPf3nY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0711ergrh8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上大规模持续集成<br>Continuous Integration at Scale on Kubernetes [B] - Karthik Gajjala, eBay</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_5DIDVLGW4U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0711xq0z30.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>展开你的Spinnaker管道到桌面<br>Expand Your Spinnaker Pipeline to the Desktop [I] - Sean Korten, Kenzan</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=b_Qn_bUVZAY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0711h5j3mk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>每天成千上万的部署到Kubernetes<br>Deploying to Kubernetes Thousands of Times Per/Day - Dan Garfield, Codefresh &amp; William Denniss</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NZq3Q0G5HKY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g07112fykaz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小组讨论：问我任何问题：微服务和服务网格<br>Panel: Ask Me Anything: Microservices and Service Mesh [B] - Moderated by Jason McGee, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=22oL0j8mh9w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e07119fbm67.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>问问你的代理服务器，它知道一切<br>Ask Your Proxy, It Knows Everything - Blake Mizerany, Backplane</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=43wFJBRTHG0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0711m5me1o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用云原生技术为网络服务建设边缘计算平台<br>Building an Edge Computing Platform for Network Services Using Cloud Native Technology [I]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JcfGWwzzHTc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0711vjd8kr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>奇迹的制造者：开发人员如何一砖一瓦地重建企业<br>The Makers of Marvels: How Developers Are Rebuilding the Enterprise, One Brick at a Time</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=K768SVksFUU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0711lklkk9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Indeed基于gRPC的下一代服务<br>Next Generation Services at Indeed Using gRPC [I] - Jaye Pitzeruse, Indeed.com</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=aQ2d9iLDR8Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i07114nba3m.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>文档的艺术和开源项目的Readme.md<br>The Art of Documentation and Readme.md for Open Source Projects - Ben Hall, Katacoda</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-EaJEnFhwjs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0711p4pkef.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>微服务式应用的分布式工作流<br>Distributed Workflows for Microservices-Style Applications [I] - Yun Qin, Nirmata</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=irML9LDtSFA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0711ev66z7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>随时间修改gRPC服务<br>Modifying gRPC Services Over Time [I] - Eric Anderson, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=F2WYEFLTKEw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0711d5phjc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给应用开发的普罗米修斯实用指南<br>A Practical Guide to Prometheus for App Developers [B] - Ilya Dmitrichenko, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-7fO99IiTpY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0712yyo3a2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>服务网格：过去、现在和未来<br>The Service Mesh: Past, Present, and Future [B] - William Morgan, Buoyant</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2trOvMUuLkk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c071249jjbg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio服务网格中使用NGINX代理的微服务模式<br>Microservices Patterns with NGINX Proxy in an Istio Services Mesh [I] - A.J. Hunyady, NGINX Inc</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hr-euazYG88" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0712cgwxxr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>通往更可用Kubernetes的道路<br>The Road to More Usable Kubernetes - Joe Beda, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QQsq2Ny5a4A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0712xoytgq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>从头开始构建Helm Charts：Kubernetes介绍<br>Building Helm Charts From the Ground Up: An Introduction to Kubernetes [I] - Amy Chen, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vQX5nokoqrQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0712vfmhov.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes发行版和“内核”<br>Kubernetes Distributions and ‘Kernels’ - Tim Hockin &amp; Michael Rubin, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=fXBjA2hH-CQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0712fkrml1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Vault和Kubernetes的秘密管理<br>Vault and Secret Management in Kubernetes [I] - Armon Dadgar, HashiCorp</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FhUJYwM_xy0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e07124yr4yv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Helm Chart模式<br>Helm Chart Patterns [I] - Vic Iglesias, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WugC_mbbiWU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0712nlo5ja.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>健康指标和评估研究所在Kubernetes上运行混合工作<br>Running Mixed Workloads on Kubernetes at the Institute for Health Metrics and Evaluation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JfIJiK7QrC8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0712kulv7k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在发展蓬勃的成熟公司拥抱云原生<br>Embracing Cloud Native at a Thriving, Established Company - Brian Akins, MailChimp</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LFKyQOaSuxk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w071223e2vi.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>扩展到5000多个独特的K8s部署，我们是如何做到的<br>Scaling to 5000+ Unique K8s Deployments, How We Did It [I] - Nicole Hubbard, WP Engine</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=al9F5r7IkKQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0712hqh6zd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>公共云中自动化测试生产就绪的Kubernetes集群<br>Automating and Testing Production Ready Kubernetes Clusters in the Public Cloud - Ron Lipke</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_n5nPlNFHYY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0712av5kme.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>GitOps - 使用Pull Request来运营<br>GitOps - Operations by Pull Request [B] - Alexis Richardson, Weaveworks &amp; William Denniss, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=BSqE2RqctNs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0712yhqvv3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>AWS上运行Kubernetes：实践与观点<br>Kubernetes on AWS: Practices &amp; Opinions [I] - Arun Gupta, Amazon Web Services &amp; Raffaele di Fazio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gegaGA7Ek9E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0712derij6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>负载测试Kubernetes：如何优化生产环境的群集资源分配<br>Load Testing Kubernetes: How to Optimize Your Cluster Resource Allocation in Production</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-lsJyni7EQA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a07121vgd7u.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用网络政策保护群集网络<br>Securing Cluster Networking with Network Policies - Ahmet Balkan, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3gGpMmYeEO8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0718l78hg7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>101种崩溃集群的方法<br>101 Ways to Crash Your Cluster [I] - Marius Grigoriu &amp; Emmanuel Gomez, Nordstrom</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=xZO9nx6GBu0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0718j7rase.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes作为大型教学基础建设<br>Large Scale Teaching Infrastructure with Kubernetes - Yuvi Panda, Berkeley University</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=g5rl7T18n-s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s07184tnpf3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes构建多云环境<br>The Architecture of a Multi-Cloud Environment with Kubernetes [I] - Brian Redbeard, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vncviMVmk64" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0718tihtv1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>kubeadm群集创建内部：从自托管到升级容易和HA<br>kubeadm Cluster Creation Internals: From Self-Hosting to Upgradability and HA [A] - Lucas Käldström</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YCOWQIFVAbg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i07187zqy1k.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>主题演讲：Kubernetes秘密的超级威力<br>Keynote: Kubernetes Secret Superpower - Chen Goldberg &amp; Anthony Yeh, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1kjgwXP_N7A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0718ye0e51.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：红帽：使容器变得沉闷（再一次地）<br>Keynote: Red Hat: Making Containers Boring (again) - Clayton Coleman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=AE0gZlA2sZ8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0718gn1xtv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：权力游戏推动Kubernetes极限<br>Keynote: Pushing the Limits of Kubernetes with Game of Thrones - Zihao Yu &amp; Illya Chekrygin, HBO</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7skInj_vqN0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c07188tnokn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：迈向零信任的Kubernetes网络<br>Keynote: Progress Toward Zero Trust Kubernetes Networks - Spike Curtis, Tigera</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Agxt9Vg-YP4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b07181x0hbp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes旅程的前路<br>Keynote: The Road Ahead on the Kubernetes Journey - Craig McLuckie, CEO, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3FR82H7NwAw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0718yl7vn4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>client-go：黄金三镖客（好的、坏的、丑的）<br>client-go: The Good, The Bad and The Ugly - Lili Cosic, Kinvolk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Q88kI8X5R48" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07187v50gn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>延伸Kubernetes 101<br>Extending Kubernetes 101 [A] - Travis Nielsen, Quantum Corp</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yn04ERW0SbI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x07188tnl3p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用外接控制器和自定义资源进行Kubernetes功能原型<br>Kubernetes Feature Prototyping with External Controllers and Custom Resource Definitions</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=fnSNPgwXcUc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0718bpyls4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用自定义资源提供云原生API管理<br>Using Custom Resources to Provide Cloud Native API Management - Frank B Greco Jr</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=--LSmvCKVSs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u07183qjx6o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>扩展Kubernetes：我们的旅程和路线图<br>Extending Kubernetes: Our Journey &amp; Roadmap [I] - Daniel Smith &amp; Eric Tune, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=KVEKkr7-IJI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n07186bdt3a.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>扩展Kubernetes API：文档没有告诉你的<br>Extending the Kubernetes API: What the Docs Don’t Tell You [I] - James Munnelly, Jetstack</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PYLFZVv68lM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c071806xqg5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>Kuberneters在混合环境中使用云连接器<br>Kuberneters in Hybrid Environments Using Cloud Interconnect [A] - Marc Chisinevski, F5 Networks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=klGalxhphxA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0718pnqu07.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混合环境中运行多集群<br>Multi-Cluster Ops in a Hybrid World [A] - Vitaliy Zinchenko &amp; Kire Filipovski, Oracle</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=K5fQWBR6fWs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0718upgw5i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混合云，符合HIPAA企业使用Kubernetes<br>Hybrid-Cloud, HIPAA Compliant Enterprise with Kubernetes - Steve Sloka, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jPsTIERe7ek" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07180l394x.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>混合环境中管理和运行多个Kubernetes集群<br>Managing and Running Multiple Kubernetes Clusters in Hybrid Setups [I] - Sebastian Scheele</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qR7CutGp96M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0718kveaag.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚫</td>
</tr>
<tr>
<td>使用Kubicorn构建群集管理API<br>Building a Cluster Management API using Kubicorn [A] - Robert Bailey, Google &amp; Kris Nova, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nLxyyI1WV_w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m07190m4my0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Pontoon：K8s的企业级无服务器架构<br>Pontoon: An Enterprise Grade Serverless Framework Using Kubernetes – As Used in VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=feFrLrEvqfk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0719vnvrfw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Fission：给Kubernetes无服务器功能<br>Fission: Serverless Functions for Kubernetes [B] - Soam Vasani, Platform9 Systems</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=X-XV6vvwhuo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0719mrhhnr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>FaaS和激情 - 任何地方在60秒内从0到无服务器<br>FaaS and Furious - 0 to Serverless in 60 Seconds, Anywhere - Alex Ellis, ADP</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XgsxqHQvMnM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0719bhu6ou.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>构建无服务器应用管道<br>Building Serverless Application Pipelines [A] - Sebastien Goasguen, Bitnami</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8P-aXKylCVs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0719vzcgkj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>无服务器的现状<br>State of Serverless [B] - Mark Peek, VMware &amp; Doug Davis, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=SNJipRS8qxw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i07194gd64v.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上建立和运行企业级的无服务器平台<br>Building and Running an Enterprise-grade Serverless Platform on Kubernetes - Ying Huang</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Y5yQC_20QlI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0719wm74cc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Squash：Kubernetes应用程序调试工具<br>Squash: A Debugger for Kubernetes Apps - Idit Levine, solo.io</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5TrV3qzXlgI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0719g24rpv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用PowerfulSeal测试K8s上的分布式软件<br>Testing Distributed Software on Kubernetes with PowerfulSeal [I] - Mikolaj Pawlikowski, Bloomberg</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=00BMn0UjsG4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j07190km89l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes进行本地开发<br>Developing Locally with Kubernetes [I] - Ryan Jarvinen, Independent</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_W6O_pfA00s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0719s5hjdg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>开发者的Kubernetes配置工具<br>Developer Tooling for Kubernetes Configuration [I] - Gareth Rushgrove, Puppet</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=P_A9M8iEMoo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b07199i1rz5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>不吓跑你的安全团队地部署Kubernetes<br>Deploying Kubernetes Without Scaring Off Your Security Team - Paul CzarkowskI &amp; Major Hayden</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VOF9KVOekY8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d07192mkued.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes解构：分解以了解Kubernetes<br>Kubernetes Deconstructed: Understanding Kubernetes by Breaking It Down - Carson Anderson, DOMO</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=90kZRyPcRZw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0719cqeda6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>Kubernetes网络的简单途径 - 不要自己开车疯狂<br>The Easy–Don’t Drive Yourself Crazy–Way to Kubernetes Networking [B] - Gerard Hickey</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=H5Zl_kDOwBU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v07193nyaqa.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🌕</td>
</tr>
<tr>
<td>Kubernetes的元素 - 应用程序运行的基本概念<br>The Elements of Kubernetes - Foundational Concepts for Apps Running on Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=S9l2MWhIBhc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d071995zb4o.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>多租户支持和使用RBAC和命名空间安全建模<br>Multi-Tenancy Support &amp; Security Modeling with RBAC and Namespaces - Fred Vong &amp; Michael Y. Chen</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ahwCkJGItkU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0719lur17p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的合规和身份管理<br>Compliance and Identity Management in Kubernetes [I] - Marc Boorshtein, Tremolo Security, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7JJsaVR65sI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0719vfm7ey.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Certifik8s：你需要知道关于K8s证书的所有<br>Certifik8s: All You Need to Know About Certificates in Kubernetes [I] - Alexander Brand, Apprenda</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gXz4cq3PKdg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07196gdq02.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大规模防止攻击<br>Preventing Attacks at Scale [I] - Dino Dai Zovi, Capsule8</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=P8891Z_uj-0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0719hcz1fa.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>欢迎来到Kubernetes - K8s简介和入门工具包<br>Welcome to Kubernetes - Introduction and Toolkit for Getting Started with Kubernetes [B]</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TkCDUFR6xqw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v07198myz3y.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪ ⚫</td>
</tr>
<tr>
<td>从Go中使用Kubernetes API<br>Using Kubernetes API from Go [B] - Alena Prokharchyk, Rancher Labs</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QIMz4V9WxVc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0719a0z7t6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">🔵</td>
</tr>
<tr>
<td>有状态的应用程序 - 如果K8s也运行您的存储会怎样？<br>You Have Stateful Apps - What if Kubernetes Would Also Run Your Storage? - Annette Clewett</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Fgpr2lMnBVY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0719axkaqm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio：航行到安全的服务网格<br>Istio: Sailing to a Secure Services Mesh [I] - Spike Curtis, Tigera &amp; Dan Berg, IBM</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=HMofcmTD444" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z07196qehuy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes集群容灾<br>Disaster Recovery for your Kubernetes Clusters [I] - Andy Goldstein &amp; Steve Kriss, Heptio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=qRPNuT080Hk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0719j7f4e7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>没有人注意到从Mesos移动到Kubernetes<br>Moving from Mesos to Kubernetes Without Anyone Noticing [I] - Anubhav Mishra, Hootsuite</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TaHQOJBLvkM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0719bfl2nr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Squarespace走向自我服务基础设施之旅<br>Kubernetes in the Datacenter: Squarespace’s Journey Towards Self-Service Infrastructure</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oHrcWU9Tyz4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0720yn9nhr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s在生产环境的永久存储 - 哪种解决方案，为什么？<br>Persistent Storage with Kubernetes in Production - Which Solution and Why? [I] - Cheryl Hung</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hqE5c5pyfrk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0720yap4hr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>kubectl apply和声明对象管理的黑暗艺术<br>kubectl apply, and The Dark Art of Declarative Object Management [I] - Aaron Levy, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=CW3ZuQy_YZw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0720fif9i3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>问题发生的时候会怎样？在Kubernetes的可靠性<br>What Happens When Something Goes Wrong? On Kubernetes Reliability - Marek Grabowski &amp; Tina Zhang</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4QiWLxG-SlY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0720txh9wm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在系统维护时间的高可用服务<br>Highly Available Services During Maintenance Events - Maisem Ali &amp; Eric Tune, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FdE-eXtDHhQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0720f2pqjb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在K8S中的UDP：签字、盖章、但交付？<br>UDP in K8S: Signed, Sealed, but Delivered? [I] - Amanpreet Singh, Crowdfire</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=auBNs9qpCJI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0720shuvys.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Apache Traffic Server作K8s入口控制器<br>Kubernetes Ingress Controller with Apache Traffic Server [I] - Mrunmayi Dhume, Oath (Yahoo)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=v_VMLkt4mTA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0720ekhjuv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>使用开源的通用资源代理在K8s上运行Mesos框架<br>Running Mesos Frameworks on Kubernetes with the Open-Source Universal Resource Broker - Fritz Ferstl</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PccCCWcpf9M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q07205rryl4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>到达Kubernetes的俄勒冈小道<br>The Oregon Trail to Kubernetes [I] - Joshua Roppo, Lytics</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jaLyEuVebsQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v07203kw9fe.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在生产环境不断发展和支持有状态、多租户的决策应用程序<br>Evolving and Supporting Stateful, Multi-Tenant Decisioning Applications in Production</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UHVW01ksg-s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e07191bdvsz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes和Linkerd从单体到微服务<br>From Monolith to Microservices with Kubernetes and Linkerd - Mason Jones, Credit Karma</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PoGUI74TimM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0720z2lbj9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes在公共部门改变原有系统和流程<br>Using Kubernetes to Change Legacy Systems and Processes in the Public Sector</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Sp1vCVivBVg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c07203rz7pf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes上管理应用程序<br>Keynote: Manage the App on Kubernetes - Brandon Philips, CTO, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ul624nYC8pw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b07206cx6se.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes是？<br>Keynote: What is Kubernetes? - Brian Grant, Principal Engineer, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cHkXOeP8rQ0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b07201nn4c1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：下一步是什么？对K8s在2018感到兴奋<br>Keynote: What’s Next? Getting Excited about Kubernetes in 2018 - Clayton Coleman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lUnD9SJDgo8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0720e1s6gq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes在GitHub的使用情况<br>Keynote: Kubernetes at GitHub - Jesse Newland, Principal Site Reliability Engineer, GitHub</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OgRHIZt8Yy8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0720nxfe43.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>主题演讲：Kubernetes社区<br>Keynote: Kubernetes Community - Sarah Novotny, Head of Open Source Strategy, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=-5R_GbGg1nI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0720vmyma4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：开幕致辞<br>Keynote: Opening Remarks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_yzw_ce1_Xo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0720ayjeup.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：闭幕致辞<br>Closing Remarks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Gm5Vkn9ZQww" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0720bzra5n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes存储变革：启用高性能分布式数据存储<br>Kubernetes Storage Evolution: Enabling High Performance Distributed Datastores</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5O5MIfGxCrI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0720zsg5oy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用本地存储连接到云提供商VM的经济学<br>Economics of using Local Storage Attached to VMs on Cloud Providers [I] - Pavel Snagovsky</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ePLUqOnbdp4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0720xcgjrr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>提供容器化的Cinder服务给裸机Kubernetes集群<br>Providing Containerized Cinder Services to Baremetal Kubernetes Clusters [I] - John Griffith, NetApp</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vCDlQ0F4kik" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0720ikmuoi.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的块卷支持<br>Block Volumes Support in Kubernetes [I] - Mitsuhiro Tanino, Hitachi Data Systems</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=k8_QQ9eNa-g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0720b8t8af.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>本地短暂存的储资源管理<br>Local Ephemeral Storage Resource Management - Jing Xu, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=cvK1t1h15XM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s072033ui4p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes赋能混合云<br>Hybrid Cloud Powered by Kubernetes [I] - Aparna Sinha, Eric Brewer &amp; Matthew DeLio, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PBfHylG4wSE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0720wzyoqf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>裸机的Kubernetes零配置模式<br>Zero Configuration Pattern of Kubernetes on Bare Metal [A] - Rob Hirschfeld, RackN</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Psm9aOWzfWk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l07205o60dj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用现货和可抢占实例实现成本效益的计算集群<br>Cost-effective Compute Clusters with Spot and Pre-emptible Instances - Bich Le &amp; Arun Sriraman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1ZeDabvJFbY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0723ho2hmq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>自托管Kubernetes：如何和为什么<br>Self-Hosted Kubernetes: How and Why [I] - Diego Pontoriero, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jIZ8NaR7msI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0723r1f4pn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubo来管理你的Kubernetes集群<br>Using Kubo to Manage your Kubernetes Clusters [I] - Oleksandr Slynko &amp; Brendan Nolan, Pivotal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7qzVgi3kg2k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q07233c6deo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>集群单盒：在lxd上部署Kubernetes<br>Cluster-in-a-Box: Deploying Kubernetes on lxd [B] - Rye Terrell, Canonical &amp; Marco Ceppi</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kQslklE5dKs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0723eegrv5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Linkerd沙龙<br>Linkerd Salon - Hosted by William Morgan, Buoyant</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wH9N8kbPbJ0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0723gxod36.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>设置和使用Istio<br>Setting Sail with Istio [B] - Lachlan Evenson, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wq1nlJNvy1w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0723cwkszg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Istio作可靠的应用程序推出和运营<br>Reliable Application Roll Out and Operations with Istio [B] - Lin Sun, IBM &amp; Mandar Jog, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8fbBnpCXP5k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n07238dgs9n.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Istio让你的微服务获得高级容错特性<br>Enable your Microservices with Advanced Resiliency and Fault Tolerance Leveraging Istio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=j0M3KFB1C1o" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0723qexewh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Istio的Mixer：自定义适配器作政策执行<br>Istio’s Mixer: Policy Enforcement with Custom Adapters - Limin Wang, Google &amp; Torin Sandall, Styra</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=czZLXUqzd24" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t07238lm3yo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>IOK：Istio-ON-Kubernetes深潜<br>IoK: Istio-on-Kubernetes Deep Dive [I] - Daneyon Hansen, Cisco</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=NMa9frJs1hA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0723ds94me.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes上的现代化大数据管道<br>Modern Big Data Pipelines over Kubernetes [I] - Eliran Bivas, Iguazio</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8tIcisyXWDU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0723g5d0zh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kafka Operator：在K8s管理和操作卡夫卡集群<br>Kafka Operator: Managing and Operating Kafka Clusters in Kubernetes [A] - Nenad Bogojevic</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jAz8sdO1rgE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0723by0nyy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>分布式数据库DevOps的困境？Kubernetes来抢救<br>Distributed Database DevOps Dilemmas? Kubernetes to the Rescue - Denis Magda, GridGain</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=k1y0Uoqepak" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0723yozqil.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes民主化机器学习<br>Democratizing Machine Learning on Kubernetes [I] - Joy Qiao &amp; Lachlan Evenson, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gvuZpRmCzTM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0723riqgqm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kube-原生的Postgres<br>Kube-native Postgres [I] - Josh Berkus, RedHat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zn1vd7sQ_bc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0723bnih1r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>别烦我，我是有状态的<br>Don’t Hassle Me, I’m Stateful - Jeff Bornemann &amp; Michael Surbey, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=yUfPd39-jHo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g07252qo1hr.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>供Kubernetes集群作容量估算的调度模拟器<br>A Scheduling Simulator for Capacity Estimation of Kubernetes Clusters - Avesh Agarwal</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uNQt5Y8RTZk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d07259ujjo7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在海盗出没的水域航运：Kubernetes实用攻防<br>Shipping in Pirate-Infested Waters: Practical Attack and Defense in Kubernetes [A] - Greg Castle</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ohTq0no0ZVU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v072521que8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>CNI、CRI和OCI - 噢，我的天啊！<br>CNI, CRI, and OCI - Oh My! [I] - Elsie Phillips &amp; Paul Burt, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=1FEBOXpTI0M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07251fuot8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>有效的RBAC<br>Effective RBAC - Jordan Liggitt, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Nw1ymxcLIDI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0725a8fpmt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>跑在Kubernetes服务的真正安全<br>Real Security for Services on Kubernetes [I] - Eric Wang &amp; Yun Zhang, Databricks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zvXQjpy5Pu8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0725zf3i33.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在GKE保护Shopify的PaaS<br>Securing Shopify’s PaaS on GKE [I] - Jonathan Pulsifer, Shopify</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ZrweAu9T24A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0725da3bi3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>破解和强化Kubernetes集群实例<br>Hacking and Hardening Kubernetes Clusters by Example [I] - Brad Geesaman, Symantec</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vTgQLzeBfRU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f07255fg4qy.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes强制定制政策<br>Enforcing Bespoke Policies in Kubernetes [I] - Torin Sandall, Styra</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=llDI8VvkUj8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0725di0uss.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>ConfigMaps 102：在动态应用部署中使用<br>ConfigMaps 102: Using ConfigMaps in Dynamic Application Deployments - Trevor McKay</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=drDj4fr7G2Y" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0725rlqae3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>Ticketmaster使用Helm进行持续部署<br>One Chart to Rule Them All: Continuous Deployment with Helm at Ticketmaster - Michael Goodness</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=HzJ9ycX1h0c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j072593abkf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>调试常见的Kubernetes集群<br>CrashLoopBackoff, Pending, FailedMount and Friends: Debugging Common Kubernetes Cluster</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7FOCG5kua1w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07259lx2x9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用网络挂接作自动更新<br>Webhooks for Automated Updates [B] - Rajashree Mandaogane, Rancher Labs</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OgJC7oi7Uh8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f07255i8sbd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>监测Kubernetes：关注数据<br>Monitoring Kubernetes: Follow the Data [B] - Ilan Rabinovitch, Datadog</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=XYWI2sf7A14" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l07259zkxpg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Planes、Raft和Pods：游览K8s内的分布式系统<br>Planes, Raft, and Pods: A Tour of Distributed Systems Within Kubernetes [B] - Bo Ingram, Craftsy</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oosXgmF-77U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0725ia4x3g.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>让我们使用电子表格和志愿者建立Kubernetes！<br>Let’s Build Kubernetes, With a Spreadsheet and Volunteers! - Justin Garrison, Independent</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=A0mWGaBawR8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0725sdxrjm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center">⚪</td>
</tr>
<tr>
<td>从屏幕到Pods：使用K8s引导多云友好系统<br>From Screen to Pods: Bootstrapping a Cloud Agnostic System using Kubernetes [I] - Patrick McQuighan</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8DguG0E0Z04" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0725awq4uj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>建立GPU机器学习云你需要知道的事儿<br>All You Need to Know to Build Your GPU Machine Learning Cloud [B] - Ye Lu, Qunar</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=IoEFLGe4EFs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i072567quvc.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用TensorFlow和K8s构建GPU加速工作流程<br>Building GPU-Accelerated Workflows with TensorFlow and Kubernetes [I] - Daniel Whitenack</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OZSA5hmkb0o" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0725atubnh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>胆大或冒险 - 使用Kubernetes实现大规模<br>‘Hot Dogs or Not” - At Scale with Kubernetes [I] - Vish Kannan &amp; David Aronchick, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=R3dVF5wWz-g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y07258iaoxd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>eBay跑在Kubernetes的地理分布式数据库<br>eBay Geo-Distributed Database on Kubernetes [A] - Chengyuan Li &amp; Xinglang Wang, eBay</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=2t_HVmih4IM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w072556jkvs.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes运行MySQL<br>Running MySQL on Kubernetes [I] - Patrick Galbraith, Consultant</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=J7h0F34iBx0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0725ac365p.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>与Kubernetes加快人道主义救援<br>Accelerating Humanitarian Relief with Kubernetes [I] - Erik Schlegel &amp; Christoph Schittko, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=UywgL70FQ3s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b07257t4rg5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：KubeCon开幕致辞<br>Keynote: KubeCon Opening Keynote - Kelsey Hightower, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=07jq-5VbBVQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0725cjjr7y.html" target="_blank" rel="external">视频</a></td>
</tr>
</tbody>
</table>
<h2 id="KubeCon-CloudNativeCon-2016-Seattle"><a href="#KubeCon-CloudNativeCon-2016-Seattle" class="headerlink" title="KubeCon + CloudNativeCon 2016 - Seattle"></a><a href="https://github.com/cncf/presentations/blob/master/chinese/2016Seattle.md" target="_blank" rel="external">KubeCon + CloudNativeCon 2016 - Seattle</a></h2><table>
<thead>
<tr>
<th>Topic</th>
<th style="text-align:center">YouTube</th>
<th style="text-align:center">Tencent</th>
<th style="text-align:center">🌕 ⚫ 🔴 🔵 ⚪</th>
</tr>
</thead>
<tbody>
<tr>
<td>给开发者和运维者从命令式到声明式的基础设施<br>Imperative to Declarative Infrastructure by For Developers and Operators by Ashwin Raveendran, eBay</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=kadpRayoh7w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0749vpqrr7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes 1.4自行托管、扩展和联邦及更多<br>Self-hosted, Scale, and Federation with Kubernetes v1.4 and Beyond by Brandon Philips, CoreOS, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3G8uWxVDQcE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0749za1k9l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>自动缩放容器…使用数学<br>Autoscaling Containers… with Math by Allan Espinosa, Engine Yard, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uJT9otr0SCY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0749ujvuh4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给容器做日志记录<br>Logging for Containers by Eduardo Silva, Treasure Data</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=395iaisdZEY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0749g4a7zh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>如何监视基于容器的应用性能<br>How to Monitor Application Performance in a Container-Based World</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PHRLSIyvWXo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0749u534rh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>EGO上跑K8s：把企业资源管理和调度带到K8s<br>Kubernetes on EGO – Bringing Enterprise Resource Management and Scheduling to Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=FpYYtw6jTm0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0749w973um.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>用于容器的网络服务协议（SLA）系统<br>Network Service Agreement (SLA) System for Container Network by Yan Sun &amp; Xuefeng Han, Huawei</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=HrC-rDrIqpY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0749xxpxq9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：整合Kubernetes和Ceph：从部署到生产<br>Lightning Talk - Kubernetes and Ceph Integration: From Deployment to Production by Huamin Chen</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=xWQui5IxS1c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0749z8k9j3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：实现Kubernetes的多云承诺<br>Lightning Talk - Realizing the Multi-Cloud Promise of Kubernetes by Blake White, The Walt Disney Co.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=vDXB7-mJjeA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0749nuvok7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：在Twitter的微服务生命周期管理<br>Lightning Talk - Micro-Services Lifecycle Management at Twitter by Micheal Benedict, Twitter</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Q1CEgPw7CG8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0749bm7pqi.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：测试持久的数据存储卷<br>Lightning Talk - Benchmarking Persistent Data Volumes by Simon Croome, StorageOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=gi6UnQ4lKe4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0749v0ilec.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：Netflix在Kubernetes上的OSS<br>Lightning Talk - Netflix OSS on Kubernetes by Christian Posta, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=hg60L_OpsBk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0749qe1av0.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：整合CoreDNS和Kubernetes的介绍<br>Lightning Talk - Introducing CoreDNS Kubernetes Integration by John Belamaric, Infoblox</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oKmir1aiSR8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0749xdo8li.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的入口：您的路由器、您的规则<br>Kubernetes Ingress: Your Router, Your Rules by Gerred Dillon, Deis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Syw2PzRudIM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d07490x34ms.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes运行多个调度<br>Running Multiple Schedulers in Kubernetes by Xiaoning Ding, Huawei</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=avORKrcyctM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0749sifhaz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes网络小组讨论：在规格协作，在执行竞争<br>Kubernetes Networking Panel: Collaborate on the Spec, Compete on Execution</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=iVZeGA3kW08" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0749x11oaq.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>开幕主题演讲：云原生联盟<br>Opening Keynote: A Cloud Native State of the Union by Dan Kohn</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3rGJ0bt0UhE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0749cb6nra.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes：终于，一个真正的云计算平台<br>Keynote: Kubernetes: Finally…A True Cloud Platform by Sam Ghods, Co-founder, Box</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=of45hYbkIZs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0749rmxnz9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：通往数字化转型的核心<br>Keynote: Journey to the Center of Digital Transformation by Ken Owens, CTO, Cisco</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Zkn_pky4Wxo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/q0749uk81qt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes作为后台<br>Keynote: Backstage with Kubernetes by Chen Goldberg, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zQoDJ70eLME" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r07495fe6o2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：OpenShift是企业就绪的Kubernetes<br>Keynote: OpenShift is Enterprise-Ready Kubernetes by Chris Wright, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Ge8-Xj5Oc88" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0750t2ti1z.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：基于开源、事件驱动和无服务器平台的云原生架构<br>Keynote: Cloud Native Architectures with an Open Source, Event Driven, Serverless Platform</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=C3PPmlUkarY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0750uri9p8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：OpenTracing和容器：跟踪的深度广度和未来<br>Keynote: OpenTracing and Containers: Depth, Breadth, and the Future of Tracing - Ben Sigelman</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=n8mUiLIXkto" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0750i6v0qh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：“简单按键”部署Kubernetes<br>Keynote: Deploying Kubernetes with an ‘Easy Button’ by Chris Gaun, Apprenda</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OgvZCT-x3JI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0750y1cv39.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：开放式创新：在谷歌云跑Kubernetes<br>Keynote: Open Innovation: Kubernetes on Google Cloud by Aparna Sinha</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=akq_bQwAb00" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0750nnq1wf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes：在任何地方也能简单管理<br>Keynote: Kubernetes: Simple to Manage Anywhere - Brandon Philips, CTO, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=TFAuLzUo1Zg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0750de02l8.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大会闭幕致辞<br>Closing Remarks - Dan Kohn, Executive Director, Cloud Native Computing Foundation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=96h94HfdVu8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0750bqoojp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>ITNW（如果这样，现在怎样）：编排一家企业<br>ITNW (If This Now What) - Orchestrating an Enterprise by Michael Ward, Pearson</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=F-Xd9wkB59Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0750zif3v4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes缩放超出了单个集群的微服务<br>Scaling Microservices Beyond a Single Cluster w/ Kubernetes by Dan Wilson, Concur</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=eQ9R8prQUHU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r0750poskdv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>案例研究：Comcast是怎样使用Kubernetes<br>Case Study:  Kubernetes at Comcast by David Arbuckle, Comcast VIPER</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lmeFkH-rHII" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l075042zf4e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>控制平面工程的简介<br>Intro to Control Plane Engineering by Bob Wise, Samsung SDS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=oTs3Gg7z_fc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0750k6sgmj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Box在生产环境是怎样使用Kubernetes运行容器<br>How Box Runs Containers in Production with Kubernetes by Sam Ghods, Box</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QIDrdZlEQdw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0750bspi97.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>K8s如何是我们全球分布的团队过渡到微服务的秘密武器<br>How Kubernetes Was the Secret Sauce in Our Globally Distributed Team’s Transition to Microservices</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EC_ZRLsw58M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0750v0xpcs.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>KubeCon：两个服务发现的故事：把老旧带到K8s<br>KubeCon: A Story of Two Service Discoveries: Bringing Legacy to Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VUCyrY7pHeE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0750zip6uk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>让我们在Kubernetes上运行Cloud Foundry<br>Let’s Run Cloud Foundry on Kubernetes by Vlad Iovanov &amp; Nikhil Manchanda, HPE</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=h5UUA2zfvV4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n07506h35ue.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Kubernetes构建银行<br>Building a Bank with Kubernetes by Oliver Beattie, Monzo</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YkOY7DgXKyw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0750bjlfup.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Unik：Kubernetes的Unikernel运行引擎<br>Unik: Unikernel Runtime for Kubernetes by Idit Levine, EMC</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=wcZWg3YtvnY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0750kv20i9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>编译成为容器<br>Compiling to Containers by Brendan Burns, Microsoft</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VQ7kpxPXTm4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0750w31np7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>安全安心：Kubernetes作持续安全<br>A Security State of Mind: Continuous Security with Kubernetes by Chris Van Tuin, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=YANLbj5p4WA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07505jjbe9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在Kubernetes和CoreOS跑多站点的SAP应用<br>Running Multi-site, SAP Applications on Kubernetes and CoreOS by Nishi Davidson &amp; Victoria Rozhina</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Po1GIN7IqTY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0750m3qtci.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kompose：K8s的Docker-Compose<br>Kompose: The Docker-Compose of Kubernetes by Sebastien Goasguen, Skippbox</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zqUfPPNVjI8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0750aqmk5q.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>超过2000节点：我们如何扩大K8s到60000个容器集群<br>2000 Nodes and Beyond: How We Scaled Kubernetes to 60,000-Container Clusters</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=K6rP0A-ahHU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0750qc8qa3.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>这样监控Kubernetes是错误的<br>You’re Monitoring Kubernetes Wrong by Loris Degioanni, Sysdig</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=agbBy1Aduew" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l07505vgmie.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给Kubernetes作自动化基础设施部署<br>Automating Infrastructure Deployment for Kubernetes - Alena Prokharchyk &amp; Brian Scott</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=5-1UuviwMws" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w07506nshjg.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在容器丛林中导航<br>Navigating the Container Jungle by Casey Davenport, Tigera</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9fKDoCB5mHQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0750cbndwv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes API请求的生命<br>Life of a Kubernetes API Request by Daniel Smith, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ryeINNfVOi8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u075159ynrp.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>可视化Kubernetes：仪表的力量<br>Visualizing Kubernetes: The Power of Dashboard by Dan Romlein, Apprenda &amp; Piotr Bryk, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=3lhf7T9Bp2E" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0751t7b4qd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的规模及性能测试：给特定应用程序的答案<br>Scale and Performance Testing of Kubernetes: Answers for Specific Applications</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=am179tPtueU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0751h8mlar.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>执掌Helm：提供Kubernetes原生的应用程序<br>Taking the Helm: Delivering Kubernetes-Native Applications by Michelle Noorali</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zBc1goRfk3k" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t07513w24fj.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes跑在Windows Server上的演示<br>Demo of Kubernetes on Windows Server by Michael Michael, Apprenda</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Tbrckccvxwg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0751y6expt.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes集群联合：过去、现在和未来<br>Cluster Federation in Kubernetes: Past, Present and the Future by Madhu C.S. &amp; Quinton Hoole, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=pq9lbkmxpS8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0751wx9ik9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>NCSOFT游戏服务器迁移到Kubernetes<br>Migration of NCSOFT Game Servers to Kubernetes by Kang Jeongsik</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=o-KJNWyHmQE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x075164l97x.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Heron即时处理数十亿的事件<br>Processing Billions of Events in Real-Time with Heron by Karthik Ramasamy, Twitter</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Y3RUpCJ8r3A" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b0751sr5sp4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>云原生就是容器原生？<br>Does Cloud Native Mean Container Native? by James Bottomley, IBM Research</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=g2t-VDc-0aA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0751wn68mz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用Container-Transform迁移配置到K8s<br>Migrating Configuration to Kubernetes with Container-Transform by Micah Hausler, Skuid</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=E0qeKO-dkFY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0751jf3ckn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>当容器失败，蘑菇云效应或会发生什么？<br>The Mushroom Cloud Effect or What Happens When Containers Fail? by Alois Mayr, Dynatrace</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=VketmwaRe5I" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/l0751zd8bae.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>BOF：发展社区（利用聚会来教育、发展和促进对话）<br>BOF: Growing a Community (Leveraging Meetups to Educate, Grow, and Facilitate Conversation)</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_SZZa5Ai1PQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/c0751cv52gk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用普罗米修斯监测MySQL和MongoDB<br>Monitoring MySQL and MongoDB with Prometheus by Vadim Tkachenko, Percona</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=19c_gNQT2dM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/r07510snhcf.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Weave Cortex：横向扩展、多租户的普罗米修斯即服务<br>Weave Cortex: Horizontally Scalable, Multitenant Prometheus as a Service by Tom Wilkie, Weaveworks</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=9Uctgnazfwk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f07519u3jk9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>普罗米修斯是适合您的初创企业<br>Prometheus Is Good for Your Small Startup by Ignacio P. Carretero, ShuttleCloud</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=veohecVHtBU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s07512csyco.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Chronix作为普罗米修斯的长期存储<br>Chronix as Long Term Storage for Prometheus by Moritz Kammerer, QAware GmbH</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=4fhXSgRmLHM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0751fs3wgo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>适应棕地应用部署到云原生技术<br>Adapting Brownfield Deployments to Cloud-Native Technology by Richard Hartmann</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=tsuCCrCNfV4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a07511bbv8g.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>超越Nagios：普罗米修斯现代化地监测青铜时代的应用程序<br>Beyond Nagios: Modern Monitoring of Bronze-Age Applications with Prometheus by Ben Kochie</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ebfEhfJBEJ8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h0751g46rmn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Sentinel：细粒度的应用安全平台<br>Sentinel: A Platform for Fine-grained Application Security by Sudheendra Murthy, eBay, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=uF8PX5VpC2M" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0751xdev2l.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>安全安心：容器的遵从和漏洞审计<br>A Security State of Mind: Compliance and Vulnerability Audits for Containers by Chris Van Tuin</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EFcJCF0j0iE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0751fvff4i.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>技术视图：容器编排和管理系统的比较<br>Technical View: Comparison of Container Orchestration and Management Systems</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=_vd0xMjWOD8" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/a0751gg1bdd.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>给容器准备云基础设施<br>Plumbing the Cloud for Containers by Michael Friis, Docker</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=QsxTxm5QgiU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0751bea5jb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Pachyderm：释放Kubernetes给大数据的力量<br>Pachyderm: Unlock the Power of Kubernetes for Big Data by Joey Zwicker, Pachyderm</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LamKVhe2RSM" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/o0751pc83r1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>掌舵：Ancestry通往Kubernetes的旅程<br>Taking the Helm - Ancestry’s Journey to Kubernetes by Paul MacKay, Ancestry.com</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=zLn_H5jaWxQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0751m4gkh2.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>与K8s不断改进开发和运维：企业采用因为安全、速度和简单<br>Evolving Dev and Ops with Kubernetes: Enterprise Adoption for Security, Speed, and Ease</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=loroCi67brg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m075145lwex.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在生产环境管理多租户Kubernetes集群<br>Managing a Multi-Tenanted Kubernetes Cluster in Production by Josh Bowen, Apigee</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lA1B2b5kU2g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y0752aqh22s.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在桅杆前的18月<br>18 Months Before the Mast by Jack Foy, Hiya</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=xkSYOtPxH_Q" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0752u1n32w.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>学习如何在3个月从正确发音到生产采用Kubernetes！<br>Learning How to Pronounce Kubernetes to Production in 3 Months! by Sheriff Mohamed, GolfNow</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=MBDog4ivBHI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0752ehgsh6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes<br>Keynote: Kubernetes by Kelsey Hightower, Staff Developer Advocate, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=8SvQqZNP6uo" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0752i8ufqx.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes 1.4及以后<br>Keynote: Kubernetes - 1.4 and Beyond by David Aronchick, Senior Product Manager, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Sic5-8ikz9g" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0752gwihx7.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：SDI：提供全球最大的云给每个人的效率<br>Keynote: SDI: Delivering the Efficiencies of the World’s Largest Clouds to Everyone</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=6y-AoVHu7-s" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07521cd8e5.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：融合ICT基础设施加速转型到云原生<br>Keynote: Accelerating Transformation to Cloud Native on Converged ICT Infrastructure</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lXfpnR2VqF0" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/w0752xc088q.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：使用普罗米修斯监测Kubernetes集群<br>Keynote: Monitoring Kubernetes Clusters with Prometheus by Fabian Reinartz, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=A760lwRDg9U" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/g0752ygb0qn.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：使用Kubernetes简化分布式系统<br>Keynote: Distributed Systems Simplified Using Kubernetes by Brandon Philips, CTO, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=Uf7PiHXqmnw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d07523cyj6f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>主题演讲：Kubernetes：像在电视看到的<br>Keynote: Kubernetes: As Seen On TV by Erik St. Martin, Systems Architect, Comcast</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=7g4da6-JXfE" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/u0752kdcogb.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>大会闭幕致辞<br>Closing Remarks by Chris Aniszczyk, VP of Developer Programs, The Linux Foundation</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=JaewuSW-zcc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0752v47ioz.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：OCI：容器标准和认证<br>Lightning Talk - OCI: Container Standards and Certification</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=ERN84-6Dakc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0752dhrvpo.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：你说什么？您在Kubernetes跑存储平台？<br>Lightning Talk - Say what? You’re Running the Storage Platform IN Kubernetes?</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=aAYpXS9bFMY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s07524v3zo6.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：该功能正式名称为PetSet<br>Lightning Talk - The Feature Formally Known as Prince … err PetSet.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=j2AgjhFE7_c" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/z0752c9kk8w.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：当Kubernetes不是解决方案<br>Lightning Talk - When Kubernetes is Not the Solution by Joonas Bergius, DigitalOcean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=lxA67W0aiDc" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/y07529b8c3f.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：ContainerOps：容器助力DevOps<br>Lightning Talk - ContainerOps – Empowering DevOps With Container by Quanyi Ma</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=jqpdveK2XAU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0752b2blzh.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>闪电讲座：K8s推广：培养K8s倡导者参与的社区<br>Lightning Talk - K8s Port: Cultivate an Engaged Community of Kubernetes Advocates</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=LwViH5eLoOI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d075594q57w.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在自己的数据中心实现Kubernetes即服务<br>Kubernetes as a Service in Your Own Data Center by Jared Rosoff, VMware</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=W56KoAJTwQs" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k0755oft350.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes进行关键任务<br>Mission Critical Kubernetes by Andy Repton &amp; Michael Russell, Schuberg Philis</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=aqt3l7f06Ic" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0755qenw1m.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>实行Kubernetes：谷歌容器引擎的实例<br>Kubernetes in Action: Examples from Google Container Engine by Aparna Sinha &amp; Robert Bailey, Google</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=H4yAOSdEY24" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/h07554f3rds.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>进入黑客帝国，在虚拟现实探索Kubernetes集群<br>Enter the Matrix, Exploring Your Kubernetes Cluster in Virtual Reality by Ryan Vanniekerk</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=RyKzTb0Q0O4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/s0755vg9psm.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在DigitalOcean提供服务<br>Delivering Services at DigitalOcean by Mac Browning, DigitalOcean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=K5WRJvMx4us" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/d0755m7g9e4.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes认证和访问控制<br>Kubernetes Auth and Access Control by Eric Chiang, CoreOS</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WvnXemaYQ50" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/f0755scbprw.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>所有关于资源调度，想知道的但怯于问的<br>Everything You Ever Wanted to Know About Resource Scheduling, But Were Afraid to Ask by Tim Hockin</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=nWGkvrIPqJ4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/t0755yhvyo9.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>另辟蹊径：探索者的Kubernetes指南<br>Off the Beaten Path: An Explorer’s Guide to Kubernetes by Taylor Thomas, Intel</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=W5H0rK9xyfI" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07558tgs2r.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>rkt和OCI：促进行业标准<br>rkt and the Open Container Initiative: Promoting Industry Standards by Derek Gonyeo, CoreOS, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=J5CGDPMhFeA" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0755l2h1da.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>管理Kubernetes生产系统：好的、坏的和丑的<br>The Good, the Bad, and the Ugly of Managing Production Systems with Kubernetes</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=36DwWqKRhxQ" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/b075592gdfu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>第三方动态存储卷配置程序<br>Third Party Dynamic Volume Provisioners by Jan Šafránek, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=htqe8mJV4P4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/e0755f1gkth.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>在PetSet上跑PostgreSQL<br>PostgreSQL on PetSet by Josh Berkus, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=InLpWzp8C18" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0755vd1i0j.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>支持GPU的当前情况<br>State of the GPU(nion) by Rudi Chiarito, Clarifai</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=OQHr_QlgmNw" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0755pi13t1.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Torus：为Kubernetes而设的分布式存储<br>Torus: Focusing Storage for Kubernetes by Barak Michener, CoreOS, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=f8Ipew7JYFU" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/m0755inby1e.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>KubeCeption！自托管Kubernetes的故事<br>KubeCeption! A Story of Self-Hosted Kubernetes by Aaron Levy, CoreOS, Inc.</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EbNxGK9MwN4" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/n0755xc9xrv.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>性能和伸缩调整K8s，优化OpenShift和Docker<br>Performance and Scalability Tuning Kubernetes for OpenShift and Docker by Jeremy Eder, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=WN8zywbWfnk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/p0755dx1jew.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes的新存储功能<br>New Features in Kubernetes Storage by Brad Childs, Red Hat</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=V6eX9S7N7Rk" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/v0755txe5ir.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>迁移现有的基础设施到K8s：Olark从战壕的教训<br>Migrating Legacy Infrastructure to Kubernetes:  Olark’s Lessons From the Trenches</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=r0nhQwbe8OY" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/j0755hcow51.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>使用PetSet配置和部署有状态的应用<br>Configuring and Deploying Stateful Applications with PetSet by David Oppenheimer</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=EuJoAKTCCXg" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/i0755v4tzfk.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Ticketmaster对公共云和K8s的战略<br>Bringing 1976 into 2016: Ticketmaster’s Public Cloud and Kubernetes Strategy by Justin Dean</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=PSPNg5AU_II" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/k07551qpwfu.html" target="_blank" rel="external">视频</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Kubernetes上构建新一代的微服务<br>Next-Generation Microservices on Kubernetes - by Paul McLoughlin &amp; Sachin Kamboj, Bloomberg LP</td>
<td style="text-align:center"><a href="https://www.youtube.com/watch?v=F2nqrXke19w" target="_blank" rel="external">Video</a></td>
<td style="text-align:center"><a href="https://v.qq.com/x/page/x0755jotffz.html" target="_blank" rel="external">视频</a></td>
</tr>
</tbody>
</table>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2OK087kzLgc4jTPVbZjuNfs" target="_blank" rel="external">Shanghai ‘18: KubeCon + CloudNativeCon</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2N8GdbjmhVU65KYm_68qBmo" target="_blank" rel="external">Copenhagen ‘18: KubeCon + CloudNativeCon</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2P-3-xqvmWaZbbI1sW-ulZb" target="_blank" rel="external">KubeCon + CloudNativeCon 2017 - Austin</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2PAavlbv0iZkod4IVh_iGqV" target="_blank" rel="external">CloudNativeCon + KubeCon 2017 - Berlin</a></li>
<li><a href="https://github.com/cncf/presentations/blob/master/chinese/2016Seattle.md" target="_blank" rel="external">KubeCon + CloudNativeCon 2016 - Seattle</a></li>
<li><a href="https://github.com/cloudyuga/kubecon18-china" target="_blank" rel="external">cloudyuga/kubecon18-china</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 KubeCon 的视频，囫囵吞枣，感觉吸收了不到一成，但是感觉功力大增。&lt;/p&gt;
&lt;p&gt;看 KubeCon，可以学习跟 Kubernetes 相关的各种解决方案，了解 CNCF 下的各个项目的进展，跟着核心开发者深入每个子项目的架构，原理，这些自然不用说，更有意思的一点是，可以通过这个窗口看到世界各地各行各业的动态，这是 KubeCon 特别的地方，因为 Kubernetes 是基础架构，来宣讲的基本都是架构师，布道师，这和 React Conf 之类的专注于一个技术点的会议是不一样的。举个例子，有一个分享是欧洲的一个公司借助 kube-scheduler 议题向大家介绍他们公司的案例，他们把服务器安装在每一户的家里，将这些机器组成一个 Kubernetes 集群，当集群运行一个 job 时，服务器就会加热，用户使用热水时就能省电，平时在家里也可以起到增温的作用，而他们公司也可以省一些机房，电费等运维费用，他们的工作内容就是借助这个 Kubernetes 集群，通过自定义调度算法，增加整个系统的利用率。对于这种系统，以前我也略有耳闻，在真的看到这样的公司的分享时，还是觉得奇妙有趣，好像思路打开了一样，同时，我还学习了怎么写一个自定义的 Kubernetes 调度算法，这样的分享怎么可能不讨人喜欢呢。&lt;/p&gt;
&lt;p&gt;这么多视频，你要问我记住了多少？呵呵呵呵&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 源码笔记（kubeadm）</title>
    <link href="http://knarfeh.github.io/2018/07/28/Kubernetes%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88kubeadm%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kubeadm）/</id>
    <published>2018-07-27T16:15:05.000Z</published>
    <updated>2018-11-30T05:45:15.526Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 发展初期，部署 Kubernetes 一直是一件让初学者头疼的事情，Kubernetes 也开始重视这个问题，2017年，在社区志愿者的推动下，社区发起了一个独立的部署 Kubernetes 的项目，<a href="https://github.com/kubernetes/kubeadm" target="_blank" rel="external">kubeadm</a>。</p>
<p>经过一年多的发展，kubeadm 已经可以一键式进行 Kubernetes 集群的快速初始化和安装，极大地简化了部署过程。值得一提的是，在很长一段时间里 kubeadm 有个比较欠缺的地方是无法做到一键部署一个高可用的 Kubernetes 集群，这是 kubeadm 目前的工作重点，好在这个功能已经在 1.11 版本刚刚发布，可以参考 <a href="https://kubernetes.io/docs/setup/independent/high-availability/" target="_blank" rel="external">Creating Highly Available Clusters with kubeadm</a>。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Kubernetes 是一个管理容器的平台，所以用容器来部署自身的组件是一件自然而然的事情，kube-apiserver, scheduler 等组件还好解决，比较麻烦的是 kubelet 组件，因为 kubelet 需要承担与容器运行时交互的工作，还需要解决容器运行时网络，存储的配置问题，这些都需要直接操作宿主机的，如果 kubelet 本身就运行在容器里，这些问题倒也不是不能解决，只是需要做各种方式的 hack，部署 Kubernetes 的这个需求会变得更为复杂。kubeadm 的方案是 kubelet 直接运行在宿主机上，其他的 Kubernetes 组件使用容器部署。</p>
<p>所以使用 kubeadm 的第一步手动安装 kubeadm，kubelet，kubectl 这3个二进制文件，可以参考我的 <a href="https://github.com/knarfeh/k8s-digitalocean-terraform/blob/9c7d1208d4f5e50204f95d1d353e1c914e837ea8/install-kubeadm.sh#L23" target="_blank" rel="external">k8s-digitalocean-terraform</a> 项目，里面有需要安装的依赖。<br>这是运行 kubeadm 的前提。</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>kubeadm 中比较关键的工作流程就两步，1. <code>kubeadm init</code> 进行初始化。2. <code>kubeadm join master-ip:master:port</code> 将 worker 节点连接到 master 节点，组成集群。</p>
<h4 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a><code>kubeadm init</code></h4><p>以下内容均考虑使用默认参数的情况。</p>
<p><code>kubeadm init</code> 首先会做一系列的检查工作，以确保当前机器是可以部署 Kubernetes 的。这一步叫做 Preflight Checks，包括：</p>
<ul>
<li>Linux 内核版本是否在 3.10 以上</li>
<li>Linux cgroups 是否可用</li>
<li>hostname 是否符合 DNS 命名规范(RFC 1123)</li>
<li>kubeadm 和 kubelet 版本是否匹配</li>
<li>是否安装了 Kubernetes 的二进制文件</li>
<li>10250，10251，10252 端口是否可用</li>
<li>ip、mount 工具是否已经存在</li>
<li>是否安装了 Docker</li>
</ul>
<p>接着 kubeadm 会生成 Kubernetes 对外提供服务所需的安全证书。</p>
<p>这个过程完成后，kubeadm 会为 Master 组件生成 Pod 的 yaml 格式的配置文件，存放在 <code>/etc/kubernetes/manifests</code>，kubelet 会使用一种叫做 Static Pod 的特殊的容器启动方法，根据 yaml 格式文件在机器上启动 kube-apiserver、kube-controller-manager、kube-scheduler、etcd 这四个组件。kubeadm 可以根据配置使用已有的 etcd 集群，不一定非得自己创建。</p>
<p>kubeadm 会监控 <code>/etc/kubernetes/manifests</code> 目录下的内容，一旦生成 yaml 文件，kubelet 就会创建这些 yaml 定义的 Pod，Master 节点的各个组件启动之后，kubeadm 会检查 <code>localhost:6443/healthz</code> 健康状态，直到 Master 节点完全运行起来。</p>
<p>再接下来 kubeadm 会为集群生成一个 bootstrap token，worker 节点可以通过这个 token 加入到集群里。生成 token  后，master 节点的重要信息会通过 cluster-info 这个 ConfigMap 保存到 etcd 里。</p>
<p>最后 kubeadm 会安装插件，有两个默认的必装的插件，一个是 kube-proxy，默认使用 iptable，未来 ipvs 会是默认选项；另一个是 DNS，默认安装 kubedns + dnsmsaq，未来趋势是转向 CoreDNS。插件会通过 Kubernetes 客户端进行创建。</p>
<h4 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a><code>kubeadm join</code></h4><p>其他节点加入到 Master 节点需要保证机器之间是网络互通的，这是将来容器之间网络互通的前提。执行完 <code>kubeadm init</code> 之后可以看到 <code>kubeadm join</code> 的使用方法，在其他机器上运行这行命令即可。</p>
<p><code>kubeadm join</code> 也会检测依赖环境，相比于 <code>kubeadm init</code> 要简单得多，通过检测时候，根据 token 从 kube-apiserver 拿到 <code>cluster-info</code>，获取 kube-apiserver 的证书，这时 kubelet 就接入了集群中。</p>
<p>如果机器很多，手工操作当然不酷，自动化才是未来，可以参考一下 <a href="https://github.com/knarfeh/k8s-digitalocean-terraform" target="_blank" rel="external">结合 Terraform 在 DigitalOcean 上一键式部署 Kubernetes</a> 这个项目。</p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>上面已经把流程描述了一遍，可以看出来，就代码实现来说，不会有什么很复杂的东西，其实代码里也真的是一股脑一个流程走到底，尽管如此我们还是继续研读一下代码，挖掘一些有价值的东西。</p>
<p>基于 v1.10.0-rc.1 代码版本进行分析。</p>
<h3 id="kubeadm-init-1"><a href="#kubeadm-init-1" class="headerlink" title="kubeadm init"></a>kubeadm init</h3><p><code>init</code> 方法的入口在 <code>cmd/kubeadm/app/cmd/init.go</code> </p>
<p>在 cobra 对应的 init 子命令下，先调用 <code>NewInit</code> 方法，进行 Preflight Checks 操作，确保本机可以运行 kubeadm，接着调用 <code>Init</code> 的 <code>Run</code> 方法进行 Master 节点的初始化操作。</p>
<h4 id="系统状态检查"><a href="#系统状态检查" class="headerlink" title="系统状态检查"></a>系统状态检查</h4><p>在 <code>NewInit</code> 里会调用 <code>RunInitMasterChecks</code> 用来完成安装前的检测，这部分内容都在 <code>cmd/kubeadm/preflight/checks.go</code> 里。核心逻辑是定义一堆 checks，然后进行变量，全部通过则满足 <code>Preflight Checks</code> 的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">checks := []Checker&#123;</div><div class="line">	KubernetesVersionCheck&#123;KubernetesVersion: cfg.KubernetesVersion, KubeadmVersion: kubeadmversion.Get().GitVersion&#125;,</div><div class="line">	SystemVerificationCheck&#123;CRISocket: cfg.CRISocket&#125;,</div><div class="line">	IsPrivilegedUserCheck&#123;&#125;,</div><div class="line">	HostnameCheck&#123;nodeName: cfg.NodeName&#125;,</div><div class="line">	KubeletVersionCheck&#123;KubernetesVersion: cfg.KubernetesVersion, exec: execer&#125;,</div><div class="line">	ServiceCheck&#123;Service: &quot;kubelet&quot;, CheckIfActive: false&#125;,</div><div class="line">	// ...</div><div class="line">	FirewalldCheck&#123;ports: []int&#123;int(cfg.API.BindPort), 10250&#125;&#125;,</div><div class="line">	PortOpenCheck&#123;port: int(cfg.API.BindPort)&#125;,</div><div class="line">	// ...</div><div class="line">	FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeAPIServer, manifestsDir)&#125;,</div><div class="line">	// ...</div><div class="line">	InPathCheck&#123;executable: &quot;ip&quot;, mandatory: true, exec: execer&#125;,</div><div class="line">	// ...</div><div class="line">	criCtlChecker,</div><div class="line">	ExtraArgsCheck&#123;</div><div class="line">		APIServerExtraArgs:         cfg.APIServerExtraArgs,</div><div class="line">		ControllerManagerExtraArgs: cfg.ControllerManagerExtraArgs,</div><div class="line">		SchedulerExtraArgs:         cfg.SchedulerExtraArgs,</div><div class="line">	&#125;,</div><div class="line">	HTTPProxyCheck&#123;Proto: &quot;https&quot;, Host: cfg.API.AdvertiseAddress&#125;,</div><div class="line">	// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>生成证书的操作在 <code>Init</code> 的 <code>Run</code> 方法里的 PHASE 1。调用 <code>certsphase.CreatePKIAssets</code> 实现。</p>
<p>这部分代码在 <code>cmd/kubeadm/app/cmd/phases/certs.go</code> 里，依次调用了一下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CreateCACertAndKeyFiles,</div><div class="line">CreateAPIServerCertAndKeyFiles,</div><div class="line">CreateAPIServerKubeletClientCertAndKeyFiles,</div><div class="line">CreateEtcdCACertAndKeyFiles,</div><div class="line">CreateEtcdServerCertAndKeyFiles,</div><div class="line">CreateEtcdPeerCertAndKeyFiles,</div><div class="line">CreateEtcdHealthcheckClientCertAndKeyFiles,</div><div class="line">CreateAPIServerEtcdClientCertAndKeyFiles,</div><div class="line">CreateServiceAccountKeyAndPublicKeyFiles,</div><div class="line">CreateFrontProxyCACertAndKeyFiles,</div><div class="line">CreateFrontProxyClientCertAndKeyFiles,</div></pre></td></tr></table></figure>
<p>为确保安全，Kubernetes 的各个组件需要使用 <code>x509</code> 证书对通信进行加密和认证，如果是使用手动安装的话，整个过程很复杂，所以 kbeadm 将这个过程自动化了。</p>
<p>首先通过 <code>CreateCACertAndKeyFiles</code> 创建 CA，用来签名后续创建的其他证书，对证书进行管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func CreateCACertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error &#123;</div><div class="line">	caCert, caKey, err := NewCACertAndKey()</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	return writeCertificateAuthorithyFilesIfNotExist(</div><div class="line">		cfg.CertificatesDir,</div><div class="line">		kubeadmconstants.CACertAndKeyBaseName,</div><div class="line">		caCert,</div><div class="line">		caKey,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewCACertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) &#123;</div><div class="line">	caCert, caKey, err := pkiutil.NewCertificateAuthority()</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;failure while generating CA certificate and key: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	return caCert, caKey, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pkiutil 模块的 <code>NewCertificateAuthority</code> 在 <code>cmd/kubeadm/app/phases/certs/pkiutil/pki_helpers.go</code> 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func NewCertificateAuthority() (*x509.Certificate, *rsa.PrivateKey, error) &#123;</div><div class="line">	key, err := certutil.NewPrivateKey()</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;unable to create private key [%v]&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	config := certutil.Config&#123;</div><div class="line">		CommonName: &quot;kubernetes&quot;,</div><div class="line">	&#125;</div><div class="line">	cert, err := certutil.NewSelfSignedCACert(config, key)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;unable to create self-signed certificate [%v]&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return cert, key, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>私钥通过 <code>k8s.io/client-go/util/cert</code> 包里的函数实现，其中 <code>NewPrivateKey</code> 只是对 rsa 库函数的封装。</p>
<p>以 <code>CreateAPIServerCertAndKeyFiles</code> 为例，我们再看 kube-apiserver 的证书是怎么生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">func CreateAPIServerCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error &#123;</div><div class="line">	caCert, caKey, err := loadCertificateAuthority(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	apiCert, apiKey, err := NewAPIServerCertAndKey(cfg, caCert, caKey)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	return writeCertificateFilesIfNotExist(</div><div class="line">		cfg.CertificatesDir,</div><div class="line">		kubeadmconstants.APIServerCertAndKeyBaseName,</div><div class="line">		caCert,</div><div class="line">		apiCert,</div><div class="line">		apiKey,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewAPIServerCertAndKey(cfg *kubeadmapi.MasterConfiguration, caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) &#123;</div><div class="line"></div><div class="line">	altNames, err := pkiutil.GetAPIServerAltNames(cfg)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;failure while composing altnames for API server: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	config := certutil.Config&#123;</div><div class="line">		CommonName: kubeadmconstants.APIServerCertCommonName,</div><div class="line">		AltNames:   *altNames,</div><div class="line">		Usages:     []x509.ExtKeyUsage&#123;x509.ExtKeyUsageServerAuth&#125;,</div><div class="line">	&#125;</div><div class="line">	apiCert, apiKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;failure while creating API server key and certificate: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return apiCert, apiKey, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewCertAndKey(caCert *x509.Certificate, caKey *rsa.PrivateKey, config certutil.Config) (*x509.Certificate, *rsa.PrivateKey, error) &#123;</div><div class="line">	key, err := certutil.NewPrivateKey()</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;unable to create private key [%v]&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cert, err := certutil.NewSignedCert(config, key, caCert, caKey)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, nil, fmt.Errorf(&quot;unable to sign certificate [%v]&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return cert, key, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致流程和生成 ca 时类似，只是进行配置时需要生成 AltName，这是 master 的地址；最后生成证书是需要用 ca 添加数字签名，生成证书。</p>
<h4 id="生成-master-各组件所需的-kubeconfig"><a href="#生成-master-各组件所需的-kubeconfig" class="headerlink" title="生成 master 各组件所需的 kubeconfig"></a>生成 master 各组件所需的 kubeconfig</h4><p>这部分代码在 <code>cmd/kubeadm/app/phases/kubeconfig/kubeconfig.go</code> 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">func CreateInitKubeConfigFiles(outDir string, cfg *kubeadmapi.MasterConfiguration) error &#123;</div><div class="line">	return createKubeConfigFiles(</div><div class="line">		outDir,</div><div class="line">		cfg,</div><div class="line">		kubeadmconstants.AdminKubeConfigFileName,</div><div class="line">		kubeadmconstants.KubeletKubeConfigFileName,</div><div class="line">		kubeadmconstants.ControllerManagerKubeConfigFileName,</div><div class="line">		kubeadmconstants.SchedulerKubeConfigFileName,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func createKubeConfigFiles(outDir string, cfg *kubeadmapi.MasterConfiguration, kubeConfigFileNames ...string) error &#123;</div><div class="line">	specs, err := getKubeConfigSpecs(cfg)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for _, kubeConfigFileName := range kubeConfigFileNames &#123;</div><div class="line">		spec, exists := specs[kubeConfigFileName]</div><div class="line">		if !exists &#123;</div><div class="line">			return fmt.Errorf(&quot;couldn&apos;t retrive KubeConfigSpec for %s&quot;, kubeConfigFileName)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		config, err := buildKubeConfigFromSpec(spec)</div><div class="line">		if err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if err = createKubeConfigFileIfNotExists(outDir, kubeConfigFileName, config); err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据配置获取 spec，然后根据根据 spec 依次生成 <code>admin.conf</code>, <code>controller-manager.conf</code>, <code>kubelet.conf</code>, <code>scheduler.conf</code> 文件。</p>
<h4 id="生成-Static-Pod-静态文件"><a href="#生成-Static-Pod-静态文件" class="headerlink" title="生成 Static Pod 静态文件"></a>生成 Static Pod 静态文件</h4><p>前面已经提过原理，kubelet 会监控 <code>/etc/kubernetes/manifests</code> 目录，加载所有的 Pod Yaml 文件，然后在本机上启动这些 Pod。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func createStaticPodFiles(manifestDir string, cfg *kubeadmapi.MasterConfiguration, componentNames ...string) error &#123;</div><div class="line">	k8sVersion, err := version.ParseSemantic(cfg.KubernetesVersion)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	specs := GetStaticPodSpecs(cfg, k8sVersion)</div><div class="line"></div><div class="line">	for _, componentName := range componentNames &#123;</div><div class="line">		spec, exists := specs[componentName]</div><div class="line">		if !exists &#123;</div><div class="line">			return fmt.Errorf(&quot;couldn&apos;t retrive StaticPodSpec for %s&quot;, componentName)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if err := staticpodutil.WriteStaticPodToDisk(componentName, manifestDir, spec); err != nil &#123;</div><div class="line">			return fmt.Errorf(&quot;failed to create static pod manifest file for %q: %v&quot;, componentName, err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		fmt.Printf(&quot;[controlplane] Wrote Static Pod manifest for component %s to %q\n&quot;, componentName, kubeadmconstants.GetStaticPodFilepath(componentName, manifestDir))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有配置外部的 etcd 集群，默认情况下也会根据这种方式创建 etcd。原理一样，不过代码在 <code>cmd/kubeadm/app/phases/etcd/local.go</code></p>
<h4 id="等待-master-启动"><a href="#等待-master-启动" class="headerlink" title="等待 master 启动"></a>等待 master 启动</h4><p>接下来的操作需要等待 master 的组件完全启动后才能进行，这一步需要拉取 kube-apiserver, kube-scheduler, kube-controller-manager, etcd 的镜像，可能会花费比较长的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func waitForAPIAndKubelet(waiter apiclient.Waiter) error &#123;</div><div class="line">	errorChan := make(chan error)</div><div class="line"></div><div class="line">	fmt.Printf(&quot;[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory %q.\n&quot;, kubeadmconstants.GetStaticPodDirectory())</div><div class="line">	fmt.Println(&quot;[init] This might take a minute or longer if the control plane images have to be pulled.&quot;)</div><div class="line"></div><div class="line">	go func(errC chan error, waiter apiclient.Waiter) &#123;</div><div class="line">		if err := waiter.WaitForHealthyKubelet(40*time.Second, &quot;http://localhost:10255/healthz&quot;); err != nil &#123;</div><div class="line">			errC &lt;- err</div><div class="line">		&#125;</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	go func(errC chan error, waiter apiclient.Waiter) &#123;</div><div class="line">		if err := waiter.WaitForHealthyKubelet(60*time.Second, &quot;http://localhost:10255/healthz/syncloop&quot;); err != nil &#123;</div><div class="line">			errC &lt;- err</div><div class="line">		&#125;</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	go func(errC chan error, waiter apiclient.Waiter) &#123;</div><div class="line">		errC &lt;- waiter.WaitForAPI()</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	return &lt;-errorChan</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kubeadm 会不断检查 <code>http://localhost:6443/healthz</code> 这个健康检查的接口 以及 <code>http://localhost:10255/healthz</code>, <code>http://localhost:10255/healthz/syncloop</code> 这两个 kubelet 的可读接口，等待 Master 组件完全运行起来。</p>
<h4 id="存储-ConfigMap"><a href="#存储-ConfigMap" class="headerlink" title="存储 ConfigMap"></a>存储 ConfigMap</h4><p>这一步没什么特别的，通过 api-client 把 Master 的配置上传到 Kubernetes 的 ConfigMap。代码在 <code>cmd/kubeadm/app/phases/uploadconfig/uploadconfig.go</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func UploadConfiguration(cfg *kubeadmapi.MasterConfiguration, client clientset.Interface) error &#123;</div><div class="line">	fmt.Printf(&quot;[uploadconfig] Storing the configuration used in ConfigMap %q in the %q Namespace\n&quot;, kubeadmconstants.MasterConfigurationConfigMap, metav1.NamespaceSystem)</div><div class="line"></div><div class="line">	externalcfg := &amp;kubeadmapiext.MasterConfiguration&#123;&#125;</div><div class="line">	legacyscheme.Scheme.Convert(cfg, externalcfg, nil)</div><div class="line"></div><div class="line">	externalcfg.Token = &quot;&quot;</div><div class="line"></div><div class="line">	cfgYaml, err := yaml.Marshal(*externalcfg)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return apiclient.CreateOrUpdateConfigMap(client, &amp;v1.ConfigMap&#123;</div><div class="line">		ObjectMeta: metav1.ObjectMeta&#123;</div><div class="line">			Name:      kubeadmconstants.MasterConfigurationConfigMap,</div><div class="line">			Namespace: metav1.NamespaceSystem,</div><div class="line">		&#125;,</div><div class="line">		Data: map[string]string&#123;</div><div class="line">			kubeadmconstants.MasterConfigurationConfigMapKey: string(cfgYaml),</div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 apiclient 是 kubeadm 对 api-client 的简单封装，代码在 <code>cmd/kubeadm/app/util/apiclient/idempotency.go</code></p>
<h4 id="创建-token"><a href="#创建-token" class="headerlink" title="创建 token"></a>创建 token</h4><p>生成的这个 token 让 worker 节点有权限可以拿到 cluster-info 这个 ConfigMap 里的信息，包括 api-server 的地址，认证信息等。</p>
<p>这部分代码在 <code>cmd/kubeadm/app/phases/bootstraptoken/node/token.go</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">func UpdateOrCreateToken(client clientset.Interface, token string, failIfExists bool, tokenDuration time.Duration, usages []string, extraGroups []string, description string) error &#123;</div><div class="line">	tokenID, tokenSecret, err := tokenutil.ParseToken(token)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	secretName := fmt.Sprintf(&quot;%s%s&quot;, bootstrapapi.BootstrapTokenSecretPrefix, tokenID)</div><div class="line">	var lastErr error</div><div class="line">	for i := 0; i &lt; tokenCreateRetries; i++ &#123;</div><div class="line">		secret, err := client.CoreV1().Secrets(metav1.NamespaceSystem).Get(secretName, metav1.GetOptions&#123;&#125;)</div><div class="line">		if err == nil &#123;</div><div class="line">			if failIfExists &#123;</div><div class="line">				return fmt.Errorf(&quot;a token with id %q already exists&quot;, tokenID)</div><div class="line">			&#125;</div><div class="line">			tokenSecretData, err := encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, extraGroups, description)</div><div class="line">			if err != nil &#123;</div><div class="line">				return err</div><div class="line">			&#125;</div><div class="line">			secret.Data = tokenSecretData</div><div class="line">			if _, err := client.CoreV1().Secrets(metav1.NamespaceSystem).Update(secret); err == nil &#123;</div><div class="line">				return nil</div><div class="line">			&#125;</div><div class="line">			lastErr = err</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if apierrors.IsNotFound(err) &#123;</div><div class="line">			tokenSecretData, err := encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, extraGroups, description)</div><div class="line">			if err != nil &#123;</div><div class="line">				return err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			secret = &amp;v1.Secret&#123;</div><div class="line">				ObjectMeta: metav1.ObjectMeta&#123;</div><div class="line">					Name: secretName,</div><div class="line">				&#125;,</div><div class="line">				Type: v1.SecretType(bootstrapapi.SecretTypeBootstrapToken),</div><div class="line">				Data: tokenSecretData,</div><div class="line">			&#125;</div><div class="line">			if _, err := client.CoreV1().Secrets(metav1.NamespaceSystem).Create(secret); err == nil &#123;</div><div class="line">				return nil</div><div class="line">			&#125;</div><div class="line">			lastErr = err</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	return fmt.Errorf(</div><div class="line">		&quot;unable to create bootstrap token after %d attempts [%v]&quot;,</div><div class="line">		tokenCreateRetries,</div><div class="line">		lastErr,</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 Kubernetes 的 secret 创建。</p>
<h4 id="安装-dns，kube-proxy-插件"><a href="#安装-dns，kube-proxy-插件" class="headerlink" title="安装 dns，kube-proxy 插件"></a>安装 dns，kube-proxy 插件</h4><p>dns，kube-proxy 是 Kubernetes 里默认的，必装的插件。</p>
<p>coreDNS 的 Deployment, ConfigMap, ClusterRole 等 yaml 配置直接用字符串定义在 <code>cmd/kubeadm/app/phases/addons/dns/manifests.go</code> 文件里。</p>
<p>代码基本就是根据配置渲染模板，通过 Kubernetes 的 api 创建，没什么特别的。</p>
<p>kube-proxy 的情况类似，yaml 配置在 <code>cmd/kubeadm/app/phases/addons/proxy/manifests.go</code> 文件里定义。</p>
<h3 id="kubeadm-join-1"><a href="#kubeadm-join-1" class="headerlink" title="kubeadm join"></a>kubeadm join</h3><p>join 方法跟 init 方法类似，但要简单得多，首先调用 <code>NewJoin</code>，先调用 <code>RunJoinNodeChecks</code> 来完成初始化前的检测，然后调用 <code>Run</code> 方法将本节点加入到集群里。</p>
<h4 id="系统状态检查-1"><a href="#系统状态检查-1" class="headerlink" title="系统状态检查"></a>系统状态检查</h4><p>worker 节点的 preflight checks 跟 master 节点的略微不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">checks := []Checker&#123;</div><div class="line">	SystemVerificationCheck&#123;CRISocket: cfg.CRISocket&#125;,</div><div class="line">	IsPrivilegedUserCheck&#123;&#125;,</div><div class="line">	HostnameCheck&#123;cfg.NodeName&#125;,</div><div class="line">	KubeletVersionCheck&#123;exec: execer&#125;,</div><div class="line">	ServiceCheck&#123;Service: &quot;kubelet&quot;, CheckIfActive: false&#125;,</div><div class="line">	PortOpenCheck&#123;port: 10250&#125;,</div><div class="line">	DirAvailableCheck&#123;Path: filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.ManifestsSubDirName)&#125;,</div><div class="line">	FileAvailableCheck&#123;Path: cfg.CACertPath&#125;,</div><div class="line">	// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了一些常规的检测外，worker 节点还需要确保 ip, ipables, mount 命令已经安装好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if runtime.GOOS == &quot;linux&quot; &#123;</div><div class="line">		checks = append(checks,</div><div class="line">			FileContentCheck&#123;Path: bridgenf, Content: []byte&#123;&apos;1&apos;&#125;&#125;,</div><div class="line">			SwapCheck&#123;&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;ip&quot;, mandatory: true, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;iptables&quot;, mandatory: true, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;mount&quot;, mandatory: true, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;nsenter&quot;, mandatory: true, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;ebtables&quot;, mandatory: false, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;ethtool&quot;, mandatory: false, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;socat&quot;, mandatory: false, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;tc&quot;, mandatory: false, exec: execer&#125;,</div><div class="line">			InPathCheck&#123;executable: &quot;touch&quot;, mandatory: false, exec: execer&#125;,</div><div class="line">			criCtlChecker)</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func (j *Join) Run(out io.Writer) error &#123;</div><div class="line">	cfg, err := discovery.For(j.cfg)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	kubeconfigFile := filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.KubeletBootstrapKubeConfigFileName)</div><div class="line"></div><div class="line">	if err := kubeconfigutil.WriteToDisk(kubeconfigFile, cfg); err != nil &#123;</div><div class="line">		return fmt.Errorf(&quot;couldn&apos;t save bootstrap-kubelet.conf to disk: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	cluster := cfg.Contexts[cfg.CurrentContext].Cluster</div><div class="line">	err = certutil.WriteCert(j.cfg.CACertPath, cfg.Clusters[cluster].CertificateAuthorityData)</div><div class="line">	if err != nil &#123;</div><div class="line">		return fmt.Errorf(&quot;couldn&apos;t save the CA certificate to disk: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if features.Enabled(j.cfg.FeatureGates, features.DynamicKubeletConfig) &#123;</div><div class="line">		if err := kubeletphase.ConsumeBaseKubeletConfiguration(j.cfg.NodeName); err != nil &#123;</div><div class="line">			return fmt.Errorf(&quot;error consuming base kubelet configuration: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Fprintf(out, joinDoneMsgf)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>join 命令会调用 <code>func (j *Join) Run(out io.Writer) error</code> 方法，先根据 token 获取 <code>cluster-info</code> 里的信息，写入 <code>bootstrap-kubelet.conf</code> 文件，然后向 Master 提交一个 certificate signing request (CSR)，通过后 worker 节点保存 <code>ca.crt</code> 和 <code>kubelet.conf</code> 文件，<code>bootstrap-kubelet.conf</code> 会被删除，这时应用 <code>kubelet.conf</code> 本节点就加入了集群。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kubeadm 是 Kubernetes 项目的原生部署工具，使用 kubeadm 部署一个 Kubernetes 集群，对于理解 Kubernetes 组件的架构很有帮助。从实现来看，kubeadm 简洁明了，对于最新版的 Kubernetes 支持很好，而且和 k8s 一样是用 Golang 写的，只需要运行一个二进制文件就行，很轻便。深入代码，我们会发现 kubeadm 完全没有如何考虑部署高可用的 Kubernetes 集群，比如创建 kube-proxy 不能配置 kube-apiserver 的地址；运行 kubeadm join 时不能对 kube-apiserver 地址进行配置。几乎没有实现高可用的扩展性，这一功能的缺失使得整个社区诞生了很多的更复杂的部署工具，有的基于 Ansible，有的是提供了一堆 shell 脚本，还有的基于 kubeadm 做修改，有的甚至用 Golang 重新写了一套部署工具，百花齐放，只是质量参差不齐，光是调研这些工具就需要很多成本和精力。值得期待的是，kubeadm 在往『部署高可用集群』这个方向努力，等到这个特性稳定之后有机会我们再研读一下代码。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/knarfeh/k8s-digitalocean-terraform" target="_blank" rel="external">knarfeh/k8s-digitalocean-terraform</a></li>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="external">Creating a single master cluster with kubeadm</a></li>
<li><a href="https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md" target="_blank" rel="external">kubeadm design_v1.10</a></li>
<li><a href="https://www.youtube.com/watch?v=YCOWQIFVAbg" target="_blank" rel="external">kubeadm Cluster Creation Internals: From Self-Hosting to Upgradability and HA [A] - Lucas Käldström</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Kubernetes 发展初期，部署 Kubernetes 一直是一件让初学者头疼的事情，Kubernetes 也开始重视这个问题，2017年，在社区志愿者的推动下，社区发起了一个独立的部署 Kubernetes 的项目，&lt;a href=&quot;https://github.com/kubernetes/kubeadm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kubeadm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;经过一年多的发展，kubeadm 已经可以一键式进行 Kubernetes 集群的快速初始化和安装，极大地简化了部署过程。值得一提的是，在很长一段时间里 kubeadm 有个比较欠缺的地方是无法做到一键部署一个高可用的 Kubernetes 集群，这是 kubeadm 目前的工作重点，好在这个功能已经在 1.11 版本刚刚发布，可以参考 &lt;a href=&quot;https://kubernetes.io/docs/setup/independent/high-availability/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Creating Highly Available Clusters with kubeadm&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Telegram Bot 的长轮询 VS Webhook</title>
    <link href="http://knarfeh.github.io/2018/03/20/Telegram%20Bot%20%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2%20VS%20Webhook/"/>
    <id>http://knarfeh.github.io/2018/03/20/Telegram Bot 的长轮询 VS Webhook/</id>
    <published>2018-03-20T01:42:59.000Z</published>
    <updated>2018-09-04T16:58:36.856Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th></th>
<th>长轮询（long polling）</th>
<th>Webhook</th>
</tr>
</thead>
<tbody>
<tr>
<td>简述</td>
<td>利用 API 中的 getUpdates 方法， 如果 Bot <strong>上次标记完成后</strong>没有收到信息，或消息已保存超过24小时，该方法会保持等待直到超时，在等待期间收到信息将会立刻返回结果；反之，该方法会返回一组包含了24小时内所有未标记信息的 Updates。利用 offset 参数可以将部分消息标记为已处理。</td>
<td>利用  setWebhook 方法告知服务器一个 url， 服务器将会在收到新消息时，通过 POST 方法将 json 格式的 Update 对象发送到指定的 url 地址。如果发送失败，Telegram 会重试一定次数。这个 url 必须是 https 的。</td>
</tr>
<tr>
<td>性能</td>
<td>没法做负载均衡，数据量比较大的情况话，性能瓶颈可能出现在 worker 上。</td>
<td>与传统服务器没有太大差异，可以做负载均衡（高可用），可以横向扩展。未来可以对接 Serverless，可扩展性更强</td>
</tr>
<tr>
<td>开发效率</td>
<td>不需要搭建服务器，不需要处理 https 证书，有一个机器人的 token 就可以在本地开发</td>
<td>在不搭建服务器的情况下，可以用 google script 开发，但只能用类 Javascript 语言。如果要用其他语言开发，需搭建服务器，需 https</td>
</tr>
<tr>
<td>交互体验</td>
<td>响应速度较 Webhook 慢</td>
<td>响应速度取决于网络延迟，体验一般比长轮询好</td>
</tr>
</tbody>
</table>
<p>结论：如果追求开发速度，并且不需要考虑服务的高可用性，在可预知用户量不会增长过快的情况下，建议使用长轮询的方式，未来用户增长比较多再改也来得及，否则用 Webhook 的方式。如果对交互体验要求高的话，最好采用 Webhook 的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;长轮询（long polling）&lt;/th&gt;
&lt;th&gt;Webhook&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简述&lt;/td&gt;
&lt;td&gt;利用 API 中的 getUpdates 
    
    </summary>
    
    
      <category term="Telegram" scheme="http://knarfeh.github.io/tags/Telegram/"/>
    
      <category term="robot" scheme="http://knarfeh.github.io/tags/robot/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E9%93%BE%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/</id>
    <published>2018-03-10T14:35:09.000Z</published>
    <updated>2018-10-27T03:49:03.940Z</updated>
    
    <content type="html"><![CDATA[<p>阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="事件和日志"><a href="#事件和日志" class="headerlink" title="事件和日志"></a>事件和日志</h3><p>在以太坊中，事件和日志的概念经常被混用可能会让人觉得困惑，所以我们先理清这两者关系。在 Solidity 和 web3.js 里，这个概念叫做 Event，常用中文翻译是事件，它的作用是在智能合约的运行中，将一些比较重要的数据记录到区块链上，在 geth 里称为日志，这些日志与合约地址是相关联的，geth 会不断地对事件，或者说日志进行索引，也会通过暴露 API 的方式让用户可以过滤，查找日志。比较典型的应用场景是，用户在页面上调用了智能合约，在智能合约里发生了一次转账的操作，这时记录一个事件，应用程序通过 web3.js 监听事件，一旦事件发生了，可以触发回调函数，进行下一步处理，比如在 UI 上做出响应。</p>
<p>每一笔交易的收据可能会包含0个到多个日志记录，它们代表着智能合约在运行过程中触发的事件。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>在 geth 中，日志的索引，过滤通过布隆过滤器来实现。</p>
<p>布隆过滤器可以用来判断一个元素是否在一个集合中，对于这种场景，最简单的方式是采用 HashTable 的方式来存储，好处是快速，精确，但会耗费大量的存储空间。1970年布隆提出一种空间复杂度和空间复杂度都很低的数据结构，利用位数组来表示一个集合，键值经过 k 个独立哈希函数后，将对应的值的位数置1，查找时进行同样的哈希计算，如果对应位全为1说明该值存在，它的缺点是有一定的错误率，它不能告诉你某个元素一定在集合内，但它可以告诉你某个元素一定不在集合内或可能在集合内。误算率的大小与数据的数量，布隆过滤器的长度，以及哈希函数有关。</p>
<p>如果想要深入了解布隆过滤器，建议浏览：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a> </li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
</ul>
<h4 id="误算率推导"><a href="#误算率推导" class="headerlink" title="误算率推导"></a>误算率推导</h4><p>假设布隆过滤器有 m 比特，里面有 n 个元素，每个元素对应 k 个哈希函数处理后的比特位，插入一个元素时，哈希函数会把过滤器中的某个比特位置置为1，对于一个特定的位置，如果这个元素经哈希过的 k 个比特位都没有把它置为 1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^k$</p>
<p>如果插入了 n 个元素还没有把某个特定的比特位置为1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>因此，插入了 n 个元素，某个特定比特位置为1的概率为：</p>
<p>$1-\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>对于一个错误识别的元素，经哈希过的 k 个比特位均为1，概率为：</p>
<p>$\left(1-\left[1-\frac{1}{m}\right]^{kn}\right)^k$</p>
<p>有 $\lim_{x\to0}\frac{e^x-1}{x}=1$ ，则 $m\to\infty$时，上述公式近似于：</p>
<p>$\left( 1-e^{\frac{-kn}{m}} \right)^k$</p>
<p>设 $a=e^{\frac{n}{m}}$, 错误识别的概率为：</p>
<p>$f(k) = (1-a^{-k})^{k}$</p>
<p>我们需要知道，在 k 取什么值时，$f(k)$ 可以取到最值。先两边取对数：</p>
<p>$\frac{f’(k)}{f(k)}=\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}$</p>
<p>令导数 $f’(k)$为0，有：</p>
<p>$\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}=0$</p>
<p>$(1-a^{-k})\cdot\ln\left(1-a^{-k}\right)=a^{-k}\cdot\ln{a}^{-k}$</p>
<p>对于 $f(x)=xlnx$，可证，不存在 $x_1+x_2=1$，使得 $f(x_1) = f(x_2)$</p>
<p>可得 $a^{k}=2$</p>
<p>即 $k=\frac{m}{n}\cdot ln{2}$ 时，误判率 $f(k)$ 可取到最小值，为 $2^{-ln 2\cdot\frac{m}{n}}$</p>
<p>还有一个结论，当 $k=\frac{m}{n}\cdot ln{2}$，$\left(1-\frac{1}{m}\right)^{kn}=\frac{1}{2}$ 也就是说某个 bit 位在插入 n 个元素后未被置1的概率为 $\frac{1}{2}$，即空间使用率为 50%，也就是说，要保持错误率低，布隆过滤器的空间使用率应小于 50%。根据空间使用率，我们可以推导 n，k 确定的情况下，要保持错误率最低，所需的最小内存空间（即 m 的大小）是多少，这个值应该为 n*k 的两倍。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>Bigtable 使用布隆过滤器查找不存在的行或列，以减少磁盘查找的 IO 次数</li>
<li>Google Chrome 浏览器使用布隆过滤器加速安全浏览服务</li>
<li>LevelDB, Hbase, Accumulo 等 key-value 数据库使用布隆过滤器加速查询过程，避免很多不必要的磁盘 IO 操作</li>
</ul>
<h2 id="geth-的实现"><a href="#geth-的实现" class="headerlink" title="geth 的实现"></a>geth 的实现</h2><p>geth 的索引，过滤功能包括对交易，区块，区块头，最新日志，特定日志的过滤，代码涉及到 <code>eth/filters</code>, <code>eth/bloombits.go</code>, <code>core/chain_indexer.go</code>, <code>core/bloombits</code> 等模块。内部的实现其实挺复杂，重构一下可能会好很多，深入到这些功能的实现，还是要有章法，采用从上之下的方式是比较好的，否则直接阅读内部实现的话，可能线索会比较错乱，不如先从 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 提供的几个 API 入手，从入口开始剖析。geth 的索引过滤功能底层的实现主要依赖布隆过滤器，读者如果在阅读下文之前就熟悉布隆过滤器自然再好不过，不了解的话可以先从 API 调用入手，在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%EF%BC%89/#%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="external">过滤功能的使用</a>这小节结束后再好好学习相关基础知识以加强理解。</p>
<h3 id="过滤功能的使用"><a href="#过滤功能的使用" class="headerlink" title="过滤功能的使用"></a>过滤功能的使用</h3><p>这里指的使用是指比较高层次的，通过 web3.js 可以直接进行交互的调用。</p>
<p>使用布隆过滤器的代码主要在 <code>eth/filter</code> 文件夹里。</p>
<p><code>eth/filter</code> 模块比较直观地提供了日志过滤的功能，这里我们可以先将布隆过滤器的实现视为黑盒，看看所谓的日志，收据的过滤到底是一个什么功能。</p>
<p>先看 <code>eth/filters/api.go</code> 里的内容。</p>
<h4 id="api-go"><a href="#api-go" class="headerlink" title="api.go"></a>api.go</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> filter <span class="keyword">struct</span> &#123;</div><div class="line">	typ      Type</div><div class="line">	deadline *time.Timer</div><div class="line">	hashes   []common.Hash</div><div class="line">	crit     FilterCriteria</div><div class="line">	logs     []*types.Log</div><div class="line">	s        *Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> PublicFilterAPI <span class="keyword">struct</span> &#123;</div><div class="line">	backend   Backend</div><div class="line">	mux       *event.TypeMux</div><div class="line">	quit      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	chainDb   ethdb.Database</div><div class="line">	events    *EventSystem</div><div class="line">	filtersMu sync.Mutex</div><div class="line">	filters   <span class="keyword">map</span>[rpc.ID]*filter</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>filter</code> 结构体用来存储过滤器的一些元信息，<code>PublicFilterAPI</code> 用来创建和管理这些过滤器，供外部客户端调用，它暴露的 API 在 Backend 里定义，这部分内容在 <code>eth/filters/filter.go</code> 里面，在之后会详细看这部分。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><code>PublicFilterAPI</code> 初始化的逻辑很简单，就一个 New 外加 <code>go api.timeoutLoop()</code> 一行而已，这里不再给出初始化的代码了。由于需要注册 API，同其他 backend 一样，调用 <code>NewPublicFilterAPI</code> 进行服务注册的部分在 <code>eth/backend.go</code> 中，有兴趣的话读者可以自己看看。</p>
<h5 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">timeoutLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	ticker := time.NewTicker(<span class="number">5</span> * time.Minute)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		&lt;-ticker.C</div><div class="line">		api.filtersMu.Lock()</div><div class="line">		<span class="keyword">for</span> id, f := <span class="keyword">range</span> api.filters &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-f.deadline.C:</div><div class="line">				f.s.Unsubscribe()</div><div class="line">				<span class="built_in">delete</span>(api.filters, id)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		api.filtersMu.Unlock()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PublicFilterAPI</code> 初始化时只用了一个 goroutine 来启动 <code>timeoutLoop()</code>，<code>timeoutLoop()</code> 做的事情很简单，对于加入到 <code>PublicFilterAPI</code> 的 filters，每过5分钟检查一次，如果过期了就删除 filter。</p>
<h5 id="增加-filter"><a href="#增加-filter" class="headerlink" title="增加 filter"></a>增加 filter</h5><p><code>PublicFilterAPI</code> 的主循环会处理 <code>filter</code>，那么 <code>filter</code> 是怎么添加的，其实是通过 <code>NewPendingTransactionFilter</code> 来添加，这个 API 也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 直接调用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactionFilter</span><span class="params">()</span> <span class="title">rpc</span>.<span class="title">ID</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		pendingTxs   = <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash)</div><div class="line">		pendingTxSub = api.events.SubscribePendingTxs(pendingTxs)</div><div class="line">	)</div><div class="line"></div><div class="line">	api.filtersMu.Lock()</div><div class="line">	api.filters[pendingTxSub.ID] = &amp;filter&#123;typ: PendingTransactionsSubscription, deadline: time.NewTimer(deadline), hashes: <span class="built_in">make</span>([]common.Hash, <span class="number">0</span>), s: pendingTxSub&#125;</div><div class="line">	api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> ph := &lt;-pendingTxs:</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="keyword">if</span> f, found := api.filters[pendingTxSub.ID]; found &#123;</div><div class="line">					f.hashes = <span class="built_in">append</span>(f.hashes, ph...)</div><div class="line">				&#125;</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">			<span class="keyword">case</span> &lt;-pendingTxSub.Err():</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="built_in">delete</span>(api.filters, pendingTxSub.ID)</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> pendingTxSub.ID</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于非长连接的情况，也就是说对于使用 HTTP 的方式进行过滤的情况，可以使用这个 API，它可以用来创建一个 filter，当有新交易时，会存储到 filter 的哈希池里。</p>
<p>然后客户端可以通过轮询该 filter 来获取过滤的结果。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetFilterChanges</span><span class="params">(id rpc.ID)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	api.filtersMu.Lock()</div><div class="line">	<span class="keyword">defer</span> api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f, found := api.filters[id]; found &#123;</div><div class="line">		<span class="keyword">if</span> !f.deadline.Stop() &#123;</div><div class="line">			&lt;-f.deadline.C</div><div class="line">		&#125;</div><div class="line">		f.deadline.Reset(deadline)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> f.typ &#123;</div><div class="line">		<span class="keyword">case</span> PendingTransactionsSubscription, BlocksSubscription:</div><div class="line">			hashes := f.hashes</div><div class="line">			f.hashes = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnHashes(hashes), <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> LogsSubscription:</div><div class="line">			logs := f.logs</div><div class="line">			f.logs = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnLogs(logs), <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;, fmt.Errorf(<span class="string">"filter not found"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterchanges" target="_blank" rel="external">JSON-RPC</a> 进行调用。</p>
<p>对于长连接的情况，可以使用 rpc 包的发送订阅模式功能，直接调用 <code>NewPendingTransactions</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactions</span><span class="params">(ctx context.Context)</span> <span class="params">(*rpc.Subscription, error)</span></span> &#123;</div><div class="line">	notifier, supported := rpc.NotifierFromContext(ctx)</div><div class="line">	<span class="keyword">if</span> !supported &#123;</div><div class="line">		<span class="keyword">return</span> &amp;rpc.Subscription&#123;&#125;, rpc.ErrNotificationsUnsupported</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	rpcSub := notifier.CreateSubscription()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		txHashes := <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash, <span class="number">128</span>)</div><div class="line">		pendingTxSub := api.events.SubscribePendingTxs(txHashes)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> hashes := &lt;-txHashes:</div><div class="line">				<span class="keyword">for</span> _, h := <span class="keyword">range</span> hashes &#123;</div><div class="line">					notifier.Notify(rpcSub.ID, h)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> &lt;-rpcSub.Err():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-notifier.Closed():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> rpcSub, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是对交易的过滤，此外 <code>PublicFilterAPI</code> 还提供了对区块，区块头，最新日志的过滤，如果有兴趣的话可以看 <code>func (api *PublicFilterAPI) NewBlockFilter()</code>, <code>func (api *PublicFilterAPI) NewHeads</code>, <code>func (api *PublicFilterAPI) Logs</code> 这几个方法的实现。这些只是交易，区块等内容的过滤，对于获取特定条件的日志的功能则在 <code>NewFilter</code>, <code>GetLogs</code>, <code>GetFilterLogs</code>, <code>GetFilterChanges</code> 这几个方法的帮助下完成。比如 <code>GetLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetLogs</span><span class="params">(ctx context.Context, crit FilterCriteria)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filter *Filter</div><div class="line">	<span class="keyword">if</span> crit.BlockHash != <span class="literal">nil</span> &#123;</div><div class="line">		filter = NewBlockFilter(api.backend, *crit.BlockHash, crit.Addresses, crit.Topics)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		begin := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.FromBlock != <span class="literal">nil</span> &#123;</div><div class="line">			begin = crit.FromBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		end := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.ToBlock != <span class="literal">nil</span> &#123;</div><div class="line">			end = crit.ToBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		filter = NewRangeFilter(api.backend, begin, end, crit.Addresses, crit.Topics)</div><div class="line">	&#125;</div><div class="line">	logs, err := filter.Logs(ctx)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> returnLogs(logs), err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以根据开始区块，结束区块，地址，Topics 来获取符合条件的日志。可以看到获取日志主要通过 filter 的 Logs 方法得到，这就引入了 Filter 对象，这部分内容在 <code>eth/filters/filter.go</code> 里。</p>
<h4 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h4><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</div><div class="line">	ChainDb() ethdb.Database</div><div class="line">	EventMux() *event.TypeMux</div><div class="line">	HeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Header, error)</div><div class="line">	GetReceipts(ctx context.Context, blockHash common.Hash) (types.Receipts, error)</div><div class="line">	GetLogs(ctx context.Context, blockHash common.Hash) ([][]*types.Log, error)</div><div class="line"></div><div class="line">	SubscribeNewTxsEvent(<span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- core.ChainEvent) event.Subscription</div><div class="line">	SubscribeRemovedLogsEvent(ch <span class="keyword">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</div><div class="line">	SubscribeLogsEvent(ch <span class="keyword">chan</span>&lt;- []*types.Log) event.Subscription</div><div class="line"></div><div class="line">	BloomStatus() (<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</div><div class="line">	ServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter <span class="keyword">struct</span> &#123;</div><div class="line">	backend Backend</div><div class="line"></div><div class="line">	db         ethdb.Database</div><div class="line">	begin, end <span class="keyword">int64</span></div><div class="line">	addresses  []common.Address</div><div class="line">	topics     [][]common.Hash</div><div class="line"></div><div class="line">	matcher *bloombits.Matcher</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 结构体中定义了 <code>Backend</code> 接口，<code>Backend</code> 接口定义了布隆过滤器实现的接口，这些接口的实现是在 <code>eth/api_backend.go</code> 里的 L212-234，可以说是比较低层次的 API。而 Matcher 是布隆过滤器的 Matcher，这部分我们将在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#Matcher" target="_blank" rel="external">Matcher</a> 进行分析</p>
<h5 id="Filter-的初始化"><a href="#Filter-的初始化" class="headerlink" title="Filter 的初始化"></a>Filter 的初始化</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(backend Backend, begin, end <span class="keyword">int64</span>, addresses []common.Address, topics [][]common.Hash)</span> *<span class="title">Filter</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filters [][][]<span class="keyword">byte</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(addresses))</div><div class="line">		<span class="keyword">for</span> i, address := <span class="keyword">range</span> addresses &#123;</div><div class="line">			filter[i] = address.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, topicList := <span class="keyword">range</span> topics &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(topicList))</div><div class="line">		<span class="keyword">for</span> i, topic := <span class="keyword">range</span> topicList &#123;</div><div class="line">			filter[i] = topic.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	size, _ := backend.BloomStatus()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;Filter&#123;</div><div class="line">		backend:   backend,</div><div class="line">		begin:     begin,</div><div class="line">		end:       end,</div><div class="line">		addresses: addresses,</div><div class="line">		topics:    topics,</div><div class="line">		db:        backend.ChainDb(),</div><div class="line">		matcher:   bloombits.NewMatcher(size, filters),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 Filter 的参数中包含 addresses 或 topics，则都将其加入到 filters 容器中，在 matcher 的阶段会用到。</p>
<h5 id="过滤日志"><a href="#过滤日志" class="headerlink" title="过滤日志"></a>过滤日志</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">Logs</span><span class="params">(ctx context.Context)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	header, _ := f.backend.HeaderByNumber(ctx, rpc.LatestBlockNumber)</div><div class="line">	<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	head := header.Number.Uint64()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f.begin == <span class="number">-1</span> &#123;</div><div class="line">		f.begin = <span class="keyword">int64</span>(head)</div><div class="line">	&#125;</div><div class="line">	end := <span class="keyword">uint64</span>(f.end)</div><div class="line">	<span class="keyword">if</span> f.end == <span class="number">-1</span> &#123;</div><div class="line">		end = head</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		logs []*types.Log</div><div class="line">		err  error</div><div class="line">	)</div><div class="line">	size, sections := f.backend.BloomStatus()</div><div class="line">	<span class="keyword">if</span> indexed := sections * size; indexed &gt; <span class="keyword">uint64</span>(f.begin) &#123;</div><div class="line">		<span class="keyword">if</span> indexed &gt; end &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, end)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, indexed<span class="number">-1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	rest, err := f.unindexedLogs(ctx, end)</div><div class="line">	logs = <span class="built_in">append</span>(logs, rest...)</div><div class="line">	<span class="keyword">return</span> logs, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Logs</code> 会从区块链中找到匹配的 log 项。首先根据最新的区块号拿到最新区块，这样如果没有 end 参数的，搜索的区间的 end 就是最新区块。接着调用 <code>BloomStatus()</code> 拿到索引的状态，需要注意的是，尽管每个区块头都有 logBloom，日志的过滤不会直接依次检索这些区块头的 logBloom，因为遍历区块头的话效率太低了，需要多次的磁盘 IO，geth 会在 LevelDB 里维护另一套索引，以4096个区块为一个 section，在一个 section 内的 logBloom 会存在一起，所以对于位于已索引的区块这一区间的搜索，会调用 <code>indexedLogs</code> 进行搜索，对于在已索引区间外的区块，会调用 <code>unindexedLogs</code> 进行搜索。我们先看 <code>indexedLogs</code> 的实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">indexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	matches := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="number">64</span>)</div><div class="line">	session, err := f.matcher.Start(ctx, <span class="keyword">uint64</span>(f.begin), end, matches)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line">	f.backend.ServiceFilter(ctx, session)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> number, ok := &lt;-matches:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				err := session.Error()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">					f.begin = <span class="keyword">int64</span>(end) + <span class="number">1</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			f.begin = <span class="keyword">int64</span>(number) + <span class="number">1</span></div><div class="line">			header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(number))</div><div class="line">			<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">			<span class="keyword">return</span> logs, ctx.Err()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>indexedLogs</code> 会调用 <code>Matcher 的 Start</code> 方法启动 session，其结果会返回到 matches 这个 channel 里，找到区块后，通过调用 <code>checkMatches</code> 以验证该区块确实在区块链中（因为布隆过滤器有一定几率误判），验证完成后，结果会增加到 logs 这个变量中，直到接收到 Done 消息，然后返回 logs。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">checkMatches</span><span class="params">(ctx context.Context, header *types.Header)</span> <span class="params">(logs []*types.Log, err error)</span></span> &#123;</div><div class="line">	logsList, err := f.backend.GetLogs(ctx, header.Hash())</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> unfiltered []*types.Log</div><div class="line">	<span class="keyword">for</span> _, logs := <span class="keyword">range</span> logsList &#123;</div><div class="line">		unfiltered = <span class="built_in">append</span>(unfiltered, logs...)</div><div class="line">	&#125;</div><div class="line">	logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> logs[<span class="number">0</span>].TxHash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			receipts, err := f.backend.GetReceipts(ctx, header.Hash())</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			unfiltered = unfiltered[:<span class="number">0</span>]</div><div class="line">			<span class="keyword">for</span> _, receipt := <span class="keyword">range</span> receipts &#123;</div><div class="line">				unfiltered = <span class="built_in">append</span>(unfiltered, receipt.Logs...)</div><div class="line">			&#125;</div><div class="line">			logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>checkMatches</code> 做的事情简单来说就是根据 <code>header</code> 的哈希值，从 <code>backend</code> 拿到所有的收据，然后调用 <code>filterLogs</code> 对 topics 一一进行匹配，匹配上了则可以确定该 logs 确实在区块链中（布隆过滤器没有误判）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterLogs</span><span class="params">(logs []*types.Log, fromBlock, toBlock *big.Int, addresses []common.Address, topics [][]common.Hash)</span> []*<span class="title">types</span>.<span class="title">Log</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> ret []*types.Log</div><div class="line">Logs:</div><div class="line">	<span class="keyword">for</span> _, log := <span class="keyword">range</span> logs &#123;</div><div class="line">		<span class="keyword">if</span> fromBlock != <span class="literal">nil</span> &amp;&amp; fromBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; fromBlock.Uint64() &gt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> toBlock != <span class="literal">nil</span> &amp;&amp; toBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; toBlock.Uint64() &lt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &amp;&amp; !includes(addresses, log.Address) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(topics) &gt; <span class="built_in">len</span>(log.Topics) &#123;</div><div class="line">			<span class="keyword">continue</span> Logs</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> i, topics := <span class="keyword">range</span> topics &#123;</div><div class="line">			fmt.Println(topics)</div><div class="line">			match := <span class="built_in">len</span>(topics) == <span class="number">0</span></div><div class="line">			<span class="keyword">for</span> _, topic := <span class="keyword">range</span> topics &#123;</div><div class="line">				<span class="keyword">if</span> log.Topics[i] == topic &#123;</div><div class="line">					match = <span class="literal">true</span></div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !match &#123;</div><div class="line">				<span class="keyword">continue</span> Logs</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ret = <span class="built_in">append</span>(ret, log)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>filterLogs</code> 方法的逻辑很简单，遍历 <code>topics</code>，如果能和 log 中的 Topics 匹配上则添加到需返回的 logs 中。</p>
<p><code>indexedLogs</code> 方法是对有索引的日志的查询，前面有介绍到在 Logs 方法中，还有一个对未索引日志的查询，即 <code>unindexedLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">unindexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> logs []*types.Log</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ; f.begin &lt;= <span class="keyword">int64</span>(end); f.begin++ &#123;</div><div class="line">		header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(f.begin))</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomFilter(header.Bloom, f.addresses, f.topics) &#123;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会根据传入的 <code>end</code>，遍历所有区块，首先通过 header 的 Bloom 判断 topics 是否可能存在，如果有可能存在，直接调用 <code>checkMatches</code> 来查看是否匹配。至此通过对已索引，未索引的日志进行过滤，就可以通过条件获取特定的日志。</p>
<p>以上就是对 geth 过滤功能的概览，可以说是过滤功能的高层次调用，接下来我们将深入这些模块的实现。</p>
<h3 id="创建索引的实现"><a href="#创建索引的实现" class="headerlink" title="创建索引的实现"></a>创建索引的实现</h3><p>要实现布隆过滤器，首先需要给区块链创建索引，这样才能实现快速响应用户的日志搜索功能。这部分代码主要在 <code>core/chain_indexer</code> 模块里。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChainIndexerBackend <span class="keyword">interface</span> &#123;</div><div class="line">	Reset(section <span class="keyword">uint64</span>, prevHead common.Hash) error</div><div class="line">	Process(header *types.Header)</div><div class="line">	Commit() error</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> ChainIndexerChain <span class="keyword">interface</span> &#123;</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- ChainEvent) event.Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ChainIndexer <span class="keyword">struct</span> &#123;</div><div class="line">	chainDb  ethdb.Database</div><div class="line">	indexDb  ethdb.Database</div><div class="line">	backend  ChainIndexerBackend</div><div class="line">	children []*ChainIndexer</div><div class="line"></div><div class="line">	active <span class="keyword">uint32</span></div><div class="line">	update <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	quit   <span class="keyword">chan</span> <span class="keyword">chan</span> error</div><div class="line"></div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	confirmsReq <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	storedSections <span class="keyword">uint64</span></div><div class="line">	knownSections  <span class="keyword">uint64</span></div><div class="line">	cascadedHead   <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	throttling time.Duration</div><div class="line"></div><div class="line">	log  log.Logger</div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要了解一些定义，这部分代码中经常出现的 section 是指一组区块头，而这个一组的数量默认为 4096。</p>
<p><code>ChainIndexerBackend</code> 是一个接口，它定义了处理区块链 section 的方法，这个接口目前有 <code>BloomIndexer</code> 这个实现。其中 <code>Reset(section uint64)</code> 用来初始化一个新的区块链 section，可能会终止任何没有完成的操作；<code>Process(header *types.Header)</code> 对区块链 section 中的下一个区块头进行处理，增加新区块头到 index，调用者需要确保区块头的连续顺序；<code>Commit() error</code> 完成区块链 section 的元数据提交，并将其存储到数据库。</p>
<p>以下是 <code>ChainIndexer</code> 结构体中较重要的一些属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">chainDb</td>
<td style="text-align:center">区块链所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">indexDb</td>
<td style="text-align:center">索引所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">backend</td>
<td style="text-align:center">生成索引的后端，它实现了 <code>ChainIndexerBacken</code> 所定义的接口，这里的实现我们只探讨 <code>eth/bloombits</code> 中的 BloomIndexer，在 light 模式中有其他实现</td>
</tr>
<tr>
<td style="text-align:center">children</td>
<td style="text-align:center">子链的索引，这是为了处理临时分叉的情况</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">事件循环是否开始的标志</td>
</tr>
<tr>
<td style="text-align:center">update</td>
<td style="text-align:center">新生成区块头发送到这个 channel</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">退出事件循环的 channel</td>
</tr>
<tr>
<td style="text-align:center">sectionSize</td>
<td style="text-align:center">索引器会一组一组处理区块头，默认的大小是 4096</td>
</tr>
<tr>
<td style="text-align:center">confirmReq</td>
<td style="text-align:center">处理完成的 section 之前的确认次数</td>
</tr>
<tr>
<td style="text-align:center">storedSections</td>
<td style="text-align:center">已经成功进行索引的 section 的数量</td>
</tr>
<tr>
<td style="text-align:center">knownSections</td>
<td style="text-align:center">已知的 section 数量</td>
</tr>
<tr>
<td style="text-align:center">cascadedHead</td>
<td style="text-align:center">级联到子索引最后一个完成的 section 的区块数</td>
</tr>
<tr>
<td style="text-align:center">throttling</td>
<td style="text-align:center">对磁盘的限制，防止大量区块进行索引</td>
</tr>
</tbody>
</table>
<h4 id="初始化-ChainIndexer"><a href="#初始化-ChainIndexer" class="headerlink" title="初始化 ChainIndexer"></a>初始化 ChainIndexer</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChainIndexer</span><span class="params">(chainDb, indexDb ethdb.Database, backend ChainIndexerBackend, section, confirm <span class="keyword">uint64</span>, throttling time.Duration, kind <span class="keyword">string</span>)</span> *<span class="title">ChainIndexer</span></span> &#123;</div><div class="line">	c := &amp;ChainIndexer&#123;</div><div class="line">		chainDb:     chainDb,</div><div class="line">		indexDb:     indexDb,</div><div class="line">		backend:     backend,</div><div class="line">		update:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</div><div class="line">		quit:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error),</div><div class="line">		sectionSize: section,</div><div class="line">		confirmsReq: confirm,</div><div class="line">		throttling:  throttling,</div><div class="line">		log:         log.New(<span class="string">"type"</span>, kind),</div><div class="line">	&#125;</div><div class="line">	c.loadValidSections()</div><div class="line">	<span class="keyword">go</span> c.updateLoop()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化 <code>ChainIndexer</code> 时，先调用 <code>loadValidSections</code>，从数据库中加载之前处理过的信息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">loadValidSections</span><span class="params">()</span></span> &#123;</div><div class="line">	data, _ := c.indexDb.Get([]<span class="keyword">byte</span>(<span class="string">"count"</span>))</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">8</span> &#123;</div><div class="line">		c.storedSections = binary.BigEndian.Uint64(data[:])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来会以一个 goroutine 的方式进入一个事件循环，它会调用 backend 处理区块链 section。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">updateLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		updating <span class="keyword">bool</span></div><div class="line">		updated  time.Time</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> errc := &lt;-c.quit:</div><div class="line">			errc &lt;- <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-c.update:</div><div class="line">			c.lock.Lock()</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				<span class="keyword">if</span> time.Since(updated) &gt; <span class="number">8</span>*time.Second &#123;</div><div class="line">					<span class="keyword">if</span> c.knownSections &gt; c.storedSections+<span class="number">1</span> &#123;</div><div class="line">						updating = <span class="literal">true</span></div><div class="line">						c.log.Info(<span class="string">"Upgrading chain index"</span>, <span class="string">"percentage"</span>, c.storedSections*<span class="number">100</span>/c.knownSections)</div><div class="line">					&#125;</div><div class="line">					updated = time.Now()</div><div class="line">				&#125;</div><div class="line">				section := c.storedSections</div><div class="line">				<span class="keyword">var</span> oldHead common.Hash</div><div class="line">				<span class="keyword">if</span> section &gt; <span class="number">0</span> &#123;</div><div class="line">					oldHead = c.SectionHead(section - <span class="number">1</span>)</div><div class="line">				&#125;</div><div class="line">				c.lock.Unlock()</div><div class="line">				newHead, err := c.processSection(section, oldHead)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					c.log.Error(<span class="string">"Section processing failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">				&#125;</div><div class="line">				c.lock.Lock()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; oldHead == c.SectionHead(section<span class="number">-1</span>) &#123;</div><div class="line">					c.setSectionHead(section, newHead)</div><div class="line">					c.setValidSections(section + <span class="number">1</span>)</div><div class="line">					<span class="keyword">if</span> c.storedSections == c.knownSections &amp;&amp; updating &#123;</div><div class="line">						updating = <span class="literal">false</span></div><div class="line">						c.log.Info(<span class="string">"Finished upgrading chain index"</span>)</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					c.cascadedHead = c.storedSections*c.sectionSize - <span class="number">1</span></div><div class="line">					<span class="keyword">for</span> _, child := <span class="keyword">range</span> c.children &#123;</div><div class="line">						c.log.Trace(<span class="string">"Cascading chain index update"</span>, <span class="string">"head"</span>, c.cascadedHead)</div><div class="line">						child.newHead(c.cascadedHead, <span class="literal">false</span>)</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					c.log.Debug(<span class="string">"Chain index processing failed"</span>, <span class="string">"section"</span>, section, <span class="string">"err"</span>, err)</div><div class="line">					c.knownSections = c.storedSections</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				time.AfterFunc(c.throttling, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> c.update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</div><div class="line">					<span class="keyword">default</span>:</div><div class="line">					&#125;</div><div class="line">				&#125;)</div><div class="line">			&#125;</div><div class="line">			c.lock.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当索引需要更新时，其他 goroutine 会往 <code>update</code> 这个 channel 发送消息，主要的逻辑代码都在这个 case 分支。当已知的 section 数大于存储的 section 数，这时需要开始索引，先通过调用 <code>SectionHead</code> 拿到上一个 section 的最后一个区块的哈希值，接着调用 <code>processSection</code> 开始新 section 的索引。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">processSection</span><span class="params">(section <span class="keyword">uint64</span>, lastHead common.Hash)</span> <span class="params">(common.Hash, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Reset(section, lastHead); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.setValidSections(<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> number := section * c.sectionSize; number &lt; (section+<span class="number">1</span>)*c.sectionSize; number++ &#123;</div><div class="line">		hash := GetCanonicalHash(c.chainDb, number)</div><div class="line">		<span class="keyword">if</span> hash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"canonical block #%d unknown"</span>, number)</div><div class="line">		&#125;</div><div class="line">		header := GetHeader(c.chainDb, hash, number)</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"block #%d [%x…] not found"</span>, number, hash[:<span class="number">4</span>])</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> header.ParentHash != lastHead &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"chain reorged during section processing"</span>)</div><div class="line">		&#125;</div><div class="line">		c.backend.Process(header)</div><div class="line">		lastHead = header.Hash()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Commit(); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.log.Error(<span class="string">"Section commit failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> lastHead, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只探讨 <code>eth/bloombits</code> 的实现，首先看 <code>Reset</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Reset</span><span class="params">(section <span class="keyword">uint64</span>, lastSectionHead common.Hash)</span> <span class="title">error</span></span> &#123;</div><div class="line">	gen, err := bloombits.NewGenerator(<span class="keyword">uint</span>(b.size))</div><div class="line">	b.gen, b.section, b.head = gen, section, common.Hash&#123;&#125;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的 <code>lastSectionHead</code> 参数其实没有用到，在 light 模式的实现中是有用到的，这里我们先不深究。实际上 reset 方法只是简单的初始化 <code>core/bloombits/generator</code>，这部分我们在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">布隆过滤器的实现</a>这一小结会讨论，先跳过这部分。回到 <code>processSection</code> 方法，如果 <code>Reset</code> 方法返回错误了，我们会重置已经存储的 section。接下来我们遍历当前 section，通过调用 <code>GetCanonicalHash</code> 获得当前区块哈希，然后拿到当前区块链中的 header，通过调用 <code>Process(header)</code> 添加当前的区块索引到布隆过滤器的 bit 数组中。</p>
<p>这部分代码在 eth/bloombits.go 中</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Process</span><span class="params">(header *types.Header)</span></span> &#123;</div><div class="line">	b.gen.AddBloom(<span class="keyword">uint</span>(header.Number.Uint64()-b.section*b.size), header.Bloom)</div><div class="line">	b.head = header.Hash()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 <code>AddBloom</code> 在 <code>core/bloombits/generator.go</code> 中。generator 用来生成基于 section 的布隆过滤器索引数据的对象，其内部的结构是：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Generator <span class="keyword">struct</span> &#123;</div><div class="line">	blooms   [types.BloomBitLength][]<span class="keyword">byte</span></div><div class="line">	sections <span class="keyword">uint</span></div><div class="line">	nextSec  <span class="keyword">uint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>bloom[2048][4096]</code> 这个类型用来存储索引的数据，比如第20个 header 的 <code>logBloom</code> 存储在 <code>bloom[2048][20]</code> 里。<code>sections</code> 指明操作的 section 的数量，<code>nextSec</code> 表示增加一个 bloom 的时候，需要设置的下一个 bit。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Generator)</span> <span class="title">AddBloom</span><span class="params">(index <span class="keyword">uint</span>, bloom types.Bloom)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> b.nextBit &gt;= b.sections &#123;</div><div class="line">		<span class="keyword">return</span> errSectionOutOfBounds</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> b.nextBit != index &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"bloom filter with unexpected index"</span>)</div><div class="line">	&#125;</div><div class="line">	byteIndex := b.nextBit / <span class="number">8</span></div><div class="line">	bitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(<span class="number">7</span>-b.nextBit%<span class="number">8</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; types.BloomBitLength; i++ &#123;</div><div class="line">		bloomByteIndex := types.BloomByteLength - <span class="number">1</span> - i/<span class="number">8</span></div><div class="line">		bloomBitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(i%<span class="number">8</span>)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (bloom[bloomByteIndex] &amp; bloomBitMask) != <span class="number">0</span> &#123;</div><div class="line">			b.blooms[i][byteIndex] |= bitMask</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	b.nextBit++</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AddBloom</code> 增加一个区块的 bit 数组。当 <code>nextBit</code> 超过 sections 时，返回超出 section 最大数量的错误，确保 <code>nextBit</code> 始终等于 index，即 bloom 在 section 里的下标，通过 <code>nextBit/8</code> 得到需要设置的 byte 位置，接着就是根据 <code>BloomBitLength</code> 变量，生成一个 bloom 数据。</p>
<h3 id="过滤功能的实现"><a href="#过滤功能的实现" class="headerlink" title="过滤功能的实现"></a>过滤功能的实现</h3><p>前面创建索引的时候有涉及到布隆过滤器的一部分功能，接下来我们来深入探讨一下布隆过滤器功能的实现。这部分代码主要在 <code>core/bloombits</code> 里。<code>core/bloombits</code> 目录下，逻辑代码都在 <code>generator.go</code>，<code>matcher.go</code>，<code>scheduler.go</code> 中，其中 generator 生成基于 section 的布隆过滤器索引数据的对象，matcher 用来匹配查询操作，scheduler 基于 section 的布隆过滤器的单个 bit 值检索进行调度。上文已经介绍了 <code>generator.go</code> 的功能，我们继续来看 <code>scheduler.go</code> 和 <code>matcher.go</code>。</p>
<h4 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h4><p>scheduler 用来调度检索操作，作为调度器，它还承担删除重复数据，缓存结果的功能，以保证在复杂的过滤条件下降低 IO 的开销。</p>
<h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type request struct &#123;</div><div class="line">	section uint64</div><div class="line">	bit     uint</div><div class="line">&#125;</div><div class="line">type response struct &#123;</div><div class="line">	cached []byte</div><div class="line">	done   chan struct&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">type scheduler struct &#123;</div><div class="line">	bit       uint</div><div class="line">	responses map[uint64]*response</div><div class="line">	lock      sync.Mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>request</code> 表示一个布隆检索任务。其中<code>section</code> 表示区块段号，每段 4096 个区块，bit 代表检索的是布隆过滤器的哪一位(一共2048位)。在同一个 section 的 logBloom 会存储在一起，对于每个 section，用一个二维数组 <code>A[2048][4096]</code> 来存储，上文已简略提到，第一维2048代表布隆过滤器的长度为2048个字节，第二位4096表示一个 section 里的所有区块，每个位置按照顺序代表其中一个区块。<code>response</code> 表示当前调度的请求的状态，该属性会在 scheduler 被引用。每产生一个请求，都会生成一个 <code>response</code> 对象来表示这个请求的状态，cached 会用来缓存这个 section 的结果。</p>
<p><code>scheduler</code> 的 bit 用来表示请求的是布隆过滤器的哪一个 bit 位(0-2047)，而 <code>response</code> 记录当前正在进行的请求或已经缓存的结果。</p>
<p><code>scheduler</code> 的 <code>run</code> 方法是调度逻辑代码的入口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">run</span><span class="params">(sections <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	pend := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(dist))</div><div class="line"></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> s.scheduleRequests(sections, dist, pend, quit, wg)</div><div class="line">	<span class="keyword">go</span> s.scheduleDeliveries(pend, done, quit, wg)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中参数 <code>sections</code> 是需要检索的区块段的 channel，<code>dist</code> 是输出通道，表示从本地检索还是从网络中检索，往这个 channel 发送请求，结果可以从 done 通道中拿到。<code>pend := make(chan uint64, cap(dist))</code> 在请求和响应之间创建一个与分发通道大小相同的转发器通道。</p>
<p>先看 <code>scheduleRequests</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleRequests</span><span class="params">(reqs <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pend)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> section, ok := &lt;-reqs:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			unique := <span class="literal">false</span></div><div class="line"></div><div class="line">			s.lock.Lock()</div><div class="line">			<span class="keyword">if</span> s.responses[section] == <span class="literal">nil</span> &#123;</div><div class="line">				s.responses[section] = &amp;response&#123;</div><div class="line">					done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">				&#125;</div><div class="line">				unique = <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Unlock()</div><div class="line">			<span class="keyword">if</span> unique &#123;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> dist &lt;- &amp;request&#123;bit: s.bit, section: section&#125;:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> pend &lt;- section:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>schedulerRequests</code> 会从 reqs 这个 channel 接收到 section 消息，然后将接收到的 section 封装成 request 发送到 dist 这个 channel，构建对象 <code>response[section]</code>，接着 section 还会发送给 pend 队列，<code>run</code> 方法调用的 <code>scheduleDeliveries</code> 会进行处理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleDeliveries</span><span class="params">(pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> idx, ok := &lt;-pend:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Lock()</div><div class="line">			res := s.responses[idx]</div><div class="line">			s.lock.Unlock()</div><div class="line"></div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-res.done:</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> done &lt;- res.cached:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleDelivers</code> 接收到 <code>pend</code> 消息后，会阻塞在 <code>response[section].done</code> 上。接着等待外部调用 <code>deliver</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">deliver</span><span class="params">(sections []<span class="keyword">uint64</span>, data [][]<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	s.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> s.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, section := <span class="keyword">range</span> sections &#123;</div><div class="line">		<span class="keyword">if</span> res := s.responses[section]; res != <span class="literal">nil</span> &amp;&amp; res.cached == <span class="literal">nil</span> &#123; </div><div class="line">			res.cached = data[i]</div><div class="line">			<span class="built_in">close</span>(res.done)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 deliver 方法，section 的 <code>request</code> 请求结果会写入 <code>response[section].cached</code>，然后关闭 <code>response[section].done</code> 这个 channel 。</p>
<p><code>scheduleDelivers</code> 接收到 <code>response[section].done</code> 信息后，<code>response[section].cached</code> 会发送到 <code>done</code> 这个channel，至此，一次检索的调度就结束了。</p>
<p>在下面的 Matcher 中，distributor 就有调用 schedule 的 deliver 方法的例子。</p>
<h4 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h4><p>Matcher 完成真正的匹配工作，对 filter 进行二进制的与/或操作。</p>
<h5 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> partialMatches <span class="keyword">struct</span> &#123;</div><div class="line">	section <span class="keyword">uint64</span></div><div class="line">	bitset  []<span class="keyword">byte</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Retrieval <span class="keyword">struct</span> &#123;</div><div class="line">	Bit      <span class="keyword">uint</span></div><div class="line">	Sections []<span class="keyword">uint64</span></div><div class="line">	Bitsets  [][]<span class="keyword">byte</span></div><div class="line"></div><div class="line">	Context context.Context</div><div class="line">	Error   error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Matcher <span class="keyword">struct</span> &#123;</div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	filters    [][]bloomIndexes</div><div class="line">	schedulers <span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler</div><div class="line"></div><div class="line">	retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	counters   <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	retrievals <span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval</div><div class="line">	deliveries <span class="keyword">chan</span> *Retrieval</div><div class="line">	running <span class="keyword">uint32</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>partialMatches</code> 表示部分匹配的结果，<code>Retrieval</code> 表示一次区块布隆过滤器的检索工作，在使用过程中，该对象会被发送给 <code>eth/bloombits.go</code> 中的 <code>startBloomHandlers</code> 来处理，该方法从数据库中加载布隆过滤器索引，然后放在 Bitsets 里返回（待确认）。Matcher 是一个操作调度器（scheduler）和匹配器（matcher）的流水线系统，它会对比特流进行二进制的与/或操作，对数据内容进行检索，创建可能的区块。</p>
<p>构造 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMatcher</span><span class="params">(sectionSize <span class="keyword">uint64</span>, filters [][][]<span class="keyword">byte</span>)</span> *<span class="title">Matcher</span></span> &#123;</div><div class="line">	m := &amp;Matcher&#123;</div><div class="line">		sectionSize: sectionSize,</div><div class="line">		schedulers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler),</div><div class="line">		retrievers:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		counters:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		retrievals:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval),</div><div class="line">		deliveries:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Retrieval),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(filter) == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		bloomBits := <span class="built_in">make</span>([]bloomIndexes, <span class="built_in">len</span>(filter))</div><div class="line">		<span class="keyword">for</span> i, clause := <span class="keyword">range</span> filter &#123;</div><div class="line">			<span class="keyword">if</span> clause == <span class="literal">nil</span> &#123;</div><div class="line">				bloomBits = <span class="literal">nil</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			bloomBits[i] = calcBloomIndexes(clause)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomBits != <span class="literal">nil</span> &#123;</div><div class="line">			m.filters = <span class="built_in">append</span>(m.filters, bloomBits)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, bloomIndexLists := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		<span class="keyword">for</span> _, bloomIndexList := <span class="keyword">range</span> bloomIndexLists &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomIndex := <span class="keyword">range</span> bloomIndexList &#123;</div><div class="line">				m.addScheduler(bloomIndex)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> m</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewMatcher</code> 根据传入的 filters 分别进行初始化操作，接着可以在可以在 <code>Start</code> 中创建对应数量的 schedule，subMatch。</p>
<p>启动 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">Start</span><span class="params">(ctx context.Context, begin, end <span class="keyword">uint64</span>, results <span class="keyword">chan</span> <span class="keyword">uint64</span>)</span> <span class="params">(*MatcherSession, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> atomic.SwapUint32(&amp;m.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"matcher already running"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> atomic.StoreUint32(&amp;m.running, <span class="number">0</span>)</div><div class="line">	session := &amp;MatcherSession&#123;</div><div class="line">		matcher: m,</div><div class="line">		quit:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		kill:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		ctx:     ctx,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, scheduler := <span class="keyword">range</span> m.schedulers &#123;</div><div class="line">		scheduler.reset()</div><div class="line">	&#125;</div><div class="line">	sink := m.run(begin, end, <span class="built_in">cap</span>(results), session)</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> res, ok := &lt;-sink:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				sectionStart := res.section * m.sectionSize</div><div class="line"></div><div class="line">				first := sectionStart</div><div class="line">				<span class="keyword">if</span> begin &gt; first &#123;</div><div class="line">					first = begin</div><div class="line">				&#125;</div><div class="line">				last := sectionStart + m.sectionSize - <span class="number">1</span></div><div class="line">				<span class="keyword">if</span> end &lt; last &#123;</div><div class="line">					last = end</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> i := first; i &lt;= last; i++ &#123;</div><div class="line">					next := res.bitset[(i-sectionStart)/<span class="number">8</span>]</div><div class="line">					<span class="keyword">if</span> next == <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">if</span> i%<span class="number">8</span> == <span class="number">0</span> &#123;</div><div class="line">							i += <span class="number">7</span></div><div class="line">						&#125;</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> bit := <span class="number">7</span> - i%<span class="number">8</span>; next&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> results &lt;- i:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> session, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Start</code> 方法首先启动一个 session，这个 session 会被返回，它可以用来管理日志过滤的生命周期，调用者会将它作为 <code>ServiceFilter</code> 的参数，根据 <code>bloomFilterThreads</code> 这个常数值（默认为3），启动 <code>bloomFilterThreads</code> 个 session 的 <code>Multiplex</code>，该方法会不断地从 distributor 领取任务，将任务投递给 bloomRequest 队列，从队列中获取结果，然后投递给 distributor，这个 Multiplex 非常重要。</p>
<p>接下来会调用 run 方法，该方法会返回一个 channel，该 channel 会一直返回搜索的结果，直到返回一个退出的信号，<code>Start</code> 方法才会结束，对于过滤的结果，其中包括 section 和 bitmap，bitmap 表明了 section 中哪些区块可能存在值，这时需要遍历这个 bitmap，找到被置位的区块，然后把区块号返回到 results 通道。接下来我们看 <code>run</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">run</span><span class="params">(begin, end <span class="keyword">uint64</span>, buffer <span class="keyword">int</span>, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	source := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, buffer)</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(source)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> i := begin / m.sectionSize; i &lt;= end/m.sectionSize; i++ &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> source &lt;- &amp;partialMatches&#123;i, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0xff</span>&#125;, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))&#125;:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	next := source</div><div class="line">	dist := <span class="built_in">make</span>(<span class="keyword">chan</span> *request, buffer)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, bloom := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		next = m.subMatch(next, dist, bloom, session)</div><div class="line">	&#125;</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> m.distributor(dist, session)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>run 方法会创建一个子匹配器的流水线，一个用于地址集合，一个用于 topic 集合。之所以称为流水线是因为它会一个一个地调用子匹配器，之前的子匹配器找到了匹配的区块后才会调用下一个子匹配器，接收到的结果会与自身结果匹配后结合，发到下一个子匹配器。最终返回一个接收结果的接收器通道。该方法首先起一个 go routine, 构造 subMatch 的第一个输入源，这个源的 bitset 字段是 0xff，表示完全匹配，这个结果会作为第一个子匹配器的输入。在结尾还会用新线程的方式调用 <code>distributor</code>，这个方法我们之后再谈，接下来我们看 <code>subMatch</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">subMatch</span><span class="params">(source <span class="keyword">chan</span> *partialMatches, dist <span class="keyword">chan</span> *request, bloom []bloomIndexes, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	sectionSources := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	sectionSinks := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	<span class="keyword">for</span> i, bits := <span class="keyword">range</span> bloom &#123;</div><div class="line">		<span class="keyword">for</span> j, bit := <span class="keyword">range</span> bits &#123;</div><div class="line">			sectionSources[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(source))</div><div class="line">			sectionSinks[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">			m.schedulers[bit].run(sectionSources[i][j], dist, sectionSinks[i][j], session.quit, &amp;session.pend)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	process := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(process)</div><div class="line"></div><div class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">				<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">					<span class="built_in">close</span>(bitSource)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-source:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">					<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> bitSource &lt;- subres.section:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> process &lt;- subres:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-process:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">var</span> orVector []<span class="keyword">byte</span></div><div class="line">				<span class="keyword">for</span> _, bloomSinks := <span class="keyword">range</span> sectionSinks &#123;</div><div class="line">					<span class="keyword">var</span> andVector []<span class="keyword">byte</span></div><div class="line">					<span class="keyword">for</span> _, bitSink := <span class="keyword">range</span> bloomSinks &#123;</div><div class="line">						<span class="keyword">var</span> data []<span class="keyword">byte</span></div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> data = &lt;-bitSink:</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">if</span> andVector == <span class="literal">nil</span> &#123;</div><div class="line">							andVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">							<span class="built_in">copy</span>(andVector, data)</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							bitutil.ANDBytes(andVector, andVector, data)</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">						orVector = andVector</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						bitutil.ORBytes(orVector, orVector, andVector)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">					orVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> subres.bitset != <span class="literal">nil</span> &#123;</div><div class="line">					bitutil.ANDBytes(orVector, orVector, subres.bitset)</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> bitutil.TestBytes(orVector) &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">						<span class="keyword">return</span></div><div class="line">					<span class="keyword">case</span> results &lt;- &amp;partialMatches&#123;subres.section, orVector&#125;:</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> results</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>subMatch 会创建一个子匹配器，用于过滤一组 address 或 topic，在组内会进行 bit 位的或操作，然后将上一个结果与当前过滤结果进行位的与操作，如果结果不全为空，结果传递到下一个子匹配器。每个 address/topic 的匹配通过获取属于该 address/topics 的三个布隆过滤器位索引的给定部分以及这些向量二进制做与的运算。</p>
<p>注意这里的 bloom 参数的类型是 <code>[]bloomIndexes</code>，首先根据这个值创建相应个数的 schedulers，调用其对应的 run 方法。前面我们有介绍 schedulers 的 run 方法，它的作用是根据后端的实现（从硬盘或网络中）执行过滤操作，结果可以通过调用 scheduler 的 deliver 获得。</p>
<p>我们继续看上面提到的 <code>distributor</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">distributor</span><span class="params">(dist <span class="keyword">chan</span> *request, session *MatcherSession)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> session.pend.Done()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		requests   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>][]<span class="keyword">uint64</span>)</div><div class="line">		unallocs   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]<span class="keyword">struct</span>&#123;&#125;)</div><div class="line">		retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		allocs   <span class="keyword">int</span></div><div class="line">		shutdown = session.quit</div><div class="line">	)</div><div class="line">	assign := <span class="function"><span class="keyword">func</span><span class="params">(bit <span class="keyword">uint</span>)</span></span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievers:</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			retrievers = m.retrievers</div><div class="line">			unallocs[bit] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-shutdown:</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			shutdown = <span class="literal">nil</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-session.kill:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> req := &lt;-dist:</div><div class="line">			queue := requests[req.bit]</div><div class="line">			index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= req.section &#125;)</div><div class="line">			requests[req.bit] = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;req.section&#125;, queue[index:]...)...)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</div><div class="line">				assign(req.bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-retrievers:</div><div class="line">			bit, best := <span class="keyword">uint</span>(<span class="number">0</span>), <span class="keyword">uint64</span>(math.MaxUint64)</div><div class="line">			<span class="keyword">for</span> idx := <span class="keyword">range</span> unallocs &#123;</div><div class="line">				<span class="keyword">if</span> requests[idx][<span class="number">0</span>] &lt; best &#123;</div><div class="line">					bit, best = idx, requests[idx][<span class="number">0</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">delete</span>(unallocs, bit)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(unallocs) == <span class="number">0</span> &#123;</div><div class="line">				retrievers = <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.counters:</div><div class="line">			fetcher &lt;- <span class="keyword">uint</span>(<span class="built_in">len</span>(requests[&lt;-fetcher]))</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievals:</div><div class="line">			task := &lt;-fetcher</div><div class="line">			<span class="keyword">if</span> want := <span class="built_in">len</span>(task.Sections); want &gt;= <span class="built_in">len</span>(requests[task.Bit]) &#123;</div><div class="line">				task.Sections = requests[task.Bit]</div><div class="line">				<span class="built_in">delete</span>(requests, task.Bit)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				task.Sections = <span class="built_in">append</span>(task.Sections[:<span class="number">0</span>], requests[task.Bit][:want]...)</div><div class="line">				requests[task.Bit] = <span class="built_in">append</span>(requests[task.Bit][:<span class="number">0</span>], requests[task.Bit][want:]...)</div><div class="line">			&#125;</div><div class="line">			fetcher &lt;- task</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requests[task.Bit]) &gt; <span class="number">0</span> &#123;</div><div class="line">				assign(task.Bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> result := &lt;-m.deliveries:</div><div class="line">			<span class="keyword">var</span> (</div><div class="line">				sections = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">				bitsets  = <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Bitsets))</div><div class="line">				missing  = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">			)</div><div class="line">			<span class="keyword">for</span> i, bitset := <span class="keyword">range</span> result.Bitsets &#123;</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(bitset) == <span class="number">0</span> &#123;</div><div class="line">					missing = <span class="built_in">append</span>(missing, result.Sections[i])</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				sections = <span class="built_in">append</span>(sections, result.Sections[i])</div><div class="line">				bitsets = <span class="built_in">append</span>(bitsets, bitset)</div><div class="line">			&#125;</div><div class="line">			m.schedulers[result.Bit].deliver(sections, bitsets)</div><div class="line">			allocs--</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(missing) &gt; <span class="number">0</span> &#123;</div><div class="line">				queue := requests[result.Bit]</div><div class="line">				<span class="keyword">for</span> _, section := <span class="keyword">range</span> missing &#123;</div><div class="line">					index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= section &#125;)</div><div class="line">					queue = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;section&#125;, queue[index:]...)...)</div><div class="line">				&#125;</div><div class="line">				requests[result.Bit] = queue</div><div class="line"></div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="built_in">len</span>(missing) &#123;</div><div class="line">					assign(result.Bit)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &amp;&amp; shutdown == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>distributor 接收来自 scheduler 的请求，首先根据 <code>dist</code> 参数，进入下面的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">case req := &lt;-dist:</div><div class="line">	// New retrieval request arrived to be distributed to some fetcher process</div><div class="line">	queue := requests[req.bit]</div><div class="line">	index := sort.Search(len(queue), func(i int) bool &#123; return queue[i] &gt;= req.section &#125;)</div><div class="line">	requests[req.bit] = append(queue[:index], append([]uint64&#123;req.section&#125;, queue[index:]...)...)</div><div class="line"></div><div class="line">	// If it&apos;s a new bit and we have waiting fetchers, allocate to them</div><div class="line">	if len(queue) == 0 &#123;</div><div class="line">		assign(req.bit)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果是新的 bit，通过 assign 指派给等待的 fetcher。这时通过 <code>Multiplex</code>, <code>AllocateSections</code> 的作用，最终会进入到 <code>case fetcher := &lt;-m.retrievals:</code> 分支。回顾一下 <code>Multiplex</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (s *MatcherSession) Multiplex(batch int, wait time.Duration, mux chan chan *Retrieval) &#123;</div><div class="line">	for &#123;</div><div class="line">		bit, ok := s.AllocateRetrieval()</div><div class="line">		if !ok &#123;</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">		if s.PendingSections(bit) &lt; batch &#123;</div><div class="line">			select &#123;</div><div class="line">			case &lt;-s.quit:</div><div class="line">				// Session terminating, we can&apos;t meaningfully service, abort</div><div class="line">				s.AllocateSections(bit, 0)</div><div class="line">				s.DeliverSections(bit, []uint64&#123;&#125;, [][]byte&#123;&#125;)</div><div class="line">				return</div><div class="line"></div><div class="line">			case &lt;-time.After(wait):</div><div class="line">				// Throttling up, fetch whatever&apos;s available</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sections := s.AllocateSections(bit, batch)</div><div class="line">		request := make(chan *Retrieval)</div><div class="line"></div><div class="line">		select &#123;</div><div class="line">		case &lt;-s.quit:</div><div class="line">			s.DeliverSections(bit, sections, make([][]byte, len(sections)))</div><div class="line">			return</div><div class="line"></div><div class="line">		case mux &lt;- request:</div><div class="line">			request &lt;- &amp;Retrieval&#123;Bit: bit, Sections: sections, Context: s.ctx&#125;</div><div class="line"></div><div class="line">			result := &lt;-request</div><div class="line">			if result.Error != nil &#123;</div><div class="line">				s.err.Store(result.Error)</div><div class="line">				s.Close()</div><div class="line">			&#125;</div><div class="line">			s.DeliverSections(result.Bit, result.Sections, result.Bitsets)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Multiplex 会不断领取任务，投递给 bloomRequest 队列，从队列中获取结果后，又通过 <code>DeliverSections</code> 发送给 deliveries 这个 channel，从而调用 schedulers 的 deliver 方法，在前面 schedule 的讲解中，我们知道这个结果会发到 <code>done</code> 这个 channel 中，这个结果最终会被 subMatch 接收(查看 scheduler 的 run 方法)，一层层发送给最后一个 subMath，最终返回 results。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ethereum/go-ethereum/issues/1897" target="_blank" rel="external">issues 1897, eth_listTransactions</a></li>
<li><a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="external">【原】布隆过滤器 (Bloom Filter) 详解</a></li>
<li><a href="http://dmod.eu/deca/ft_gateway.cfm.pdf" target="_blank" rel="external">Space/Time Trade-offs in Hash Coding with Allowable Errors </a></li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Bloom filter wiki</a></li>
<li><a href="https://web.stanford.edu/~balaji/papers/bloom.pdf" target="_blank" rel="external">Bloom Filters: Design Innovations and Novel Applications</a></li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-EVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）/</id>
    <published>2018-03-10T14:35:08.000Z</published>
    <updated>2018-10-20T06:56:31.927Z</updated>
    
    <content type="html"><![CDATA[<p>前面的文章 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a> 讨论了 geth 中对交易的处理，其中有一个阶段需要通过 EVM 执行，如果交易转入方地址为空，则调用 EVM 的 Create 函数创建合约；如果不为空，则为普通转账，调用 Call() 函数。这一篇我们将深入以太坊的虚拟机看看具体的过程。</p>
<p>这一篇需要对智能合约， ERC-20 标准，编译原理（了解编译器，解释器，虚拟机等概念），计算机组成原理（了解基于栈的虚拟机与基于寄存器的虚拟机的区别）有所了解。</p>
<a id="more"></a>
<p>以太坊与比特币最大的不同是以太坊设计了图灵完备的虚拟机用于执行合约代码，geth 中的 EVM 本质上就是一个字节码执行引擎。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>在以太坊的<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#virtual-machine" target="_blank" rel="external">设计原理</a>中描述了 EVM 的设计目标:</p>
<ul>
<li><strong>简单</strong>：操作码尽可能的简单，低级，数据类型尽可能少，虚拟机结构尽可能少。</li>
<li><strong>结果明确</strong>：在 VM 规范里，没有任何可能产生歧义的空间，结果应该是完全确定的，此外，计算步骤应该是精确的，以便可以计量 gas 消耗量。</li>
<li><strong>节约空间</strong>：EVM 汇编码应该尽可能紧凑。</li>
<li><strong>预期应用应具备专业化能力</strong>：在 VM 上构建的应用能够处理20字节的地址，以及32位的自定义加密值，拥有用于自定义加密的模数运算、读取区块和交易数据和状态交互等能力。</li>
<li><strong>简单安全</strong>：能够容易地建立一套操作的 gas 消耗成本模型，让 VM 不被利用。</li>
<li><strong>优化友好</strong>：应该易于优化，以便即时编译(JIT)和 VM 的加速版本能够构建出来。</li>
</ul>
<p>特点：</p>
<ul>
<li>区分临时存储（Memory，存在于每个 VM 实例中，并在 VM 执行结束后消失）和永久存储（Storage，存在于区块链的状态层）。</li>
<li>采用基于栈（stack）的架构。</li>
<li>机器码长度为32字节。</li>
<li>没有重用 Java，或其他一些 Lisp 方言，Lua 的虚拟机，自定义虚拟机。</li>
<li>使用可变的可扩展内存大小。</li>
<li>限制调用深度为 1024。</li>
<li>没有类型。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通常智能合约的开发流程是使用 solidity 编写逻辑代码，通过编译器编译成 bytecode，然后发布到以太坊上，以太坊底层通过 EVM 模块支持合约的执行和调用，调用时根据合约地址获取到代码，即合约的字节码，生成环境后载入到 EVM 执行。</p>
<p>大致流程如下图1，指令的执行过程如下图2，从 EVM code 中不断取出指令执行，利用 Gas 来实现限制循环，利用栈来进行操作，内存存储临时变量，账户状态中的 storage 用来存储数据。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/evm_process.jpg" alt="evm_process"></p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/evm_code_executed.png" alt="evm_code_executed"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>EVM 模块的文件比较多，这里先给出每个文件的简述，先对每个文件提供的功能有个简单的了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── analysis.go            // 跳转目标判定</div><div class="line">├── common.go</div><div class="line">├── contract.go            // 合约的数据结构</div><div class="line">├── contracts.go           // 预编译好的合约</div><div class="line">├── errors.go</div><div class="line">├── evm.go                 // 对外提供的接口   </div><div class="line">├── gas.go                 // 用来计算指令耗费的 gas</div><div class="line">├── gas_table.go           // 指令耗费计算函数表</div><div class="line">├── gen_structlog.go       </div><div class="line">├── instructions.go        // 指令操作</div><div class="line">├── interface.go           // 定义 StateDB 的接口</div><div class="line">├── interpreter.go         // 解释器</div><div class="line">├── intpool.go             // 存放大整数</div><div class="line">├── int_pool_verifier_empty.go</div><div class="line">├── int_pool_verifier.go</div><div class="line">├── jump_table.go           // 指令和指令操作（操作，花费，验证）对应表</div><div class="line">├── logger.go               // 状态日志</div><div class="line">├── memory.go               // EVM 内存</div><div class="line">├── memory_table.go         // EVM 内存操作表，用来衡量操作所需内存大小</div><div class="line">├── noop.go</div><div class="line">├── opcodes.go              // 指令以及一些对应关系     </div><div class="line">├── runtime</div><div class="line">│   ├── env.go              // 执行环境 </div><div class="line">│   ├── fuzz.go</div><div class="line">│   └── runtime.go          // 运行接口，测试使用</div><div class="line">├── stack.go                // 栈</div><div class="line">└── stack_table.go          // 栈验证</div></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在 EVM 模块中，有两个高层次的结构体，分别是 Context，EVM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">type Context struct &#123;</div><div class="line">	CanTransfer CanTransferFunc</div><div class="line">	Transfer TransferFunc</div><div class="line">	GetHash GetHashFunc</div><div class="line">	Origin   common.Address</div><div class="line">	GasPrice *big.Int</div><div class="line">	Coinbase    common.Address</div><div class="line">	GasLimit    uint64</div><div class="line">	BlockNumber *big.Int</div><div class="line">	Time        *big.Int</div><div class="line">	Difficulty  *big.Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">type EVM struct &#123;</div><div class="line">	Context</div><div class="line">	StateDB StateDB</div><div class="line">	depth int</div><div class="line">	chainConfig *params.ChainConfig</div><div class="line">	chainRules params.Rules</div><div class="line">	vmConfig Config</div><div class="line">	interpreter *Interpreter</div><div class="line">	abort int32</div><div class="line">	callGasTemp uint64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Context 给 EVM 提供运行合约的上下文信息，其中 <code>CanTransfer</code> 是返回账户是否有足够余额的函数，<code>Transfer</code> 可以用来完成转账操作，<code>GetHash</code> 返回第 n 个区块的哈希值。其他的属性在之前文章有过描述，代码中也有注释，这里不再赘述。EVM 结构体中稍值得一提的是 interpreter，它根据代码以及 jump_table 中对应的指令逐条执行合约，这部分我们将在稍后看到。</p>
<p>我们先从<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a> 中谈到的 Create，Call 方法谈起。</p>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>Create 方法可以用来创建一个新合约。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">func (evm *EVM) create(caller ContractRef, code []byte, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) &#123;</div><div class="line">	if evm.depth &gt; int(params.CallCreateDepth) &#123;</div><div class="line">		return nil, common.Address&#123;&#125;, gas, ErrDepth</div><div class="line">	&#125;</div><div class="line">	if !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</div><div class="line">		return nil, common.Address&#123;&#125;, gas, ErrInsufficientBalance</div><div class="line">	&#125;</div><div class="line">	nonce := evm.StateDB.GetNonce(caller.Address())</div><div class="line">	evm.StateDB.SetNonce(caller.Address(), nonce+1)</div><div class="line"></div><div class="line">	contractHash := evm.StateDB.GetCodeHash(address)</div><div class="line">	if evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</div><div class="line">		return nil, common.Address&#123;&#125;, 0, ErrContractAddressCollision</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	snapshot := evm.StateDB.Snapshot()</div><div class="line">	evm.StateDB.CreateAccount(address)</div><div class="line">	if evm.ChainConfig().IsEIP158(evm.BlockNumber) &#123;</div><div class="line">		evm.StateDB.SetNonce(address, 1)</div><div class="line">	&#125;</div><div class="line">	evm.Transfer(evm.StateDB, caller.Address(), address, value)</div><div class="line"></div><div class="line">	contract := NewContract(caller, AccountRef(address), value, gas)</div><div class="line">	contract.SetCallCode(&amp;address, crypto.Keccak256Hash(code), code)</div><div class="line"></div><div class="line">	if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 &#123;</div><div class="line">		return nil, address, gas, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</div><div class="line">		evm.vmConfig.Tracer.CaptureStart(caller.Address(), address, true, code, gas, value)</div><div class="line">	&#125;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	ret, err := run(evm, contract, nil)</div><div class="line"></div><div class="line">	maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; len(ret) &gt; params.MaxCodeSize</div><div class="line"></div><div class="line">	if err == nil &amp;&amp; !maxCodeSizeExceeded &#123;</div><div class="line">		createDataGas := uint64(len(ret)) * params.CreateDataGas</div><div class="line">		if contract.UseGas(createDataGas) &#123;</div><div class="line">			evm.StateDB.SetCode(address, ret)</div><div class="line">		&#125; else &#123;</div><div class="line">			err = ErrCodeStoreOutOfGas</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if maxCodeSizeExceeded || (err != nil &amp;&amp; (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) &#123;</div><div class="line">		evm.StateDB.RevertToSnapshot(snapshot)</div><div class="line">		if err != errExecutionReverted &#123;</div><div class="line">			contract.UseGas(contract.Gas)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if maxCodeSizeExceeded &amp;&amp; err == nil &#123;</div><div class="line">		err = errMaxCodeSizeExceeded</div><div class="line">	&#125;</div><div class="line">	if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</div><div class="line">		evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</div><div class="line">	&#125;</div><div class="line">	return ret, address, contract.Gas, err</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会进行一系列验证，调用栈的深度不能超过 1024；调用的账户有足够多的余额；对调用者地址的 nonce+1，通过地址和 nonce 生成合约地址，通过合约地址获取合约哈希值，确保调用的地址不能已经存在合约。接着利用 StateDB 创建一个快照，如果之后的调用出现问题可以回滚。在进行了这一系列初始化之后，发起一笔转账操作，发送方地址余额减 value 值，合约账户的余额加 value 值，接着通过调用 contract 的 <code>SetCallCode</code> ，根据发送方地址，合约地址，金额 value，gas，合约代码，代码哈希初始化合约对象，然后调用 <code>run(evm, contract, nil)</code>执行合约的初始化代码，这个生成的代码有一定的长度限制，当合约创建成功，没有错误返回，则计算存储代码所需的 gas，如果没有足够 gas 则进行报错。之后就是错误处理了，如果存在错误，需要回滚到之前创建的状态快照，没有错误则返回创建成功。可以看到，合约代码通过 state 模块的 SetCode，保存在账户中 codehash 指向的存储区域，这部分的代码都属于对世界状态的修改。</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>当进行转账或执行合约代码，会调用 Call 方法，合约里的 call 指令也会调用这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) &#123;</div><div class="line">	if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 &#123;</div><div class="line">		return nil, gas, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if evm.depth &gt; int(params.CallCreateDepth) &#123;</div><div class="line">		return nil, gas, ErrDepth</div><div class="line">	&#125;</div><div class="line">	if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</div><div class="line">		return nil, gas, ErrInsufficientBalance</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		to       = AccountRef(addr)</div><div class="line">		snapshot = evm.StateDB.Snapshot()</div><div class="line">	)</div><div class="line">	if !evm.StateDB.Exist(addr) &#123;</div><div class="line">		precompiles := PrecompiledContractsHomestead</div><div class="line">		if evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</div><div class="line">			precompiles = PrecompiledContractsByzantium</div><div class="line">		&#125;</div><div class="line">		if precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == 0 &#123;</div><div class="line">			if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</div><div class="line">				evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)</div><div class="line">				evm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)</div><div class="line">			&#125;</div><div class="line">			return nil, gas, nil</div><div class="line">		&#125;</div><div class="line">		evm.StateDB.CreateAccount(addr)</div><div class="line">	&#125;</div><div class="line">	evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</div><div class="line"></div><div class="line">	contract := NewContract(caller, to, value, gas)</div><div class="line">	contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</div><div class="line">		evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)</div><div class="line"></div><div class="line">		defer func() &#123;</div><div class="line">			evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	ret, err = run(evm, contract, input)</div><div class="line"></div><div class="line">	if err != nil &#123;</div><div class="line">		evm.StateDB.RevertToSnapshot(snapshot)</div><div class="line">		if err != errExecutionReverted &#123;</div><div class="line">			contract.UseGas(contract.Gas)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return ret, contract.Gas, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 Create 方法类似，不过 Create 方法的资金转移发生在创建合约用户账户和合约账户之间，而 Call 方法的资金转移发生在合约发送方和合约接收方之间。Call 方法需要先检查合约调用深度；确保账户有足够余额；调用 Call 方法的可能是一个转账操作，也可能是一个运行合约的操作，所以接下来会通过 StateDB 查看指定的地址是否存在，如果不存在的话，接着查看该地址是否为内置合约，这些预编译的合约在 <code>core/vm/constracts.go</code> 中定义，主要是用于加密操作，如果本地确实没有合约接收方的账户，创建一个接收方的账户，更新本地的状态数据库。接着 evm 会调用 Transfer 方法（即 Context 里的 TransferFunc）进行转账。最后，通过 StateDB 的 <code>GetCode</code> 拿到该地址对应的代码，通过 <code>run(evm, contract, input)</code> 运行合约，如果是单纯的转账，通过 <code>GetCode</code> 拿到的代码是空，自然也没有合约的运行。这一步完成后，就可以返回执行结果了。合约产生的 gas 总数会加入到矿工账户，作为矿工收入。</p>
<h4 id="解释器执行合约指令"><a href="#解释器执行合约指令" class="headerlink" title="解释器执行合约指令"></a>解释器执行合约指令</h4><p>我们已经大致了解了合约是怎么创建和执行的，执行合约的关键在于 Call 方法的最后通过 <code>run(evm, contract, input)</code> 运行合约，接下来我们就深入到 <code>run</code> 函数，看看 evm 中解释器执行合约的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func run(evm *EVM, contract *Contract, input []byte) ([]byte, error) &#123;</div><div class="line">	if contract.CodeAddr != nil &#123;</div><div class="line">		precompiles := PrecompiledContractsHomestead</div><div class="line">		if evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</div><div class="line">			precompiles = PrecompiledContractsByzantium</div><div class="line">		&#125;</div><div class="line">		if p := precompiles[*contract.CodeAddr]; p != nil &#123;</div><div class="line">			return RunPrecompiledContract(p, input, contract)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return evm.interpreter.Run(contract, input)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 run 方法中，首先检查调用的是否是之前编译好的原生合约，如果是原生合约则调用原生合约，否则调用解释器执行合约。解释器的代码在 <code>core/vm/interpreter.go</code> 中。</p>
<p>要理解虚拟机中解释器的的执行过程，首先需要知道该解释器的初始化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func NewInterpreter(evm *EVM, cfg Config) *Interpreter &#123;</div><div class="line">	if !cfg.JumpTable[STOP].valid &#123;</div><div class="line">		switch &#123;</div><div class="line">		case evm.ChainConfig().IsConstantinople(evm.BlockNumber):</div><div class="line">			cfg.JumpTable = constantinopleInstructionSet</div><div class="line">		case evm.ChainConfig().IsByzantium(evm.BlockNumber):</div><div class="line">			cfg.JumpTable = byzantiumInstructionSet</div><div class="line">		case evm.ChainConfig().IsHomestead(evm.BlockNumber):</div><div class="line">			cfg.JumpTable = homesteadInstructionSet</div><div class="line">		default:</div><div class="line">			cfg.JumpTable = frontierInstructionSet</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return &amp;Interpreter&#123;</div><div class="line">		evm:      evm,</div><div class="line">		cfg:      cfg,</div><div class="line">		gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),</div><div class="line">		intPool:  newIntPool(),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Interpreter 中很重要的一个配置是 Jumptable，它保存的是指令集，在不同的以太坊版本有不同的指令集。查看 <code>core/vm/jump_table.go</code> 中的 <code>newFrontierInstructionSet</code>, <code>newHomesteadInstructionSet</code>, <code>newByzantiumInstructionSet</code>, <code>newConstantinopleInstructionSet</code> 方法，你会发现指令集是向前兼容的。</p>
<p>这里以 ADD 指令为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ADD: &#123;</div><div class="line">	execute:       opAdd,</div><div class="line">	gasCost:       constGasFunc(GasFastestStep),</div><div class="line">	validateStack: makeStackFunc(2, 1),</div><div class="line">	valid:         true,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>ADD 指令对应的方法 <code>opAdd</code> 在 <code>core/vm/instructions.go</code> 中。其中 <code>execute</code> 指的是对应的操作函数，<code>gasCost</code> 对应的是 gas 消耗，<code>validateStack</code> 用来验证栈深度，<code>valid</code> 指明操作是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func opAdd(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) &#123;</div><div class="line">	x, y := stack.pop(), stack.peek()</div><div class="line">	math.U256(y.Add(x, y))</div><div class="line"></div><div class="line">	evm.interpreter.intPool.put(x)</div><div class="line">	return nil, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过栈拿到需要进行运算的 x, y 值（弹出一个值，取一个值，进行运算后这个值就变成结果值），在进行加法运算后，该结果会被缓存。不同的指令的实现自然不同，指令不多，但这里也不一一介绍了。还需要了解的一点是，这些指令都对应了一个编码，这些是在 <code>core/vm/opcodes.go</code> 中定义的，这个编码是一个 byte，合约编译出来的 bytecode，一个 OpCode 就对应其中的一位(可以参考<a href="https://github.com/trailofbits/evm-opcodes" target="_blank" rel="external">EVM指令集</a>)。</p>
<p>了解了指令集后，我们再看 <code>Run</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">func (in *Interpreter) Run(contract *Contract, input []byte) (ret []byte, err error) &#123;</div><div class="line">	in.evm.depth++</div><div class="line">	defer func() &#123; in.evm.depth-- &#125;()</div><div class="line"></div><div class="line">	in.returnData = nil</div><div class="line"></div><div class="line">	if len(contract.Code) == 0 &#123;</div><div class="line">		return nil, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		op    OpCode</div><div class="line">		mem   = NewMemory()</div><div class="line">		stack = newstack()</div><div class="line">		pc   = uint64(0)</div><div class="line">		cost uint64</div><div class="line">		pcCopy  uint64</div><div class="line">		gasCopy uint64</div><div class="line">		logged  bool</div><div class="line">	)</div><div class="line">	contract.Input = input</div><div class="line"></div><div class="line">	if in.cfg.Debug &#123;</div><div class="line">		defer func() &#123;</div><div class="line">			if err != nil &#123;</div><div class="line">				if !logged &#123;</div><div class="line">					in.cfg.Tracer.CaptureState(in.evm, pcCopy, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err)</div><div class="line">				&#125; else &#123;</div><div class="line">					in.cfg.Tracer.CaptureFault(in.evm, pcCopy, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	for atomic.LoadInt32(&amp;in.evm.abort) == 0 &#123;</div><div class="line">		if in.cfg.Debug &#123;</div><div class="line">			logged, pcCopy, gasCopy = false, pc, contract.Gas</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		op = contract.GetOp(pc)</div><div class="line">		operation := in.cfg.JumpTable[op]</div><div class="line">		if !operation.valid &#123;</div><div class="line">			return nil, fmt.Errorf(&quot;invalid opcode 0x%x&quot;, int(op))</div><div class="line">		&#125;</div><div class="line">		if err := operation.validateStack(stack); err != nil &#123;</div><div class="line">			return nil, err</div><div class="line">		&#125;</div><div class="line">		if err := in.enforceRestrictions(op, operation, stack); err != nil &#123;</div><div class="line">			return nil, err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		var memorySize uint64</div><div class="line">		if operation.memorySize != nil &#123;</div><div class="line">			memSize, overflow := bigUint64(operation.memorySize(stack))</div><div class="line">			if overflow &#123;</div><div class="line">				return nil, errGasUintOverflow</div><div class="line">			&#125;</div><div class="line">			if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow &#123;</div><div class="line">				return nil, errGasUintOverflow</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)</div><div class="line">		if err != nil || !contract.UseGas(cost) &#123;</div><div class="line">			return nil, ErrOutOfGas</div><div class="line">		&#125;</div><div class="line">		if memorySize &gt; 0 &#123;</div><div class="line">			mem.Resize(memorySize)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if in.cfg.Debug &#123;</div><div class="line">			in.cfg.Tracer.CaptureState(in.evm, pc, op, gasCopy, cost, mem, stack, contract, in.evm.depth, err)</div><div class="line">			logged = true</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		res, err := operation.execute(&amp;pc, in.evm, contract, mem, stack)</div><div class="line">		if verifyPool &#123;</div><div class="line">			verifyIntegerPool(in.intPool)</div><div class="line">		&#125;</div><div class="line">		if operation.returns &#123;</div><div class="line">			in.returnData = res</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		switch &#123;</div><div class="line">		case err != nil:</div><div class="line">			return nil, err</div><div class="line">		case operation.reverts:</div><div class="line">			return res, errExecutionReverted</div><div class="line">		case operation.halts:</div><div class="line">			return res, nil</div><div class="line">		case !operation.jumps:</div><div class="line">			pc++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Run 方法会循环执行合约的代码，主要逻辑在 for 循环中，直到遇到 STOP，RETURN，SELFDESTRUCT 指令被执行，或者是遇到任意错误，或者说 done 标志被父 context 设置。这个循环才会结束。大致的执行过程是首先通过 <code>op = contract.GetOp(pc)</code> 拿到下一个需要执行的指令，接着通过 <code>operation := in.cfg.JumpTable[op]</code> 拿到对应的 operation，operation 的类型在 <code>core/vm/jump_table.go</code> 中定义，其中包括指令对应的方法，计算 gas 的方法，验证栈溢出的方法，计算内存的方法等。进行一系列检查后再通过 <code>operation.execute</code> 执行指令。最后一个指令的执行结果会决定整个合约代码的执行结果。到这一步，我们就完整地过了一遍以太坊虚拟机的执行过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>EVM 是一个256位的机器，以32字节来处理数据最佳</li>
<li>EVM 选择基于栈的虚拟机的原因其实不难理解，基于栈的虚拟机代码尺寸更小（因为可以用更小的空间放更多的指令），而且移植性更好（不需要通用寄存器），代码生成也更简单，不需要考虑为临时变量分配空间的问题。但从速度上来说，基于寄存器的架构更占优势。</li>
<li>在以太坊中部署的智能合约是完全不可修改的，只能通过部署新的合约来部署新的合约</li>
<li>Solidity 等编译器的优化一般以减少 gas 的使用为目标</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://ethereum.gitbooks.io/frontier-guide/content/contracts_and_transactions_intro.html" target="_blank" rel="external">contracts_and_transactions_intro</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="external">EIP 20: ERC-20 Token Standard</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-158" target="_blank" rel="external">EIP 158: State clearing</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethereum-Virtual-Machine-(EVM" target="_blank" rel="external">Ethereum Virtual Machine (EVM) Awesome List</a>-Awesome-List)</li>
<li><a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall" target="_blank" rel="external">Difference between CALL, CALLCODE and DELEGATECALL</a></li>
<li><a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="external">Diving Into The Ethereum VM</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale" target="_blank" rel="external">Design-Rationale</a></li>
<li><a href="https://github.com/takenobu-hs/ethereum-evm-illustrated" target="_blank" rel="external">takenobu-hs/ethereum-evm-illustrated</a></li>
<li><a href="https://paper.seebug.org/640/" target="_blank" rel="external">以太坊智能合约 OPCODE 逆向之理论基础篇</a></li>
<li><a href="https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf" target="_blank" rel="external">Virtual Machine Showdown: Stack Versus Registers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的文章 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）&lt;/a&gt; 讨论了 geth 中对交易的处理，其中有一个阶段需要通过 EVM 执行，如果交易转入方地址为空，则调用 EVM 的 Create 函数创建合约；如果不为空，则为普通转账，调用 Call() 函数。这一篇我们将深入以太坊的虚拟机看看具体的过程。&lt;/p&gt;
&lt;p&gt;这一篇需要对智能合约， ERC-20 标准，编译原理（了解编译器，解释器，虚拟机等概念），计算机组成原理（了解基于栈的虚拟机与基于寄存器的虚拟机的区别）有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）/</id>
    <published>2018-03-10T14:35:07.000Z</published>
    <updated>2018-10-19T02:09:39.522Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的文章，我们了解了 geth 的大致原理，知道了区块链是怎么组织构成的，有了 rlp，MPT 这些数据结构的基础，也知道了账户是怎么组织的，交易是如何管理的，挖矿是一个什么样的流程，这一篇我们将深入到交易的具体处理过程，看看交易过程中是如何修改世界状态，生成交易收据的。</p>
<p>这篇文章将涉及到 <code>core/types/transaction.go</code>, <code>core/state</code> 模块，需要对交易池，账户等基本概念有所了解。</p>
<a id="more"></a>
<p><code>core/state</code> 包提供了用户和合约的状态管理的功能。包括 trie，数据库，cache，日志和回滚相关功能。还记得<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a> 中曾给出的总体架构图吗？</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/stackexchange-ethereum-block-architecture.jpg" alt="https://i.stack.imgur.com/afWDt.jpg"> 按照定义，日志应该属于交易树的部分，但 <code>core/state</code> 中的 <code>journal.go</code> 却提供了日志的管理，这里有点不符合逻辑，可以稍稍注意一下。</p>
<p>前面的文章中有提过，在 geth 中存在三棵主要的 MPT 树，状态树，交易树，收据树。在交易上链的过程中，状态树，收据树会不断改变，</p>
<p>世界状态其实是一个账户地址和账户状态的映射，不管是外部账户还是合约账户，账户状态都包括：</p>
<ul>
<li>nonce，如果账户是一个外部拥有账户，nonce 代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce 代表此账户创建的合约序号</li>
<li>balance，该地址拥有 Wei 的数量。1Ether=10^18Wei</li>
<li>storageRoot， MPT 树的根节点哈希值。这个 MPT 会将此账户存储内容的哈希值进行编码，默认是空值</li>
<li>codeHash，该账户 EVM 代码的哈希值。对于合约账户，就是被哈希之后的代码，以 codeHash 保存。对于外部拥有账户，codeHash 是一个空字符串的哈希值</li>
</ul>
<p>以太坊还会为每笔交易生成收据，每张收据都包含有关交易的某些信息。包括以下内容：</p>
<ul>
<li>区块号</li>
<li>区块哈希</li>
<li>事务哈希值</li>
<li>当前交易使用的 gas</li>
<li>在当前交易执行后当前块中使用的 gas</li>
<li>执行当前事务时创建的日志</li>
</ul>
<p>我们先从收据树入手。</p>
<h2 id="插入区块更新状态"><a href="#插入区块更新状态" class="headerlink" title="插入区块更新状态"></a>插入区块更新状态</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>还记得在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 这一篇的 insertChain 方法中，有一个调用 <code>receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</code> 的动作，这是在插入转账区块后，更新状态树，收据树，我们来看看 <code>Process</code> 具体做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) &#123;</div><div class="line">	var (</div><div class="line">		receipts types.Receipts</div><div class="line">		usedGas  = new(uint64)</div><div class="line">		header   = block.Header()</div><div class="line">		allLogs  []*types.Log</div><div class="line">		gp       = new(GasPool).AddGas(block.GasLimit())</div><div class="line">	)</div><div class="line">	if p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == 0 &#123;</div><div class="line">		misc.ApplyDAOHardFork(statedb)</div><div class="line">	&#125;</div><div class="line">	for i, tx := range block.Transactions() &#123;</div><div class="line">		statedb.Prepare(tx.Hash(), block.Hash(), i)</div><div class="line">		receipt, _, err := ApplyTransaction(p.config, p.bc, nil, gp, statedb, header, tx, usedGas, cfg)</div><div class="line">		if err != nil &#123;</div><div class="line">			return nil, nil, 0, err</div><div class="line">		&#125;</div><div class="line">		receipts = append(receipts, receipt)</div><div class="line">		allLogs = append(allLogs, receipt.Logs...)</div><div class="line">	&#125;</div><div class="line">	p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles(), receipts)</div><div class="line"></div><div class="line">	return receipts, allLogs, *usedGas, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Process</code> 根据以太坊规则运行交易来对改变 statedb 的状态，以奖励挖矿者或其他的叔父节点。<code>Process</code> 会返回执行过程中累计的收据和日志，并返回过程中使用的 gas，如果 gas 不足导致任何交易执行失败，返回错误。</p>
<p><code>Process</code> 首先会声明变量，值得注意的是 GasPool 变量，它告诉你剩下还有多少 Gas 可以使用，在每一个交易的执行过程中，以太坊设计了 refund 的机制进行处理，偿还的 gas 也会加到 GasPool 中。接着处理 DAO 事件的硬分叉，接着遍历区块中的所有交易，通过调用 <code>ApplyTransaction</code> 获得每个交易的收据。这个过程结束后，调用一致性引擎的 <code>Finalize</code>，拿到区块奖励或叔块奖励，最终将世界状态写入到区块链中，也就是说 stateTrie 随着每次交易的执行变化，这个过程在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a> 也有提及，它通过 StateDB 的 <code>IntermediateRoot()</code> 方法实现。我们先深入到 <code>ApplyTransaction</code> 看看每一个交易是如何构成收据的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) &#123;</div><div class="line">	msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, 0, err</div><div class="line">	&#125;</div><div class="line">	vmenv := vm.NewEVM(context, statedb, config, cfg)</div><div class="line">	_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, 0, err</div><div class="line">	&#125;</div><div class="line">	var root []byte</div><div class="line">	if config.IsByzantium(header.Number) &#123;</div><div class="line">		statedb.Finalise(true)</div><div class="line">	&#125; else &#123;</div><div class="line">		root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</div><div class="line">	&#125;</div><div class="line">	*usedGas += gas</div><div class="line"></div><div class="line">	receipt := types.NewReceipt(root, failed, *usedGas)</div><div class="line">	receipt.TxHash = tx.Hash()</div><div class="line">	receipt.GasUsed = gas</div><div class="line">	if msg.To() == nil &#123;</div><div class="line">		receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</div><div class="line">	&#125;</div><div class="line">	receipt.Logs = statedb.GetLogs(tx.Hash())</div><div class="line">	receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</div><div class="line"></div><div class="line">	return receipt, gas, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每个交易，都会创建一个新的虚拟机环境，即根据输入参数封装 EVM 对象，接着调用 <code>ApplyMessage</code> 将交易应用于当前的状态中，<code>Finalise</code> 方法会调用 update 方法，将存放在 cache 的修改写入 trie 数据库中，返回的是使用的 gas，这部分代码涉及到 <code>core/state_transition.go</code>。</p>
<p>接着，如果是拜占庭硬分叉，直接调用 <code>statedb.Finalise(true)</code>，否则调用 <code>statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</code>，最后，初始化一个收据对象，其 <code>TxHash</code> 为交易哈希，<code>Logs</code> 字段通过 <code>statedb.GetLogs(tx.Hash())</code> 拿到，<code>Bloom</code> 字段通过 <code>types.CreateBloom(types.Receipts{receipt})</code> 创建，最后返回收据和消耗的 gas。</p>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>Process 部分的代码是插入区块时被调用的，而我们发现 Process 在处理每一个交易时，最终会调用 <code>core/state_transition.go</code> 中的 <code>Finalise</code>，实际上，如果说 <code>core/state_processor.go</code> 是用来处理区块级别的交易，那么可以说 <code>core/state_transition.go</code> 是用来处理一个一个的交易，最终将获得世界状态，收据，gas 等信息。</p>
<p>Transition 完成世界状态转换的工作，它会利用世界状态来执行交易，然后改变当前的世界状态。我们可以细看一下 <code>TransitionDb()</code> 的执行过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (st *StateTransition) TransitionDb() (ret []byte, usedGas uint64, failed bool, err error) &#123;</div><div class="line">	if err = st.preCheck(); err != nil &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	msg := st.msg</div><div class="line">	sender := vm.AccountRef(msg.From())</div><div class="line">	homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)</div><div class="line">	contractCreation := msg.To() == nil</div><div class="line"></div><div class="line">	gas, err := IntrinsicGas(st.data, contractCreation, homestead)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, 0, false, err</div><div class="line">	&#125;</div><div class="line">	if err = st.useGas(gas); err != nil &#123;</div><div class="line">		return nil, 0, false, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		evm = st.evm</div><div class="line">		vmerr error</div><div class="line">	)</div><div class="line">	if contractCreation &#123;</div><div class="line">		ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</div><div class="line">	&#125; else &#123;</div><div class="line">		st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)</div><div class="line">		ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</div><div class="line">	&#125;</div><div class="line">	if vmerr != nil &#123;</div><div class="line">		log.Debug(&quot;VM returned with error&quot;, &quot;err&quot;, vmerr)</div><div class="line">		if vmerr == vm.ErrInsufficientBalance &#123;</div><div class="line">			return nil, 0, false, vmerr</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	st.refundGas()</div><div class="line">	st.state.AddBalance(st.evm.Coinbase, new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</div><div class="line"></div><div class="line">	return ret, st.gasUsed(), vmerr != nil, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TransitionDb</code> 首先会调用 <code>preCheck</code>，<code>preCheck</code> 的作用是检测 Nonce 的值是否正确，然后通过 <code>buyGas()</code> 购买 Gas。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (st *StateTransition) buyGas() error &#123;</div><div class="line">	mgval := new(big.Int).Mul(new(big.Int).SetUint64(st.msg.Gas()), st.gasPrice)</div><div class="line">	if st.state.GetBalance(st.msg.From()).Cmp(mgval) &lt; 0 &#123;</div><div class="line">		return errInsufficientBalanceForGas</div><div class="line">	&#125;</div><div class="line">	if err := st.gp.SubGas(st.msg.Gas()); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	st.gas += st.msg.Gas()</div><div class="line"></div><div class="line">	st.initialGas = st.msg.Gas()</div><div class="line">	st.state.SubBalance(st.msg.From(), mgval)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>buyGas</code> 会从交易的转出方账户扣除 <code>GasLimit * gasPrice</code>，GasPool 也会减掉这笔 Gas 消耗。</p>
<p>回到 <code>TransitionDb</code> 方法，在 <code>preCheck()</code> 之后，会调用 <code>IntrinsicGas</code> 方法，计算交易的固有 Gas 消耗，这个消耗有两部分，一部分是交易（或创建合约）预设消耗量，一部分是根据交易 data 的非0字节和0字节长度决定的消耗量，<code>TransitionDb</code> 方法中最终会从 gas 中减去这笔消耗。再接下来就是 EVM 的执行，如果是创建合约，调用的是 <code>evm.Create(sender, st.data, st.gas, st.value)</code>，如果是普通的交易，调用的是 <code>evm.Call(sender, st.to(), st.data, st.gas, st.value)</code>，这两个方法很重要，在接下来的 (go-ethereum 源码笔记（core 模块-EVM）)[#TODO] 这篇文章中会有讲解，这两个方法同样也会消耗 gas。接着调用 <code>refundGas</code> 方法执行退 gas 的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (st *StateTransition) refundGas() &#123;</div><div class="line">	refund := st.gasUsed() / 2</div><div class="line">	if refund &gt; st.state.GetRefund() &#123;</div><div class="line">		refund = st.state.GetRefund()</div><div class="line">	&#125;</div><div class="line">	st.gas += refund</div><div class="line"></div><div class="line">	remaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gas), st.gasPrice)</div><div class="line">	st.state.AddBalance(st.msg.From(), remaining)</div><div class="line">	st.gp.AddGas(st.gas)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>refundGas</code> 首先会将用户剩下的 gas 还回去，但退回的金额不会超过用户使用的 gas 的 1/2。</p>
<p><code>TransitionDb</code> 最后会通过 <code>st.state.AddBalance</code> 奖励区块的挖掘者，这笔钱等于 <code>gasPrice*(initialGas-gas)</code>，至此，这个交易的 gas 消耗量计算就完成了。</p>
<h2 id="state-模块"><a href="#state-模块" class="headerlink" title="state 模块"></a>state 模块</h2><p>在上面的 Process, Transition 小节，我们了解了 geth 中状态管理的部分功能，实际上就管理世界状态而言，<code>core/state</code> 还提供了很多其他功能，不过这些功能大多只是在 EVM 进行合约的操作时才使用到，例如 <code>core/vm/instructions.go</code> 中的 makeLog 指令，在进行出栈操作后，最终还是会通过 StateDB 的 AddLog 方法实现写日志的功能。这里我们将深入 <code>core/state</code> 模块的实现，限于篇幅，无法面面俱到，我们只分析几个应用场景。</p>
<h3 id="存储以太坊合约和账户-StateDB"><a href="#存储以太坊合约和账户-StateDB" class="headerlink" title="存储以太坊合约和账户 StateDB"></a>存储以太坊合约和账户 StateDB</h3><p>stateDB 用来与以太坊中的世界状态进行交互，它可以与状态树进行交互，提供了检索合约，账户的功能。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">type StateDB struct &#123;</div><div class="line">	db   Database</div><div class="line">	trie Trie</div><div class="line">	</div><div class="line">	stateObjects      map[common.Address]*stateObject</div><div class="line">	stateObjectsDirty map[common.Address]struct&#123;&#125;</div><div class="line"></div><div class="line">	dbErr error</div><div class="line">	refund uint64</div><div class="line"></div><div class="line">	thash, bhash common.Hash</div><div class="line">	txIndex      int</div><div class="line">	logs         map[common.Hash][]*types.Log</div><div class="line">	logSize      uint</div><div class="line"></div><div class="line">	preimages map[common.Hash][]byte</div><div class="line"></div><div class="line">	journal        *journal</div><div class="line">	validRevisions []revision</div><div class="line">	nextRevisionId int</div><div class="line"></div><div class="line">	lock sync.Mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>stateObjects</code> 用来缓存状态对象，<code>stateObjectsDirty</code> 用来缓存被修改过的对象，这部分代码在 <code>core/state/state_object.go</code> 里。<code>stateObject</code> 主要依赖于 <code>core/state/database.go</code>，<code>core/state/database.go</code> 中的 Database（也是 StateDB 中的 Database） 封装了一下对 MPT 树的操作，可以增删改查世界状态，余额等。<br>journal 表示操作日志，<code>core/state/journal.go</code> 针对各种操作日志提供了对应的回滚功能，可以基于这个日志做一些事务类型的操作。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func New(root common.Hash, db Database) (*StateDB, error) &#123;</div><div class="line">	tr, err := db.OpenTrie(root)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return &amp;StateDB&#123;</div><div class="line">		db:                db,</div><div class="line">		trie:              tr,</div><div class="line">		stateObjects:      make(map[common.Address]*stateObject),</div><div class="line">		stateObjectsDirty: make(map[common.Address]struct&#123;&#125;),</div><div class="line">		logs:              make(map[common.Hash][]*types.Log),</div><div class="line">		preimages:         make(map[common.Hash][]byte),</div><div class="line">		journal:           newJournal(),</div><div class="line">	&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化的时候会利用 <code>OpenTrie</code> 获取 trie，这部分功能由 <code>core/state/database.go</code> 提供，<code>core/state/database.go</code> 封装了与数据库交互的代码，从 database 提供的接口中可以一窥一二。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type Database interface &#123;</div><div class="line">	OpenTrie(root common.Hash) (Trie, error)</div><div class="line">	OpenStorageTrie(addrHash, root common.Hash) (Trie, error)</div><div class="line">	CopyTrie(Trie) Trie</div><div class="line">	ContractCode(addrHash, codeHash common.Hash) ([]byte, error)</div><div class="line">	ContractCodeSize(addrHash, codeHash common.Hash) (int, error)</div><div class="line">	TrieDB() *trie.Database</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OpenTrie</code> 的会先从缓存中查找 trie，如果没有缓存的话构建个 trie 返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func (db *cachingDB) OpenTrie(root common.Hash) (Trie, error) &#123;</div><div class="line">	db.mu.Lock()</div><div class="line">	defer db.mu.Unlock()</div><div class="line"></div><div class="line">	for i := len(db.pastTries) - 1; i &gt;= 0; i-- &#123;</div><div class="line">		if db.pastTries[i].Hash() == root &#123;</div><div class="line">			return cachedTrie&#123;db.pastTries[i].Copy(), db&#125;, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	tr, err := trie.NewSecure(root, db.db, MaxTrieCacheGen)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return cachedTrie&#123;tr, db&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Database 中还有 <code>OpenStorage</code> 方法，该方法和 OpenTrie 类似；<code>ContractCode</code> 可以用来访问合约代码；<code>ContractCodeSize</code> 用来获取合约的大小；<code>CopyTrie</code> 返回一个指定 trie 的 copy。代码都没有什么特别的，这里不再赘述，</p>
<p>我们接着看 <code>stateDB</code> 提供的功能。我们通过几个例子看看 StateDB 如何与 stateObject，journal，Database 进行交互的。</p>
<h4 id="AddBalance-增加余额"><a href="#AddBalance-增加余额" class="headerlink" title="AddBalance 增加余额"></a>AddBalance 增加余额</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func (self *StateDB) AddBalance(addr common.Address, amount *big.Int) &#123;</div><div class="line">	stateObject := self.GetOrNewStateObject(addr)</div><div class="line">	if stateObject != nil &#123;</div><div class="line">		stateObject.AddBalance(amount)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>core/state/state_object.go</code> 中 <code>AddBalance</code> 方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func (c *stateObject) AddBalance(amount *big.Int) &#123;</div><div class="line">	if amount.Sign() == 0 &#123;</div><div class="line">		if c.empty() &#123;</div><div class="line">			c.touch()</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	c.SetBalance(new(big.Int).Add(c.Balance(), amount))</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *stateObject) SetBalance(amount *big.Int) &#123;</div><div class="line">	self.db.journal.append(balanceChange&#123;</div><div class="line">		account: &amp;self.address,</div><div class="line">		prev:    new(big.Int).Set(self.data.Balance),</div><div class="line">	&#125;)</div><div class="line">	self.setBalance(amount)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *stateObject) setBalance(amount *big.Int) &#123;</div><div class="line">	self.data.Balance = amount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 journal 记录了一条日志，方便回滚操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func (j *journal) append(entry journalEntry) &#123;</div><div class="line">	j.entries = append(j.entries, entry)</div><div class="line">	if addr := entry.dirtied(); addr != nil &#123;</div><div class="line">		j.dirties[*addr]++</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GetBalance-获取余额"><a href="#GetBalance-获取余额" class="headerlink" title="GetBalance 获取余额"></a>GetBalance 获取余额</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (self *StateDB) GetBalance(addr common.Address) *big.Int &#123;</div><div class="line">	stateObject := self.getStateObject(addr)</div><div class="line">	if stateObject != nil &#123;</div><div class="line">		return stateObject.Balance()</div><div class="line">	&#125;</div><div class="line">	return common.Big0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>core/state/state_object.go</code> 中，Balance 方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (self *stateObject) Balance() *big.Int &#123;</div><div class="line">	return self.data.Balance</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>data 是 账户类型，在 stateObject 中已有缓存。</p>
<p>通过写入余额，获取余额的两个例子，我们知道了 StateDB 提供的功能，以及 journal，state_object 模块的职责，可以看到目前为止这些功能还是在内存里操作的，而世界状态最终还是会写到 LevelDB 里。</p>
<h4 id="Commit-提交当前状态"><a href="#Commit-提交当前状态" class="headerlink" title="Commit 提交当前状态"></a>Commit 提交当前状态</h4><p>通过 StateDB 的 Commit 方法可以写入当前的世界状态到数据库中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">func (s *StateDB) Commit(deleteEmptyObjects bool) (root common.Hash, err error) &#123;</div><div class="line">	defer s.clearJournalAndRefund()</div><div class="line"></div><div class="line">	for addr := range s.journal.dirties &#123;</div><div class="line">		s.stateObjectsDirty[addr] = struct&#123;&#125;&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	for addr, stateObject := range s.stateObjects &#123;</div><div class="line">		_, isDirty := s.stateObjectsDirty[addr]</div><div class="line">		switch &#123;</div><div class="line">		case stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):</div><div class="line">			s.deleteStateObject(stateObject)</div><div class="line">		case isDirty:</div><div class="line">			if stateObject.code != nil &amp;&amp; stateObject.dirtyCode &#123;</div><div class="line">				s.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)</div><div class="line">				stateObject.dirtyCode = false</div><div class="line">			&#125;</div><div class="line">			if err := stateObject.CommitTrie(s.db); err != nil &#123;</div><div class="line">				return common.Hash&#123;&#125;, err</div><div class="line">			&#125;</div><div class="line">			s.updateStateObject(stateObject)</div><div class="line">		&#125;</div><div class="line">		delete(s.stateObjectsDirty, addr)</div><div class="line">	&#125;</div><div class="line">	root, err = s.trie.Commit(func(leaf []byte, parent common.Hash) error &#123;</div><div class="line">		var account Account</div><div class="line">		if err := rlp.DecodeBytes(leaf, &amp;account); err != nil &#123;</div><div class="line">			return nil</div><div class="line">		&#125;</div><div class="line">		if account.Root != emptyState &#123;</div><div class="line">			s.db.TrieDB().Reference(account.Root, parent)</div><div class="line">		&#125;</div><div class="line">		code := common.BytesToHash(account.CodeHash)</div><div class="line">		if code != emptyCode &#123;</div><div class="line">			s.db.TrieDB().Reference(code, parent)</div><div class="line">		&#125;</div><div class="line">		return nil</div><div class="line">	&#125;)</div><div class="line">	log.Debug(&quot;Trie cache stats after commit&quot;, &quot;misses&quot;, trie.CacheMisses(), &quot;unloads&quot;, trie.CacheUnloads())</div><div class="line">	return root, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终通过 <code>core/state/database.go</code> 中的 Commit 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (m cachedTrie) Commit(onleaf trie.LeafCallback) (common.Hash, error) &#123;</div><div class="line">	root, err := m.SecureTrie.Commit(onleaf)</div><div class="line">	if err == nil &#123;</div><div class="line">		m.db.pushTrie(m.SecureTrie)</div><div class="line">	&#125;</div><div class="line">	return root, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="IntermediateRoot-获取当前世界状态哈希"><a href="#IntermediateRoot-获取当前世界状态哈希" class="headerlink" title="IntermediateRoot 获取当前世界状态哈希"></a><code>IntermediateRoot</code> 获取当前世界状态哈希</h4><p>还记得我们在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a>  提到 <code>stateTrie</code> 比较特别，交易执行时，<code>stateTrie</code> 一直在变化，前文中提到，交易执行的入口函数 <code>StateProcessor.Process()</code> 会调用 <code>Engine</code> 的 <code>Finalize()</code> 方法，而 <code>Finalize</code> 方法最终会调用 <code>IntermediateRoot</code>  方法获取世界状态的当前 root 值并返回给 header.Root 进行赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func (s *StateDB) IntermediateRoot(deleteEmptyObjects bool) common.Hash &#123;</div><div class="line">	s.Finalise(deleteEmptyObjects)</div><div class="line">	return s.trie.Hash()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到这个方法会在交易执行的过程中被调用，返回的哈希值会被存到交易收据树里。</p>
<h4 id="snapshot-快照功能"><a href="#snapshot-快照功能" class="headerlink" title="snapshot 快照功能"></a>snapshot 快照功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">func (self *StateDB) Snapshot() int &#123;</div><div class="line">	id := self.nextRevisionId</div><div class="line">	self.nextRevisionId++</div><div class="line">	self.validRevisions = append(self.validRevisions, revision&#123;id, self.journal.length()&#125;)</div><div class="line">	return id</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *StateDB) RevertToSnapshot(revid int) &#123;</div><div class="line">	idx := sort.Search(len(self.validRevisions), func(i int) bool &#123;</div><div class="line">		return self.validRevisions[i].id &gt;= revid</div><div class="line">	&#125;)</div><div class="line">	if idx == len(self.validRevisions) || self.validRevisions[idx].id != revid &#123;</div><div class="line">		panic(fmt.Errorf(&quot;revision id %v cannot be reverted&quot;, revid))</div><div class="line">	&#125;</div><div class="line">	snapshot := self.validRevisions[idx].journalIndex</div><div class="line"></div><div class="line">	self.journal.revert(self, snapshot)</div><div class="line">	self.validRevisions = self.validRevisions[:idx]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Snapshot</code> 方法用来创建当前世界状态的快照，<code>RevertToSnapshot</code> 可以根据快照 id 进行回滚，这个功能通过 <code>core/state/journal.go</code> 的 <code>revert</code> 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (j *journal) revert(statedb *StateDB, snapshot int) &#123;</div><div class="line">	for i := len(j.entries) - 1; i &gt;= snapshot; i-- &#123;</div><div class="line">		j.entries[i].revert(statedb)</div><div class="line"></div><div class="line">		if addr := j.entries[i].dirtied(); addr != nil &#123;</div><div class="line">			if j.dirties[*addr]--; j.dirties[*addr] == 0 &#123;</div><div class="line">				delete(j.dirties, *addr)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	j.entries = j.entries[:snapshot]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">core-state源码分析</a></li>
<li><a href="http://www.wjblog.top/articles/d8361364/" target="_blank" rel="external">How does Ethereum work, anyway?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面的文章，我们了解了 geth 的大致原理，知道了区块链是怎么组织构成的，有了 rlp，MPT 这些数据结构的基础，也知道了账户是怎么组织的，交易是如何管理的，挖矿是一个什么样的流程，这一篇我们将深入到交易的具体处理过程，看看交易过程中是如何修改世界状态，生成交易收据的。&lt;/p&gt;
&lt;p&gt;这篇文章将涉及到 &lt;code&gt;core/types/transaction.go&lt;/code&gt;, &lt;code&gt;core/state&lt;/code&gt; 模块，需要对交易池，账户等基本概念有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（ethdb 模块）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88ethdb%20%E6%A8%A1%E5%9D%97%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（ethdb 模块）/</id>
    <published>2018-03-10T14:35:06.000Z</published>
    <updated>2018-10-19T15:35:12.469Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的文章，我们知道了有工作量证明的区块链是怎么构建的，然而区块链一直在内存中当然是不行的，我们需要将区块链持久化到数据库中。<br><a id="more"></a></p>
<p>区块链的本质是一个分布式数据库，尽管如此，底层使用的数据库并没有太大要求，不需要分布式，分片等等特性，这些特性是在数据库的上层做的。所有的节点都是一个完整的实例，是它们组成了一个分布式系统。就实现业务来说，我们只需要一个简单的 k-v 数据库就够了。</p>
<p>geth 采用的是 LevelDB，回头来看这个选择还是有很多可以反思的地方，LevelDB 在顺序读写的场景下性能很好，但 geth 在运行智能合约时，面临的更多的场景是大量时间耗费在世界状态的读写上，通过前面对 MPT 的分析我们知道，这些 IO 大多是离散随机的，这导致了 geth 的性能瓶颈，特别是在合约里的数据大量分布在 Storage Trie 的情况下，因为树的高度可能很高，而每加载一个节点都需要进行一次 IO。这一点在<a href="https://zhuanlan.zhihu.com/p/39262324" target="_blank" rel="external">以太坊(Ethereum) 的执行交易性能瓶颈</a>这篇文章中有论述。<a href="https://www.weibo.com/dcaoyuan" target="_blank" rel="external">邓草原</a> 正在开发的 Kesque 也可以关注一下。这不是本文重点，就不展开了。</p>
<p>中本聪的最初论文并没有提具体要用什么数据库，尽管如此，社区使用最多的参考实现 Bitcoin Core 最初使用的是 Berkeley DB，后来转而使用 levelDB 存区块链索引，以太坊的 Go，C++, Python 实现的客户端使用的是 LevelDB 数据库，Rust 客户端 Parity 使用的是 RocksDB。</p>
<p>go-ethereum 对 LevelDB 的增删改查是通过 ethdb 这个模块来交互的。ethdb 实际上是对 github.com/syndtr/goleveldb/leveldb 这个库的封装，其中增加了收集 metric 的功能。</p>
<p>如果想要对 LevelDB 有更深层次的了解可以自行查询相关资料。</p>
<p>ethdb 模块的功能比较单一，就4个文件：</p>
<ul>
<li>interface.go 定义数据库增删改查的接口</li>
<li>database.go 封装 levelDB 的代码</li>
<li>memory_database.go 基于内存的数据库，不会持久化到文件，只在测试时使用</li>
<li>database_test.go 测试用例</li>
</ul>
<h2 id="interface-go"><a href="#interface-go" class="headerlink" title="interface.go"></a>interface.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type Database interface &#123;</div><div class="line">	Putter</div><div class="line">	Get(key []byte) ([]byte, error)</div><div class="line">	Has(key []byte) (bool, error)</div><div class="line">	Delete(key []byte) error</div><div class="line">	Close()</div><div class="line">	NewBatch() Batch</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Database 接口定义了所有数据库操作，Putter 接口定义批量操作和普通操作的接口。批量操作不能多线程同时使用。</p>
<h2 id="memory-database-go"><a href="#memory-database-go" class="headerlink" title="memory_database.go"></a>memory_database.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type MemDatabase struct &#123;</div><div class="line">	db   map[string][]byte</div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个文件跟 LevelDB 没什么关系，它只是封装了内存里的 key-value 结构，暴露的增删改查的接口(Put，Has，Get，Keys，Delete 等等)跟对 LevelDB 的封装基本一致。加了锁以在多线程的情况下对资源进行保护。</p>
<h2 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h2><p>封装了 levelDB 接口，在 go-ethereum 中大量使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type LDBDatabase struct &#123;</div><div class="line">	fn string</div><div class="line">	db *leveldb.DB</div><div class="line"></div><div class="line">	compTimeMeter  metrics.Meter</div><div class="line">	compReadMeter  metrics.Meter</div><div class="line">	compWriteMeter metrics.Meter</div><div class="line">	diskReadMeter  metrics.Meter</div><div class="line">	diskWriteMeter metrics.Meter</div><div class="line"></div><div class="line">	quitLock sync.Mutex</div><div class="line">	quitChan chan chan error</div><div class="line"></div><div class="line">	log log.Logger</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Path, Put, Has, Get 等方法是对 levelDB 的封装，没有什么特别的，也不需要用锁，因为 github.com/syndtr/goleveldb/leveldb 支持多线程访问。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Path() string &#123;</div><div class="line">	return db.fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Put(key []byte, value []byte) error &#123;</div><div class="line">	return db.db.Put(key, value, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Has"><a href="#Has" class="headerlink" title="Has"></a>Has</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Has(key []byte) (bool, error) &#123;</div><div class="line">	return db.db.Has(key, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Get(key []byte) ([]byte, error) &#123;</div><div class="line">	dat, err := db.db.Get(key, nil)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return dat, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Delete(key []byte) error &#123;</div><div class="line">	return db.db.Delete(key, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p><code>compTimeMeter</code>, <code>compReadMeter</code>, <code>compWriteMeter</code>, <code>diskReadMeter</code>, <code>diskWriteMeter</code> 这几个方法都通过 <code>metrics.NewRegisteredMeter</code> 注册得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func (db *LDBDatabase) Meter(prefix string) &#123;</div><div class="line">	if !metrics.Enabled &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	db.compTimeMeter = metrics.NewRegisteredMeter(prefix+&quot;compact/time&quot;, nil)</div><div class="line">	db.compReadMeter = metrics.NewRegisteredMeter(prefix+&quot;compact/input&quot;, nil)</div><div class="line">	db.compWriteMeter = metrics.NewRegisteredMeter(prefix+&quot;compact/output&quot;, nil)</div><div class="line">	db.diskReadMeter = metrics.NewRegisteredMeter(prefix+&quot;disk/read&quot;, nil)</div><div class="line">	db.diskWriteMeter = metrics.NewRegisteredMeter(prefix+&quot;disk/write&quot;, nil)</div><div class="line"></div><div class="line">	db.quitLock.Lock()</div><div class="line">	db.quitChan = make(chan chan error)</div><div class="line">	db.quitLock.Unlock()</div><div class="line"></div><div class="line">	go db.meter(3 * time.Second)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过一个 goroutine 调用 db.meter。</p>
<p>该方法是一个死循环，过三秒钟就通过 <code>db.db.GetProperty(&quot;leveldb.iostats&quot;)</code> 获取一次 leveldb 的 stats，然后发到 metrics 系统。如果收到 quitChan 的信号就退出死循环。</p>
<h2 id="业务相关代码"><a href="#业务相关代码" class="headerlink" title="业务相关代码"></a>业务相关代码</h2><p>与业务直接相关的代码在 <code>core/rawdb</code> 目录下，基本上所有与底层数据库交互的代码都在这里，没有很复杂的内容，不过了解这些底层的数据结构对于理解业务很有帮助，可以自行浏览。</p>
<h2 id="key-gt-value"><a href="#key-gt-value" class="headerlink" title="key-&gt;value"></a>key-&gt;value</h2><p>以下是一些 geth 中常见的 key-value 对（在 <code>core/rawdb/schema.go</code> 中定义）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">value</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“h” + num + hash</td>
<td style="text-align:center">区块头的数据</td>
<td style="text-align:center">根据区块高度和区块哈希找到区块头数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“h” + num + hash + “t”</td>
<td style="text-align:center">区块总难度</td>
<td style="text-align:center">根据区块高度，区块哈希找到 totalDifficulty，即累计的区块难度的和</td>
</tr>
<tr>
<td style="text-align:center">“h” + num + “n”</td>
<td style="text-align:center">区块头哈希值</td>
<td style="text-align:center">根据存储的规范区块链高度找到区块头哈希值</td>
</tr>
<tr>
<td style="text-align:center">“H” + hash</td>
<td style="text-align:center">区块高度</td>
<td style="text-align:center">根据哈希值找到区块高度</td>
</tr>
<tr>
<td style="text-align:center">“b” + num + hash</td>
<td style="text-align:center">区块体的数据</td>
<td style="text-align:center">根据区块高度，区块哈希找到区块体的数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“r” + num + hash</td>
<td style="text-align:center">收据的数据</td>
<td style="text-align:center">根据区块高度，区块哈希找到收据的数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“l” + hash</td>
<td style="text-align:center">交易，收据查找的 metadata</td>
<td style="text-align:center">根据哈希值找到交易，收据查找的 metadata</td>
</tr>
<tr>
<td style="text-align:center">“B” + bit + section + hash</td>
<td style="text-align:center">布隆过滤器的结果</td>
<td style="text-align:center">用于日志的过滤</td>
</tr>
</tbody>
</table>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/syndtr/goleveldb" target="_blank" rel="external">LevelDB 的 Golang 实现</a></li>
<li><a href="https://github.com/google/leveldb" target="_blank" rel="external">LevelDB 的 C++ 实现</a></li>
<li><a href="https://www.zhihu.com/question/19887265/answer/78839142" target="_blank" rel="external">LSM 算法的原理是什么？</a></li>
<li><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/" target="_blank" rel="external">Log Structured Merge Trees</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39262324" target="_blank" rel="external">以太坊(Ethereum) 的执行交易性能瓶颈</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面的文章，我们知道了有工作量证明的区块链是怎么构建的，然而区块链一直在内存中当然是不行的，我们需要将区块链持久化到数据库中。&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（miner,consensus 模块-挖矿和共识算法）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88miner,%20consensus%20%E6%A8%A1%E5%9D%97-%E6%8C%96%E7%9F%BF%E5%92%8C%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（miner, consensus 模块-挖矿和共识算法）/</id>
    <published>2018-03-10T14:35:05.000Z</published>
    <updated>2018-09-22T08:23:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>前面的章节 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 描述了区块链世界的核心：区块，区块链。我们已经知道区块链可以用来存储交易的数据，也知道了如何在区块链里发起一笔交易，而问题是，往区块链中增加数据应该是一个较困难的操作，按照比特币论文里的说法，即需要一个 PoW（Proof of Work，工作量证明），否则每个人都能轻易往区块链中增加数据，安全性和一致性无法保证。这一点上，以太坊法和比特币类似，尽管略有不同，但大致都需要矿工的角色贡献计算力，完成一个复杂的计算，即找到一个区块的哈希值，验证正确之后才能加入到区块链中。这个过程就叫做挖矿。矿工们去做这件事当然是有一定利益驱使的，每完成一次挖矿，他们就能获得一些以太币奖励。</p>
<a id="more"></a>
<p>挖矿涉及的 Ethash 算法涉及到 miner, consensu 模块。</p>
<p>geth 中的挖矿是 CPU 挖矿，现在挖矿基本都是 GPU 挖矿了，因为这两者的效率已经不在一个数量级。但是研究 geth 的代码能给我们一个很好的参考，可以帮助我们了解挖矿的原理。关于 GPU 的挖矿可以参考：<a href="https://github.com/ethereum-mining/ethminer" target="_blank" rel="external">ethereum-mining/ethminer</a>，不过这块我还没有深入研究，有开发经验的朋友可以一起来讨论。</p>
<h1 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h1><p>以太坊从一开始就计划采用 PoS（Proof of Stack），但现阶段仍采用 PoW 的方式，尽管是临时的，以太坊的 PoW 从设计到实现都算得上精美。比特币诞生之初的设计理念是『一CPU一票』，随着显卡挖矿，ASIC 矿机的出现，这个价值回归用户的口号似乎成为空词，实际上矿机的出现是技术和生产力的进步，本质上和一CPU一票没有不同，云挖矿的模式也早就出现，不管是 CPU 还是显卡，矿机，其实质都是『一份资产的投入可低一票』。话虽如此，现在 PoW 的貌似畸形的模式还是给普通民众留下口实。</p>
<p>geth 使用的 Ethash 算法，之前叫做 Dagger-Hashimoto，从名字也可以看出来这是两个算法的结合体。Dagger-Hashimoto 算法的目标是（来自 <a href="https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md" target="_blank" rel="external">wiki /Dagger-Hashimoto.md</a>）：</p>
<ul>
<li>抵制矿机(ASIC，专门用于挖矿的芯片)</li>
<li>轻客户端验证</li>
<li>全链式存储</li>
</ul>
<h2 id="Hashimoto-算法"><a href="#Hashimoto-算法" class="headerlink" title="Hashimoto 算法"></a>Hashimoto 算法</h2><p><a href="https://github.com/knarfeh/papers/blob/master/Blockchain/Hashimoto%2C%20I%3AO%20bound%20proof%20of%20work.pdf" target="_blank" rel="external">Hashimoto：I/O bound proof of work</a></p>
<p>作者是 Thaddeus Dryja，这个算法的目标是通过 IO 限制来抵制矿机。</p>
<h2 id="Dagger-算法"><a href="#Dagger-算法" class="headerlink" title="Dagger 算法"></a>Dagger 算法</h2><p><a href="http://www.hashcash.org/papers/dagger.html" target="_blank" rel="external">Dagger: A Memory-Hard to Compute, Memory-Easy to Verify Scrypt Alternative</a></p>
<p>作者是 Vitalik，算法利用了 DAG(有向非循环图) 数据结构，目的是将挖矿操作限制为必须使用大内存，以抵抗矿机。</p>
<h2 id="Ethash"><a href="#Ethash" class="headerlink" title="Ethash"></a>Ethash</h2><p>Ethash 是以太坊使用的 PoW 算法，其原理可以用一个公式来概括：</p>
<p>$RAND(h, n) &lt;= \frac{M}{d}$</p>
<p>其中 h 是区块头的哈希值（没有 Nonce），n 是 Nonce 值，M 是一个极大的数字，d 指挖矿难度，RAND 是一个根据参数生成随机值的操作，挖矿的过程简单来说就是寻找适合的 nonce，使上述不等式成立。原理和比特币的基本相同，但 Ethash 稍特别一点，因为 geth 的开发者在设计初期就考虑了抵制矿机的问题里，Ethash 的具体步骤为：</p>
<ol>
<li>对于每个区块，先算出一个种子。种子的计算只依赖当前区块信息。</li>
<li>使用种子生成伪随机数据集，称为 cache。轻客户端需要保存 cache</li>
<li>基于 cache 生成 1GB 大小的数据集，称为 the DAG。这个数据集的每一个元素都依赖于 cache 中的某几个元素，只要有 cache 就可以快速计算出 DAG 中指定位置的元素。完整可挖矿客户端需要保存 DAG。</li>
<li>挖矿可以概括为从 DAG 中随机选择元素，然后暴力枚举选择一个 nonce 值，对其进行哈希计算，使其符合约定的难度，而这个难度其实就是要求哈希值的前缀包括多少个0。验证的时候，基于 cache 计算指定位置 DAG 元素，然后验证这个元素集合的哈希值结果小于某个值，这个过程只需要普通 CPU 和普通内存。</li>
<li>cache 和 DAG 每过一个周期更新一次，一个周期长度是 30000 个区块。DAG 只取决于区块数量，大小会随着时间推移线性增长，从 1GB 开始，每年大约增加 7GB。由于 DAG 需要很长时间生成，所以 geth 每次会维护2个 DAG 集合。</li>
</ol>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="miner-模块"><a href="#miner-模块" class="headerlink" title="miner 模块"></a>miner 模块</h2><p>挖矿的入口在 <code>miner/miner.go</code> 中的 Miner：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type Miner struct &#123;</div><div class="line">	mux *event.TypeMux</div><div class="line">	worker *worker</div><div class="line">	coinbase common.Address</div><div class="line">	mining   int32</div><div class="line">	eth      Backend</div><div class="line">	engine   consensus.Engine</div><div class="line">	canStart    int32</div><div class="line">	shouldStart int32</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>func New(eth Backend, config *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine)</code> 方法，可以获得一个 Miner 实例(见 <code>eth/backend.go</code> 的 <code>eth.miner = miner.New(eth, eth.chainConfig, eth.EventMux(), eth.engine)</code>)，在实例化的过程中，会通过一个 goroutine 调用 <code>miner.update()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (self *Miner) update() &#123;</div><div class="line">	events := self.mux.Subscribe(downloader.StartEvent&#123;&#125;, downloader.DoneEvent&#123;&#125;, downloader.FailedEvent&#123;&#125;)</div><div class="line">out:</div><div class="line">	for ev := range events.Chan() &#123;</div><div class="line">		switch ev.Data.(type) &#123;</div><div class="line">		case downloader.StartEvent:</div><div class="line">			atomic.StoreInt32(&amp;self.canStart, 0)</div><div class="line">			if self.Mining() &#123;</div><div class="line">				self.Stop()</div><div class="line">				atomic.StoreInt32(&amp;self.shouldStart, 1)</div><div class="line">				log.Info(&quot;Mining aborted due to sync&quot;)</div><div class="line">			&#125;</div><div class="line">		case downloader.DoneEvent, downloader.FailedEvent:</div><div class="line">			shouldStart := atomic.LoadInt32(&amp;self.shouldStart) == 1</div><div class="line"></div><div class="line">			atomic.StoreInt32(&amp;self.canStart, 1)</div><div class="line">			atomic.StoreInt32(&amp;self.shouldStart, 0)</div><div class="line">			if shouldStart &#123;</div><div class="line">				self.Start(self.coinbase)</div><div class="line">			&#125;</div><div class="line">			events.Unsubscribe()</div><div class="line">			break out</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动消息监听，当收到 downloader 的 <code>StartEvent</code>，表示本节点正在从其他节点下载新区块，这是 miner 会停止进行中的挖掘工作；如果收到 downloader 的 DoneEvent 或 FailEvent 方法，表明本节点的下载任务已经结束，这时可以开始挖掘新区块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (self *Miner) Start(coinbase common.Address) &#123;</div><div class="line">	atomic.StoreInt32(&amp;self.shouldStart, 1)</div><div class="line">	self.SetEtherbase(coinbase)</div><div class="line">	if atomic.LoadInt32(&amp;self.canStart) == 0 &#123;</div><div class="line">		log.Info(&quot;Network syncing, will start miner afterwards&quot;)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	atomic.StoreInt32(&amp;self.mining, 1)</div><div class="line">	log.Info(&quot;Starting mining operation&quot;)</div><div class="line">	self.worker.start()</div><div class="line">	self.worker.commitNewWork()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Miner</code> struct 中有一个 worker 类型成员变量，它指向 worker 中的 Work struct，当我们需要开始挖矿时，我们通过 <code>miner.Start()</code> 开始（见 <code>eth/backend.go</code> 中的 <code>StartMining</code>，L358）。在设置好 coinbase 和等待网络同步完成后，继续调用 <code>self.worker.start()</code>。</p>
<p><code>miner/woker.go</code> 负责管理挖矿，它有一组 agent，每个 agent 单独完成挖矿过程。见 worker.go 中的 L203-L213</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (self *worker) start() &#123;</div><div class="line">	...</div><div class="line">	// spin up agents</div><div class="line">	for agent := range self.agents &#123;</div><div class="line">		agent.Start()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>agent 指的是实现了共识算法的 agent。这个我们接下来再详细描述。需要注意的是，实例化 Worker 的时候，也就是在 miner.go 的 New 方法调用 <code>newWorker(config, engine, common.Address{}, eth, mux)</code> 的过程中，我们会以 goroutine 的方式调用其他 worker 的其他方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker &#123;</div><div class="line">	...</div><div class="line">	worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh)</div><div class="line">	worker.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)</div><div class="line">	worker.chainSideSub = eth.BlockChain().SubscribeChainSideEvent(worker.chainSideCh)</div><div class="line">	go worker.update()</div><div class="line">	go worker.wait()</div><div class="line">	worker.commitNewWork()</div><div class="line">	return worker</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>go worker.update()</code>, <code>go worker.wait()</code>, <code>worker.commitNewWork()</code> 这三行很重要，我们依次来看。</p>
<h3 id="worker-update"><a href="#worker-update" class="headerlink" title="worker.update()"></a>worker.update()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func (self *worker) update() &#123;</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case &lt;-self.chainHeadCh:</div><div class="line">			self.commitNewWork()</div><div class="line">		case ev := &lt;-self.chainSideCh:</div><div class="line">			self.uncleMu.Lock()</div><div class="line">			self.possibleUncles[ev.Block.Hash()] = ev.Block</div><div class="line">			self.uncleMu.Unlock()</div><div class="line">		case ev := &lt;-self.txCh:</div><div class="line">			if atomic.LoadInt32(&amp;self.mining) == 0 &#123;</div><div class="line">				self.currentMu.Lock()</div><div class="line">				acc, _ := types.Sender(self.current.signer, ev.Tx)</div><div class="line">				txs := map[common.Address]types.Transactions&#123;acc: &#123;ev.Tx&#125;&#125;</div><div class="line">				txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs)</div><div class="line"></div><div class="line">				self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase)</div><div class="line">				self.currentMu.Unlock()</div><div class="line">			&#125; else &#123;</div><div class="line">				if self.config.Clique != nil &amp;&amp; self.config.Clique.Period == 0 &#123;</div><div class="line">					self.commitNewWork()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>worker.update</code> 会监听 <code>ChainHeadEvent</code>，<code>ChainSideEvent</code>，<code>TxPreEvent</code> 3个事件。通过 <code>chainHeadCh</code>, <code>chainSideCh</code>, <code>txCh</code> 这3个 channel 来实现。<code>ChainHeadEvent</code> 事件指的是区块链中已经加入一个新的区块作为链头，这时候 worker 会开始挖掘下一个区块(在代码库中搜索 ChainHeadEvent，可以在 <code>blockchain.go</code> 中的 L1191 看到该事件是怎么触发的)。<code>ChainSideEvent</code> 指区块链中加入了一个新区块作为当前链头的分支，woker 会把这个区块放在 <code>possibleUncles</code> 数组，作为下一个挖掘区块可能的 Uncle 之一。当一个新的交易 <code>tx</code> 被加入 <code>TxPool</code> 中，会触发 <code>TxPreEvent</code>，如果这时 <code>worker</code> 没有在挖矿，那么开始执行，并把 <code>tx</code> 加入到 <code>Work.txs</code> 数组中，下次挖掘新区块可以使用。 </p>
<h3 id="worker-wait"><a href="#worker-wait" class="headerlink" title="worker.wait()"></a>worker.wait()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">func (self *worker) wait() &#123;</div><div class="line">	for &#123;</div><div class="line">		mustCommitNewWork := true</div><div class="line">		for result := range self.recv &#123;</div><div class="line">			atomic.AddInt32(&amp;self.atWork, -1)</div><div class="line"></div><div class="line">			if result == nil &#123;</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			block := result.Block</div><div class="line">			work := result.Work</div><div class="line"></div><div class="line">			for _, r := range work.receipts &#123;</div><div class="line">				for _, l := range r.Logs &#123;</div><div class="line">					l.BlockHash = block.Hash()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			for _, log := range work.state.Logs() &#123;</div><div class="line">				log.BlockHash = block.Hash()</div><div class="line">			&#125;</div><div class="line">			stat, err := self.chain.WriteBlockWithState(block, work.receipts, work.state)</div><div class="line">			if err != nil &#123;</div><div class="line">				log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err)</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			if stat == core.CanonStatTy &#123;</div><div class="line">				mustCommitNewWork = false</div><div class="line">			&#125;</div><div class="line">			log.Error(&quot;I got new block&quot;)</div><div class="line">			self.mux.Post(core.NewMinedBlockEvent&#123;Block: block&#125;)</div><div class="line">			var (</div><div class="line">				events []interface&#123;&#125;</div><div class="line">				logs   = work.state.Logs()</div><div class="line">			)</div><div class="line">			events = append(events, core.ChainEvent&#123;Block: block, Hash: block.Hash(), Logs: logs&#125;)</div><div class="line">			if stat == core.CanonStatTy &#123;</div><div class="line">				events = append(events, core.ChainHeadEvent&#123;Block: block&#125;)</div><div class="line">			&#125;</div><div class="line">			self.chain.PostChainEvents(events, logs)</div><div class="line"></div><div class="line">			self.unconfirmed.(block.NumberU64(), block.Hash())</div><div class="line"></div><div class="line">			if mustCommitNewWork &#123;</div><div class="line">				self.commitNewWork()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>worker.wait</code> 执行挖完一个区块后的操作，通过 Result 这个 chan 实现，agent 完成挖矿后，从 chan 中获取 Block 和 Work 对象，Block 会被写到数据库中，加入本地的区块链，成为新的链头。完成这个操作后，会发送一条 <code>NewMinedBlockEvent</code> 事件，其他节点会决定是否接受这个新区块成为区块链新的链头。</p>
<h3 id="worker-commitNewWork"><a href="#worker-commitNewWork" class="headerlink" title="worker.commitNewWork()"></a>worker.commitNewWork()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line">func (self *worker) commitNewWork() &#123;</div><div class="line">	self.mu.Lock()</div><div class="line">	defer self.mu.Unlock()</div><div class="line">	self.uncleMu.Lock()</div><div class="line">	defer self.uncleMu.Unlock()</div><div class="line">	self.currentMu.Lock()</div><div class="line">	defer self.currentMu.Unlock()</div><div class="line"></div><div class="line">	tstart := time.Now()</div><div class="line">	parent := self.chain.CurrentBlock()</div><div class="line"></div><div class="line">	tstamp := tstart.Unix()</div><div class="line">	if parent.Time().Cmp(new(big.Int).SetInt64(tstamp)) &gt;= 0 &#123;</div><div class="line">		tstamp = parent.Time().Int64() + 1</div><div class="line">	&#125;</div><div class="line">	if now := time.Now().Unix(); tstamp &gt; now+1 &#123;</div><div class="line">		wait := time.Duration(tstamp-now) * time.Second</div><div class="line">		log.Info(&quot;Mining too far in the future&quot;, &quot;wait&quot;, common.PrettyDuration(wait))</div><div class="line">		time.Sleep(wait)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	num := parent.Number()</div><div class="line">	header := &amp;types.Header&#123;</div><div class="line">		ParentHash: parent.Hash(),</div><div class="line">		Number:     num.Add(num, common.Big1),</div><div class="line">		GasLimit:   core.CalcGasLimit(parent),</div><div class="line">		Extra:      self.extra,</div><div class="line">		Time:       big.NewInt(tstamp),</div><div class="line">	&#125;</div><div class="line">	if self.isRunning() &#123;</div><div class="line">		if self.coinbase == (common.Address&#123;&#125;) &#123;</div><div class="line">			log.Error(&quot;Refusing to mine without etherbase&quot;)</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">		header.Coinbase = self.coinbase</div><div class="line">	&#125;</div><div class="line">	if err := self.engine.Prepare(self.chain, header); err != nil &#123;</div><div class="line">		log.Error(&quot;Failed to prepare header for mining&quot;, &quot;err&quot;, err)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if daoBlock := self.config.DAOForkBlock; daoBlock != nil &#123;</div><div class="line">		limit := new(big.Int).Add(daoBlock, params.DAOForkExtraRange)</div><div class="line">		if header.Number.Cmp(daoBlock) &gt;= 0 &amp;&amp; header.Number.Cmp(limit) &lt; 0 &#123;</div><div class="line">			if self.config.DAOForkSupport &#123;</div><div class="line">				header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</div><div class="line">			&#125; else if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</div><div class="line">				header.Extra = []byte&#123;&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	err := self.makeCurrent(parent, header)</div><div class="line">	if err != nil &#123;</div><div class="line">		log.Error(&quot;Failed to create mining context&quot;, &quot;err&quot;, err)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	env := self.current</div><div class="line">	if self.config.DAOForkSupport &amp;&amp; self.config.DAOForkBlock != nil &amp;&amp; self.config.DAOForkBlock.Cmp(header.Number) == 0 &#123;</div><div class="line">		misc.ApplyDAOHardFork(env.state)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		uncles    []*types.Header</div><div class="line">		badUncles []common.Hash</div><div class="line">	)</div><div class="line">	for hash, uncle := range self.possibleUncles &#123;</div><div class="line">		if len(uncles) == 2 &#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">		if err := self.commitUncle(env, uncle.Header()); err != nil &#123;</div><div class="line">			log.Trace(&quot;Bad uncle found and will be removed&quot;, &quot;hash&quot;, hash)</div><div class="line">			log.Trace(fmt.Sprint(uncle))</div><div class="line"></div><div class="line">			badUncles = append(badUncles, hash)</div><div class="line">		&#125; else &#123;</div><div class="line">			log.Debug(&quot;Committing new uncle to block&quot;, &quot;hash&quot;, hash)</div><div class="line">			uncles = append(uncles, uncle.Header())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for _, hash := range badUncles &#123;</div><div class="line">		delete(self.possibleUncles, hash)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		emptyBlock *types.Block</div><div class="line">		fullBlock  *types.Block</div><div class="line">	)</div><div class="line"></div><div class="line">	emptyState := env.state.Copy()</div><div class="line">	if emptyBlock, err = self.engine.Finalize(self.chain, header, emptyState, nil, uncles, nil); err != nil &#123;</div><div class="line">		log.Error(&quot;Failed to finalize block for temporary sealing&quot;, &quot;err&quot;, err)</div><div class="line">	&#125; else &#123;</div><div class="line">		if self.isRunning() &#123;</div><div class="line">			log.Info(&quot;Commit new empty mining work&quot;, &quot;number&quot;, emptyBlock.Number(), &quot;uncles&quot;, len(uncles))</div><div class="line">			self.push(&amp;Package&#123;nil, emptyState, emptyBlock&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	pending, err := self.eth.TxPool().Pending()</div><div class="line">	if err != nil &#123;</div><div class="line">		log.Error(&quot;Failed to fetch pending transactions&quot;, &quot;err&quot;, err)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	txs := types.NewTransactionsByPriceAndNonce(self.current.signer, pending)</div><div class="line">	env.commitTransactions(self.mux, txs, self.chain, self.coinbase)</div><div class="line"></div><div class="line">	if fullBlock, err = self.engine.Finalize(self.chain, header, env.state, env.txs, uncles, env.receipts); err != nil &#123;</div><div class="line">		log.Error(&quot;Failed to finalize block for sealing&quot;, &quot;err&quot;, err)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if self.isRunning() &#123;</div><div class="line">		log.Info(&quot;Commit new full mining work&quot;, &quot;number&quot;, fullBlock.Number(), &quot;txs&quot;, env.tcount, &quot;uncles&quot;, len(uncles), &quot;elapsed&quot;, common.PrettyDuration(time.Since(tstart)))</div><div class="line">		self.unconfirmed.Shift(fullBlock.NumberU64() - 1)</div><div class="line">		self.push(&amp;Package&#123;env.receipts, env.state, fullBlock&#125;)</div><div class="line">	&#125;</div><div class="line">	self.updateSnapshot()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commitNewWork</code> 的作用是完成待挖掘区块的组装，最后通过 <code>func (self *worker) push(p *Package)</code> 让 agent 开始工作。具体来说，首先获取以系统当前时间作为新区块的时间，但要确保父区块的时间要早于新区块时间，否则进行 sleep 操作；接着构造区块头，确定父区块哈希值，当前区块编号，Gas 消耗数，附加数据，时间等，区块头的其他属性会在公式算法中确定；然后调用 <code>engine.Prepare</code>，准备好 Header 对象；处理 DAO 硬分叉的情况，增加附加数据；再接下来会从交易池里获取交易，加入到新区块的交易列表中，从 <code>possibleUncles</code> 获取叔区块；最后调用一致性引擎的 <code>Finalize()</code> 方法，给区块头增加 <code>Root</code>, <code>TxHash</code>, <code>ReceiptHash</code> 等属性，将创建的 <code>Package</code> 通过 channel 发送给 agent，进行挖矿操作。</p>
<h2 id="consensus-模块"><a href="#consensus-模块" class="headerlink" title="consensus 模块"></a>consensus 模块</h2><p>通过以上的分析，我们了解到 <code>miner/miner.go</code>, <code>miner/worker.go</code> 这几个模块的只是一些对 chan 的创建和订阅，封装挖矿所需数据的操作，真正的挖矿的过程在 <code>agent</code> 里面。<code>miner/worker.go</code> 中定义了 <code>agent</code> 的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type Agent interface &#123;</div><div class="line">	Work() chan&lt;- *Work</div><div class="line">	SetReturnCh(chan&lt;- *Result)</div><div class="line">	Stop()</div><div class="line">	Start()</div><div class="line">	GetHashRate() int64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实现在 <code>miner/agent.go</code> 中，而 <code>miner/agent.go</code> 的代码实际上是 consensus 模块的封装，我们先来看看 <code>miner/agent.go</code> 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">func (self *CpuAgent) Start() &#123;</div><div class="line">	if !atomic.CompareAndSwapInt32(&amp;self.isMining, 0, 1) &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	go self.update()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *CpuAgent) update() &#123;</div><div class="line">out:</div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case p := &lt;-self.taskCh:</div><div class="line">			self.mu.Lock()</div><div class="line">			if self.quitCurrentOp != nil &#123;</div><div class="line">				close(self.quitCurrentOp)</div><div class="line">			&#125;</div><div class="line">			self.quitCurrentOp = make(chan struct&#123;&#125;)</div><div class="line">			go self.mine(p, self.quitCurrentOp)</div><div class="line">			self.mu.Unlock()</div><div class="line">		case &lt;-self.stop:</div><div class="line">			self.mu.Lock()</div><div class="line">			if self.quitCurrentOp != nil &#123;</div><div class="line">				close(self.quitCurrentOp)</div><div class="line">				self.quitCurrentOp = nil</div><div class="line">			&#125;</div><div class="line">			self.mu.Unlock()</div><div class="line">			break out</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们提到 <code>commitNewWork</code> 提供挖矿数据的组装，然后通过 <code>func (self *worker) push(p *Package)</code> 将数据写入 <code>update()</code> 的 <code>taskCh</code> 这个 chan 中，<code>CpuAgent</code> 通过这个 chan 拿到 <code>Package</code> 对象，然后调用 <code>self.mine(work, self, quitCurrentOp)</code>，如果收到停止的消息，就退出相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (self *CpuAgent) mine(work *Work, stop &lt;-chan struct&#123;&#125;) &#123;</div><div class="line">	if result, err := self.engine.Seal(self.chain, work.Block, stop); result != nil &#123;</div><div class="line">		log.Info(&quot;Successfully sealed new block&quot;, &quot;number&quot;, result.Number(), &quot;hash&quot;, result.Hash())</div><div class="line">		self.returnCh &lt;- &amp;Result&#123;work, result&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		if err != nil &#123;</div><div class="line">			log.Warn(&quot;Block sealing failed&quot;, &quot;err&quot;, err)</div><div class="line">		&#125;</div><div class="line">		self.returnCh &lt;- nil</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>mine</code> 方法是 <code>engine.Seal</code> 的简单封装，共识算法会对传入的区块进行真正的挖矿操作，如果成功，<code>Block</code> 和 <code>work</code> 对象会通过 chan 传给 <code>work.wait</code> 进行处理。</p>
<h3 id="共识算法-ethash"><a href="#共识算法-ethash" class="headerlink" title="共识算法 ethash"></a>共识算法 ethash</h3><p>共识算法 Engine 接口的定义在 <code>consensus/consensus.go</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type Engine interface &#123;</div><div class="line">	Author(header *types.Header) (common.Address, error)</div><div class="line">	VerifyHeader(chain ChainReader, header *types.Header, seal bool) error</div><div class="line">	VerifyHeaders(chain ChainReader, headers []*types.Header, seals []bool) (chan&lt;- struct&#123;&#125;, &lt;-chan error)</div><div class="line">	VerifySeal(chain ChainReader, header *types.Header) error</div><div class="line">	Prepare(chain ChainReader, header *types.Header) error</div><div class="line">	Finalize(chain ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction,</div><div class="line">		uncles []*types.Header, receipts []*types.Receipt) (*types.Block, error)</div><div class="line">	Seal(chain ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error)</div><div class="line">	CalcDifficulty(chain ChainReader, time uint64, parent *types.Header) *big.Int</div><div class="line">	APIs(chain ChainReader) []rpc.API</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有两个实现，一个是 ethash, 一个是 clique，clique 只在测试网络中有使用，这里我们主要讨论 ethash。在公式算法的引擎中，最重要的两个方法大概是 <code>Seal</code> 和 <code>VerifySeal</code>，一个用来挖矿，找到 nonce，一个用来验证挖矿结果，下面我们将讨论 ethash 中的 <code>Seal</code>，<code>VerifySeal</code> 的实现。</p>
<p>最开始我们简述了 Dagger-Hashimoto 算法，然后我们从 CPU 挖矿的入口函数开始，层层剖析，最终发现挖矿的核心逻辑在 consensus 目录下，接下来我们就来看看 CPU 挖矿到底是怎么实现的。</p>
<p>前面说到，挖矿需要一个基于一个数据集，那么我们先来看看数据集是怎么生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) dataset(block uint64) *dataset &#123;</div><div class="line">	epoch := block / epochLength</div><div class="line">	currentI, futureI := ethash.datasets.get(epoch)</div><div class="line">	current := currentI.(*dataset)</div><div class="line">	current.generate(ethash.config.DatasetDir, ethash.config.DatasetsOnDisk, ethash.config.PowMode == ModeTest)</div><div class="line">	if futureI != nil &#123;</div><div class="line">		future := futureI.(*dataset)</div><div class="line">		go future.generate(ethash.config.DatasetDir, ethash.config.DatasetsOnDisk, ethash.config.PowMode == ModeTest)</div><div class="line">	&#125;</div><div class="line">	return current</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>consensus/ethash/ethash.go</code>中，dataset 方法对数据集进行了封装。首先尝试从内存中取得，如果不存在则在文件目录中取得，如果还是不存在则通过 <code>func (d *dataset) generate(dir string, limit int, test bool)</code> 生成。具体来说，首先，我们计算 epoch，前面说到，每 30000 个区块就会换 DAG，这里的 30000 也就是 epochLength，也就是说 epoch 不变的的话，DAG 也不需要变。</p>
<p>先通过 <code>get</code> 尝试从内存中取得 dataset。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func (lru *lru) get(epoch uint64) (item, future interface&#123;&#125;) &#123;</div><div class="line">	lru.mu.Lock()</div><div class="line">	defer lru.mu.Unlock()</div><div class="line">	item, ok := lru.cache.Get(epoch)</div><div class="line">	if !ok &#123;</div><div class="line">		if lru.future &gt; 0 &amp;&amp; lru.future == epoch &#123;</div><div class="line">			item = lru.futureItem</div><div class="line">		&#125; else &#123;</div><div class="line">			log.Trace(&quot;Requiring new ethash &quot;+lru.what, &quot;epoch&quot;, epoch)</div><div class="line">			item = lru.new(epoch)</div><div class="line">		&#125;</div><div class="line">		lru.cache.Add(epoch, item)</div><div class="line">	&#125;</div><div class="line">	if epoch &lt; maxEpoch-1 &amp;&amp; lru.future &lt; epoch+1 &#123;</div><div class="line">		log.Trace(&quot;Requiring new future ethash &quot;+lru.what, &quot;epoch&quot;, epoch+1)</div><div class="line">		future = lru.new(epoch + 1)</div><div class="line">		lru.future = epoch + 1</div><div class="line">		lru.futureItem = future</div><div class="line">	&#125;</div><div class="line">	return item, future</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get 方法会返回两个 interface(实际类型为 dataset)，第一个是当前 epoch 对应的 dataset，第二个值是未来会用到的 dataset（epoch +1），如果不为空，表明需要重新生成，如果为空，表明之前已经生成过了。回到 dataset 方法，我们看看 DAG 是怎么通过 <code>generate</code> 方法生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">func (d *dataset) generate(dir string, limit int, test bool) &#123;</div><div class="line">	d.once.Do(func() &#123;</div><div class="line">		csize := cacheSize(d.epoch*epochLength + 1)</div><div class="line">		dsize := datasetSize(d.epoch*epochLength + 1)</div><div class="line">		seed := seedHash(d.epoch*epochLength + 1)</div><div class="line">		if test &#123;</div><div class="line">			csize = 1024</div><div class="line">			dsize = 32 * 1024</div><div class="line">		&#125;</div><div class="line">		if dir == &quot;&quot; &#123;</div><div class="line">			cache := make([]uint32, csize/4)</div><div class="line">			generateCache(cache, d.epoch, seed)</div><div class="line"></div><div class="line">			d.dataset = make([]uint32, dsize/4)</div><div class="line">			generateDataset(d.dataset, d.epoch, cache)</div><div class="line">		&#125;</div><div class="line">		var endian string</div><div class="line">		if !isLittleEndian() &#123;</div><div class="line">			endian = &quot;.be&quot;</div><div class="line">		&#125;</div><div class="line">		path := filepath.Join(dir, fmt.Sprintf(&quot;full-R%d-%x%s&quot;, algorithmRevision, seed[:8], endian))</div><div class="line">		logger := log.New(&quot;epoch&quot;, d.epoch)</div><div class="line"></div><div class="line">		runtime.SetFinalizer(d, (*dataset).finalizer)</div><div class="line"></div><div class="line">		d.dump, d.mmap, d.dataset, err = memoryMap(path)</div><div class="line">		if err == nil &#123;</div><div class="line">			logger.Debug(&quot;Loaded old ethash dataset from disk&quot;)</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">		logger.Debug(&quot;Failed to load old ethash dataset&quot;, &quot;err&quot;, err)</div><div class="line">		cache := make([]uint32, csize/4)</div><div class="line">		generateCache(cache, d.epoch, seed)</div><div class="line"></div><div class="line">		d.dump, d.mmap, d.dataset, err = memoryMapAndGenerate(path, dsize, func(buffer []uint32) &#123; generateDataset(buffer, d.epoch, cache) &#125;)</div><div class="line">		if err != nil &#123;</div><div class="line">			logger.Error(&quot;Failed to generate mapped ethash dataset&quot;, &quot;err&quot;, err)</div><div class="line"></div><div class="line">			d.dataset = make([]uint32, dsize/2)</div><div class="line">			generateDataset(d.dataset, d.epoch, cache)</div><div class="line">		&#125;</div><div class="line">		for ep := int(d.epoch) - limit; ep &gt;= 0; ep-- &#123;</div><div class="line">			seed := seedHash(uint64(ep)*epochLength + 1)</div><div class="line">			path := filepath.Join(dir, fmt.Sprintf(&quot;full-R%d-%x%s&quot;, algorithmRevision, seed[:8], endian))</div><div class="line">			os.Remove(path)</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过 <code>csize := cacheSize(d.epoch*epochLength + 1)</code>，<code>dsize := datasetSize(d.epoch*epochLength + 1)</code> 这两个调用得到缓存大小和数据集大小，前面有介绍，这两个大小是根据区块数量线性增长的，深入到这两个方法中，你会发现 <code>cacheSize</code> 调用 <code>calcCacheSize</code> 这样的一层层调用，ethereum 的维基页面里给出的 Python 代码可能更直观一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def get_cache_size(block_number):</div><div class="line">    sz = CACHE_BYTES_INIT + CACHE_BYTES_GROWTH * (block_number // EPOCH_LENGTH)</div><div class="line">    sz -= HASH_BYTES</div><div class="line">    while not isprime(sz / HASH_BYTES):</div><div class="line">        sz -= 2 * HASH_BYTES</div><div class="line">    return sz</div><div class="line"></div><div class="line">def get_full_size(block_number):</div><div class="line">    sz = DATASET_BYTES_INIT + DATASET_BYTES_GROWTH * (block_number // EPOCH_LENGTH)</div><div class="line">    sz -= MIX_BYTES</div><div class="line">    while not isprime(sz / MIX_BYTES):</div><div class="line">        sz -= 2 * MIX_BYTES</div><div class="line">    return sz</div></pre></td></tr></table></figure>
<p>前 6140000 个区块的缓存大小和数据集大小已经硬编码在 <code>consensus/ethash/algorithm.go</code> 的 <code>datasetSizes</code> 和 <code>cacheSizes</code> 中，显然这样能加快得到这两个集合的速度。接下来我们通过 <code>seedHash</code> 来生成 seed。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func seedHash(block uint64) []byte &#123;</div><div class="line">	seed := make([]byte, 32)</div><div class="line">	if block &lt; epochLength &#123;</div><div class="line">		return seed</div><div class="line">	&#125;</div><div class="line">	keccak256 := makeHasher(sha3.NewKeccak256())</div><div class="line">	for i := 0; i &lt; int(block/epochLength); i++ &#123;</div><div class="line">		keccak256(seed, seed)</div><div class="line">	&#125;</div><div class="line">	return seed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续看 <code>generate</code> 方法，可以看到，主要逻辑在 <code>generateCache</code>， <code>generateDataset</code> 这两个方法，我们依次来看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">func generateCache(dest []uint32, epoch uint64, seed []byte) &#123;</div><div class="line">	logger := log.New(&quot;epoch&quot;, epoch)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	defer func() &#123;</div><div class="line">		elapsed := time.Since(start)</div><div class="line"></div><div class="line">		logFn := logger.Debug</div><div class="line">		if elapsed &gt; 3*time.Second &#123;</div><div class="line">			logFn = logger.Info</div><div class="line">		&#125;</div><div class="line">		logFn(&quot;Generated ethash verification cache&quot;, &quot;elapsed&quot;, common.PrettyDuration(elapsed))</div><div class="line">	&#125;()</div><div class="line">	header := *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest))</div><div class="line">	header.Len *= 4</div><div class="line">	header.Cap *= 4</div><div class="line">	cache := *(*[]byte)(unsafe.Pointer(&amp;header))</div><div class="line"></div><div class="line">	size := uint64(len(cache))</div><div class="line">	rows := int(size) / hashBytes</div><div class="line"></div><div class="line">	var progress uint32</div><div class="line"></div><div class="line">	done := make(chan struct&#123;&#125;)</div><div class="line">	defer close(done)</div><div class="line"></div><div class="line">	go func() &#123;</div><div class="line">		for &#123;</div><div class="line">			select &#123;</div><div class="line">			case &lt;-done:</div><div class="line">				return</div><div class="line">			case &lt;-time.After(3 * time.Second):</div><div class="line">				logger.Info(&quot;Generating ethash verification cache&quot;, &quot;percentage&quot;, atomic.LoadUint32(&amp;progress)*100/uint32(rows)/4, &quot;elapsed&quot;, common.PrettyDuration(time.Since(start)))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line"></div><div class="line">	keccak512(cache, seed)</div><div class="line">	for offset := uint64(hashBytes); offset &lt; size; offset += hashBytes &#123;</div><div class="line">		keccak512(cache[offset:], cache[offset-hashBytes:offset])</div><div class="line">		atomic.AddUint32(&amp;progress, 1)</div><div class="line">	&#125;</div><div class="line">	temp := make([]byte, hashBytes)</div><div class="line"></div><div class="line">	for i := 0; i &lt; cacheRounds; i++ &#123;</div><div class="line">		for j := 0; j &lt; rows; j++ &#123;</div><div class="line">			var (</div><div class="line">				srcOff = ((j - 1 + rows) % rows) * hashBytes</div><div class="line">				dstOff = j * hashBytes</div><div class="line">				xorOff = (binary.LittleEndian.Uint32(cache[dstOff:]) % uint32(rows)) * hashBytes</div><div class="line">			)</div><div class="line">			bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBytes], cache[xorOff:xorOff+hashBytes])</div><div class="line">			keccak512(cache[dstOff:], temp)</div><div class="line"></div><div class="line">			atomic.AddUint32(&amp;progress, 1)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if !isLittleEndian() &#123;</div><div class="line">		swap(cache)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>generateCache</code> 方法会根据 <code>epoch</code>，<code>seed</code> 的值生成 cache。整个过程可以用下面的 Python 代码描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def mkcache(cache_size, seed):</div><div class="line">    n = cache_size // HASH_BYTES</div><div class="line">    o = [sha3_512(seed)]</div><div class="line">    for i in range(1, n):</div><div class="line">        o.append(sha3_512(o[-1]))</div><div class="line"></div><div class="line">    for _ in range(CACHE_ROUNDS):</div><div class="line">        for i in range(n):</div><div class="line">            v = o[i][0] % n</div><div class="line">            o[i] = sha3_512(map(xor, o[(i-1+n) % n], o[v]))</div><div class="line"></div><div class="line">    return o</div></pre></td></tr></table></figure>
<p>生成数据集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">func generateDataset(dest []uint32, epoch uint64, cache []uint32) &#123;</div><div class="line">	logger := log.New(&quot;epoch&quot;, epoch)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	defer func() &#123;</div><div class="line">		elapsed := time.Since(start)</div><div class="line"></div><div class="line">		logFn := logger.Debug</div><div class="line">		if elapsed &gt; 3*time.Second &#123;</div><div class="line">			logFn = logger.Info</div><div class="line">		&#125;</div><div class="line">		logFn(&quot;Generated ethash verification cache&quot;, &quot;elapsed&quot;, common.PrettyDuration(elapsed))</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	swapped := !isLittleEndian()</div><div class="line"></div><div class="line">	header := *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest))</div><div class="line">	header.Len *= 4</div><div class="line">	header.Cap *= 4</div><div class="line">	dataset := *(*[]byte)(unsafe.Pointer(&amp;header))</div><div class="line"></div><div class="line">	threads := runtime.NumCPU()</div><div class="line">	size := uint64(len(dataset))</div><div class="line"></div><div class="line">	var pend sync.WaitGroup</div><div class="line">	pend.Add(threads)</div><div class="line"></div><div class="line">	var progress uint32</div><div class="line">	for i := 0; i &lt; threads; i++ &#123;</div><div class="line">		go func(id int) &#123;</div><div class="line">			defer pend.Done()</div><div class="line"></div><div class="line">			keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line">			batch := uint32((size + hashBytes*uint64(threads) - 1) / (hashBytes * uint64(threads)))</div><div class="line">			first := uint32(id) * batch</div><div class="line">			limit := first + batch</div><div class="line">			if limit &gt; uint32(size/hashBytes) &#123;</div><div class="line">				limit = uint32(size / hashBytes)</div><div class="line">			&#125;</div><div class="line">			percent := uint32(size / hashBytes / 100)</div><div class="line">			for index := first; index &lt; limit; index++ &#123;</div><div class="line">				item := generateDatasetItem(cache, index, keccak512)</div><div class="line">				if swapped &#123;</div><div class="line">					swap(item)</div><div class="line">				&#125;</div><div class="line">				copy(dataset[index*hashBytes:], item)</div><div class="line"></div><div class="line">				if status := atomic.AddUint32(&amp;progress, 1); status%percent == 0 &#123;</div><div class="line">					logger.Info(&quot;Generating DAG in progress&quot;, &quot;percentage&quot;, uint64(status*100)/(size/hashBytes), &quot;elapsed&quot;, common.PrettyDuration(time.Since(start)))</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	pend.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何生成数据集后，现在我们来看看 ethash 算法是如何根据数据集进行挖矿的。</p>
<p>前面有说到，ethash 的 <code>mine</code> 方法实际上是 <code>engine.Seal</code> 的简单封装。<code>engine.Seal</code> 接口在 <code>consensu/consensus.go</code> 中定义，而实现是在 <code>consensus/ethash/sealer.go</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) Seal(chain consensus.ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error) &#123;</div><div class="line">	if ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</div><div class="line">		header := block.Header()</div><div class="line">		header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</div><div class="line">		return block.WithSeal(header), nil</div><div class="line">	&#125;</div><div class="line">	if ethash.shared != nil &#123;</div><div class="line">		return ethash.shared.Seal(chain, block, stop)</div><div class="line">	&#125;</div><div class="line">	abort := make(chan struct&#123;&#125;)</div><div class="line">	found := make(chan *types.Block)</div><div class="line"></div><div class="line">	ethash.lock.Lock()</div><div class="line">	threads := ethash.threads</div><div class="line">	if ethash.rand == nil &#123;</div><div class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</div><div class="line">		if err != nil &#123;</div><div class="line">			ethash.lock.Unlock()</div><div class="line">			return nil, err</div><div class="line">		&#125;</div><div class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64()))</div><div class="line">	&#125;</div><div class="line">	ethash.lock.Unlock()</div><div class="line">	if threads == 0 &#123;</div><div class="line">		threads = runtime.NumCPU()</div><div class="line">	&#125;</div><div class="line">	if threads &lt; 0 &#123;</div><div class="line">		threads = 0</div><div class="line">	&#125;</div><div class="line">	var pend sync.WaitGroup</div><div class="line">	for i := 0; i &lt; threads; i++ &#123;</div><div class="line">		pend.Add(1)</div><div class="line">		go func(id int, nonce uint64) &#123;</div><div class="line">			defer pend.Done()</div><div class="line">			ethash.mine(block, id, nonce, abort, found)</div><div class="line">		&#125;(i, uint64(ethash.rand.Int63()))</div><div class="line">	&#125;</div><div class="line">	var result *types.Block</div><div class="line">	select &#123;</div><div class="line">	case &lt;-stop:</div><div class="line">		close(abort)</div><div class="line">	case result = &lt;-found:</div><div class="line">		close(abort)</div><div class="line">	case &lt;-ethash.update:</div><div class="line">		close(abort)</div><div class="line">		pend.Wait()</div><div class="line">		return ethash.Seal(chain, block, stop)</div><div class="line">	&#125;</div><div class="line">	pend.Wait()</div><div class="line">	return result, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 fake 模式，立即返回 0 nonce，这部分是为了方便单元测试。<br>如果是共享 pow，转到它的共享对象执行 seal 操作。<br>接下来通过多个 goroutine 调用 <code>ethash.mine</code>，因此需要上锁，保证缓存的安全。<br><code>Seal</code> 的核心还是在 <code>ethash.mine(block, id, nonce, abort, found)</code> 这一行，不过我们先往后面看。<br><code>seal</code> 最后会监听 <code>stop</code>, <code>found</code>, <code>ethash.update</code> 这几个 channel，如果外部意外终止了，停止所有挖矿线程，如果其中有一个线程挖到正确区块，终止其他线程，如果 ethash 对象发生了变化，停止当前所有操作，重新调用 <code>ethash.Seal</code>。</p>
<p>接下来我们来看看 ethash 的 <code>mine</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct&#123;&#125;, found chan *types.Block) &#123;</div><div class="line">	var (</div><div class="line">		header  = block.Header()</div><div class="line">		hash    = header.HashNoNonce().Bytes()</div><div class="line">		target  = new(big.Int).Div(maxUint256, header.Difficulty)</div><div class="line">		number  = header.Number.Uint64()</div><div class="line">		dataset = ethash.dataset(number)</div><div class="line">	)</div><div class="line">	var (</div><div class="line">		attempts = int64(0)</div><div class="line">		nonce    = seed</div><div class="line">	)</div><div class="line">	logger := log.New(&quot;miner&quot;, id)</div><div class="line">	logger.Trace(&quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed)</div><div class="line">search:</div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case &lt;-abort:</div><div class="line">			logger.Trace(&quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed)</div><div class="line">			ethash.hashrate.Mark(attempts)</div><div class="line">			break search</div><div class="line">		default:</div><div class="line">			attempts++</div><div class="line">			if (attempts % (1 &lt;&lt; 15)) == 0 &#123;</div><div class="line">				ethash.hashrate.Mark(attempts)</div><div class="line">				attempts = 0</div><div class="line">			&#125;</div><div class="line">			digest, result := hashimotoFull(dataset.dataset, hash, nonce)</div><div class="line">			if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 &#123;</div><div class="line">				header = types.CopyHeader(header)</div><div class="line">				header.Nonce = types.EncodeNonce(nonce)</div><div class="line">				header.MixDigest = common.BytesToHash(digest)</div><div class="line"></div><div class="line">				select &#123;</div><div class="line">				case found &lt;- block.WithSeal(header):</div><div class="line">					logger.Trace(&quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce)</div><div class="line">				case &lt;-abort:</div><div class="line">					logger.Trace(&quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce)</div><div class="line">				&#125;</div><div class="line">				break search</div><div class="line">			&#125;</div><div class="line">			nonce++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	runtime.KeepAlive(dataset)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是变量的初始化，从区块头部提取一些数据，得到哈希值，目标值等等，注意 <code>target  = new(big.Int).Div(maxUint256, header.Difficulty)</code> 这一行， 难度越高，target 也就越小，也就越难得到正确的结果。接下来 <code>nonse</code> 会初始化为 seed 值，然后进入一个死循环，不断增加 <code>nonce</code> 的值，通过调用 hashimotoFull 算法不断尝试，直到找到正确 <code>nonse</code>，写入到 <code>found</code> 这个 chan 里。</p>
<p>接下来进入到 <code>hashimotoFull</code> 算法中，看看 pow 的核心算法，这部分在 <code>ethash/algorithm.go</code> 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) &#123;</div><div class="line">	lookup := func(index uint32) []uint32 &#123;</div><div class="line">		offset := index * hashWords</div><div class="line">		return dataset[offset : offset+hashWords]</div><div class="line">	&#125;</div><div class="line">	return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>hashimotoFull</code> 和 <code>hashimotoLight</code>的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) &#123;</div><div class="line">	keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line"></div><div class="line">	lookup := func(index uint32) []uint32 &#123;</div><div class="line">		rawData := generateDatasetItem(cache, index, keccak512)</div><div class="line"></div><div class="line">		data := make([]uint32, len(rawData)/4)</div><div class="line">		for i := 0; i &lt; len(data); i++ &#123;</div><div class="line">			data[i] = binary.LittleEndian.Uint32(rawData[i*4:])</div><div class="line">		&#125;</div><div class="line">		return data</div><div class="line">	&#125;</div><div class="line">	return hashimoto(hash, nonce, size, lookup)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>hashimotoLight</code> 的 <code>lookup</code> 函数不需要一个完整的 <code>dataset</code>，只需要一个占存储空间很小的 cache，然后临时生成一个 dataset，而 <code>hashimotoFull</code> 是直接从 dataset 拿到所需数据。因此 <code>hashimotoLight</code> 可以用于轻量级客户端的验证。<code>hashimotoLight</code> 和 <code>hashimotoFull</code> 最终会调用 <code>hashimoto</code>，我们继续分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) &#123;</div><div class="line">	rows := uint32(size / mixBytes)</div><div class="line">	seed := make([]byte, 40)</div><div class="line">	copy(seed, hash)</div><div class="line">	binary.LittleEndian.PutUint64(seed[32:], nonce)</div><div class="line">	seed = crypto.Keccak512(seed)</div><div class="line">	seedHead := binary.LittleEndian.Uint32(seed)</div><div class="line">	mix := make([]uint32, mixBytes/4)</div><div class="line">	for i := 0; i &lt; len(mix); i++ &#123;</div><div class="line">		mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:])</div><div class="line">	&#125;</div><div class="line">	temp := make([]uint32, len(mix))</div><div class="line">	for i := 0; i &lt; loopAccesses; i++ &#123;</div><div class="line">		parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows</div><div class="line">		for j := uint32(0); j &lt; mixBytes/hashBytes; j++ &#123;</div><div class="line">			copy(temp[j*hashWords:], lookup(2*parent+j))</div><div class="line">		&#125;</div><div class="line">		fnvHash(mix, temp)</div><div class="line">	&#125;</div><div class="line">	for i := 0; i &lt; len(mix); i += 4 &#123;</div><div class="line">		mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3])</div><div class="line">	&#125;</div><div class="line">	mix = mix[:len(mix)/4]</div><div class="line">	digest := make([]byte, common.HashLength)</div><div class="line">	for i, val := range mix &#123;</div><div class="line">		binary.LittleEndian.PutUint32(digest[i*4:], val)</div><div class="line">	&#125;</div><div class="line">	return digest, crypto.Keccak256(append(seed, digest...))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法的流程可以概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">def hashimoto(header, nonce, full_size, dataset_lookup):</div><div class="line">    n = full_size / HASH_BYTES</div><div class="line">    w = MIX_BYTES // WORD_BYTES</div><div class="line">    mixhashes = MIX_BYTES / HASH_BYTES</div><div class="line">    s = sha3_512(header + nonce[::-1])</div><div class="line">    mix = []</div><div class="line">    for _ in range(MIX_BYTES / HASH_BYTES):</div><div class="line">        mix.extend(s)</div><div class="line">    for i in range(ACCESSES):</div><div class="line">        p = fnv(i ^ s[0], mix[i % w]) % (n // mixhashes) * mixhashes</div><div class="line">        newdata = []</div><div class="line">        for j in range(MIX_BYTES / HASH_BYTES):</div><div class="line">            newdata.extend(dataset_lookup(p + j))</div><div class="line">        mix = map(fnv, mix, newdata)</div><div class="line">    cmix = []</div><div class="line">    for i in range(0, len(mix), 4):</div><div class="line">        cmix.append(fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]))</div><div class="line">    return &#123;</div><div class="line">        &quot;mix digest&quot;: serialize_hash(cmix),</div><div class="line">        &quot;result&quot;: serialize_hash(sha3_256(s+cmix))</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其数据流可以用一张图片表示：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/pow_hashimoto.png" alt="hashimoto"></p>
<p>上图摘自 <a href="https://blog.csdn.net/metal1/article/details/79682636" target="_blank" rel="external">[以太坊源代码分析]III. 挖矿和共识算法的奥秘</a> </p>
<p>其流程是（参考以太坊源代码分析]III. 挖矿和共识算法的奥秘的描述）：</p>
<ul>
<li>首先，将 hash 和 nonce 合并成一个40 bytes长的数组，取它的 SHA-512 哈希值取名 seed，长度为64 bytes。</li>
<li>然后，将 <code>seed[]</code> 转化成以 uint32 为元素的数组 <code>mix[]</code>，注意一个 uint32 数等于4 bytes，所以 <code>seed[]</code> 只能转化成16个 uint32 数，而 <code>mix[]</code> 数组长度32，所以此时 <code>mix[]</code> 数组前后各半是等值的。</li>
<li>接着，使用 <code>lookup()</code> 函数。用一个循环，不断调用 <code>lookup()</code> 从外部数据集中取出 uint32 元素类型数组，向 <code>mix[]</code> 数组中混入未知的数据。循环的次数可用参数调节，目前设为64次。每次循环中，变化生成参数 index，从而使得每次调用 <code>lookup()</code> 函数取出的数组都各不相同。这里混入数据的方式是一种类似向量『异或』的操作，来自于 <a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="external">FNV 算法</a>。</li>
<li>待混淆数据完成后，得到一个基本上面目全非的 <code>mix[]</code>，长度为32的 uint32 数组。这时，将其折叠(压缩)成一个长度缩小成原长1/4的uint32数组，折叠的操作方法来自于 FNV 算法。</li>
<li>最后，将折叠后的 <code>mix[]</code> 由长度为8的 uint32 型数组直接转化成一个长度32的 byte 数组，这就是返回值 <code>digest</code>；同时将之前的 <code>seed[]</code> 数组与 <code>digest</code> 合并再取一次 SHA-256 哈希值，得到的长度32的 byte 数组，即返回值 result。</li>
</ul>
<p>经过多次多种哈希运算，<code>hashimoto</code> 返回两个长度均为32的 byte 数组 <code>digest</code> 和 <code>result</code>，前文已提到，在 <code>Ethash</code> 的 <code>mine</code> 方法里，挖矿时需要经过一个死循环，直到找到一个 <code>nonce</code>，使得 <code>hashimoto</code> 返回的 <code>result</code> 和 <code>target</code> 是相等的，这时就表示符合要求，<code>digest</code> 被取 SHA3-256 哈希后也会存到区块头的 <code>MixDigest</code> 字段里，待 <code>Ethash.VerifySeal()</code> 进行验证。</p>
<h3 id="VerifySeal-验证挖矿结果"><a href="#VerifySeal-验证挖矿结果" class="headerlink" title="VerifySeal 验证挖矿结果"></a>VerifySeal 验证挖矿结果</h3><p>谈完挖矿，我们看看如何验证挖矿结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) VerifySeal(chain consensus.ChainReader, header *types.Header) error &#123;</div><div class="line">	if ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</div><div class="line">		time.Sleep(ethash.fakeDelay)</div><div class="line">		if ethash.fakeFail == header.Number.Uint64() &#123;</div><div class="line">			return errInvalidPoW</div><div class="line">		&#125;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if ethash.shared != nil &#123;</div><div class="line">		return ethash.shared.VerifySeal(chain, header)</div><div class="line">	&#125;</div><div class="line">	if header.Difficulty.Sign() &lt;= 0 &#123;</div><div class="line">		return errInvalidDifficulty</div><div class="line">	&#125;</div><div class="line">	number := header.Number.Uint64()</div><div class="line"></div><div class="line">	cache := ethash.cache(number)</div><div class="line">	size := datasetSize(number)</div><div class="line">	if ethash.config.PowMode == ModeTest &#123;</div><div class="line">		size = 32 * 1024</div><div class="line">	&#125;</div><div class="line">	digest, result := hashimotoLight(size, cache.cache, header.HashNoNonce().Bytes(), header.Nonce.Uint64())</div><div class="line">	runtime.KeepAlive(cache)</div><div class="line"></div><div class="line">	if !bytes.Equal(header.MixDigest[:], digest) &#123;</div><div class="line">		return errInvalidMixDigest</div><div class="line">	&#125;</div><div class="line">	target := new(big.Int).Div(maxUint256, header.Difficulty)</div><div class="line">	if new(big.Int).SetBytes(result).Cmp(target) &gt; 0 &#123;</div><div class="line">		return errInvalidPoW</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VerifySeal</code> 的核心是 <code>digest, result := hashimotoLight(size, cache.cache, header.HashNoNonce().Bytes(), header.Nonce.Uint64())</code> 这一行，这里不需要一个完整的 <code>dataset</code>，只需要 cache 生成就行了，与挖矿时的区别其实就两点，一，这个 Nonce 是区块头里面的。二，dataset 由 cache 临时生成。计算出 <code>digest</code> 后，与区块头的 <code>MixDigest</code> 进行比较即可。</p>
<h3 id="难度动态调整"><a href="#难度动态调整" class="headerlink" title="难度动态调整"></a>难度动态调整</h3><p>难度可以用来度量挖出一个区块平均需要的运算次数。</p>
<p>前面的<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/#%E4%BB%A5%E5%A4%AA%E5%9D%8A-3" target="_blank" rel="external">博文</a>里有提过以太坊的挖矿难度调整算法。其公式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">本区块难度 = 父区块难度 + 难度调整 + 难度炸弹</div><div class="line">难度调整 = 父区块难度 // 2048 * MAX(1 - (block_timestamp - parent_timestamp) // 10, -99)</div><div class="line">难度炸弹 = INT(2**((block_number // 100000) - 2))</div></pre></td></tr></table></figure>
<h2 id="Clique-算法"><a href="#Clique-算法" class="headerlink" title="Clique 算法"></a>Clique 算法</h2><p>Clique 算法只在测试网中使用，有机会再研究。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://medium.com/verifyas/why-dagger-hashimoto-for-ethereum-773f0792a689" target="_blank" rel="external">Why Dagger-Hashimoto for Ethereum?</a></li>
<li><a href="http://www.hashcash.org/" target="_blank" rel="external">hashcash.org</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethash" target="_blank" rel="external">wiki/Ethash</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethash-Design-Rationale" target="_blank" rel="external">Ethash Design Rationale</a></li>
<li><a href="http://www.ethdocs.org/en/latest/mining.html" target="_blank" rel="external">ethdocs mining</a></li>
<li><a href="http://ethdoc.cn/mining.html" target="_blank" rel="external">挖矿</a></li>
<li><a href="http://www.askmaclean.com/archives/eth-mining.html" target="_blank" rel="external">eth-mining</a></li>
<li><a href="https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md" target="_blank" rel="external">Dagger-Hashimoto</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" target="_blank" rel="external">Fowler–Noll–Vo hash function</a></li>
<li><a href="https://www.cnblogs.com/Evsward/p/ethash.html" target="_blank" rel="external">以太坊挖矿源码：ethash算法</a></li>
<li><a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="external">FNV Hash</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/projects/14" target="_blank" rel="external">Revamp the miner</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的章节 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（core 模块-区块链操作）&lt;/a&gt; 描述了区块链世界的核心：区块，区块链。我们已经知道区块链可以用来存储交易的数据，也知道了如何在区块链里发起一笔交易，而问题是，往区块链中增加数据应该是一个较困难的操作，按照比特币论文里的说法，即需要一个 PoW（Proof of Work，工作量证明），否则每个人都能轻易往区块链中增加数据，安全性和一致性无法保证。这一点上，以太坊法和比特币类似，尽管略有不同，但大致都需要矿工的角色贡献计算力，完成一个复杂的计算，即找到一个区块的哈希值，验证正确之后才能加入到区块链中。这个过程就叫做挖矿。矿工们去做这件事当然是有一定利益驱使的，每完成一次挖矿，他们就能获得一些以太币奖励。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-交易池）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-交易池）/</id>
    <published>2018-03-10T14:35:04.000Z</published>
    <updated>2018-09-15T02:31:43.401Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们探究了以太坊账户，转账的实现，在文末的时候挖了一个坑，调用了提交转账的 api 后我们就没有再继续往下走了。这一篇我们更进一步，看看交易池是怎么实现的。</p>
<a id="more"></a>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">type TxPool struct &#123;</div><div class="line">	config       TxPoolConfig</div><div class="line">	chainconfig  *params.ChainConfig</div><div class="line">	chain        blockChain</div><div class="line">	gasPrice     *big.Int</div><div class="line">	txFeed       event.Feed</div><div class="line">	scope        event.SubscriptionScope</div><div class="line">	chainHeadCh  chan ChainHeadEvent</div><div class="line">	chainHeadSub event.Subscription</div><div class="line">	signer       types.Signer</div><div class="line">	mu           sync.RWMutex</div><div class="line"></div><div class="line">	currentState  *state.StateDB</div><div class="line">	pendingState  *state.ManagedState</div><div class="line">	currentMaxGas uint64</div><div class="line"></div><div class="line">	locals  *accountSet</div><div class="line">	journal *txJournal</div><div class="line"></div><div class="line">	pending map[common.Address]*txList</div><div class="line">	queue   map[common.Address]*txList</div><div class="line">	beats   map[common.Address]time.Time</div><div class="line">	all     *txLookup</div><div class="line">	priced  *txPricedList</div><div class="line"></div><div class="line">	wg sync.WaitGroup</div><div class="line">	homestead bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交易池用来存放当前的网络接收到的交易或本地提交的交易，如果已经加入到区块链中会被移除。</p>
<p>下面是重要字段的描述。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">TxPoolConfig 类型，包含了交易池的配置信息，如 PriceLimit，移除交易的最低 GasPrice 限制；PriceBump，替换相同 Nonce 的交易的价格的百分比；AccountSlots，每个账户 pending 的槽位的最小值；GlobalSlots，全局 pending 队列的最大值；AccountQueue，每个账户的 queueing 的槽位的最小值；GlobalQueue，全局 queueing 的最大值；Lifetime，在队列的最长等待时间</td>
</tr>
<tr>
<td style="text-align:center">chainconfig</td>
<td style="text-align:center">区块链的配置</td>
</tr>
<tr>
<td style="text-align:center">gasPrice</td>
<td style="text-align:center">最低的 GasPrice 限制</td>
</tr>
<tr>
<td style="text-align:center">txFeed</td>
<td style="text-align:center">可以通过 txFeed 来订阅 TxPool 的消息</td>
</tr>
<tr>
<td style="text-align:center">chainHeadCh</td>
<td style="text-align:center">可以通过 chainHeadCh 订阅区块头的消息</td>
</tr>
<tr>
<td style="text-align:center">signer</td>
<td style="text-align:center">封装了事务签名处理</td>
</tr>
</tbody>
</table>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">func NewTxPool(config TxPoolConfig, chainconfig *params.ChainConfig, chain blockChain) *TxPool &#123;</div><div class="line">	config = (&amp;config).sanitize()</div><div class="line"></div><div class="line">	pool := &amp;TxPool&#123;</div><div class="line">		config:      config,</div><div class="line">		chainconfig: chainconfig,</div><div class="line">		chain:       chain,</div><div class="line">		signer:      types.NewEIP155Signer(chainconfig.ChainID),</div><div class="line">		pending:     make(map[common.Address]*txList),</div><div class="line">		queue:       make(map[common.Address]*txList),</div><div class="line">		beats:       make(map[common.Address]time.Time),</div><div class="line">		all:         newTxLookup(),</div><div class="line">		chainHeadCh: make(chan ChainHeadEvent, chainHeadChanSize),</div><div class="line">		gasPrice:    new(big.Int).SetUint64(config.PriceLimit),</div><div class="line">	&#125;</div><div class="line">	pool.locals = newAccountSet(pool.signer)</div><div class="line">	pool.priced = newTxPricedList(pool.all)</div><div class="line">	pool.reset(nil, chain.CurrentBlock().Header())</div><div class="line"></div><div class="line">	if !config.NoLocals &amp;&amp; config.Journal != &quot;&quot; &#123;</div><div class="line">		pool.journal = newTxJournal(config.Journal)</div><div class="line"></div><div class="line">		if err := pool.journal.load(pool.AddLocals); err != nil &#123;</div><div class="line">			log.Warn(&quot;Failed to load transaction journal&quot;, &quot;err&quot;, err)</div><div class="line">		&#125;</div><div class="line">		if err := pool.journal.rotate(pool.local()); err != nil &#123;</div><div class="line">			log.Warn(&quot;Failed to rotate transaction journal&quot;, &quot;err&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</div><div class="line"></div><div class="line">	pool.wg.Add(1)</div><div class="line">	go pool.loop()</div><div class="line"></div><div class="line">	return pool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化交易池后会调用 <code>reset</code> 方法，这个方法会检索区块链当前状态，确保交易池里的内容与区块链状态是匹配的。</p>
<p>在 <code>NewTxPool</code> 方法里，如果本地可以发起交易，并且配置的 Journal 目录不为空，那么从指定的目录加载交易日志。<code>NewTxPool</code> 方法的最后会用一个 goroutine 调用 <code>loop()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) loop() &#123;</div><div class="line">	defer pool.wg.Done()</div><div class="line">	var prevPending, prevQueued, prevStales int</div><div class="line"></div><div class="line">	report := time.NewTicker(statsReportInterval)</div><div class="line">	defer report.Stop()</div><div class="line"></div><div class="line">	evict := time.NewTicker(evictionInterval)</div><div class="line">	defer evict.Stop()</div><div class="line"></div><div class="line">	journal := time.NewTicker(pool.config.Rejournal)</div><div class="line">	defer journal.Stop()</div><div class="line"></div><div class="line">	head := pool.chain.CurrentBlock()</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case ev := &lt;-pool.chainHeadCh:</div><div class="line">			if ev.Block != nil &#123;</div><div class="line">				pool.mu.Lock()</div><div class="line">				if pool.chainconfig.IsHomestead(ev.Block.Number()) &#123;</div><div class="line">					pool.homestead = true</div><div class="line">				&#125;</div><div class="line">				pool.reset(head.Header(), ev.Block.Header())</div><div class="line">				head = ev.Block</div><div class="line"></div><div class="line">				pool.mu.Unlock()</div><div class="line">			&#125;</div><div class="line">		case &lt;-pool.chainHeadSub.Err():</div><div class="line">			return</div><div class="line">		case &lt;-report.C:</div><div class="line">			pool.mu.RLock()</div><div class="line">			pending, queued := pool.stats()</div><div class="line">			stales := pool.priced.stales</div><div class="line">			pool.mu.RUnlock()</div><div class="line"></div><div class="line">			if pending != prevPending || queued != prevQueued || stales != prevStales &#123;</div><div class="line">				log.Debug(&quot;Transaction pool status report&quot;, &quot;executable&quot;, pending, &quot;queued&quot;, queued, &quot;stales&quot;, stales)</div><div class="line">				prevPending, prevQueued, prevStales = pending, queued, stales</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		case &lt;-evict.C:</div><div class="line">			pool.mu.Lock()</div><div class="line">			for addr := range pool.queue &#123;</div><div class="line">				if pool.locals.contains(addr) &#123;</div><div class="line">					continue</div><div class="line">				&#125;</div><div class="line">				if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime &#123;</div><div class="line">					for _, tx := range pool.queue[addr].Flatten() &#123;</div><div class="line">						pool.removeTx(tx.Hash(), true)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			pool.mu.Unlock()</div><div class="line">		case &lt;-journal.C:</div><div class="line">			if pool.journal != nil &#123;</div><div class="line">				pool.mu.Lock()</div><div class="line">				if err := pool.journal.rotate(pool.local()); err != nil &#123;</div><div class="line">					log.Warn(&quot;Failed to rotate local tx journal&quot;, &quot;err&quot;, err)</div><div class="line">				&#125;</div><div class="line">				pool.mu.Unlock()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loop()</code> 用来接收区块链的事件，负责处理超时的交易和定时写交易日志。</p>
<h3 id="处理交易"><a href="#处理交易" class="headerlink" title="处理交易"></a>处理交易</h3><p>先回顾一下。上一篇谈到，转账时，在 <code>submitTransaction</code> 中会调用 <code>SendTx</code>，<code>SendTx</code> 的实现在 <code>eth/api_backend.go</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (b *EthApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error &#123;</div><div class="line">	return b.eth.txPool.AddLocal(signedTx)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>AddLocal</code> 方法在 <code>core/tx_pool.go</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) AddLocal(tx *types.Transaction) error &#123;</div><div class="line">	return pool.addTx(tx, !pool.config.NoLocals)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续看 <code>addTx</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) addTx(tx *types.Transaction, local bool) error &#123;</div><div class="line">	pool.mu.Lock()</div><div class="line">	defer pool.mu.Unlock()</div><div class="line">	replace, err := pool.add(tx, local)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	if !replace &#123;</div><div class="line">		from, _ := types.Sender(pool.signer, tx)</div><div class="line">		pool.promoteExecutables([]common.Address&#123;from&#125;)</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addTx</code> 将交易放入交易池中，<code>pool.add(tx, local)</code> 会返回一个 bool 类型，如果为 <code>true</code>，则表明这笔交易合法并且交易之前不存在于交易池，这时候调用 <code>promoteExecutables</code>，可以将可处理的交易变成待处理。所以说，交易池的交易大致分为两种，一种是提交了但还不能执行的，放在 queue 里等待能够被执行（比如 nonce 太高），还有就是等待执行的，放在 pending 里面等待执行。我们会分别探讨 <code>pool.add(tx, local)</code> 和 <code>pool.promoteExecutables</code> 这两个方法如何处理这两种交易。</p>
<h4 id="pool-add-tx-local"><a href="#pool-add-tx-local" class="headerlink" title="pool.add(tx, local)"></a><code>pool.add(tx, local)</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) &#123;</div><div class="line">	hash := tx.Hash()</div><div class="line">	if pool.all[hash] != nil &#123;</div><div class="line">		log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">		return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash)</div><div class="line">	&#125;</div><div class="line">	if err := pool.validateTx(tx, local); err != nil &#123;</div><div class="line">		log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err)</div><div class="line">		invalidTxCounter.Inc(1)</div><div class="line">		return false, err</div><div class="line">	&#125;</div><div class="line">	if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</div><div class="line">		if pool.priced.Underpriced(tx, pool.locals) &#123;</div><div class="line">			log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice())</div><div class="line">			underpricedTxCounter.Inc(1)</div><div class="line">			return false, ErrUnderpriced</div><div class="line">		&#125;</div><div class="line">		drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals)</div><div class="line">		for _, tx := range drop &#123;</div><div class="line">			log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice())</div><div class="line">			underpricedTxCounter.Inc(1)</div><div class="line">			pool.removeTx(tx.Hash(), false)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	from, _ := types.Sender(pool.signer, tx)</div><div class="line">	if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) &#123;</div><div class="line">		inserted, old := list.Add(tx, pool.config.PriceBump)</div><div class="line">		if !inserted &#123;</div><div class="line">			pendingDiscardCounter.Inc(1)</div><div class="line">			return false, ErrReplaceUnderpriced</div><div class="line">		&#125;</div><div class="line">		if old != nil &#123;</div><div class="line">			delete(pool.all, old.Hash())</div><div class="line">			pool.priced.Removed()</div><div class="line">			pendingReplaceCounter.Inc(1)</div><div class="line">		&#125;</div><div class="line">		pool.all[tx.Hash()] = tx</div><div class="line">		pool.priced.Put(tx)</div><div class="line">		pool.journalTx(from, tx)</div><div class="line">		log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To())</div><div class="line">		go pool.txFeed.Send(TxPreEvent&#123;tx&#125;)</div><div class="line"></div><div class="line">		return old != nil, nil</div><div class="line">	&#125;</div><div class="line">	replace, err := pool.enqueueTx(hash, tx)</div><div class="line">	if err != nil &#123;</div><div class="line">		return false, err</div><div class="line">	&#125;</div><div class="line">	if local &#123;</div><div class="line">		pool.locals.add(from)</div><div class="line">	&#125;</div><div class="line">	pool.journalTx(from, tx)</div><div class="line">	log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To())</div><div class="line">	return replace, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，根据交易哈希值，确定交易池中是否已经有这笔交易，如果有，则退出。接下来调用 <code>validateTx</code> 验证交易是否合法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error &#123;</div><div class="line">	if tx.Size() &gt; 32*1024 &#123;</div><div class="line">		return ErrOversizedData</div><div class="line">	&#125;</div><div class="line">	if tx.Value().Sign() &lt; 0 &#123;</div><div class="line">		return ErrNegativeValue</div><div class="line">	&#125;</div><div class="line">	if pool.currentMaxGas &lt; tx.Gas() &#123;</div><div class="line">		return ErrGasLimit</div><div class="line">	&#125;</div><div class="line">	from, err := types.Sender(pool.signer, tx)</div><div class="line">	if err != nil &#123;</div><div class="line">		return ErrInvalidSender</div><div class="line">	&#125;</div><div class="line">	local = local || pool.locals.contains(from)</div><div class="line">	if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 &#123;</div><div class="line">		return ErrUnderpriced</div><div class="line">	&#125;</div><div class="line">	if pool.currentState.GetNonce(from) &gt; tx.Nonce() &#123;</div><div class="line">		return ErrNonceTooLow</div><div class="line">	&#125;</div><div class="line">	if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 &#123;</div><div class="line">		return ErrInsufficientFunds</div><div class="line">	&#125;</div><div class="line">	intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	if tx.Gas() &lt; intrGas &#123;</div><div class="line">		return ErrIntrinsicGas</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>validateTx</code> 有很多使用 if 语句的条件判断，大致会有如下判断：</p>
<ul>
<li>拒绝大于 32kb 的交易，防止 DDoS 攻击</li>
<li>拒绝转账金额小于0的交易</li>
<li>拒绝 gas 超过交易池 gas 上限的交易</li>
<li>验证这笔交易的签名是否合法</li>
<li>如果交易不是来自本地的，并且 gas 小于当前交易池中的 gas，拒绝这笔交易</li>
<li>当前用户 nonce 如果大于这笔交易的 nonce，拒绝这笔交易</li>
<li>当前账户余额不足，拒绝这笔交易，queue 和 pending 对应账户的交易会被删除</li>
<li>拒绝当前交易固有花费小于交易池 gas 的交易</li>
</ul>
<p>判断交易合法后，回到 <code>add</code> 方法，接着判断交易池的容量，如果交易池超过容量了，并且这笔交易的费用低于当前交易池中列表的最小值，拒绝这笔交易；如果这笔交易费用比当前交易池列表最小值高，那么从交易池中移除交易费用最低的交易，为这笔新交易腾出空间，也就是说按照 GasPrice 排出优先级。接着通过调用 <code>Overlaps</code> 通过检查这笔交易的 Nonce 值确认该用户是否已经存在这笔交易，如果已经存在，删除之前的交易，将该交易放入交易池，返回；如果不存在，调用 <code>enqueueTx</code> 将交易放入交易池，如果交易是本地发出的，将发送者保存在交易池的 local 中。注意到 <code>add</code> 方法最后会调用 <code>pool.journalTx(from, tx)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) journalTx(from common.Address, tx *types.Transaction) &#123;</div><div class="line">	if pool.journal == nil || !pool.locals.contains(from) &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if err := pool.journal.insert(tx); err != nil &#123;</div><div class="line">		log.Warn(&quot;Failed to journal local transaction&quot;, &quot;err&quot;, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本地的交易会使用 journal 的功能存在磁盘，节点重启后可以重写导入。</p>
<h4 id="pool-promoteExecutables"><a href="#pool-promoteExecutables" class="headerlink" title="pool.promoteExecutables"></a><code>pool.promoteExecutables</code></h4><p><code>pool.add(tx, local)</code> 方法探讨完了，我们看看 <code>promoteExecutables</code> 方法，该方法的作用是将所有可以处理的交易放入 pending 区，并且移除所有非法交易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) promoteExecutables(accounts []common.Address) &#123;</div><div class="line">	if accounts == nil &#123;</div><div class="line">		accounts = make([]common.Address, 0, len(pool.queue))</div><div class="line">		for addr := range pool.queue &#123;</div><div class="line">			accounts = append(accounts, addr)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for _, addr := range accounts &#123;</div><div class="line">		list := pool.queue[addr]</div><div class="line">		if list == nil &#123;</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(&quot;Removed old queued transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">			delete(pool.all, hash)</div><div class="line">			pool.priced.Removed()</div><div class="line">		&#125;</div><div class="line">		drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</div><div class="line">		for _, tx := range drops &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(&quot;Removed unpayable queued transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">			delete(pool.all, hash)</div><div class="line">			pool.priced.Removed()</div><div class="line">			queuedNofundsCounter.Inc(1)</div><div class="line">		&#125;</div><div class="line">		for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(&quot;Promoting queued transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">			pool.promoteTx(addr, hash, tx)</div><div class="line">		&#125;</div><div class="line">		if !pool.locals.contains(addr) &#123;</div><div class="line">			for _, tx := range list.Cap(int(pool.config.AccountQueue)) &#123;</div><div class="line">				hash := tx.Hash()</div><div class="line">				delete(pool.all, hash)</div><div class="line">				pool.priced.Removed()</div><div class="line">				queuedRateLimitCounter.Inc(1)</div><div class="line">				log.Trace(&quot;Removed cap-exceeding queued transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if list.Empty() &#123;</div><div class="line">			delete(pool.queue, addr)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	pending := uint64(0)</div><div class="line">	for _, list := range pool.pending &#123;</div><div class="line">		pending += uint64(list.Len())</div><div class="line">	&#125;</div><div class="line">	if pending &gt; pool.config.GlobalSlots &#123;</div><div class="line">		pendingBeforeCap := pending</div><div class="line">		spammers := prque.New()</div><div class="line">		for addr, list := range pool.pending &#123;</div><div class="line">			if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots &#123;</div><div class="line">				spammers.Push(addr, float32(list.Len()))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		offenders := []common.Address&#123;&#125;</div><div class="line">		for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() &#123;</div><div class="line">			offender, _ := spammers.Pop()</div><div class="line">			offenders = append(offenders, offender.(common.Address))</div><div class="line">			if len(offenders) &gt; 1 &#123;</div><div class="line">				threshold := pool.pending[offender.(common.Address)].Len()</div><div class="line"></div><div class="line">				for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold &#123;</div><div class="line">					for i := 0; i &lt; len(offenders)-1; i++ &#123;</div><div class="line">						list := pool.pending[offenders[i]]</div><div class="line">						for _, tx := range list.Cap(list.Len() - 1) &#123;</div><div class="line">							hash := tx.Hash()</div><div class="line">							delete(pool.all, hash)</div><div class="line">							pool.priced.Removed()</div><div class="line">							if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce &#123;</div><div class="line">								pool.pendingState.SetNonce(offenders[i], nonce)</div><div class="line">							&#125;</div><div class="line">							log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">						&#125;</div><div class="line">						pending--</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 &#123;</div><div class="line">			for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots &#123;</div><div class="line">				for _, addr := range offenders &#123;</div><div class="line">					list := pool.pending[addr]</div><div class="line">					for _, tx := range list.Cap(list.Len() - 1) &#123;</div><div class="line">						hash := tx.Hash()</div><div class="line">						delete(pool.all, hash)</div><div class="line">						pool.priced.Removed()</div><div class="line">						if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce &#123;</div><div class="line">							pool.pendingState.SetNonce(addr, nonce)</div><div class="line">						&#125;</div><div class="line">						log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash)</div><div class="line">					&#125;</div><div class="line">					pending--</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending))</div><div class="line">	&#125;</div><div class="line">	queued := uint64(0)</div><div class="line">	for _, list := range pool.queue &#123;</div><div class="line">		queued += uint64(list.Len())</div><div class="line">	&#125;</div><div class="line">	if queued &gt; pool.config.GlobalQueue &#123;</div><div class="line">		addresses := make(addresssByHeartbeat, 0, len(pool.queue))</div><div class="line">		for addr := range pool.queue &#123;</div><div class="line">			if !pool.locals.contains(addr) &#123;</div><div class="line">				addresses = append(addresses, addressByHeartbeat&#123;addr, pool.beats[addr]&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sort.Sort(addresses)</div><div class="line">		for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; &#123;</div><div class="line">			addr := addresses[len(addresses)-1]</div><div class="line">			list := pool.queue[addr.address]</div><div class="line"></div><div class="line">			addresses = addresses[:len(addresses)-1]</div><div class="line">			if size := uint64(list.Len()); size &lt;= drop &#123;</div><div class="line">				for _, tx := range list.Flatten() &#123;</div><div class="line">					pool.removeTx(tx.Hash(), true)</div><div class="line">				&#125;</div><div class="line">				drop -= size</div><div class="line">				queuedRateLimitCounter.Inc(int64(size))</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			txs := list.Flatten()</div><div class="line">			for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- &#123;</div><div class="line">				pool.removeTx(txs[i].Hash(), true)</div><div class="line">				drop--</div><div class="line">				queuedRateLimitCounter.Inc(1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先遍历所有当前账户交易，通过 <code>list.Forward</code> 方法迭代当前账户，检查 nonce，如果 nonce 太低，删除该交易。接着通过 <code>list.Filter</code> 方法检查余额不足或 gas 不足的交易，删除不满足的交易。这时得到的所有可执行的交易，通过调用 <code>promoteTx</code> 加入到 <code>pending</code> 里，接着移除超过了限制的交易。对于已经加入到 <code>promoted</code> 的交易，调用 <code>pool.txFeed.Send</code> 将消息发给订阅者，在 eth 协议里，这个交易会被广播出去。</p>
<p>经过上面的处理，<code>pending</code> 的数量可能会超过系统配置的数量，这时需要进行一些处理，移除一些交易。</p>
<p><code>pending</code> 处理完后，继续处理 future queue，队列里的数量也可能会超过 <code>GlobalQueue</code> 里的数量，根据心跳时间排列所有交易，移除最旧的交易。</p>
<h3 id="tx-list-go"><a href="#tx-list-go" class="headerlink" title="tx_list.go"></a>tx_list.go</h3><p>前文中有很多地方用到 txList 这个结构体里的方法，这些方法都在 <code>core/tx_list.go</code> 里，算是交易池的工具箱了，代码也有一些参考价值，所以分出一个独立的小节，选几个典型的方法讲解。</p>
<h4 id="nonceHeap"><a href="#nonceHeap" class="headerlink" title="nonceHeap"></a>nonceHeap</h4><p>我们在上文中知道维护交易池在很多情况下都需要一个根据 nonce 值排序的优先级队列，如果用堆来实现优先级队列，插入，删除的性能是 $O(log n)$，在 Golang 中，<code>container/heap</code> 包定义了堆的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Interface interface &#123;  </div><div class="line">    sort.Interface  </div><div class="line">    Push(x interface&#123;&#125;)</div><div class="line">    Pop() interface&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>sort.Interface</code> 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Interface interface &#123;</div><div class="line">	Len() int</div><div class="line">	Less(i, j int) bool</div><div class="line">	Swap(i, j int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要实现 <code>Len</code>，<code>Less</code>，<code>Swap</code>，<code>Push</code>，<code>Pop</code> 这几个接口就可以实现堆。<code>nonceHeap</code> 实现了一个以 <code>nonce</code> 为基准的堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type nonceHeap []uint64</div><div class="line"></div><div class="line">func (h nonceHeap) Len() int           &#123; return len(h) &#125;</div><div class="line">func (h nonceHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;</div><div class="line">func (h nonceHeap) Swap(i, j int)      &#123; h[i], h[j] = h[j], h[i] &#125;</div><div class="line"></div><div class="line">func (h *nonceHeap) Push(x interface&#123;&#125;) &#123;</div><div class="line">	*h = append(*h, x.(uint64))</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (h *nonceHeap) Pop() interface&#123;&#125; &#123;</div><div class="line">	old := *h</div><div class="line">	n := len(old)</div><div class="line">	x := old[n-1]</div><div class="line">	*h = old[0 : n-1]</div><div class="line">	return x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="txSortedMap"><a href="#txSortedMap" class="headerlink" title="txSortedMap"></a>txSortedMap</h4><p><code>txSortedMap</code> 用来存储同一个账户下的所有交易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type txSortedMap struct &#123;</div><div class="line">	items map[uint64]*types.Transaction</div><div class="line">	index *nonceHeap</div><div class="line">	cache types.Transactions</div><div class="line">&#125;</div><div class="line"></div><div class="line">func newTxSortedMap() *txSortedMap &#123;</div><div class="line">	return &amp;txSortedMap&#123;</div><div class="line">		items: make(map[uint64]*types.Transaction),</div><div class="line">		index: new(nonceHeap),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>items</code> 是交易数据的 hash map，以 nonce 为索引，<code>index</code> 是以 <code>nonce</code> 为基准的优先级队列，<code>cache</code> 用来缓存已经排好序的交易。</p>
<h5 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Get(nonce uint64) *types.Transaction &#123;</div><div class="line">	return m.items[nonce]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Get 方法获取指定 nonce 的交易。</p>
<h5 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Put(tx *types.Transaction) &#123;</div><div class="line">	nonce := tx.Nonce()</div><div class="line">	if m.items[nonce] == nil &#123;</div><div class="line">		heap.Push(m.index, nonce)</div><div class="line">	&#125;</div><div class="line">	m.items[nonce], m.cache = tx, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Put</code> 方法将交易插入到 map 中，同时更新 items。 </p>
<h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Forward(threshold uint64) types.Transactions &#123;</div><div class="line">	var removed types.Transactions</div><div class="line">	for m.index.Len() &gt; 0 &amp;&amp; (*m.index)[0] &lt; threshold &#123;</div><div class="line">		nonce := heap.Pop(m.index).(uint64)</div><div class="line">		removed = append(removed, m.items[nonce])</div><div class="line">		delete(m.items, nonce)</div><div class="line">	&#125;</div><div class="line">	if m.cache != nil &#123;</div><div class="line">		m.cache = m.cache[len(removed):]</div><div class="line">	&#125;</div><div class="line">	return removed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Forward</code> 可以用来删除所有 <code>nonce</code> 小于 <code>threshold</code> 的交易，返回的是所有被移除的交易。</p>
<h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Filter(filter func(*types.Transaction) bool) types.Transactions &#123;</div><div class="line">	var removed types.Transactions</div><div class="line"></div><div class="line">	for nonce, tx := range m.items &#123;</div><div class="line">		if filter(tx) &#123;</div><div class="line">			removed = append(removed, tx)</div><div class="line">			delete(m.items, nonce)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if len(removed) &gt; 0 &#123;</div><div class="line">		*m.index = make([]uint64, 0, len(m.items))</div><div class="line">		for nonce := range m.items &#123;</div><div class="line">			*m.index = append(*m.index, nonce)</div><div class="line">		&#125;</div><div class="line">		heap.Init(m.index)</div><div class="line"></div><div class="line">		m.cache = nil</div><div class="line">	&#125;</div><div class="line">	return removed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 接收 <code>filter</code> 函数，删除所有使得 <code>filter</code> 函数调用返回 <code>true</code> 的交易，返回这些被移除的交易。</p>
<h5 id="Cap"><a href="#Cap" class="headerlink" title="Cap"></a>Cap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Cap(threshold int) types.Transactions &#123;</div><div class="line">	if len(m.items) &lt;= threshold &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	var drops types.Transactions</div><div class="line"></div><div class="line">	sort.Sort(*m.index)</div><div class="line">	for size := len(m.items); size &gt; threshold; size-- &#123;</div><div class="line">		drops = append(drops, m.items[(*m.index)[size-1]])</div><div class="line">		delete(m.items, (*m.index)[size-1])</div><div class="line">	&#125;</div><div class="line">	*m.index = (*m.index)[:threshold]</div><div class="line">	heap.Init(m.index)</div><div class="line"></div><div class="line">	if m.cache != nil &#123;</div><div class="line">		m.cache = m.cache[:len(m.cache)-len(drops)]</div><div class="line">	&#125;</div><div class="line">	return drops</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Cap</code> 根据 <code>threshold</code> 参数对 items 参数进行限制，删除超出的交易，重建堆，返回这些被移除的交易。</p>
<h5 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Remove(nonce uint64) bool &#123;</div><div class="line">	_, ok := m.items[nonce]</div><div class="line">	if !ok &#123;</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line">	for i := 0; i &lt; m.index.Len(); i++ &#123;</div><div class="line">		if (*m.index)[i] == nonce &#123;</div><div class="line">			heap.Remove(m.index, i)</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	delete(m.items, nonce)</div><div class="line">	m.cache = nil</div><div class="line"></div><div class="line">	return true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>nonce</code> 从堆里移除交易，如果没有这个交易返回 <code>false</code>。</p>
<h5 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Ready(start uint64) types.Transactions &#123;</div><div class="line">	if m.index.Len() == 0 || (*m.index)[0] &gt; start &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	var ready types.Transactions</div><div class="line">	for next := (*m.index)[0]; m.index.Len() &gt; 0 &amp;&amp; (*m.index)[0] == next; next++ &#123;</div><div class="line">		ready = append(ready, m.items[next])</div><div class="line">		delete(m.items, next)</div><div class="line">		heap.Pop(m.index)</div><div class="line">	&#125;</div><div class="line">	m.cache = nil</div><div class="line"></div><div class="line">	return ready</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Ready</code> 返回从指定 <code>nonce</code> 开始，连续的交易。</p>
<h5 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Flatten() types.Transactions &#123;</div><div class="line">	if m.cache == nil &#123;</div><div class="line">		m.cache = make(types.Transactions, 0, len(m.items))</div><div class="line">		for _, tx := range m.items &#123;</div><div class="line">			m.cache = append(m.cache, tx)</div><div class="line">		&#125;</div><div class="line">		sort.Sort(types.TxByNonce(m.cache))</div><div class="line">	&#125;</div><div class="line">	txs := make(types.Transactions, len(m.cache))</div><div class="line">	copy(txs, m.cache)</div><div class="line">	return txs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个基于 <code>nonce</code> 排序的交易列表，缓存到 <code>cache</code> 字段里。</p>
<h4 id="txList"><a href="#txList" class="headerlink" title="txList"></a>txList</h4><p><code>txList</code> 用来存储连续的可执行的交易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type txList struct &#123;</div><div class="line">	strict bool</div><div class="line">	txs    *txSortedMap</div><div class="line"></div><div class="line">	costcap *big.Int</div><div class="line">	gascap  uint64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func newTxList(strict bool) *txList &#123;</div><div class="line">	return &amp;txList&#123;</div><div class="line">		strict:  strict,</div><div class="line">		txs:     newTxSortedMap(),</div><div class="line">		costcap: new(big.Int),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func (l *txList) Add(tx *types.Transaction, priceBump uint64) (bool, *types.Transaction) &#123;</div><div class="line">	old := l.txs.Get(tx.Nonce())</div><div class="line">	if old != nil &#123;</div><div class="line">		threshold := new(big.Int).Div(new(big.Int).Mul(old.GasPrice(), big.NewInt(100+int64(priceBump))), big.NewInt(100))</div><div class="line">		if old.GasPrice().Cmp(tx.GasPrice()) &gt;= 0 || threshold.Cmp(tx.GasPrice()) &gt; 0 &#123;</div><div class="line">			return false, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	l.txs.Put(tx)</div><div class="line">	if cost := tx.Cost(); l.costcap.Cmp(cost) &lt; 0 &#123;</div><div class="line">		l.costcap = cost</div><div class="line">	&#125;</div><div class="line">	if gas := tx.Gas(); l.gascap &lt; gas &#123;</div><div class="line">		l.gascap = gas</div><div class="line">	&#125;</div><div class="line">	return true, old</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Add</code> 方法会尝试插入一个交易，如果新的交易比老的交易的 GasPrice 值高出一定的数量，则会替换老的交易。 </p>
<h5 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func (l *txList) Filter(costLimit *big.Int, gasLimit uint64) (types.Transactions, types.Transactions) &#123;</div><div class="line">	if l.costcap.Cmp(costLimit) &lt;= 0 &amp;&amp; l.gascap &lt;= gasLimit &#123;</div><div class="line">		return nil, nil</div><div class="line">	&#125;</div><div class="line">	l.costcap = new(big.Int).Set(costLimit)</div><div class="line">	l.gascap = gasLimit</div><div class="line"></div><div class="line">	removed := l.txs.Filter(func(tx *types.Transaction) bool &#123; return tx.Cost().Cmp(costLimit) &gt; 0 || tx.Gas() &gt; gasLimit &#125;)</div><div class="line"></div><div class="line">	var invalids types.Transactions</div><div class="line"></div><div class="line">	if l.strict &amp;&amp; len(removed) &gt; 0 &#123;</div><div class="line">		lowest := uint64(math.MaxUint64)</div><div class="line">		for _, tx := range removed &#123;</div><div class="line">			if nonce := tx.Nonce(); lowest &gt; nonce &#123;</div><div class="line">				lowest = nonce</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		invalids = l.txs.Filter(func(tx *types.Transaction) bool &#123; return tx.Nonce() &gt; lowest &#125;)</div><div class="line">	&#125;</div><div class="line">	return removed, invalids</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 方法根据参数 <code>cost</code> 或 <code>gasLimit</code> 的值移除所有比该值更高的交易，被移除的交易会返回以便进一步处理。</p>
<h5 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func (l *txList) Remove(tx *types.Transaction) (bool, types.Transactions) &#123;</div><div class="line">	nonce := tx.Nonce()</div><div class="line">	if removed := l.txs.Remove(nonce); !removed &#123;</div><div class="line">		return false, nil</div><div class="line">	&#125;</div><div class="line">	if l.strict &#123;</div><div class="line">		return true, l.txs.Filter(func(tx *types.Transaction) bool &#123; return tx.Nonce() &gt; nonce &#125;)</div><div class="line">	&#125;</div><div class="line">	return true, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除给定 <code>Nonce</code> 的交易，如果是严格模式，删除所有 <code>nonce</code> 大于给定 <code>Nonce</code> 的交易。</p>
<h5 id="Overlaps-Forward-Cap-Ready-Empty-Empty-Flatten"><a href="#Overlaps-Forward-Cap-Ready-Empty-Empty-Flatten" class="headerlink" title="Overlaps, Forward, Cap, Ready, Empty, Empty, Flatten"></a>Overlaps, Forward, Cap, Ready, Empty, Empty, Flatten</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func (l *txList) Overlaps(tx *types.Transaction) bool &#123;</div><div class="line">	return l.txs.Get(tx.Nonce()) != nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Forward(threshold uint64) types.Transactions &#123;</div><div class="line">	return l.txs.Forward(threshold)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Cap(threshold int) types.Transactions &#123;</div><div class="line">	return l.txs.Cap(threshold)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Ready(start uint64) types.Transactions &#123;</div><div class="line">	return l.txs.Ready(start)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Len() int &#123;</div><div class="line">	return l.txs.Len()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Empty() bool &#123;</div><div class="line">	return l.Len() == 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (l *txList) Flatten() types.Transactions &#123;</div><div class="line">	return l.txs.Flatten()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Overlaps</code>, <code>Forward</code>, <code>Cap</code>, <code>Ready</code>, <code>Empty</code>, <code>Empty</code>, <code>Flatten</code> 直接调用 <code>txSortedMap</code> 的对应方法。</p>
<h4 id="priceHeap"><a href="#priceHeap" class="headerlink" title="priceHeap"></a>priceHeap</h4><p><code>priceHeap</code> 类似于上面提到的 <code>nonceHeap</code>，不过比较优先级时，优先比较 <code>GasPrice</code>，如果相同则比较 <code>Nonce</code>。这里不再赘述</p>
<h4 id="txPricedList"><a href="#txPricedList" class="headerlink" title="txPricedList"></a>txPricedList</h4><p><code>txPricedList</code> 类似于上面提到的 <code>txList</code>，其中有 <code>Put</code>, <code>Removed</code>, <code>Cap</code>, <code>Underpriced</code>, <code>Discard</code> 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是交易池的主要逻辑，在提交交易之后，数据会通过 geth 的 p2p 系统广播出去，接下来就等矿工进行挖矿了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97" target="_blank" rel="external">优先队列</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们探究了以太坊账户，转账的实现，在文末的时候挖了一个坑，调用了提交转账的 api 后我们就没有再继续往下走了。这一篇我们更进一步，看看交易池是怎么实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88accounts,%20transaction%20%E6%A8%A1%E5%9D%97-%E8%B4%A6%E6%88%B7%E5%92%8C%E8%BD%AC%E8%B4%A6%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）/</id>
    <published>2018-03-10T14:35:03.000Z</published>
    <updated>2018-09-10T00:38:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇分析 <code>geth</code> 中与账户和转账相关的源代码。</p>
<p>交易是以太坊里的一个很核心的概念，它不仅仅体现在价值的转移上。我们知道智能合约是以太坊的一个重大创新，而智能合约的执行是依靠交易来触发的，可以这么说，在以太坊中，大部分场景的状态转换都依靠交易实现，而交易又与账户紧密相关，所以这一篇我们将账户，转账这两个模块结合在一起来探讨。<br><a id="more"></a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>以太坊引入账户状态概念取代比特币 UTXO 模型。账户以地址为索引，地址是公钥的最后20字节。</p>
<p>以太坊中有两类账户，一类是外部账户，一类是合约账户。每个账户都有一个与之关联的账户状态和一个10字节地址，都可以用来存储以太币。</p>
<ul>
<li>外部账户（EOA）：由人创建，用私钥控制，没有代码与之关联，地址由公钥决定。私钥可用于对交易签名从而主动向其他账户发起交易进行消息传递。</li>
<li>合约账户：外部账户创建，由合约代码控制，有代码与之关联，其地址由合约创造者地址和该地址发出过的交易数量 nonce 共同决定。不能主动向其他账户发起交易，但可以『响应』其他账户进行消息调用。</li>
</ul>
<h3 id="生成外部账户"><a href="#生成外部账户" class="headerlink" title="生成外部账户"></a>生成外部账户</h3><p>生成一个账户地址大致是3步：</p>
<ol>
<li>设置账户秘钥（根据用户密码等信息）</li>
<li>通过 secp256k1 椭圆曲线密码算法，由私钥生成对应的公钥</li>
<li>根据公钥得到相应的账户地址</li>
</ol>
<h3 id="私钥的三种形态"><a href="#私钥的三种形态" class="headerlink" title="私钥的三种形态"></a>私钥的三种形态</h3><ul>
<li>Private Key，随机生成的256位二进制数字</li>
<li>Keystore &amp; Password，私钥和公钥以加密的方式保存一份 JSON 文件，存在 keystore 子目录下，这份 JSON 文件就是 Keystore，用户需要保存 Keystore，以及创建钱包时设置的密码。</li>
<li>Memonic code，由 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="external">bip 39</a> 提出，随机生成12~24个比较容易记住的单词，通过 PBKDF2 和 HMAC-SHA512 函数创建随机种子，再生成钱包。</li>
</ul>
<h3 id="外部账户和合约账户的区别"><a href="#外部账户和合约账户的区别" class="headerlink" title="外部账户和合约账户的区别"></a>外部账户和合约账户的区别</h3><p>外部账户可以通过创建以及用自己的私钥对交易进行签名，来发送消息给另一个外部账户或合约账户，在两个外部账户之间传送的消息只是一个简单的价值转移，但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作(包括转移代币，写入内部存储，挖出新代币，执行运算，创建一个新合约等)。合约账户不能自己发起交易，它只能在接收到一个消息（可以来自外部账户或合约账户）之后，为响应该消息触发一个交易。</p>
<h3 id="交易相关的基本概念"><a href="#交易相关的基本概念" class="headerlink" title="交易相关的基本概念"></a>交易相关的基本概念</h3><p>交易是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它可以是以太币的转账，也可以是包含智能合约代码的消息。</p>
<p>交易有3种类型。</p>
<ol>
<li>转账交易，从一个账户向另一个账户发送以太币</li>
<li>创建智能合约的交易，将合约部署到区块链上。</li>
<li>执行智能合约，执行已经部署在区块链上的智能合约。</li>
</ol>
<h3 id="转账流程"><a href="#转账流程" class="headerlink" title="转账流程"></a>转账流程</h3><ul>
<li>用户输入转出的地址，转入的地址和转出的金额</li>
<li>系统通过转出地址私钥对转账信息进行签名，以确保这笔交易是本人进行的</li>
<li>系统对交易信息进行确认</li>
<li>将交易加入到本地交易池</li>
<li>将交易信息广播到其他节点</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="账户（在-accounts-accounts-go-中定义）"><a href="#账户（在-accounts-accounts-go-中定义）" class="headerlink" title="账户（在 accounts/accounts.go 中定义）"></a>账户（在 accounts/accounts.go 中定义）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">	Address common.Address `json:&quot;address&quot;`</div><div class="line">	URL     URL            `json:&quot;url&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交易相关的数据结构"><a href="#交易相关的数据结构" class="headerlink" title="交易相关的数据结构"></a>交易相关的数据结构</h3><p>交易的数据结构在 <code>core/types/transaction.go</code> 中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">type Transaction struct &#123;</div><div class="line">	data txdata</div><div class="line">	hash atomic.Value</div><div class="line">	size atomic.Value</div><div class="line">	from atomic.Value</div><div class="line">&#125;</div><div class="line"></div><div class="line">type txdata struct &#123;</div><div class="line">	AccountNonce uint64          `json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</div><div class="line">	Price        *big.Int        `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</div><div class="line">	GasLimit     uint64          `json:&quot;gas&quot;      gencodec:&quot;required&quot;`</div><div class="line">	Recipient    *common.Address `json:&quot;to&quot;       rlp:&quot;nil&quot;`</div><div class="line">	Amount       *big.Int        `json:&quot;value&quot;    gencodec:&quot;required&quot;`</div><div class="line">	Payload      []byte          `json:&quot;input&quot;    gencodec:&quot;required&quot;`</div><div class="line">	V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;`</div><div class="line">	R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;`</div><div class="line">	S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;`</div><div class="line">	Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Transaction</code> 结构体中，实际上只有一个 <code>data</code> 是有效字段，另外3个 <code>hash</code>, <code>size</code>, <code>from</code> 是用做缓存的。<code>txdata</code> 结构体中没有交易发送者，因为发起者可以通过签名数据获得。<code>txdata</code> 结构体其他字段的含义可以在下表中查看：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>AccountNonce</td>
<td>交易发送者已经发送交易的次数</td>
</tr>
<tr>
<td>Price</td>
<td>该交易的 gas 费用</td>
</tr>
<tr>
<td>GasLimit</td>
<td>本次交易允许消耗 gas 的最大数量</td>
</tr>
<tr>
<td>Recipient</td>
<td>交易接收者</td>
</tr>
<tr>
<td>Amount</td>
<td>交易的以太坊数量</td>
</tr>
<tr>
<td>Payload</td>
<td>交易携带的数据</td>
</tr>
<tr>
<td>V, R, S</td>
<td>交易的签名数据</td>
</tr>
</tbody>
</table>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p><code>accounts</code> 模块实现以太坊客户端钱包，账户管理。智能合约的 ABI 代码也在 <code>accounts/abi</code> 目录下。钱包的接口在 <code>accounts/accounts.go</code> 中定义，目前有两种该接口实现，一个是 keyStore，一个是 usbwallet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type Wallet interface &#123;</div><div class="line">	URL() URL</div><div class="line">	Status() (string, error)</div><div class="line">	Open(passphrase string) error</div><div class="line">	Close() error</div><div class="line">	Accounts() []Account</div><div class="line">	Contains(account Account) bool</div><div class="line">	Derive(path DerivationPath, pin bool) (Account, error)</div><div class="line">	SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)</div><div class="line">	SignHash(account Account, hash []byte) ([]byte, error)</div><div class="line">	SignTx(account Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error)</div><div class="line">	SignHashWithPassphrase(account Account, passphrase string, hash []byte) ([]byte, error)</div><div class="line">	SignTxWithPassphrase(account Account, passphrase string, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL()</td>
<td>获取钱包可以访问的规范路径。它会被用来给所有的后端钱包进行排序</td>
</tr>
<tr>
<td>Status() (string, error)</td>
<td>返回一个文本值标识当前钱包状态，同时返回一个 error 标识钱包遇到的任何错误。</td>
</tr>
<tr>
<td>Open(passphrase string) error</td>
<td>初始化对钱包实例的访问。</td>
</tr>
<tr>
<td>Close() error</td>
<td>释放由 Open 方法占用的任何资源</td>
</tr>
<tr>
<td>Accounts() []Account</td>
<td>获取钱包中签名的账户</td>
</tr>
<tr>
<td>Contains(account Account) bool</td>
<td>判断一个账户是否属于本钱包</td>
</tr>
<tr>
<td>Derive(path DerivationPath, pin bool) (Account, error)</td>
<td>尝试在指定派生路径上派生出分层确定性账户，如果 pin 为 true，派生账户添加到钱包的跟踪账户列表中。</td>
</tr>
<tr>
<td>SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)</td>
<td>设置一个基本账户导出路径，从中钱包尝试发现非零账户，自动将其添加到跟踪账户列表中。</td>
</tr>
<tr>
<td>SignHash(account Account, hash []byte) ([]byte, error)</td>
<td>钱包需要额外验证才能签名时使用这个接口。</td>
</tr>
<tr>
<td>SignTx(account Account, tx <em>types.Transaction, chainID </em>big.Int) (*types.Transaction, error)</td>
<td>请求钱包对指定交易进行签名。</td>
</tr>
<tr>
<td>SignHashWithPassphrase(account Account, passphrase string, hash []byte) ([]byte, error)</td>
<td>请求钱包使用指定的 passphrase 给给定 hash 签名</td>
</tr>
<tr>
<td>SignTxWithPassphrase(account Account, passphrase string, tx <em>types.Transaction, chainID </em>big.Int) (*types.Transaction, error)</td>
<td>请求钱包使用给定 passphrase 给给定 transaction 签名。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type Backend interface &#123;</div><div class="line">	Wallets() []Wallet</div><div class="line">	Subscribe(sink chan&lt;- WalletEvent) event.Subscription</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Backend</code> 接口是一个钱包 provider，它包含一个钱包列表，在检测到钱包开启或关闭时可以接收到通知，可以用来请求签名交易。其中 <code>Wallets()</code> 返回当前可用的钱包，按字母顺序排序，<code>Subscribe()</code> 创建异步订阅的方法，当钱包发生变动时通过 chan 接收消息。</p>
<p>在 <code>accounts/manager.go</code> 中，定义了 <code>Manager</code> 结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type Manager struct &#123;</div><div class="line">	backends map[reflect.Type][]Backend</div><div class="line">	updaters []event.Subscription</div><div class="line">	updates  chan WalletEvent</div><div class="line">	wallets  []Wallet</div><div class="line">	feed event.Feed</div><div class="line">	quit chan chan error</div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Manager</code> 是管理账户的入口，可以与各种 <code>backends</code> 进行通信。</p>
<p>其中 <code>backends</code> 是当前已注册的所有 <code>Backend</code>，<code>updaters</code> 是所有 <code>Backend</code> 的更新订阅器，<code>updates</code> 是 <code>Backend</code> 对应 <code>wallet</code> 事件更新的 chan，<code>wallets</code> 是所有已经注册的 <code>Backends</code> 的钱包的缓存，<code>feed</code> 用于钱包事件的通知，<code>quit</code> 用于退出的事件。<code>manager.go</code> 的代码没有什么很特别的地方，有兴趣的话可以自行查看源代码，这里只做概述。这里只挑几个典型的，下面讲解业务实例时会用到的方法。</p>
<h3 id="NewManager"><a href="#NewManager" class="headerlink" title="NewManager"></a><code>NewManager</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func NewManager(backends ...Backend) *Manager &#123;</div><div class="line">	var wallets []Wallet</div><div class="line">	for _, backend := range backends &#123;</div><div class="line">		wallets = merge(wallets, backend.Wallets()...)</div><div class="line">	&#125;</div><div class="line">	updates := make(chan WalletEvent, 4*len(backends))</div><div class="line"></div><div class="line">	subs := make([]event.Subscription, len(backends))</div><div class="line">	for i, backend := range backends &#123;</div><div class="line">		subs[i] = backend.Subscribe(updates)</div><div class="line">	&#125;</div><div class="line">	am := &amp;Manager&#123;</div><div class="line">		backends: make(map[reflect.Type][]Backend),</div><div class="line">		updaters: subs,</div><div class="line">		updates:  updates,</div><div class="line">		wallets:  wallets,</div><div class="line">		quit:     make(chan chan error),</div><div class="line">	&#125;</div><div class="line">	for _, backend := range backends &#123;</div><div class="line">		kind := reflect.TypeOf(backend)</div><div class="line">		am.backends[kind] = append(am.backends[kind], backend)</div><div class="line">	&#125;</div><div class="line">	go am.update()</div><div class="line">	return am</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewManager</code> 会将所有 <code>backends</code> 的 wallets 收集起来，获取所有的 <code>backends</code> 的时间订阅，然后根据这些参数创建新的 <code>manager</code>。</p>
<h3 id="update"><a href="#update" class="headerlink" title="update()"></a><code>update()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func (am *Manager) update() &#123;</div><div class="line">	defer func() &#123;</div><div class="line">		am.lock.Lock()</div><div class="line">		for _, sub := range am.updaters &#123;</div><div class="line">			sub.Unsubscribe()</div><div class="line">		&#125;</div><div class="line">		am.updaters = nil</div><div class="line">		am.lock.Unlock()</div><div class="line">	&#125;()</div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case event := &lt;-am.updates:</div><div class="line">			am.lock.Lock()</div><div class="line">			switch event.Kind &#123;</div><div class="line">			case WalletArrived:</div><div class="line">				am.wallets = merge(am.wallets, event.Wallet)</div><div class="line">			case WalletDropped:</div><div class="line">				am.wallets = drop(am.wallets, event.Wallet)</div><div class="line">			&#125;</div><div class="line">			am.lock.Unlock()</div><div class="line"></div><div class="line">			am.feed.Send(event)</div><div class="line"></div><div class="line">		case errc := &lt;-am.quit:</div><div class="line">			errc &lt;- nil</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>update</code>在 <code>NewManager</code> 作为一个 <code>goroutine</code> 被调用，一直运行，监控所有 backend 触发的更新消息，发给 feed 用来进行进一步的处理。</p>
<h3 id="Subscribe-sink-chan-lt-WalletEvent-event-Subscription"><a href="#Subscribe-sink-chan-lt-WalletEvent-event-Subscription" class="headerlink" title="Subscribe(sink chan&lt;- WalletEvent) event.Subscription"></a><code>Subscribe(sink chan&lt;- WalletEvent) event.Subscription</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (am *Manager) Subscribe(sink chan&lt;- WalletEvent) event.Subscription &#123;</div><div class="line">	return am.feed.Subscribe(sink)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个异步的消息订阅对象，当钱包发生变动时可以收到信息。</p>
<h3 id="Find-account-Account-Wallet-error"><a href="#Find-account-Account-Wallet-error" class="headerlink" title="Find(account Account) (Wallet, error)"></a><code>Find(account Account) (Wallet, error)</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (am *Manager) Find(account Account) (Wallet, error) &#123;</div><div class="line">	am.lock.RLock()</div><div class="line">	defer am.lock.RUnlock()</div><div class="line"></div><div class="line">	for _, wallet := range am.wallets &#123;</div><div class="line">		if wallet.Contains(account) &#123;</div><div class="line">			return wallet, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil, ErrUnknownAccount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Find</code> 方法会对钱包进行遍历，找到某个账户的钱包，由于钱包中的账户是动态的增加或删除的，所以我们需要加锁。</p>
<h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>如果是通过命令行创建账户，可以使用 <code>geth account new</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func accountCreate(ctx *cli.Context) error &#123;</div><div class="line">	cfg := gethConfig&#123;Node: defaultNodeConfig()&#125;</div><div class="line">	if file := ctx.GlobalString(configFileFlag.Name); file != &quot;&quot; &#123;</div><div class="line">		if err := loadConfig(file, &amp;cfg); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	scryptN, scryptP, keydir, err := cfg.Node.AccountConfig()</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read configuration: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	password := getPassPhrase(&quot;Your new account is locked with a password. Please give a password. Do not forget this password.&quot;, true, 0, utils.MakePasswordList(ctx))</div><div class="line">	address, err := keystore.StoreKey(keydir, password, scryptN, scryptP)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to create account: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Address: &#123;%x&#125;\n&quot;, address)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑很简单。首先获取配置信息，通过 <code>getPassPhrase</code> 获取密码后，通过 <code>keystore.StoreKey</code> 获得账户地址。</p>
<p>在 <code>internal/ethapi/api.go</code> 中，也可以通过 <code>NewAccount</code> 获取新账户，这个 api 可以通过交互式命令行或 rpc 接口调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (s *PrivateAccountAPI) NewAccount(password string) (common.Address, error) &#123;</div><div class="line">	acc, err := fetchKeystore(s.am).NewAccount(password)</div><div class="line">	if err == nil &#123;</div><div class="line">		return acc.Address, nil</div><div class="line">	&#125;</div><div class="line">	return common.Address&#123;&#125;, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先调用 <code>fetchKeystore</code>，通过 <code>backends</code> 获得 <code>KeyStore</code> 对象，最后通过调用 <code>keystore.go</code> 中的 <code>NewAccount</code> 获得新账户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func (ks *KeyStore) NewAccount(passphrase string) (accounts.Account, error) &#123;</div><div class="line">	_, account, err := storeNewKey(ks.storage, crand.Reader, passphrase)</div><div class="line">	if err != nil &#123;</div><div class="line">		return accounts.Account&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	ks.cache.add(account)</div><div class="line">	ks.refreshWallets()</div><div class="line">	return account, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewAccount</code> 会调用 <code>storeNewKey</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func storeNewKey(ks keyStore, rand io.Reader, auth string) (*Key, accounts.Account, error) &#123;</div><div class="line">	key, err := newKey(rand)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, accounts.Account&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	a := accounts.Account&#123;Address: key.Address, URL: accounts.URL&#123;Scheme: KeyStoreScheme, Path: ks.JoinPath(keyFileName(key.Address))&#125;&#125;</div><div class="line">	if err := ks.StoreKey(a.URL.Path, key, auth); err != nil &#123;</div><div class="line">		zeroKey(key.PrivateKey)</div><div class="line">		return nil, a, err</div><div class="line">	&#125;</div><div class="line">	return key, a, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意第一个参数是 <code>keyStore</code>，这是一个接口类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type keyStore interface &#123;</div><div class="line">	GetKey(addr common.Address, filename string, auth string) (*Key, error)</div><div class="line">	StoreKey(filename string, k *Key, auth string) error</div><div class="line">	JoinPath(filename string) string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>storeNewKey</code> 首先调用 <code>newKey</code>，通过椭圆曲线加密算法获取公私钥对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func newKey(rand io.Reader) (*Key, error) &#123;</div><div class="line">	privateKeyECDSA, err := ecdsa.GenerateKey(crypto.S256(), rand)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return newKeyFromECDSA(privateKeyECDSA), nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后会根据参数 ks 的类型调用对应的实现，通过 <code>geth account new</code> 命令创建新账户，调用的就是 <code>accounts/keystore/keystore_passphrase.go</code> 中的实现。即 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (ks keyStorePassphrase) StoreKey(filename string, key *Key, auth string) error &#123;</div><div class="line">	keyjson, err := EncryptKey(key, auth, ks.scryptN, ks.scryptP)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	return writeKeyFile(filename, keyjson)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以深入到 <code>EncryptKey</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">func EncryptKey(key *Key, auth string, scryptN, scryptP int) ([]byte, error) &#123;</div><div class="line">	authArray := []byte(auth)</div><div class="line">	salt := randentropy.GetEntropyCSPRNG(32)</div><div class="line">	derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptR, scryptP, scryptDKLen)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	encryptKey := derivedKey[:16]</div><div class="line">	keyBytes := math.PaddedBigBytes(key.PrivateKey.D, 32)</div><div class="line"></div><div class="line">	iv := randentropy.GetEntropyCSPRNG(aes.BlockSize) // 16</div><div class="line">	cipherText, err := aesCTRXOR(encryptKey, keyBytes, iv)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	mac := crypto.Keccak256(derivedKey[16:32], cipherText)</div><div class="line"></div><div class="line">	scryptParamsJSON := make(map[string]interface&#123;&#125;, 5)</div><div class="line">	scryptParamsJSON[&quot;n&quot;] = scryptN</div><div class="line">	scryptParamsJSON[&quot;r&quot;] = scryptR</div><div class="line">	scryptParamsJSON[&quot;p&quot;] = scryptP</div><div class="line">	scryptParamsJSON[&quot;dklen&quot;] = scryptDKLen</div><div class="line">	scryptParamsJSON[&quot;salt&quot;] = hex.EncodeToString(salt)</div><div class="line"></div><div class="line">	cipherParamsJSON := cipherparamsJSON&#123;</div><div class="line">		IV: hex.EncodeToString(iv),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cryptoStruct := cryptoJSON&#123;</div><div class="line">		Cipher:       &quot;aes-128-ctr&quot;,</div><div class="line">		CipherText:   hex.EncodeToString(cipherText),</div><div class="line">		CipherParams: cipherParamsJSON,</div><div class="line">		KDF:          keyHeaderKDF,</div><div class="line">		KDFParams:    scryptParamsJSON,</div><div class="line">		MAC:          hex.EncodeToString(mac),</div><div class="line">	&#125;</div><div class="line">	encryptedKeyJSONV3 := encryptedKeyJSONV3&#123;</div><div class="line">		hex.EncodeToString(key.Address[:]),</div><div class="line">		cryptoStruct,</div><div class="line">		key.Id.String(),</div><div class="line">		version,</div><div class="line">	&#125;</div><div class="line">	return json.Marshal(encryptedKeyJSONV3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>EncryptKey</code> 的 key 参数是加密的账户，包括 ID，公私钥，地址，auth 参数是用户输入的密码，<code>scryptN</code> 参数是 scrypt 算法中的 N，<code>scryptP</code> 参数是 scrypt 算法中的 P。整个过程，首先对密码使用 scrypt 算法加密，得到加密后的密码 derivedKey，然后用 derivedKey 对私钥使用 AES-CTR 算法加密，得到密文 cipherText，再对 derivedKey 和 cipherText 进行哈希运算得到 mac，mac 起到签名的作用，在解密的时候可以验证合法性，防止别人篡改。<code>EncryptKey</code> 最终返回 json 字符串，Storekey 方法接下来会将其保存在文件中。</p>
<h3 id="列出所有账户"><a href="#列出所有账户" class="headerlink" title="列出所有账户"></a>列出所有账户</h3><p>列出所有账户的入口也在 <code>internal/ethapi/api.go</code> 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func (s *PrivateAccountAPI) ListAccounts() []common.Address &#123;</div><div class="line">	addresses := make([]common.Address, 0) // return [] instead of nil if empty</div><div class="line">	for _, wallet := range s.am.Wallets() &#123;</div><div class="line">		for _, account := range wallet.Accounts() &#123;</div><div class="line">			addresses = append(addresses, account.Address)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return addresses</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会从 <code>Account Manager</code> 中读取所有钱包信息，获取其对应的所有地址信息。</p>
<p>如果读者对 geth account 命令还有印象的话，geth account 命令还有 <code>update</code>，<code>import</code> 等方法，这里就不再讨论了。</p>
<h3 id="发起转账"><a href="#发起转账" class="headerlink" title="发起转账"></a>发起转账</h3><p>发起一笔转账的函数入口在 <code>internal/ethapi/api.go</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123;</div><div class="line">	account := accounts.Account&#123;Address: args.From&#125;</div><div class="line">	wallet, err := s.b.AccountManager().Find(account)</div><div class="line">	if err != nil &#123;</div><div class="line">		return common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	if args.Nonce == nil &#123;</div><div class="line">		s.nonceLock.LockAddr(args.From)</div><div class="line">		defer s.nonceLock.UnlockAddr(args.From)</div><div class="line">	&#125;</div><div class="line">	if err := args.setDefaults(ctx, s.b); err != nil &#123;</div><div class="line">		return common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	tx := args.toTransaction()</div><div class="line"></div><div class="line">	var chainID *big.Int</div><div class="line">	if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) &#123;</div><div class="line">		chainID = config.ChainId</div><div class="line">	&#125;</div><div class="line">	signed, err := wallet.SignTx(account, tx, chainID)</div><div class="line">	if err != nil &#123;</div><div class="line">		return common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	return submitTransaction(ctx, s.b, signed)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转账时，首先利用传入的参数 <code>from</code> 构造一个 <code>account</code>，表示转出方。然后通过 <code>accountMananger</code> 的 <code>Find</code> 方法获得这个账户的钱包(<code>Find</code> 方法在上面有介绍)，接下来有一个稍特别的地方。我们知道以太坊采用的是账户余额的体系，对于 UTXO 的方式来说，防止双花的方式很直观，一个输出不能同时被两个输入而引用，这种方式自然而然地就防止了发起转账时可能出现的双花，采用账户系统的以太坊没有这种便利，以太坊的做法是，每个账户有一个 nonce 值，它等于账户累计发起的交易数量，账户发起交易时，交易数据里必须包含 nonce，而且该值必须大于账户的 nonce 值，否则为非法，如果交易的 nonce 值减去账户的 nonce 值大于1，这个交易也不能打包到区块中，这确保了交易是按照一定的顺序执行的。如果有两笔交易有相同 nonce，那么其中只有一笔交易能够成功，通过给  nonce 加锁就是用来防止双花的问题。接着调用 <code>args.setDefaults(ctx, s.b)</code> 方法设置一些交易默认值。最后调用 <code>toTransaction</code> 方法创建交易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (args *SendTxArgs) toTransaction() *types.Transaction &#123;</div><div class="line">	var input []byte</div><div class="line">	if args.Data != nil &#123;</div><div class="line">		input = *args.Data</div><div class="line">	&#125; else if args.Input != nil &#123;</div><div class="line">		input = *args.Input</div><div class="line">	&#125;</div><div class="line">	if args.To == nil &#123;</div><div class="line">		return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)</div><div class="line">	&#125;</div><div class="line">	return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个分支，如果传入的交易的 <code>to</code> 参数不存在，那就表明这是一笔合约转账；如果有 <code>to</code> 参数，就是一笔普通的转账，深入后你会发现这两种转账最终调用的都是 <code>newTransaction</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func NewTransaction(nonce uint64, to common.Address, amount *big.Int, gasLimit uint64, gasPrice *big.Int, data []byte) *Transaction &#123;</div><div class="line">	return newTransaction(nonce, &amp;to, amount, gasLimit, gasPrice, data)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewContractCreation(nonce uint64, amount *big.Int, gasLimit uint64, gasPrice *big.Int, data []byte) *Transaction &#123;</div><div class="line">	return newTransaction(nonce, nil, amount, gasLimit, gasPrice, data)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>newTransaction</code> 的功能很简单，实际上就是返回一个 <code>Transaction</code> 实例。我们接着看 <code>SendTransaction</code> 方法接下来的部分。创建好一笔交易，接着我们通过 <code>ChainConfig</code> 方法获得区块链的配置信息，如果是 EIP155 里描述的配置，需要做特殊处理（待深入），然后调用 <code>SignTx</code> 对交易签名来确保这笔交易是真实有效的。<code>SignTx</code> 的接口定义在 <code>accounts/accounts.go</code> 中，这里我们看 keystore 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123;</div><div class="line">	ks.mu.RLock()</div><div class="line">	defer ks.mu.RUnlock()</div><div class="line"></div><div class="line">	unlockedKey, found := ks.unlocked[a.Address]</div><div class="line">	if !found &#123;</div><div class="line">		return nil, ErrLocked</div><div class="line">	&#125;</div><div class="line">	if chainID != nil &#123;</div><div class="line">		return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey)</div><div class="line">	&#125;</div><div class="line">	return types.SignTx(tx, types.HomesteadSigner&#123;&#125;, unlockedKey.PrivateKey)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先验证账户是否已解锁，若没有解锁，直接报异常退出。接着根据 <code>chainID</code> 判断使用哪一种签名方式，调用相应 <code>SignTx</code> 方法进行签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) &#123;</div><div class="line">	h := s.Hash(tx)</div><div class="line">	sig, err := crypto.Sign(h[:], prv)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return tx.WithSignature(s, sig)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SignTx</code> 的功能是调用椭圆加密函数获得签名，得到带签名的交易后，通过 <code>SubmitTrasaction</code> 提交交易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) &#123;</div><div class="line">	if err := b.SendTx(ctx, tx); err != nil &#123;</div><div class="line">		return common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	if tx.To() == nil &#123;</div><div class="line">		signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number())</div><div class="line">		from, err := types.Sender(signer, tx)</div><div class="line">		if err != nil &#123;</div><div class="line">			return common.Hash&#123;&#125;, err</div><div class="line">		&#125;</div><div class="line">		addr := crypto.CreateAddress(from, tx.Nonce())</div><div class="line">		log.Info(&quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex())</div><div class="line">	&#125; else &#123;</div><div class="line">		log.Info(&quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To())</div><div class="line">	&#125;</div><div class="line">	return tx.Hash(), nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>submitTransaction</code> 首先调用 <code>SendTx</code>，这个接口在 <code>internal/ethapi/backend.go</code> 中定义，而实现在 <code>eth/api_backend.go</code> 中，这部分代码涉及到交易池，我们在单独的交易池章节进行探讨，这里就此打住。</p>
<p>将交易写入交易池后，如果没有因错误退出，<code>submitTransaction</code> 会完成提交交易，返回交易哈希值。发起交易的这个过程就结束了，剩下的就交给矿工将交易上链。挖矿相关的代码会在之后的博客中进行介绍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇分析 &lt;code&gt;geth&lt;/code&gt; 中与账户和转账相关的源代码。&lt;/p&gt;
&lt;p&gt;交易是以太坊里的一个很核心的概念，它不仅仅体现在价值的转移上。我们知道智能合约是以太坊的一个重大创新，而智能合约的执行是依靠交易来触发的，可以这么说，在以太坊中，大部分场景的状态转换都依靠交易实现，而交易又与账户紧密相关，所以这一篇我们将账户，转账这两个模块结合在一起来探讨。&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（trie 模块-MPT 的实现）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/</id>
    <published>2018-03-10T14:35:02.000Z</published>
    <updated>2018-09-18T18:23:30.552Z</updated>
    
    <content type="html"><![CDATA[<p>默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之前，读者应该对默克尔树，帕特里夏树这两个数据结构有一定了解，这些是阅读源代码的基础知识，这里只做概述。下面我们先分别介绍这两种数据结构。</p>
<a id="more"></a>
<h2 id="Merkle-Tree-默克尔树"><a href="#Merkle-Tree-默克尔树" class="headerlink" title="Merkle Tree 默克尔树"></a>Merkle Tree 默克尔树</h2><p>默克尔树即哈希树，它是一种树形数据结构，由一组叶结点，一组中间节点和一个根节点构成。最下面的叶结点包含基础数据，每个中间节点是它的子节点的哈希值，根节点是他的子节点的哈希值，表示默克尔树的根部。它的作用是对大容量的数据进行快速比对。对于一个数据集，我们可以将其分成多个小的数据集，存在叶子节点上，默克尔树的根节点存储的哈希值就表示这个数据集的哈希值，当更新、添加或删除树节点时，都需要更新节点的哈希值，根节点的哈希值也会有所不同，这样可以用根节点到数据节点这一路径的数据来证明数据的正确性，而这个数据量相比于整个数据集来说是很小的。</p>
<p>举两个实际的例子，你就能很好的理解默克尔树的作用。</p>
<h3 id="Dynano-数据库"><a href="#Dynano-数据库" class="headerlink" title="Dynano 数据库"></a>Dynano 数据库</h3><p>在 Amazon 的 Dynamo 数据库中，大量使用到默克尔树。场景是这样的：为了保证 Dynamo 集群中的数据存储的持久性，一台机器上的数据在其他机器上存有备份，也就是副本。副本经常需要同步，保证数据的一致，这时候需要对数据进行比对，找到不一致的地方。网络传输时间是这个过程的瓶颈，我们需要尽可能减少数据传输量。比对两台机器的数据，传输不一致的数据当然是最佳选择，如何比对？首先应该想到的是应该比对哈希值，避免之间传输数据带来的巨大传输量，其次，用二分法能更快的找到差异数据，如果能想到这两点，我们就和 Merkle 想的一样了。在每台机器对每个区间的数据构建默克尔树，比对数据时，从根节点开始比较，如果一致，表明两个副本一致，否则就遍历这颗二叉树，定位到差异数据的复杂度是 $O(log(n))$。</p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种中心索引式的 P2P 文件分析通信协议。进行 P2P 下载时，先从中心索引服务器获取一个扩展名为 torrent 的索引文件，torrent 文件包含了共享文件的信息，包括文件名，大小，文件的 Hash 和指向 Tracker 的 URL，当我们使用 BitTorrent 下载文件时有几个步骤：</p>
<ol>
<li>客户端 A 根据下载的种子文件得出资源的目标服务器地址，然后与目标服务器地址建立连接，进行数据块下载。</li>
<li>当一个数据块下载完成后，客户端 A 会计算该数据块的摘要，然后用这个摘要与先前种子文件里的摘要进行对比，如果一致，表示这个数据块下载成功，否则，重新下载。</li>
<li>当一个数据块下载成功，客户端 A 会与其他下载资源的客户端进行通信，告知它们它已经成功下载了一个数据库，其他客户端需要下载这个数据块时，会去客户端 A 下载。</li>
</ol>
<p>如果不采用默克尔树，可以采取 hash list 的方式，即将文件分成一个一个的数据块后，分别对其取 hash，这带来一个问题是，torrent 文件应该是越小越好，否则会对种子文件服务器造成很大的负载压力，要想要 torrent 文件很小，那么数据块就应该分得足够大，但数据块足够大的话，客户端下载完一个数据块后校验发现数据块无效，重新传输代价又很大。引入默克尔树可以解决这个问题，将所有数据块构造成默克尔树之后，种子文件可以只存放根节点的哈希值。当出现传输错误时可以使用二分查找快速找到出错的数据块，然后重新传输，</p>
<p>从上述的两个例子可以看到引入默克尔树的意义，默克尔树将哈希表和二叉树的结合起来，由根节点，中间节点和叶子节点组成，叶子节点存的是数据或哈希值，中间节点是它的两个孩子的哈希值，根节点也是它的两个孩子的哈希值，它表示这一组数据的指纹。根据哈希表和二叉树的特点我们可以知道，叶子节点数据的任何变动，都可以通过父节点体现，而通过二叉树，可以很快定位到变更的数据。</p>
<p>因此，默克尔树的典型应用场景有：</p>
<ul>
<li>快速比较大量数据：如果两个默克尔树的根节点的值相同，意味着它们代表的值相同</li>
<li>可以快速定位到变更的数据，复杂度是 $O(log(n))$</li>
<li>零知识证明</li>
</ul>
<h2 id="Patricia-帕特里夏树"><a href="#Patricia-帕特里夏树" class="headerlink" title="Patricia 帕特里夏树"></a>Patricia 帕特里夏树</h2><p>要搞懂帕特里夏树，首先要先搞懂字典树。</p>
<h3 id="trie-字典树"><a href="#trie-字典树" class="headerlink" title="trie 字典树"></a><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie 字典树</a></h3><p>也称前缀树，单词查找树，键树。它用来保存关联数组，其中的键通常是字符串，键不直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串。并不是所有节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>trie 的思想是用空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。如下图就是一个 trie 树。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/trie_example.png" alt="trie"></p>
<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>字符串检索</li>
</ul>
<p>Trie 树可以用来查询字符串，判断一个字符串是否存在于某个字符串集合。</p>
<ul>
<li>词频统计</li>
</ul>
<p>实现词频统计时，节点结构有一个字段来记录该节点表示的单词的个数。</p>
<ul>
<li>字符串排序</li>
</ul>
<p>一次插入字符串到 Trie 树的过程就是一次排序的过程，先序输出 Trie 树的所有关键字就可以得到有序的字符串。</p>
<ul>
<li>前缀匹配</li>
</ul>
<p>在搜索引擎中，使用 Trie 前缀可以找到所有以某个字符串为前缀的字符串集合。</p>
<p>Trie 的插入和查询效率都是 $O(m)$，其中 m 是待插入/查询的字符串的长度。相比于哈希查找，Trie 树中不同的关键字不会产生冲突，而且查询共同前缀的 key 时很高效，如果是使用哈希查找，需要遍历整个哈希表，时间效率为 $O(n)$，n 为哈希表的数据总数；但 Trie 的缺点是空间消耗比较大，如果是直接查找，效率是 $O(m)$，并且有 m 次 IO 的开销，对于磁盘的压力也很大，而哈希表的查找效率是 $O(1)$。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Trie 在 redisearch 中有<a href="https://github.com/RedisLabsModules/RediSearch/blob/master/src/trie/trie.c" target="_blank" rel="external">实现</a>，用来实现搜索提示。</p>
<p>弄清原理后，可以尝试自己动手实现一下，在 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="external">leetcode</a> 上有相关题目。</p>
<h3 id="PatriciaTrie-帕特里夏树"><a href="#PatriciaTrie-帕特里夏树" class="headerlink" title="PatriciaTrie 帕特里夏树"></a>PatriciaTrie 帕特里夏树</h3><p>又叫做基数树，压缩前缀树或紧凑前缀树（compact prefix tree)，是一种更节省空间的前缀树。它与 Trie 的区别是，如果某个节点只有一个子树，那么这个子树跟父节点合并，这样可以缩短 Trie 里不必要的深度，节约存储空间，加快搜索节点的速度。</p>
<p>帕特里夏树的诞生是因为 Trie 有一定的缺陷，Trie 树会给每个字符串分配一个节点，如果有很多很长的，又没有公共节点的字符串就会使得 Trie 退化成一个数组，如果以太坊直接使用的是 Trie 话，有可能造成严重的存储空间的浪费，导致 Dos 攻击。</p>
<h2 id="Merkle-Patricia-Tree-默克尔-帕特里夏树"><a href="#Merkle-Patricia-Tree-默克尔-帕特里夏树" class="headerlink" title="Merkle Patricia Tree 默克尔-帕特里夏树"></a>Merkle Patricia Tree 默克尔-帕特里夏树</h2><p>Merkle Patricia Tree 默克尔-帕特里夏树是一种融合了默克尔树和前缀树两种结构优点的，经过改良的数据结构，在以太坊中用来组织交易信息、账户状态及其变更、收据相关的数据，为我们提供一个高效地、易更新的、且代表整个状态树的『指纹』。</p>
<p>每一个以太坊的区块头包含3颗 MPT 树，分别是：</p>
<ul>
<li>交易树 txTrie<br>用来存储交易数据。路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后才生成，在挖矿结束后不会再更新。</li>
<li>状态树 stateTrie<br>世界状态存储的地方，存储了所有账户的信息，包括余额，交易次数，EVM 指令（合约数据）等等，每次交易执行，stateTrie 都会变化，这部分内容我们将在 <a href="#TODO">go-ethereum 源码笔记（core 模块-状态管理）</a> 这一篇进行探讨。路径是 <code>sha3(ethereumAddress)</code>，值是 <code>rlp(ethereumAccount)</code>，其中 <code>ethereumAccount</code> 是一个列表 <code>[nonce,balance,storageRoot,codeHash]</code>，而 <code>storageRoot</code> 是另一个独立的帕特里树，每个账户都有一个独立的帕特里夏树，它用来存储所有的合约数据。参考 <a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a>。</li>
<li>收据树 receiptTrie<br>路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后生成，在挖矿结束后不会再更新。</li>
</ul>
<h2 id="Geth-的-MPT"><a href="#Geth-的-MPT" class="headerlink" title="Geth 的 MPT"></a>Geth 的 MPT</h2><p>MPT 在以太坊中作为键值存储的数据结构，使得插入，查找，删除的复杂度为 <code>O(log(n))</code>，并且能获得默克尔树的全部特性。</p>
<p>根据<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">以太坊官方博客</a>所描述的，MPT 使得轻节点可以实现以下的查询：</p>
<ul>
<li>这笔交易被包含在特定的区块中了吗？</li>
<li>这笔交易在过去的30天中，发出 X 类型事件的所有实例(例如，一个众筹合约完成了它的目标)</li>
<li>目前我的账户余额是多少</li>
<li>这个账户是否存在</li>
<li>假设在这个合约中运行这笔交易，它的输出是什么</li>
</ul>
<p>其实第1种情况可以由交易树处理，第2种情况可以由收据树处理，第3，4，5中情况可以由状态树来处理，计算前4个查询任务相当简单，服务器找到对象，获取默克尔分支，将分支回复给客户端。<br>对于第5种查询任务，利用状态树实现，这种方式称为默克尔状态转换证明。轻节点想要得到一个可信的结果，这个问题相当于，如果在根 S 的状态树上运行交易 T，其结果状态树将是根为 S’，log 为 L，输出为 O’。为推断这个证明，服务器创建一个假的区块，状态设为 S，请求这笔交易时假装是轻客户端，请求这笔交易时，需要客户端确定一个账户的余额，然后这个假的轻客户端会发出一个余额查询请求，服务器会回应这些请求，也会将这些请求中的数据合并以一个证明的方式发送给轻节点，轻节点这时会进行验证，将服务器提供的证明作为数据库使用，如果客户端验证的结果和服务器提供的是一样的，客户端就接受这个证明。看起来这种方式跟默克尔证明没有本质区别，都很好的利用了默克尔树的特性。</p>
<p>接下来我们换个角度，根据默克尔树和帕特里夏树两种结构的特性来说明 MPT 在以太坊中起到的作用。</p>
<h3 id="默克尔树的作用"><a href="#默克尔树的作用" class="headerlink" title="默克尔树的作用"></a>默克尔树的作用</h3><h4 id="轻节点扩展"><a href="#轻节点扩展" class="headerlink" title="轻节点扩展"></a>轻节点扩展</h4><p>MPT 实现了默克尔树，所以能提供一个默克尔证明这个功能，而通过默克尔证明我们可以实现区块链的轻节点扩展。</p>
<h5 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h5><p>在以太坊中，全节点是指维护整个区块链数据的节点，这包括整个区块链中的区块头，所有交易信息，账户状态，交易收据信息。随着时间推移，整个区块链数据量会非常大，这使得在 PC 或移动设备上运行全节点的可能性很小。中本聪的论文中描述了这种情况，并利用默克尔树来解决这个问题。我们可以运行一种节点，这个节点只维护区块链中所有的区块头信息，这种节点就叫做轻节点。</p>
<h5 id="默克尔证明"><a href="#默克尔证明" class="headerlink" title="默克尔证明"></a>默克尔证明</h5><p>默克尔证明是指一个轻节点向一个全节点发起一次证明请求，询问完整的默克尔树中是否存在一个指定的节点（这里指的是树的节点），全节点会向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证其存在性。这里利用了哈希函数的特性保证了这个验证是真实可靠的。</p>
<p>当我们需要验证某笔交易确实存在于区块链时，轻节点不需要维护区块的信息，当它需要验证时，可以向全节点请求一条默克尔树的路径，该路径实际上是从根节点到叶子节点的所有节点的哈希值列表，轻节点收到这条路径后，一层层地计算根哈希，再与本地的根哈希匹配，如果匹配成功了则说明这笔交易是存在的。哈希操作是不可逆的，所以不存在一个所谓的恶意节点可以伪造一条假的路径使得计算的根哈希与轻节点的根哈希是一致的。有人可能会有疑问，为什么不直接向网络中的某个全节点请求交易数据是否在区块链中，如果这样做的话，就不能保证安全性了，区块链的美妙之处在于，上面存的数据是全网的共识，除非受到 51% 攻击，否则区块链的数据是完全可信的，这与中心化的数据库不同。如果是直接向网络中某节点或某些节点请求数据，可能这些节点都是恶意节点，不能保证安全性。需要说明的是，轻节点尽管没有参与维护整个区块链数据，它也是去中心化的，因为它所拿到的区块头数据是经过了全网共识的，所以有足够的安全保障。</p>
<h3 id="帕特里树的作用"><a href="#帕特里树的作用" class="headerlink" title="帕特里树的作用"></a>帕特里树的作用</h3><ul>
<li>存储任意长度的 key-value 键值对数据</li>
<li>快速索引根据哈希存储的数据集</li>
<li>引入了几种节点类型来提高效率，包括空节点，叶子节点，扩展节点，分支节点</li>
</ul>
<h2 id="MPT-在-geth-中的实现细节"><a href="#MPT-在-geth-中的实现细节" class="headerlink" title="MPT 在 geth 中的实现细节"></a>MPT 在 geth 中的实现细节</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在以太坊中，MPT 有四种类型的树节点，目的是压缩整体树高、降低操作复杂度。树节点可以分为以下四类：</p>
<ul>
<li>空节点</li>
<li>分支节点</li>
<li>叶子节点</li>
<li>扩展节点</li>
</ul>
<p>这些是黄皮书中的定义，在 geth 的实现中，上述概念有不同的结构与之对应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">type node interface &#123;</div><div class="line">	fstring(string) string</div><div class="line">	cache() (hashNode, bool)</div><div class="line">	canUnload(cachegen, cachelimit uint16) bool</div><div class="line">&#125;</div><div class="line">type (</div><div class="line">	fullNode struct &#123;</div><div class="line">		Children [17]node</div><div class="line">		flags    nodeFlag</div><div class="line">	&#125;</div><div class="line">	shortNode struct &#123;</div><div class="line">		Key   []byte</div><div class="line">		Val   node</div><div class="line">		flags nodeFlag</div><div class="line">	&#125;</div><div class="line">	hashNode  []byte</div><div class="line">	valueNode []byte</div><div class="line">)</div><div class="line">...</div><div class="line">type nodeFlag struct &#123;</div><div class="line">	hash  hashNode</div><div class="line">	gen   uint16</div><div class="line">	dirty bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下图是一个世界状态的例子（摘自 <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" target="_blank" rel="external">Ethereum block architecture</a>）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/worldstatetrie.png" alt="worldstatetrie"></p>
<h4 id="fullNode"><a href="#fullNode" class="headerlink" title="fullNode"></a>fullNode</h4><p>fullNode 是一个可以携带多个子节点的节点。它有一个 node 数组类型的成员变量 Children，数组的前16个空位分别对应十六进制的0-9a-f，对于每个子节点，根据其 key 值的十六进制表示一一对应，Children 数组的第17位，fullNode 用来存储数据。</p>
<p>对应黄皮书中的分支节点。</p>
<h4 id="shortNode"><a href="#shortNode" class="headerlink" title="shortNode"></a>shortNode</h4><p>shortNode 是一个仅有一个子节点的节点。成员变量 Val 指向一个子节点，成员变量 Key 是一个由任意长度的字符串，这体现了压缩前缀树的特点，通过合并只有一个子节点的父节点和其子节点来缩短 Trie 的深度。</p>
<p>对应黄皮书里的扩展节点和叶子节点，通过 <code>shortNode.Val</code> 的类型来对应。</p>
<h4 id="valueNode"><a href="#valueNode" class="headerlink" title="valueNode"></a>valueNode</h4><p>valueNode 在 MPT 结构中存储真正的数据。充当 MPT 的叶子节点，不带子节点。</p>
<p>valueNode 是一个字节数组，但是它实现了 <code>fstring(string) string</code>, <code>cache() (hashNode, bool)</code>, <code>canUnload(cachegen, cachelimit uint16) bool</code> 这三个接口（实际上 fullNode，shortNode，hashNode 也实现了这三个接口），因此可以作为 fullNode，shortNode 中的 <code>node</code> 使用。valueNode 可以承接数据，携带的的是数据的 RLP 哈希值，长度为 32 byte，RLP 编码的值存在 LevelDB 里。</p>
<h4 id="hashNode"><a href="#hashNode" class="headerlink" title="hashNode"></a>hashNode</h4><p>hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存。遍历 MPT 时有时会遇到一个 hashNode，表明原来的 node 需要动态加载，hashNode 以 nodeFlag 结构体的成员 hash 的形式存在，如果 fullNode 或 shortNode 的成员变量发生变化，那么就需要更新它的 hashNode，在增删改的过程结束了都会调用 <code>trie.Hash()</code>，整个 MPT 自底向上变量，对所有清空的 hashNode 重新赋值，最终得到根节点的 hashNode，也就是整个 MPT 结构的哈希值。</p>
<p>结合之前讲过的基础知识，可以看到 fullNode 体现了 Trie 的特点，shortNode 实现了 PatriciaTrie 的特性（当然也实现了 Trie 的特性），hashNode 既实现了 MPT 节点的动态加载，也实现了默克尔树的功能。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Trie-的基本操作"><a href="#Trie-的基本操作" class="headerlink" title="Trie 的基本操作"></a>Trie 的基本操作</h4><p>我们首先将 Trie 看做一个黑盒，看看它具体暴露了什么接口，对全局有个总体的把握之后再深入其对应的细节。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func New(root common.Hash, db *Database) (*Trie, error) &#123;</div><div class="line">	if db == nil &#123;</div><div class="line">		panic(&quot;trie.New called without a database&quot;)</div><div class="line">	&#125;</div><div class="line">	trie := &amp;Trie&#123;</div><div class="line">		db:           db,</div><div class="line">		originalRoot: root,</div><div class="line">	&#125;</div><div class="line">	if (root != common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</div><div class="line">		rootnode, err := trie.resolveHash(root[:], nil)</div><div class="line">		if err != nil &#123;</div><div class="line">			return nil, err</div><div class="line">		&#125;</div><div class="line">		trie.root = rootnode</div><div class="line">	&#125;</div><div class="line">	return trie, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <code>New</code> 函数进行初始化，参数 root 是一个哈希值，如果哈希值不为空，说明数据中已存在 <code>Trie</code> 结构，调用 <code>trie.resolveHash</code> 方法来加载整个 Trie 树，如果 root 为空，新建 Trie 返回。</p>
<p>下面我们看看 Trie 结构的增删改查的过程，需要注意的是，MPT 是一棵树，这些数据结构的操作都是递归调用的过程，因此参数的上下文应该是当前这棵树下的含义。</p>
<h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) &#123;</div><div class="line">	if len(key) == 0 &#123;</div><div class="line">		if v, ok := n.(valueNode); ok &#123;</div><div class="line">			return !bytes.Equal(v, value.(valueNode)), value, nil</div><div class="line">		&#125;</div><div class="line">		return true, value, nil</div><div class="line">	&#125;</div><div class="line">	switch n := n.(type) &#123;</div><div class="line">	case *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		if matchlen == len(n.Key) &#123;</div><div class="line">			dirty, nn, err := t.insert(n.Val, append(prefix, key[:matchlen]...), key[matchlen:], value)</div><div class="line">			if !dirty || err != nil &#123;</div><div class="line">				return false, n, err</div><div class="line">			&#125;</div><div class="line">			return true, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, nil</div><div class="line">		&#125;</div><div class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</div><div class="line">		var err error</div><div class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(nil, append(prefix, n.Key[:matchlen+1]...), n.Key[matchlen+1:], n.Val)</div><div class="line">		if err != nil &#123;</div><div class="line">			return false, nil, err</div><div class="line">		&#125;</div><div class="line">		_, branch.Children[key[matchlen]], err = t.insert(nil, append(prefix, key[:matchlen+1]...), key[matchlen+1:], value)</div><div class="line">		if err != nil &#123;</div><div class="line">			return false, nil, err</div><div class="line">		&#125;</div><div class="line">		if matchlen == 0 &#123;</div><div class="line">			return true, branch, nil</div><div class="line">		&#125;</div><div class="line">		return true, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, nil</div><div class="line"></div><div class="line">	case *fullNode:</div><div class="line">		dirty, nn, err := t.insert(n.Children[key[0]], append(prefix, key[0]), key[1:], value)</div><div class="line">		if !dirty || err != nil &#123;</div><div class="line">			return false, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.copy()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[0]] = nn</div><div class="line">		return true, n, nil</div><div class="line"></div><div class="line">	case nil:</div><div class="line">		return true, &amp;shortNode&#123;key, value, t.newFlag()&#125;, nil</div><div class="line"></div><div class="line">	case hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		if err != nil &#123;</div><div class="line">			return false, nil, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</div><div class="line">		if !dirty || err != nil &#123;</div><div class="line">			return false, rn, err</div><div class="line">		&#125;</div><div class="line">		return true, nn, nil</div><div class="line"></div><div class="line">	default:</div><div class="line">		panic(fmt.Sprintf(&quot;%T: invalid node: %v&quot;, n, n))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数 node 是当前插入的根节点，prefix 是当前已经处理的 key(即 Patricia 树中节点共有的前缀)，key 是待处理的部分，完整的 key 应该是 prefix + key，value 是需要插入的值。返回的名为 dirty 的布尔值在 commit 阶段指明该树是否需要重新进行哈希计算。</p>
<p>如果当前根节点类型为 shortNode(当前节点为叶子节点或扩展节点)，首先通过 <code>prefixLen</code> 方法计算公共前缀。</p>
<p>如果公共前缀长度等于 key 的长度，那么说明插入的 key 和待插入的树的 key 一样，这时分两种情况。</p>
<ul>
<li>如果 value 也一样，那么返回 false，即 dirty 为 false。</li>
<li>如果 value 不一样，实际上这是一个 <code>update</code> 的操作，这时返回的 dirty 为 true。</li>
</ul>
<p>如果公共前缀不完全匹配，又分两种情况。</p>
<ul>
<li>如果匹配长度为 0 的话，返回的是一个 fullNode，这个 fullNode 有两个 shortNode 类型的子节点，一个子节点即当前的根节点，另一个为以要插入的值为 node 的 shortNode；</li>
<li>匹配长度大于零，这时公共节点提取出来形成一个独立的 shortNode(扩展节点)，这个 shortNode 的 Val 是 fullNode，fullNode 的两个子节点，一个即当前的根节点，另一个为以要插入的值为 node 的 shortNode</li>
</ul>
<p>这部分逻辑是当前根节点类型为 shortNode 的情况，可以看到这里实际上是帕特里夏树的体现，对于 Trie 进行空间使用率的优化，如果一个父节点只有一个子节点，那么这个父节点将与其子节点合并，这样可以缩短搜索深度。</p>
<p>对于当前根节点类型为 fullNode 的情况，直接往对应的孩子节点调用 insert 方法，insert 方法会返回插入后的根节点，然后将该孩子指向这个返回的根节点即可。</p>
<p>对于当前根节点类型为 nil 的情况，即要插入的 Trie 是空的，直接返回一个 shortNode，Val 字段即为要插入的 node。</p>
<p>对于当前节点为 hashNode 的情况，表明要插入的当前根节点还在数据库中，没有加载到内存中，首先调用 <code>t.resolveHash(n, prefix)</code> 方法进行加载，在调用 insert 方法进行插入。</p>
<p>以上就是插入一个新节点的全部逻辑，基本上概括了帕特里夏树的特点，删，改，查的操作实际上大同小异，因此接下来的讲解会简略一点。</p>
<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) Delete(key []byte) &#123;</div><div class="line">	if err := t.TryDelete(key); err != nil &#123;</div><div class="line">		log.Error(fmt.Sprintf(&quot;Unhandled trie error: %v&quot;, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) TryDelete(key []byte) error &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	_, n, err := t.delete(t.root, nil, k)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	t.root = n</div><div class="line">	return nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) delete(n node, prefix, key []byte) (bool, node, error) &#123;</div><div class="line">	switch n := n.(type) &#123;</div><div class="line">	case *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		if matchlen &lt; len(n.Key) &#123;</div><div class="line">			return false, n, nil</div><div class="line">		&#125;</div><div class="line">		if matchlen == len(key) &#123;</div><div class="line">			return true, nil, nil</div><div class="line">		&#125;</div><div class="line">		dirty, child, err := t.delete(n.Val, append(prefix, key[:len(n.Key)]...), key[len(n.Key):])</div><div class="line">		if !dirty || err != nil &#123;</div><div class="line">			return false, n, err</div><div class="line">		&#125;</div><div class="line">		switch child := child.(type) &#123;</div><div class="line">		case *shortNode:</div><div class="line">			return true, &amp;shortNode&#123;concat(n.Key, child.Key...), child.Val, t.newFlag()&#125;, nil</div><div class="line">		default:</div><div class="line">			return true, &amp;shortNode&#123;n.Key, child, t.newFlag()&#125;, nil</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	case *fullNode:</div><div class="line">		dirty, nn, err := t.delete(n.Children[key[0]], append(prefix, key[0]), key[1:])</div><div class="line">		if !dirty || err != nil &#123;</div><div class="line">			return false, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.copy()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[0]] = nn</div><div class="line">		</div><div class="line">		pos := -1</div><div class="line">		for i, cld := range n.Children &#123;</div><div class="line">			if cld != nil &#123;</div><div class="line">				if pos == -1 &#123;</div><div class="line">					pos = i</div><div class="line">				&#125; else &#123;</div><div class="line">					pos = -2</div><div class="line">					break</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if pos &gt;= 0 &#123;</div><div class="line">			if pos != 16 &#123;</div><div class="line">				cnode, err := t.resolve(n.Children[pos], prefix)</div><div class="line">				if err != nil &#123;</div><div class="line">					return false, nil, err</div><div class="line">				&#125;</div><div class="line">				if cnode, ok := cnode.(*shortNode); ok &#123;</div><div class="line">					k := append([]byte&#123;byte(pos)&#125;, cnode.Key...)</div><div class="line">					return true, &amp;shortNode&#123;k, cnode.Val, t.newFlag()&#125;, nil</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			return true, &amp;shortNode&#123;[]byte&#123;byte(pos)&#125;, n.Children[pos], t.newFlag()&#125;, nil</div><div class="line">		&#125;</div><div class="line">		return true, n, nil</div><div class="line"></div><div class="line">	case valueNode:</div><div class="line">		return true, nil, nil</div><div class="line"></div><div class="line">	case nil:</div><div class="line">		return false, nil, nil</div><div class="line"></div><div class="line">	case hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		if err != nil &#123;</div><div class="line">			return false, nil, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.delete(rn, prefix, key)</div><div class="line">		if !dirty || err != nil &#123;</div><div class="line">			return false, rn, err</div><div class="line">		&#125;</div><div class="line">		return true, nn, nil</div><div class="line"></div><div class="line">	default:</div><div class="line">		panic(fmt.Sprintf(&quot;%T: invalid node: %v (%v)&quot;, n, n, key))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除的真正逻辑在 <code>delete(n node, prefix, key []byte) (bool, node, error)</code> 这个方法里，其中参数 key 是通过 <code>keybytesToHex</code> 获得的 hex 编码。删除的过程也是递归调用，其中 node，prefix，key 参数意义与插入时的参数一致。</p>
<p>对于 shortNode 情况，首先进行 key 的匹配，如果匹配的长度小于根节点的 key 的长度，意味着要删除的节点不在这颗树上，返回 false 以及根节点，不做任何操作；如果匹配的长度正好等于 key 的长度，意味着完全匹配，返回 true 以及 nil(表明该节点已经被删除)。</p>
<p>如果匹配的长度等于根节点的 key 的长度，并且小于参数 key 的长度，那么意味着要删除的节点是该树的子节点，需要删除的是根树的一颗子树，那么继续递归调用。</p>
<p>对于删除 fullNode 的情况，如果 fullNode 删除后有两个及以上的子节点，删除后返回根节点即可，如果删除后只有一个子节点，那么需要将该根节点变成 shortNode 返回。</p>
<p>对于删除 hashNode 的情况，先加载节点到内存中再递归调用删除操作。</p>
<h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) Update(key, value []byte) &#123;</div><div class="line">	if err := t.TryUpdate(key, value); err != nil &#123;</div><div class="line">		log.Error(fmt.Sprintf(&quot;Unhandled trie error: %v&quot;, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) TryUpdate(key, value []byte) error &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	if len(value) != 0 &#123;</div><div class="line">		_, n, err := t.insert(t.root, nil, k, valueNode(value))</div><div class="line">		if err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125; else &#123;</div><div class="line">		_, n, err := t.delete(t.root, nil, k)</div><div class="line">		if err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新的操作，如果 value 长度不为零，即 value 不为空的话，直接调用插入操作，如果为空，则删除根节点。</p>
<h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) Get(key []byte) []byte &#123;</div><div class="line">	res, err := t.TryGet(key)</div><div class="line">	if err != nil &#123;</div><div class="line">		log.Error(fmt.Sprintf(&quot;Unhandled trie error: %v&quot;, err))</div><div class="line">	&#125;</div><div class="line">	return res</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) TryGet(key []byte) ([]byte, error) &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	value, newroot, didResolve, err := t.tryGet(t.root, key, 0)</div><div class="line">	if err == nil &amp;&amp; didResolve &#123;</div><div class="line">		t.root = newroot</div><div class="line">	&#125;</div><div class="line">	return value, err</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) tryGet(origNode node, key []byte, pos int) (value []byte, newnode node, didResolve bool, err error) &#123;</div><div class="line">	switch n := (origNode).(type) &#123;</div><div class="line">	case nil:</div><div class="line">		return nil, nil, false, nil</div><div class="line">	case valueNode:</div><div class="line">		return n, n, false, nil</div><div class="line">	case *shortNode:</div><div class="line">		if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) &#123;</div><div class="line">			return nil, n, false, nil</div><div class="line">		&#125;</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+len(n.Key))</div><div class="line">		if err == nil &amp;&amp; didResolve &#123;</div><div class="line">			n = n.copy()</div><div class="line">			n.Val = newnode</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">		&#125;</div><div class="line">		return value, n, didResolve, err</div><div class="line">	case *fullNode:</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+1)</div><div class="line">		if err == nil &amp;&amp; didResolve &#123;</div><div class="line">			n = n.copy()</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">			n.Children[key[pos]] = newnode</div><div class="line">		&#125;</div><div class="line">		return value, n, didResolve, err</div><div class="line">	case hashNode:</div><div class="line">		child, err := t.resolveHash(n, key[:pos])</div><div class="line">		if err != nil &#123;</div><div class="line">			return nil, n, true, err</div><div class="line">		&#125;</div><div class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</div><div class="line">		return value, newnode, true, err</div><div class="line">	default:</div><div class="line">		panic(fmt.Sprintf(&quot;%T: invalid node: %v&quot;, origNode, origNode))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询的操作，实际上最终查的还是 valueNode，根据 key，根据 pos 指示的 key 位置跟根节点的 Key 属性值进行匹配，递归调用即可，与上述的操作很类似。</p>
<h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><p>提交阶段会将内存中的所有 trie 写入到数据库中。在这期间会根据 dirty 值做一件非常重要的事情，如果 dirty 置为 true 了，表明其代表的父节点有改动需要提交，hashNode 的成员 hash 设为空，需重新进行计算得到 hashNode 的哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) Commit(onleaf LeafCallback) (root common.Hash, err error) &#123;</div><div class="line">	if t.db == nil &#123;</div><div class="line">		panic(&quot;commit called on trie with nil database&quot;)</div><div class="line">	&#125;</div><div class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</div><div class="line">	if err != nil &#123;</div><div class="line">		return common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	t.root = cached</div><div class="line">	t.cachegen++</div><div class="line">	return common.BytesToHash(hash.(hashNode)), nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *Trie) hashRoot(db *Database, onleaf LeafCallback) (node, node, error) &#123;</div><div class="line">	if t.root == nil &#123;</div><div class="line">		return hashNode(emptyRoot.Bytes()), nil, nil</div><div class="line">	&#125;</div><div class="line">	h := newHasher(t.cachegen, t.cachelimit, onleaf)</div><div class="line">	defer returnHasherToPool(h)</div><div class="line">	return h.hash(t.root, db, true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (h *hasher) hash(n node, db *Database, force bool) (node, node, error) &#123;</div><div class="line">	if hash, dirty := n.cache(); hash != nil &#123;</div><div class="line">		if db == nil &#123;</div><div class="line">			return hash, n, nil</div><div class="line">		&#125;</div><div class="line">		if n.canUnload(h.cachegen, h.cachelimit) &#123;</div><div class="line">			cacheUnloadCounter.Inc(1)</div><div class="line">			return hash, hash, nil</div><div class="line">		&#125;</div><div class="line">		if !dirty &#123;</div><div class="line">			return hash, n, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	collapsed, cached, err := h.hashChildren(n, db)</div><div class="line">	if err != nil &#123;</div><div class="line">		return hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	hashed, err := h.store(collapsed, db, force)</div><div class="line">	if err != nil &#123;</div><div class="line">		return hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	cachedHash, _ := hashed.(hashNode)</div><div class="line">	switch cn := cached.(type) &#123;</div><div class="line">	case *shortNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		if db != nil &#123;</div><div class="line">			cn.flags.dirty = false</div><div class="line">		&#125;</div><div class="line">	case *fullNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		if db != nil &#123;</div><div class="line">			cn.flags.dirty = false</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return hashed, cached, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (h *hasher) hashChildren(original node, db *Database) (node, node, error) &#123;</div><div class="line">	var err error</div><div class="line"></div><div class="line">	switch n := original.(type) &#123;</div><div class="line">	case *shortNode:</div><div class="line">		collapsed, cached := n.copy(), n.copy()</div><div class="line">		collapsed.Key = hexToCompact(n.Key)</div><div class="line">		cached.Key = common.CopyBytes(n.Key)</div><div class="line"></div><div class="line">		if _, ok := n.Val.(valueNode); !ok &#123;</div><div class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, false)</div><div class="line">			if err != nil &#123;</div><div class="line">				return original, original, err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return collapsed, cached, nil</div><div class="line"></div><div class="line">	case *fullNode:</div><div class="line">		collapsed, cached := n.copy(), n.copy()</div><div class="line"></div><div class="line">		for i := 0; i &lt; 16; i++ &#123;</div><div class="line">			if n.Children[i] != nil &#123;</div><div class="line">				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, false)</div><div class="line">				if err != nil &#123;</div><div class="line">					return original, original, err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cached.Children[16] = n.Children[16]</div><div class="line">		return collapsed, cached, nil</div><div class="line"></div><div class="line">	default:</div><div class="line">		return n, original, nil</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提交 MPT 时，会调用 <code>Trie.hashRoot</code> 从根节点开始折叠，而 <code>hashRoot</code> 会调用 <code>trie/hasher.go</code> 里的 <code>hash</code> 方法，<code>hash</code> 方法和 <code>hashChildren</code> 方法会递归调用遍历整个 MPT，大致逻辑是：如果 node 没有子节点，直接返回；如果 node 是 shortNode，将 <code>valueNode</code> 作为参数调用 <code>hash</code> 方法；如果 node 是 fullNode，对其每个子节点调用 <code>hash</code> 方法。最终将这个 node 作为参数调用 <code>store</code> 方法，获得 RLP 编码，并进行哈希计算，获取哈希值，也就是 MPT 根节点的哈希值。</p>
<h4 id="Trie-的序列化和反序列化"><a href="#Trie-的序列化和反序列化" class="headerlink" title="Trie 的序列化和反序列化"></a>Trie 的序列化和反序列化</h4><p>上一篇文章 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</a> 介绍了 geth 里是怎么进行序列化和反序列化的，而通过上文我们知道了 MPT 有一个折叠和动态加载节点的过程，这个过程需要通过 rlp 模块进行序列化和反序列化，与 LevelDB 进行交互，我们来具体看看这个过程是怎么实现的。</p>
<h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">func (h *hasher) store(n node, db *Database, force bool) (node, error) &#123;</div><div class="line">	if _, isHash := n.(hashNode); n == nil || isHash &#123;</div><div class="line">		return n, nil</div><div class="line">	&#125;</div><div class="line">	h.tmp.Reset()</div><div class="line">	if err := rlp.Encode(&amp;h.tmp, n); err != nil &#123;</div><div class="line">		panic(&quot;encode error: &quot; + err.Error())</div><div class="line">	&#125;</div><div class="line">	if len(h.tmp) &lt; 32 &amp;&amp; !force &#123;</div><div class="line">		return n, nil</div><div class="line">	&#125;</div><div class="line">	hash, _ := n.cache()</div><div class="line">	if hash == nil &#123;</div><div class="line">		hash = h.makeHashNode(h.tmp)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if db != nil &#123;</div><div class="line">		hash := common.BytesToHash(hash)</div><div class="line"></div><div class="line">		db.lock.Lock()</div><div class="line">		db.insert(hash, h.tmp, n)</div><div class="line">		db.lock.Unlock()</div><div class="line"></div><div class="line">		if h.onleaf != nil &#123;</div><div class="line">			switch n := n.(type) &#123;</div><div class="line">			case *shortNode:</div><div class="line">				if child, ok := n.Val.(valueNode); ok &#123;</div><div class="line">					h.onleaf(child, hash)</div><div class="line">				&#125;</div><div class="line">			case *fullNode:</div><div class="line">				for i := 0; i &lt; 16; i++ &#123;</div><div class="line">					if child, ok := n.Children[i].(valueNode); ok &#123;</div><div class="line">						h.onleaf(child, hash)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return hash, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面有提到 store 方法，它通过调用 <code>rlp.Encode</code> 对节点进行 RLP 编码，然后计算哈希值，通过 <code>db.insert</code> 将其插入数据库，需注意的是分别对 shortNode，fullNode 调用的 <code>onleaf</code>方法，它用来存储外部的 MPT，如果没有猜错的话，它应该是用来存储账户相关内容的，待验证。</p>
<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) resolveHash(n hashNode, prefix []byte) (node, error) &#123;</div><div class="line">	cacheMissCounter.Inc(1)</div><div class="line"></div><div class="line">	hash := common.BytesToHash(n)</div><div class="line">	if node := t.db.node(hash, t.cachegen); node != nil &#123;</div><div class="line">		return node, nil</div><div class="line">	&#125;</div><div class="line">	return nil, &amp;MissingNodeError&#123;NodeHash: hash, Path: prefix&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (db *Database) node(hash common.Hash, cachegen uint16) node &#123;</div><div class="line">	db.lock.RLock()</div><div class="line">	node := db.nodes[hash]</div><div class="line">	db.lock.RUnlock()</div><div class="line"></div><div class="line">	if node != nil &#123;</div><div class="line">		return node.obj(hash, cachegen)</div><div class="line">	&#125;</div><div class="line">	enc, err := db.diskdb.Get(hash[:])</div><div class="line">	if err != nil || enc == nil &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	return mustDecodeNode(hash[:], enc, cachegen)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func mustDecodeNode(hash, buf []byte, cachegen uint16) node &#123;</div><div class="line">	n, err := decodeNode(hash, buf, cachegen)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(fmt.Sprintf(&quot;node %x: %v&quot;, hash, err))</div><div class="line">	&#125;</div><div class="line">	return n</div><div class="line">&#125;</div><div class="line"></div><div class="line">func decodeNode(hash, buf []byte, cachegen uint16) (node, error) &#123;</div><div class="line">	if len(buf) == 0 &#123;</div><div class="line">		return nil, io.ErrUnexpectedEOF</div><div class="line">	&#125;</div><div class="line">	elems, _, err := rlp.SplitList(buf)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, fmt.Errorf(&quot;decode error: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	switch c, _ := rlp.CountValues(elems); c &#123;</div><div class="line">	case 2:</div><div class="line">		n, err := decodeShort(hash, elems, cachegen)</div><div class="line">		return n, wrapError(err, &quot;short&quot;)</div><div class="line">	case 17:</div><div class="line">		n, err := decodeFull(hash, elems, cachegen)</div><div class="line">		return n, wrapError(err, &quot;full&quot;)</div><div class="line">	default:</div><div class="line">		return nil, fmt.Errorf(&quot;invalid number of list elements: %v&quot;, c)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到，在遍历的过程中，如果遇到了 hashNode，需要动态加载这个节点，这个方法就是 resolve。resolve 方法会调用 <code>trie/database.go</code> 的 <code>node</code> 方法，先从内存里拿，否则从硬盘里拿，接着调用 <code>trie/node.go</code> 的 <code>mustDecodeNode</code>，<code>mustDecodeNode</code> 是 <code>decodeNode</code> 的简单封装，在这里可以看到调用 rlp 模块进行反序列化的过程，根据 RLP 的 list 的长度来判断这个编码是什么节点，如果是2那么就是 shortNode，如果是17就是 fullNode，根据节点的不同调用相应的 decode 方法。</p>
<h4 id="默克尔证明-1"><a href="#默克尔证明-1" class="headerlink" title="默克尔证明"></a>默克尔证明</h4><p>前面已经介绍了默克尔证明的原理，而且我们现在也有了 MPT 的基础，这里我们直接看默克尔证明的代码。默克尔证明的相关逻辑主要在 <code>trie/proof.go</code> 里。</p>
<h5 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">func (t *Trie) Prove(key []byte, fromLevel uint, proofDb ethdb.Putter) error &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	nodes := []node&#123;&#125;</div><div class="line">	tn := t.root</div><div class="line">	for len(key) &gt; 0 &amp;&amp; tn != nil &#123;</div><div class="line">		switch n := tn.(type) &#123;</div><div class="line">		case *shortNode:</div><div class="line">			if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) &#123;</div><div class="line">				tn = nil</div><div class="line">			&#125; else &#123;</div><div class="line">				tn = n.Val</div><div class="line">				key = key[len(n.Key):]</div><div class="line">			&#125;</div><div class="line">			nodes = append(nodes, n)</div><div class="line">		case *fullNode:</div><div class="line">			tn = n.Children[key[0]]</div><div class="line">			key = key[1:]</div><div class="line">			nodes = append(nodes, n)</div><div class="line">		case hashNode:</div><div class="line">			var err error</div><div class="line">			tn, err = t.resolveHash(n, nil)</div><div class="line">			if err != nil &#123;</div><div class="line">				log.Error(fmt.Sprintf(&quot;Unhandled trie error: %v&quot;, err))</div><div class="line">				return err</div><div class="line">			&#125;</div><div class="line">		default:</div><div class="line">			panic(fmt.Sprintf(&quot;%T: invalid node: %v&quot;, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	hasher := newHasher(0, 0, nil)</div><div class="line">	for i, n := range nodes &#123;</div><div class="line">		n, _, _ = hasher.hashChildren(n, nil)</div><div class="line">		hn, _ := hasher.store(n, nil, false)</div><div class="line">		if hash, ok := hn.(hashNode); ok || i == 0 &#123;</div><div class="line">			if fromLevel &gt; 0 &#123;</div><div class="line">				fromLevel--</div><div class="line">			&#125; else &#123;</div><div class="line">				enc, _ := rlp.EncodeToBytes(n)</div><div class="line">				if !ok &#123;</div><div class="line">					hash = crypto.Keccak256(enc)</div><div class="line">				&#125;</div><div class="line">				proofDb.Put(hash, enc)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Prove</code> 方法用来获取指定 key 的默克尔证明。这个方法会遍历整个 MPT，获取从根节点到叶子节点这条路径上的所有节点的 hash 值列表。对于 key 不匹配的情况，则会返回一个最长匹配的列表。</p>
<h5 id="VerifyProof"><a href="#VerifyProof" class="headerlink" title="VerifyProof"></a>VerifyProof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">func VerifyProof(rootHash common.Hash, key []byte, proofDb DatabaseReader) (value []byte, nodes int, err error) &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	wantHash := rootHash</div><div class="line">	for i := 0; ; i++ &#123;</div><div class="line">		buf, _ := proofDb.Get(wantHash[:])</div><div class="line">		if buf == nil &#123;</div><div class="line">			return nil, i, fmt.Errorf(&quot;proof node %d (hash %064x) missing&quot;, i, wantHash)</div><div class="line">		&#125;</div><div class="line">		n, err := decodeNode(wantHash[:], buf, 0)</div><div class="line">		if err != nil &#123;</div><div class="line">			return nil, i, fmt.Errorf(&quot;bad proof node %d: %v&quot;, i, err)</div><div class="line">		&#125;</div><div class="line">		keyrest, cld := get(n, key)</div><div class="line">		switch cld := cld.(type) &#123;</div><div class="line">		case nil:</div><div class="line">			return nil, i, nil</div><div class="line">		case hashNode:</div><div class="line">			key = keyrest</div><div class="line">			copy(wantHash[:], cld)</div><div class="line">		case valueNode:</div><div class="line">			return cld, i + 1, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func get(tn node, key []byte) ([]byte, node) &#123;</div><div class="line">	for &#123;</div><div class="line">		switch n := tn.(type) &#123;</div><div class="line">		case *shortNode:</div><div class="line">			if len(key) &lt; len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) &#123;</div><div class="line">				return nil, nil</div><div class="line">			&#125;</div><div class="line">			tn = n.Val</div><div class="line">			key = key[len(n.Key):]</div><div class="line">		case *fullNode:</div><div class="line">			tn = n.Children[key[0]]</div><div class="line">			key = key[1:]</div><div class="line">		case hashNode:</div><div class="line">			return key, n</div><div class="line">		case nil:</div><div class="line">			return key, nil</div><div class="line">		case valueNode:</div><div class="line">			return nil, n</div><div class="line">		default:</div><div class="line">			panic(fmt.Sprintf(&quot;%T: invalid node: %v&quot;, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VerifyProof</code> 方法以 roothash，key，proof 证明为参数，验证 key 是否存在于 MPT 的某条路径里，如果 key 确实存在，返回这个节点的索引 i，err 字段是 nil，否则返回 error。</p>
<h4 id="MPT-安全性"><a href="#MPT-安全性" class="headerlink" title="MPT 安全性"></a>MPT 安全性</h4><h5 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h5><p>MPT 存储的 key-value 值没有长度限制，虽然说使用的是 Patricia Trie，仍然会有整棵树深度越来越深的问题，这可能会导致查询节点需要多次 IO，影响效率；导致 Dos 攻击。<br>以太坊中里，与 MPT 交互时，key 还会进行一次 sha3 的哈希计算，这样一来，key 的长度是固定的32字节，可以避免树里出现很深的路径，同时也实现了 key 的加密存储。</p>
<p>这部分代码在 <code>trie/secure_trie.go</code>，<code>trie/hasher.go</code>，<code>crypto/sha3</code> 里面，没有什么特别的，基本上就是对增删改查的操作做了一层加 keccak256 算法的封装。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>前文介绍过分支节点，以太坊想要在效率和存储空间上达到一个平衡，所以 fullNode 只有17个孩子节点，这个值是与16进制有关的，MPT 的 key 值实际上有三种编码方法，Raw 编码，Hex 编码，HP 编码，Raw 编码即原始的字节数组，这种方式的问题是它的一个字节的范围很大，fullNode 的子树这么多会影响检索效率，当树节点需要存储到数据库时，会根据16进制来进行编码，Hex 编码和 HP 编码没本质区别，可以理解为 Hex 编码是存在于内存的中间形式，在以太坊的黄皮书了介绍的是 Hex Prefix Encoding，即 HP 编码。我们一一来看。</p>
<h5 id="Raw-编码（keybytes-encoding）"><a href="#Raw-编码（keybytes-encoding）" class="headerlink" title="Raw 编码（keybytes encoding）"></a>Raw 编码（keybytes encoding）</h5><p>原生的 key 字节数组，不做修改，这种方式是 MPT 对外提供 API 的默认方式，如果数据需要插入到树里，Raw 编码需要转换为 Hex 编码。</p>
<h5 id="Hex-编码（hex-encoding）"><a href="#Hex-编码（hex-encoding）" class="headerlink" title="Hex 编码（hex encoding）"></a>Hex 编码（hex encoding）</h5><p>Hex 编码用于对内存里的树节点 key 进行编码，当树节点需要持久化到数据库时，Hex 编码被转换为 HP 编码。</p>
<p>具体来说，这个编码的每个字节包含 key 的半个字节，尾部加一个 byte 的『终结符』16，表示这是 hex 格式。节点被加载到内存时 key 使用的是这种编码，因为方便访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func keybytesToHex(str []byte) []byte &#123;</div><div class="line">	l := len(str)*2 + 1</div><div class="line">	var nibbles = make([]byte, l)</div><div class="line">	for i, b := range str &#123;</div><div class="line">		nibbles[i*2] = b / 16</div><div class="line">		nibbles[i*2+1] = b % 16</div><div class="line">	&#125;</div><div class="line">	nibbles[l-1] = 16</div><div class="line">	return nibbles</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是 Raw 编码转换为 Hex 编码的代码。</p>
<h5 id="HP-编码（compact-encoding）"><a href="#HP-编码（compact-encoding）" class="headerlink" title="HP 编码（compact encoding）"></a>HP 编码（compact encoding）</h5><p>全称是 Hex Prefix 编码，hex 编码解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但这种方式有数据冗余的问题，对于 shortNode，目前 hex 格式下的 key，长度会是原来 keybytes 格式下的两倍，这一点对于节点的哈希计算影响很大，compact 编码用于对 hex 格式进行优化。compact encoding 的主要思路是将 Hex 格式字符串先恢复到 keybytes 格式，同时加入当前编码的标记位，表示奇偶不同长度的 hex 格式。</p>
<p>具体来说，compact 编码首先会将 hex 尾部标记的 byte 去掉，然后将原来 hex 编码的包含的 key 的半个字节（称为 nibble）一一合并为1 byte，最后如果 hex 格式编码有效长度为奇数，在头部增加 0011xxxx，其中 xxxx 为第一个 nibble，否则在头部增加 00100000。节点在写入数据库时使用的是 compact 编码，因为可以节约磁盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func hexToCompact(hex []byte) []byte &#123;</div><div class="line">	terminator := byte(0)</div><div class="line">	if hasTerm(hex) &#123;</div><div class="line">		terminator = 1</div><div class="line">		hex = hex[:len(hex)-1]</div><div class="line">	&#125;</div><div class="line">	buf := make([]byte, len(hex)/2+1)</div><div class="line">	buf[0] = terminator &lt;&lt; 5</div><div class="line">	if len(hex)&amp;1 == 1 &#123;</div><div class="line">		buf[0] |= 1 &lt;&lt; 4 </div><div class="line">		buf[0] |= hex[0]</div><div class="line">		hex = hex[1:]</div><div class="line">	&#125;</div><div class="line">	decodeNibbles(hex, buf[1:])</div><div class="line">	return buf</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果该节点有 value，则 teerminator 为1，其中 <code>buf[0] = terminator &lt;&lt; 5</code> 表示，如果是叶子节点，<code>buf[0]</code> 为 00100000，否则为 00000000，接下来的 <code>if len(hex)&amp;1 == 1</code> if 判断表示 hex 长度为奇数的情况，这时将 buf[0] 赋值为 0011xxxx，其中 xxxx 为 hex[0] 的值，即第一个 nibble 的值，最后调用 <code>decodeNibbles</code>，将两个两个的 nibble 字节合并为一个字节。以上就是 HP 编码的整个过程。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie</a></li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">leetcode, 208. Implement Trie(Prefix Tree)</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a></li>
<li><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">merkling-in-ethereum</a></li>
<li><a href="https://github.com/ethereumjs/merkle-patricia-tree" target="_blank" rel="external">ethereumjs/merkle-patricia-tree</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之前，读者应该对默克尔树，帕特里夏树这两个数据结构有一定了解，这些是阅读源代码的基础知识，这里只做概述。下面我们先分别介绍这两种数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（rlp 模块-序列化与反序列化）/</id>
    <published>2018-03-10T14:35:01.000Z</published>
    <updated>2018-09-18T18:23:04.643Z</updated>
    
    <content type="html"><![CDATA[<p>RLP 的定义，作用，用法在 <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="external">wiki</a> 文档中有文字说明，这部分我们只做简单描述。</p>
<p>在<a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">黄皮书</a>里有 RLP 的形式化说明，这里我会总结一下，然后侧重于分析源码，讲解实现原理。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>RLP（Recursive Length Prefix）递归长度前缀是一种编码算法，用于编码任意嵌套结构的二进制数据，它是以太坊中数据序列化和反序列化的主要方法，区块、交易等数据结构在持久化时会先经过 RLP 编码再存储到数据库，p2p 网络中节点之间的数据传输也需要 RLP 的编码。</p>
<p>RLP 有两个特点：一个是递归，被编码的数据是递归的结构，编码算法也是递归进行处理的；二是长度前缀，RLP 编码都带有一个前缀，这个前缀与被编码数据长度相关。</p>
<p>根据定义，RLP 编码只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如<code>[&quot;cat&quot;,[&quot;puppy&quot;,&quot;cow&quot;],&quot;horse&quot;,[[]],&quot;pig&quot;,[&quot;&quot;],&quot;sheep&quot;]</code>就是一个复杂的列表。其他类型的数据需要转成以上的两类。</p>
<h2 id="规则和例子"><a href="#规则和例子" class="headerlink" title="规则和例子"></a>规则和例子</h2><p>在 <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP#definition" target="_blank" rel="external">wiki</a> 中有详细定义，这里不赘述。</p>
<h2 id="黄皮书里的形式化方法"><a href="#黄皮书里的形式化方法" class="headerlink" title="黄皮书里的形式化方法"></a>黄皮书里的形式化方法</h2><p>在<a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">黄皮书</a>中有 RLP 的形式化定义，形式化的描述比大白话更直观，这里我们做一下简单总结:</p>
<p>首先定义集合 T：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structures%20T.png" alt="rlp-structure-t"></p>
<p>$\mathbb{T}$ 表示所有的字节数组和树形结构的组合，$\mathbb{L}$ 表示不止单一节点的树形结构，如结构体，树节点的分支节点，非叶子节点。 $\mathbb{O}$ 表示所有 byte 的集合，$\mathbb{B}$ 表示所有可能的字节数组，</p>
<p>$\mathbb{T}$ 和 $\mathbb{L}$ 是 RLP 需要处理的两种结构。</p>
<p>RLP 可以用两个子函数描述：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20sub-functions.png" alt="rlp-structure-rlp"></p>
<p>其中：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20Rbx.png" alt="rlp-structure-rbx"></p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20Rlx.png" alt="rlp-structure-rlx"></p>
<p>对于 $\mathbb{B}$ 类型的字节数组，处理规则是：</p>
<ul>
<li>如果字节数组只有一个字节，并且字节大小小于 128，编码结果就是它本身。</li>
<li>如果字节数组（字符串）长度小于56，编码结果是128加上字节数组长度的和作为前缀，再加上原始数据。由于被编码的字符串长度是<code>55=0x37</code>，因此单字节前缀的最大值是 <code>0x80+0x37=0xb7</code>，即编码的第一个字节的取值范围是 <code>[0x80, 0xb7]</code>。</li>
<li>如果字节数组长度大于等于56，编码结果是: 以183加上原始数据的长度的大端表示的长度作为前缀，加上原始数据长度的大端表示，再加上原始数据。</li>
</ul>
<p>其中 $\mathtt{\tiny BE}$ 实际上表示去掉前导0的大端模式。</p>
<p>对于 $\mathtt{T} $类型（树形结构），处理规则是：</p>
<ul>
<li>首先对树形结构里面的每一个元素使用 RLP 处理，然后将结果连接起来，记为 s。</li>
<li>如果连接后的字节长度小于56，编码结果是：以192加上连接后的长度作为前缀，加上连接后的结果，即 <code>0xc0</code> 加上列表的总长度，编码的第一个字节的取值范围是 <code>[0xc0, 0xf7]</code>。</li>
<li>如果连接后的字节长度大于56字节，编码结果是：以247加上连接后的长度的大端模式的长度的结果作为前缀，加上连接后的长度的大端模式，再加上列表中各元素项 RLP 编码的结果。即 <code>0xf7</code> 加上列表总长度的二进制形式的字节长度。编码的第一个字节的取值范围是 <code>[0xf8, 0xff]</code>。</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>RLP 包的源码在 rlp 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">├── decode.go                         # 解码器，反序列化的过程，将 RLP 数据解码为 Golang 数据结构</div><div class="line">├── decode_tail_test.go</div><div class="line">├── decode_test.go</div><div class="line">├── doc.go                            # 包的文档</div><div class="line">├── encode.go                         # 编码器，序列化的过程，将 Golang 数据编码为 RLP 结构数据</div><div class="line">├── encode_test.go</div><div class="line">├── encoder_example_test.go</div><div class="line">├── raw.go                            # 没有解码的原生数据</div><div class="line">├── raw_test.go</div><div class="line">└── typecache.go                      # 类型缓存，记录了类型 -&gt;（编码器|解码器）的内容</div></pre></td></tr></table></figure>
<p>测试代码也是很好的参考文档，有时候甚至比注释还好懂，可以好好看看。这里我们开始讲解序列化和反序列化的代码实现。</p>
<h3 id="typeinfo"><a href="#typeinfo" class="headerlink" title="typeinfo"></a>typeinfo</h3><p>上面提到，对于不同的类型，有不同的编码方式，在 C++ 这样的语言中，可以通过相同函数名，不同类型，也就是重载来实现不同类型的编码器的分派，也可以通过泛型实现分派。</p>
<p>Go 不支持这些语言级别的特性，为了实现函数分派，引入了 <code>typeinfo</code> 结构，可以根据类型快速找到编码器和解码器函数，这部分内容在 <code>rlp/typecache.go</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var (</div><div class="line">	typeCacheMutex sync.RWMutex</div><div class="line">	typeCache      = make(map[typekey]*typeinfo)</div><div class="line">)</div><div class="line"></div><div class="line">type typeinfo struct &#123;</div><div class="line">	decoder</div><div class="line">	writer</div><div class="line">&#125;</div><div class="line"></div><div class="line">type tags struct &#123;</div><div class="line">	tail bool</div><div class="line">	ignored bool</div><div class="line">&#125;</div><div class="line"></div><div class="line">type typekey struct &#123;</div><div class="line">	reflect.Type</div><div class="line">	tags</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>typeCacheMutex</code> 是读写锁，在多线程的使用过程中保护 <code>typeCache</code>，<code>typeCache</code> 的作用是记录类型和编码器函数的对应关系。</p>
<h4 id="获取编码器，解码器"><a href="#获取编码器，解码器" class="headerlink" title="获取编码器，解码器"></a>获取编码器，解码器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func cachedTypeInfo(typ reflect.Type, tags tags) (*typeinfo, error) &#123;</div><div class="line">	typeCacheMutex.RLock()</div><div class="line">	info := typeCache[typekey&#123;typ, tags&#125;]</div><div class="line">	typeCacheMutex.RUnlock()</div><div class="line">	if info != nil &#123;</div><div class="line">		return info, nil</div><div class="line">	&#125;</div><div class="line">	typeCacheMutex.Lock()</div><div class="line">	defer typeCacheMutex.Unlock()</div><div class="line">	return cachedTypeInfo1(typ, tags)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func cachedTypeInfo1(typ reflect.Type, tags tags) (*typeinfo, error) &#123;</div><div class="line">	key := typekey&#123;typ, tags&#125;</div><div class="line">	info := typeCache[key]</div><div class="line">	if info != nil &#123;</div><div class="line">		return info, nil</div><div class="line">	&#125;</div><div class="line">	typeCache[key] = new(typeinfo)</div><div class="line">	info, err := genTypeInfo(typ, tags)</div><div class="line">	if err != nil &#123;</div><div class="line">		delete(typeCache, key)</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	*typeCache[key] = *info</div><div class="line">	return typeCache[key], err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没能明白 <code>cachedTypeInfo</code> 和 <code>cachedTypeInfo1</code> 的真正区别是什么，有熟悉这块代码的朋友可以赐教一下。</p>
<p>获取编码器，解码器时，首先会从缓存中请求，如果没有命中的话再调用 <code>genTypeInfo</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func genTypeInfo(typ reflect.Type, tags tags) (info *typeinfo, err error) &#123;</div><div class="line">	info = new(typeinfo)</div><div class="line">	if info.decoder, err = makeDecoder(typ, tags); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if info.writer, err = makeWriter(typ, tags); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return info, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码器和解码器大同小异，只是方向不同，这里我们以编码器为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">func makeWriter(typ reflect.Type, ts tags) (writer, error) &#123;</div><div class="line">	kind := typ.Kind()</div><div class="line">	switch &#123;</div><div class="line">	case typ == rawValueType:</div><div class="line">		return writeRawValue, nil</div><div class="line">	case typ.Implements(encoderInterface):</div><div class="line">		return writeEncoder, nil</div><div class="line">	case kind != reflect.Ptr &amp;&amp; reflect.PtrTo(typ).Implements(encoderInterface):</div><div class="line">		return writeEncoderNoPtr, nil</div><div class="line">	case kind == reflect.Interface:</div><div class="line">		return writeInterface, nil</div><div class="line">	case typ.AssignableTo(reflect.PtrTo(bigInt)):</div><div class="line">		return writeBigIntPtr, nil</div><div class="line">	case typ.AssignableTo(bigInt):</div><div class="line">		return writeBigIntNoPtr, nil</div><div class="line">	case isUint(kind):</div><div class="line">		return writeUint, nil</div><div class="line">	case kind == reflect.Bool:</div><div class="line">		return writeBool, nil</div><div class="line">	case kind == reflect.String:</div><div class="line">		return writeString, nil</div><div class="line">	case kind == reflect.Slice &amp;&amp; isByte(typ.Elem()):</div><div class="line">		return writeBytes, nil</div><div class="line">	case kind == reflect.Array &amp;&amp; isByte(typ.Elem()):</div><div class="line">		return writeByteArray, nil</div><div class="line">	case kind == reflect.Slice || kind == reflect.Array:</div><div class="line">		return makeSliceWriter(typ, ts)</div><div class="line">	case kind == reflect.Struct:</div><div class="line">		return makeStructWriter(typ)</div><div class="line">	case kind == reflect.Ptr:</div><div class="line">		return makePtrWriter(typ)</div><div class="line">	default:</div><div class="line">		return nil, fmt.Errorf(&quot;rlp: type %v is not RLP-serializable&quot;, typ)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>makeWriter</code> 实际上就是一堆 switch 分支，根据不同的类型，调用不同的编码方法。接下来我们会挑取几个典型方法来看。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>首先看字符串的编码方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func writeString(val reflect.Value, w *encbuf) error &#123;</div><div class="line">	s := val.String()</div><div class="line">	if len(s) == 1 &amp;&amp; s[0] &lt;= 0x7f &#123;</div><div class="line">		w.str = append(w.str, s[0])</div><div class="line">	&#125; else &#123;</div><div class="line">		w.encodeStringHeader(len(s))</div><div class="line">		w.str = append(w.str, s...)</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于字符串，如果只有一个字节，并且字节大小小于128，编码结果是其本身，这对应规则一的第1点。对于第2，第3种情况，调用 <code>encodeStringHeader</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func (w *encbuf) encodeStringHeader(size int) &#123;</div><div class="line">	if size &lt; 56 &#123;</div><div class="line">		w.str = append(w.str, 0x80+byte(size))</div><div class="line">	&#125; else &#123;</div><div class="line">		sizesize := putint(w.sizebuf[1:], uint64(size))</div><div class="line">		w.sizebuf[0] = 0xB7 + byte(sizesize)</div><div class="line">		w.str = append(w.str, w.sizebuf[:sizesize+1]...)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果长度小于56，编码结果是128加上字节数组长度的和作为前缀再加上原始数据，这对应的是第2种情况，如果长度大于等于56，则编码结果是0x87加上原始数据长度的大端表示的长度作为前缀，再加上原始数据长度的大端表示，再加上原始数据，这对应的是第3种情况。</p>
<p>再看树形结构的编码方法。</p>
<p>实际上这里所指的树形结构就是结构体数据。对于普通的类型，例如字符串，整形，布尔型，我们可以直接调用对应的编码方法，往 encbuf 里填充数据，对于结构体类型，我们没法确定其具体结构，但每种类型都实现了 writer 这一类型，即 <code>type writer func(reflect.Value, *encbuf) error</code>，注意到 writer 类型与 <code>func writeString(val reflect.Value, w *encbuf) error</code> 这些编码方法的类型是一致的。因此我们可以用递归的方式解决结构体类型的编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func makeStructWriter(typ reflect.Type) (writer, error) &#123;</div><div class="line">	fields, err := structFields(typ)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	writer := func(val reflect.Value, w *encbuf) error &#123;</div><div class="line">		lh := w.list()</div><div class="line">		for _, f := range fields &#123;</div><div class="line">			if err := f.info.writer(val.Field(f.index), w); err != nil &#123;</div><div class="line">				return err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		w.listEnd(lh)</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	return writer, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先拿到该结构体的所有字段，然后定义一个 <code>writer</code> 的匿名方法，即 <code>writer func(reflect.Value, *encbuf) error</code> 类型，这个方法可能会被递归调用，在这个方法中，遍历之前通过 <code>structFields</code> 拿到的所有字段，调用对应的 writer 方法，这些结果都会加入到 <code>w</code>(encbuf 类型)中，根据 RLP 编码的定义，需要根据树形结构的长度确定前缀的大小，这是通过 <code>list</code>, <code>listEnd</code>, <code>size</code>, <code>toBytes</code> 等方法实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func (w *encbuf) list() *listhead &#123;</div><div class="line">	lh := &amp;listhead&#123;offset: len(w.str), size: w.lhsize&#125;</div><div class="line">	w.lheads = append(w.lheads, lh)</div><div class="line">	return lh</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (w *encbuf) listEnd(lh *listhead) &#123;</div><div class="line">	lh.size = w.size() - lh.offset - lh.size</div><div class="line">	if lh.size &lt; 56 &#123;</div><div class="line">		w.lhsize += 1</div><div class="line">	&#125; else &#123;</div><div class="line">		w.lhsize += 1 + intsize(uint64(lh.size))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (w *encbuf) size() int &#123;</div><div class="line">	return len(w.str) + w.lhsize</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (w *encbuf) toBytes() []byte &#123;</div><div class="line">	out := make([]byte, w.size())</div><div class="line">	strpos := 0</div><div class="line">	pos := 0</div><div class="line">	for _, head := range w.lheads &#123;</div><div class="line">		n := copy(out[pos:], w.str[strpos:head.offset])</div><div class="line">		pos += n</div><div class="line">		strpos += n</div><div class="line">		enc := head.encode(out[pos:])</div><div class="line">		pos += len(enc)</div><div class="line">	&#125;</div><div class="line">	copy(out[pos:], w.str[strpos:])</div><div class="line">	return out</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>toBytes()</code> 是 <code>encbuf</code> 最后的处理逻辑，返回最终的 RLP 数据。</p>
<p>编码即序列化的整个流程就是这样，解码的过程就不赘述了，相反流程而已，最后看一下 encode 模块暴露的外部方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">func Encode(w io.Writer, val interface&#123;&#125;) error &#123;</div><div class="line">	if outer, ok := w.(*encbuf); ok &#123;</div><div class="line">		return outer.encode(val)</div><div class="line">	&#125;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	defer encbufPool.Put(eb)</div><div class="line">	eb.reset()</div><div class="line">	if err := eb.encode(val); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	return eb.toWriter(w)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func EncodeToBytes(val interface&#123;&#125;) ([]byte, error) &#123;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	defer encbufPool.Put(eb)</div><div class="line">	eb.reset()</div><div class="line">	if err := eb.encode(val); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	return eb.toBytes(), nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func EncodeToReader(val interface&#123;&#125;) (size int, r io.Reader, err error) &#123;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	eb.reset()</div><div class="line">	if err := eb.encode(val); err != nil &#123;</div><div class="line">		return 0, nil, err</div><div class="line">	&#125;</div><div class="line">	return eb.size(), &amp;encReader&#123;buf: eb&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Encode</code>， <code>EncodeToBytes</code>，<code>EncodeToReader</code> 等方法将值编码到 <code>io.Writer</code>, <code>Bytes</code>, <code>reader</code> 等等，它们有一个共同点，都调用了 encode 这个内部方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func (w *encbuf) encode(val interface&#123;&#125;) error &#123;</div><div class="line">	rval := reflect.ValueOf(val)</div><div class="line">	ti, err := cachedTypeInfo(rval.Type(), tags&#123;&#125;)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	return ti.writer(rval, w)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>encode</code> 方法会从 <code>cachedTypeInfo</code> 中获得某类型对应的编码器，然后调用 <code>writer</code> 方法，结果就能写到 <code>encbuf</code> 类型中。<code>EncodeToBytes</code>，<code>EncodeToReader</code> 等只是最后调用的方法不一致，如果是调用 <code>toBytes</code>，则返回经过 RLP 编码的字节码数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="external">ethereum/wiki RLP</a></li>
<li><a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">ethereum yellowpaper</a></li>
<li><a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/#rlp" target="_blank" rel="external">深入ethereum源码-p2p模块基础结构</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RLP 的定义，作用，用法在 &lt;a href=&quot;https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wiki&lt;/a&gt; 文档中有文字说明，这部分我们只做简单描述。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/ethereum/yellowpaper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;黄皮书&lt;/a&gt;里有 RLP 的形式化说明，这里我会总结一下，然后侧重于分析源码，讲解实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-区块链操作）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-区块链操作）/</id>
    <published>2018-03-10T14:35:00.000Z</published>
    <updated>2018-08-29T02:15:16.788Z</updated>
    
    <content type="html"><![CDATA[<p>区块链区块链，即区块组成的链，不妨先从区块谈起。这一篇我们将着眼于区块链的一些基本操作。在区块链中，区块存储有效信息，在阅读源代码之前，我们应该对区块头，区块体，区块链这些基本的数据结构有所了解。</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>Block</code>, <code>Header</code>, <code>BlockChain</code> 的数据结构请查阅 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></p>
<h2 id="区块链基本操作"><a href="#区块链基本操作" class="headerlink" title="区块链基本操作"></a>区块链基本操作</h2><h3 id="创世区块"><a href="#创世区块" class="headerlink" title="创世区块"></a>创世区块</h3><p>在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a> 这一篇，我们提到有一个 <code>geth init</code> 命令，它可以用来创建创世区块。如果我们将本地的 geth 节点连接测试网络或主网的话，我们不会再进行创世区块的创建，因为区块链已经存在了，这时候应该是从其他节点进行同步。而如果我们需要运行一个私有链的话，这时候就需要一个创建一个创世区块。这部分代码在 <code>core/genesis.go</code> 中。</p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>genesis.go</code> 会定义创世区块的数据结构，提供创建，查询创世区块的方法。</p>
<p>首先看 Genesis 结构体，它定义了创世区块应包含的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type Genesis struct &#123;</div><div class="line">	Config     *params.ChainConfig `json:&quot;config&quot;`</div><div class="line">	Nonce      uint64              `json:&quot;nonce&quot;`</div><div class="line">	Timestamp  uint64              `json:&quot;timestamp&quot;`</div><div class="line">	ExtraData  []byte              `json:&quot;extraData&quot;`</div><div class="line">	GasLimit   uint64              `json:&quot;gasLimit&quot;   gencodec:&quot;required&quot;`</div><div class="line">	Difficulty *big.Int            `json:&quot;difficulty&quot; gencodec:&quot;required&quot;`</div><div class="line">	Mixhash    common.Hash         `json:&quot;mixHash&quot;`</div><div class="line">	Coinbase   common.Address      `json:&quot;coinbase&quot;`</div><div class="line">	Alloc      GenesisAlloc        `json:&quot;alloc&quot;      gencodec:&quot;required&quot;`</div><div class="line"></div><div class="line">	Number     uint64      `json:&quot;number&quot;`</div><div class="line">	GasUsed    uint64      `json:&quot;gasUsed&quot;`</div><div class="line">	ParentHash common.Hash `json:&quot;parentHash&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>伴随创世区块的还有创世账户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type GenesisAlloc map[common.Address]GenesisAccount</div><div class="line"></div><div class="line">type GenesisAccount struct &#123;</div><div class="line">	Code       []byte                      `json:&quot;code,omitempty&quot;`</div><div class="line">	Storage    map[common.Hash]common.Hash `json:&quot;storage,omitempty&quot;`</div><div class="line">	Balance    *big.Int                    `json:&quot;balance&quot; gencodec:&quot;required&quot;`</div><div class="line">	Nonce      uint64                      `json:&quot;nonce,omitempty&quot;`</div><div class="line">	PrivateKey []byte                      `json:&quot;secretKey,omitempty&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h4><p><code>SetupGenesisBlock</code> 函数用来在数据库中写入创世区块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">func SetupGenesisBlock(db ethdb.Database, genesis *Genesis) (*params.ChainConfig, common.Hash, error) &#123;</div><div class="line">	if genesis != nil &amp;&amp; genesis.Config == nil &#123;</div><div class="line">		return params.AllEthashProtocolChanges, common.Hash&#123;&#125;, errGenesisNoConfig</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stored := rawdb.ReadCanonicalHash(db, 0)</div><div class="line">	if (stored == common.Hash&#123;&#125;) &#123;</div><div class="line">		if genesis == nil &#123;</div><div class="line">			log.Info(&quot;Writing default main-net genesis block&quot;)</div><div class="line">			genesis = DefaultGenesisBlock()</div><div class="line">		&#125; else &#123;</div><div class="line">			log.Info(&quot;Writing custom genesis block&quot;)</div><div class="line">		&#125;</div><div class="line">		block, err := genesis.Commit(db)</div><div class="line">		return genesis.Config, block.Hash(), err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if genesis != nil &#123;</div><div class="line">		hash := genesis.ToBlock(nil).Hash()</div><div class="line">		if hash != stored &#123;</div><div class="line">			return genesis.Config, hash, &amp;GenesisMismatchError&#123;stored, hash&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	newcfg := genesis.configOrDefault(stored)</div><div class="line">	storedcfg := rawdb.ReadChainConfig(db, stored)</div><div class="line">	if storedcfg == nil &#123;</div><div class="line">		log.Warn(&quot;Found genesis block without chain config&quot;)</div><div class="line">		rawdb.WriteChainConfig(db, stored, newcfg)</div><div class="line">		return newcfg, stored, nil</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	if genesis == nil &amp;&amp; stored != params.MainnetGenesisHash &#123;</div><div class="line">		return storedcfg, stored, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	height := rawdb.ReadHeaderNumber(db, rawdb.ReadHeadHeaderHash(db))</div><div class="line">	if height == nil &#123;</div><div class="line">		return newcfg, stored, fmt.Errorf(&quot;missing block number for head header hash&quot;)</div><div class="line">	&#125;</div><div class="line">	compatErr := storedcfg.CheckCompatible(newcfg, *height)</div><div class="line">	if compatErr != nil &amp;&amp; *height != 0 &amp;&amp; compatErr.RewindTo != 0 &#123;</div><div class="line">		return newcfg, stored, compatErr</div><div class="line">	&#125;</div><div class="line">	rawdb.WriteChainConfig(db, stored, newcfg)</div><div class="line">	return newcfg, stored, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SetupGenesisBlock</code> 会根据创世区块返回一个区块链的配置。从 db 参数中拿到的区块里如果没有创世区块的话，首先提交一个新区块。接着通过调用 <code>genesis.configOrDefault(stored)</code> 拿到当前链的配置，测试兼容性后将配置写回 DB 中。最后返回区块链的配置信息。</p>
<p><code>Genesis</code> 有一个 <code>ToBlock</code> 方法，它会根据 <code>Genesis</code> 的数据，使用基于内存的数据库，创建一个区块并返回（通过 <code>types.NewBlock</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (g *Genesis) ToBlock(db ethdb.Database) *types.Block &#123;</div><div class="line">	if db == nil &#123;</div><div class="line">		db, _ = ethdb.NewMemDatabase()</div><div class="line">	&#125;</div><div class="line">	statedb, _ := state.New(common.Hash&#123;&#125;, state.NewDatabase(db))</div><div class="line">	for addr, account := range g.Alloc &#123;</div><div class="line">		statedb.AddBalance(addr, account.Balance)</div><div class="line">		statedb.SetCode(addr, account.Code)</div><div class="line">		statedb.SetNonce(addr, account.Nonce)</div><div class="line">		for key, value := range account.Storage &#123;</div><div class="line">			statedb.SetState(addr, key, value)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	root := statedb.IntermediateRoot(false)</div><div class="line">	head := &amp;types.Header&#123;</div><div class="line">		Number:     new(big.Int).SetUint64(g.Number),</div><div class="line">		Nonce:      types.EncodeNonce(g.Nonce),</div><div class="line">		Time:       new(big.Int).SetUint64(g.Timestamp),</div><div class="line">		ParentHash: g.ParentHash,</div><div class="line">		Extra:      g.ExtraData,</div><div class="line">		GasLimit:   g.GasLimit,</div><div class="line">		GasUsed:    g.GasUsed,</div><div class="line">		Difficulty: g.Difficulty,</div><div class="line">		MixDigest:  g.Mixhash,</div><div class="line">		Coinbase:   g.Coinbase,</div><div class="line">		Root:       root,</div><div class="line">	&#125;</div><div class="line">	if g.GasLimit == 0 &#123;</div><div class="line">		head.GasLimit = params.GenesisGasLimit</div><div class="line">	&#125;</div><div class="line">	if g.Difficulty == nil &#123;</div><div class="line">		head.Difficulty = params.GenesisDifficulty</div><div class="line">	&#125;</div><div class="line">	statedb.Commit(false)</div><div class="line">	statedb.Database().TrieDB().Commit(root, true)</div><div class="line"></div><div class="line">	return types.NewBlock(head, nil, nil, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Commit 方法将给定的 <code>genesis</code> 的区块和 <code>state</code> 写入数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func (g *Genesis) Commit(db ethdb.Database) (*types.Block, error) &#123;</div><div class="line">	block := g.ToBlock(db)</div><div class="line">	if block.Number().Sign() != 0 &#123;</div><div class="line">		return nil, fmt.Errorf(&quot;can&apos;t commit genesis block with number &gt; 0&quot;)</div><div class="line">	&#125;</div><div class="line">	if err := WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if err := WriteBlock(db, block); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if err := WriteBlockReceipts(db, block.Hash(), block.NumberU64(), nil); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if err := WriteCanonicalHash(db, block.Hash(), block.NumberU64()); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if err := WriteHeadBlockHash(db, block.Hash()); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	if err := WriteHeadHeaderHash(db, block.Hash()); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	config := g.Config</div><div class="line">	if config == nil &#123;</div><div class="line">		config = params.AllEthashProtocolChanges</div><div class="line">	&#125;</div><div class="line">	return block, WriteChainConfig(db, block.Hash(), config)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-NewBlockChain-初始化区块链"><a href="#使用-NewBlockChain-初始化区块链" class="headerlink" title="使用 NewBlockChain 初始化区块链"></a>使用 <code>NewBlockChain</code> 初始化区块链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">func NewBlockChain(db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig, engine consensus.Engine, vmConfig vm.Config) (*BlockChain, error) &#123;</div><div class="line">	if cacheConfig == nil &#123;</div><div class="line">		cacheConfig = &amp;CacheConfig&#123;</div><div class="line">			TrieNodeLimit: 256 * 1024 * 1024,</div><div class="line">			TrieTimeLimit: 5 * time.Minute,</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bodyCache, _ := lru.New(bodyCacheLimit)</div><div class="line">	bodyRLPCache, _ := lru.New(bodyCacheLimit)</div><div class="line">	blockCache, _ := lru.New(blockCacheLimit)</div><div class="line">	futureBlocks, _ := lru.New(maxFutureBlocks)</div><div class="line">	badBlocks, _ := lru.New(badBlockLimit)</div><div class="line"></div><div class="line">	bc := &amp;BlockChain&#123;</div><div class="line">		chainConfig:  chainConfig,</div><div class="line">		cacheConfig:  cacheConfig,</div><div class="line">		db:           db,</div><div class="line">		triegc:       prque.New(),</div><div class="line">		stateCache:   state.NewDatabase(db),</div><div class="line">		quit:         make(chan struct&#123;&#125;),</div><div class="line">		bodyCache:    bodyCache,</div><div class="line">		bodyRLPCache: bodyRLPCache,</div><div class="line">		blockCache:   blockCache,</div><div class="line">		futureBlocks: futureBlocks,</div><div class="line">		engine:       engine,</div><div class="line">		vmConfig:     vmConfig,</div><div class="line">		badBlocks:    badBlocks,</div><div class="line">	&#125;</div><div class="line">	bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))</div><div class="line">	bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))</div><div class="line"></div><div class="line">	var err error</div><div class="line">	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	bc.genesisBlock = bc.GetBlockByNumber(0)</div><div class="line">	if bc.genesisBlock == nil &#123;</div><div class="line">		return nil, ErrNoGenesis</div><div class="line">	&#125;</div><div class="line">	if err := bc.loadLastState(); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	for hash := range BadHashes &#123;</div><div class="line">		if header := bc.GetHeaderByHash(hash); header != nil &#123;</div><div class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</div><div class="line">			if headerByNumber != nil &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</div><div class="line">				log.Error(&quot;Found bad hash, rewinding chain&quot;, &quot;number&quot;, header.Number, &quot;hash&quot;, header.ParentHash)</div><div class="line">				bc.SetHead(header.Number.Uint64() - 1)</div><div class="line">				log.Error(&quot;Chain rewind was successful, resuming normal operation&quot;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	go bc.update()</div><div class="line">	return bc, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BlockChain</code> 的初始化需要 <code>ethdb.Database</code>,  <code>*CacheConfig</code>, <code>params.ChainConfig</code>， <code>consensus.Engine</code>，<code>vm.Config</code> 参数。它们分别表示 db 对象；缓存配置（在 <code>core/blockchain.go</code> 中定义）；区块链配置（可通过 <code>core/genesis.go</code> 中的 <code>SetupGenesisBlock</code> 拿到）；一致性引擎（可通过 <code>core/blockchain.go</code> 中的 <code>CreateConsensusEngine</code> 得到）；虚拟机配置（通过 <code>core/vm</code> 定义）这些实参需要提前定义，以 eth 的 <code>backend.go</code> 为例，你可以在初始化 Ethereum 对象时看到这些参数是怎么初始化的，当然你也可以查看对应的测试代码学习 <code>NewBlockChain</code> 如何使用。</p>
<p>回到 <code>NewBlockChain</code> 的具体代码，首先判断是否有默认 <code>cacheConfig</code>，如果没有根据默认配置创建 <code>cacheConfig</code>，再通过 hashicorp 公司的 lru 模块创建 <code>bodyCache</code>, <code>bodyRLPCache</code> 等缓存对象（lru 是 last recently used 的缩写，常见数据结构，不了解的朋友请自行查阅相关资料），根据这些信息创建 <code>BlockChain</code> 对象，然后通过调用 <code>BlockChain</code> 的 <code>SetValidator</code> 和 <code>SetProcessor</code> 方法创建验证器和处理器，接下来通过 <code>NewHeaderChain</code> 获得区块头，尝试判断创始区块是否存在，<code>bc.loadLastState()</code> 加载区块最新状态，最后检查当前状态，确保本地运行的区块链上没有非法的区块。接下来我们深入到 <code>loadLastState</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) loadLastState() error &#123;</div><div class="line">	head := GetHeadBlockHash(bc.db)</div><div class="line">	if head == (common.Hash&#123;&#125;) &#123;</div><div class="line">		log.Warn(&quot;Empty database, resetting chain&quot;)</div><div class="line">		return bc.Reset()</div><div class="line">	&#125;</div><div class="line">	currentBlock := bc.GetBlockByHash(head)</div><div class="line">	if currentBlock == nil &#123;</div><div class="line">		log.Warn(&quot;Head block missing, resetting chain&quot;, &quot;hash&quot;, head)</div><div class="line">		return bc.Reset()</div><div class="line">	&#125;</div><div class="line">	if _, err := state.New(currentBlock.Root(), bc.stateCache); err != nil &#123;</div><div class="line">		log.Warn(&quot;Head state missing, repairing chain&quot;, &quot;number&quot;, currentBlock.Number(), &quot;hash&quot;, currentBlock.Hash())</div><div class="line">		if err := bc.repair(&amp;currentBlock); err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bc.currentBlock.Store(currentBlock)</div><div class="line"></div><div class="line">	currentHeader := currentBlock.Header()</div><div class="line">	if head := GetHeadHeaderHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</div><div class="line">		if header := bc.GetHeaderByHash(head); header != nil &#123;</div><div class="line">			currentHeader = header</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bc.hc.SetCurrentHeader(currentHeader)</div><div class="line">	</div><div class="line">	bc.currentFastBlock.Store(currentBlock)</div><div class="line">	if head := GetHeadFastBlockHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</div><div class="line">		if block := bc.GetBlockByHash(head); block != nil &#123;</div><div class="line">			bc.currentFastBlock.Store(block)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Issue a status log for the user</div><div class="line">	// ... </div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadLastState</code> 会从数据库中加载区块链状态，首先通过 <code>GetHeadBlockHash</code> 从数据库中取得当前区块头，如果当前区块不存在，即数据库为空的话，通过 <code>Reset</code> 将创始区块写入数据库以达到重置目的。如果当前区块不存在，同样通过 <code>Reset</code> 重置。接下来确认当前区块的世界状态是否正确，世界状态这是一个稍特别的概念，这个过程我们将在之后的文章中描述。如果有问题，则通过 <code>repair</code> 进行修复，<code>repair</code> 中是一个死循环，它会一直回溯当前区块，直到找到对应的世界状态。然后通过 <code>bc.hc.SetCurrentHeader</code> 设置当前区块头，并恢复快速同步区块。</p>
<p>在 <code>NewBlockChain</code> 调用 <code>loadLastState</code> 之后，会判断是否需要硬分叉，<code>BadHashes</code> 是手工配置的区块 hash 值，根据这些值我们可以决定是否以及如何进行硬分叉。最后以 goroutine 的方式调用 <code>bc.update()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) update() &#123;</div><div class="line">	futureTimer := time.Tick(5 * time.Second)</div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case &lt;-futureTimer:</div><div class="line">			bc.procFutureBlocks()</div><div class="line">		case &lt;-bc.quit:</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>update()</code> 的作用是定时处理 Future 区块，简单地来说就是定时调用 <code>procFutureBlocks</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) procFutureBlocks() &#123;</div><div class="line">	blocks := make([]*types.Block, 0, bc.futureBlocks.Len())</div><div class="line">	for _, hash := range bc.futureBlocks.Keys() &#123;</div><div class="line">		if block, exist := bc.futureBlocks.Peek(hash); exist &#123;</div><div class="line">			blocks = append(blocks, block.(*types.Block))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if len(blocks) &gt; 0 &#123;</div><div class="line">		types.BlockBy(types.Number).Sort(blocks)</div><div class="line">		for i := range blocks &#123;</div><div class="line">			bc.InsertChain(blocks[i : i+1])</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>procFutureBlocks</code> 可以从 <code>futureBlocks</code> 拿到需要插入的区块，最终会调用 <code>InsertChain</code> 将区块插入到区块链中。</p>
<h3 id="插入区块"><a href="#插入区块" class="headerlink" title="插入区块"></a>插入区块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) InsertChain(chain types.Blocks) (int, error) &#123;</div><div class="line">	n, events, logs, err := bc.insertChain(chain)</div><div class="line">	bc.PostChainEvents(events, logs)</div><div class="line">	return n, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>InsertChain</code> 将尝试将给定的区块插入到规范的区块链中，或者创建一个分支，插入后，会通过 <code>PostChainEvents</code> 触发所有事件。下面我们看看 <code>insertChain</code> 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) insertChain(chain types.Blocks) (int, []interface&#123;&#125;, []*types.Log, error) &#123;</div><div class="line">	for i := 1; i &lt; len(chain); i++ &#123;</div><div class="line">		if chain[i].NumberU64() != chain[i-1].NumberU64()+1 || chain[i].ParentHash() != chain[i-1].Hash() &#123;</div><div class="line">			log.Error(&quot;Non contiguous block insert&quot;, &quot;number&quot;, chain[i].Number(), &quot;hash&quot;, chain[i].Hash(),</div><div class="line">				&quot;parent&quot;, chain[i].ParentHash(), &quot;prevnumber&quot;, chain[i-1].Number(), &quot;prevhash&quot;, chain[i-1].Hash())</div><div class="line"></div><div class="line">			return 0, nil, nil, fmt.Errorf(&quot;non contiguous insert: item %d is #%d [%x…], item %d is #%d [%x…] (parent [%x…])&quot;, i-1, chain[i-1].NumberU64(),</div><div class="line">				chain[i-1].Hash().Bytes()[:4], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:4], chain[i].ParentHash().Bytes()[:4])</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//...</div><div class="line">	var (</div><div class="line">		stats         = insertStats&#123;startTime: mclock.Now()&#125;</div><div class="line">		events        = make([]interface&#123;&#125;, 0, len(chain))</div><div class="line">		lastCanon     *types.Block</div><div class="line">		coalescedLogs []*types.Log</div><div class="line">	)</div><div class="line">	headers := make([]*types.Header, len(chain))</div><div class="line">	seals := make([]bool, len(chain))</div><div class="line"></div><div class="line">	for i, block := range chain &#123;</div><div class="line">		headers[i] = block.Header()</div><div class="line">		seals[i] = true</div><div class="line">	&#125;</div><div class="line">	abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</div><div class="line">	defer close(abort)</div><div class="line"></div><div class="line">	for i, block := range chain &#123;</div><div class="line">		// ...</div><div class="line">		// Wait for the block&apos;s verification to complete ...</div><div class="line">		bstart := time.Now()</div><div class="line"></div><div class="line">		err := &lt;-results</div><div class="line">		if err == nil &#123;</div><div class="line">			err = bc.Validator().ValidateBody(block)</div><div class="line">		&#125;</div><div class="line">		switch &#123;</div><div class="line">		case err == ErrKnownBlock:</div><div class="line">			if bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() &#123;</div><div class="line">				stats.ignored++</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		case err == consensus.ErrFutureBlock:</div><div class="line">			max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)</div><div class="line">			if block.Time().Cmp(max) &gt; 0 &#123;</div><div class="line">				return i, events, coalescedLogs, fmt.Errorf(&quot;future block: %v &gt; %v&quot;, block.Time(), max)</div><div class="line">			&#125;</div><div class="line">			bc.futureBlocks.Add(block.Hash(), block)</div><div class="line">			stats.queued++</div><div class="line">			continue</div><div class="line"></div><div class="line">		case err == consensus.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):</div><div class="line">			bc.futureBlocks.Add(block.Hash(), block)</div><div class="line">			stats.queued++</div><div class="line">			continue</div><div class="line"></div><div class="line">		case err == consensus.ErrPrunedAncestor:</div><div class="line">			currentBlock := bc.CurrentBlock()</div><div class="line">			localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</div><div class="line">			externTd := new(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()-1), block.Difficulty())</div><div class="line">			if localTd.Cmp(externTd) &gt; 0 &#123;</div><div class="line">				if err = bc.WriteBlockWithoutState(block, externTd); err != nil &#123;</div><div class="line">					return i, events, coalescedLogs, err</div><div class="line">				&#125;</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			var winner []*types.Block</div><div class="line"></div><div class="line">			parent := bc.GetBlock(block.ParentHash(), block.NumberU64()-1)</div><div class="line">			for !bc.HasState(parent.Root()) &#123;</div><div class="line">				winner = append(winner, parent)</div><div class="line">				parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()-1)</div><div class="line">			&#125;</div><div class="line">			for j := 0; j &lt; len(winner)/2; j++ &#123;</div><div class="line">				winner[j], winner[len(winner)-1-j] = winner[len(winner)-1-j], winner[j]</div><div class="line">			&#125;</div><div class="line">			bc.chainmu.Unlock()</div><div class="line">			_, evs, logs, err := bc.insertChain(winner)</div><div class="line">			bc.chainmu.Lock()</div><div class="line">			events, coalescedLogs = evs, logs</div><div class="line"></div><div class="line">			if err != nil &#123;</div><div class="line">				return i, events, coalescedLogs, err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		case err != nil:</div><div class="line">			bc.reportBlock(block, nil, err)</div><div class="line">			return i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		var parent *types.Block</div><div class="line">		if i == 0 &#123;</div><div class="line">			parent = bc.GetBlock(block.ParentHash(), block.NumberU64()-1)</div><div class="line">		&#125; else &#123;</div><div class="line">			parent = chain[i-1]</div><div class="line">		&#125;</div><div class="line">		state, err := state.New(parent.Root(), bc.stateCache)</div><div class="line">		if err != nil &#123;</div><div class="line">			return i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</div><div class="line">		if err != nil &#123;</div><div class="line">			bc.reportBlock(block, receipts, err)</div><div class="line">			return i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)</div><div class="line">		if err != nil &#123;</div><div class="line">			bc.reportBlock(block, receipts, err)</div><div class="line">			return i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		proctime := time.Since(bstart)</div><div class="line"></div><div class="line">		status, err := bc.WriteBlockWithState(block, receipts, state)</div><div class="line">		if err != nil &#123;</div><div class="line">			return i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		switch status &#123;</div><div class="line">		case CanonStatTy:</div><div class="line">			log.Debug(&quot;Inserted new block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, block.Hash(), &quot;uncles&quot;, len(block.Uncles()),</div><div class="line">				&quot;txs&quot;, len(block.Transactions()), &quot;gas&quot;, block.GasUsed(), &quot;elapsed&quot;, common.PrettyDuration(time.Since(bstart)))</div><div class="line"></div><div class="line">			coalescedLogs = append(coalescedLogs, logs...)</div><div class="line">			blockInsertTimer.UpdateSince(bstart)</div><div class="line">			events = append(events, ChainEvent&#123;block, block.Hash(), logs&#125;)</div><div class="line">			lastCanon = block</div><div class="line"></div><div class="line">			bc.gcproc += proctime</div><div class="line"></div><div class="line">		case SideStatTy:</div><div class="line">			log.Debug(&quot;Inserted forked block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, block.Hash(), &quot;diff&quot;, block.Difficulty(), &quot;elapsed&quot;,</div><div class="line">				common.PrettyDuration(time.Since(bstart)), &quot;txs&quot;, len(block.Transactions()), &quot;gas&quot;, block.GasUsed(), &quot;uncles&quot;, len(block.Uncles()))</div><div class="line"></div><div class="line">			blockInsertTimer.UpdateSince(bstart)</div><div class="line">			events = append(events, ChainSideEvent&#123;block&#125;)</div><div class="line">		&#125;</div><div class="line">		stats.processed++</div><div class="line">		stats.usedGas += usedGas</div><div class="line">		stats.report(chain, i, bc.stateCache.TrieDB().Size())</div><div class="line">	&#125;</div><div class="line">	if lastCanon != nil &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</div><div class="line">		events = append(events, ChainHeadEvent&#123;lastCanon&#125;)</div><div class="line">	&#125;</div><div class="line">	return 0, events, coalescedLogs, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先做一个健康检查，确保要插入的链是有序且相互连接的。接下来通过 <code>bc.engine.VerifyHeaders</code> 调用一致性引擎来验证区块头是有效的。进入 <code>for i, block := range chain</code> 循环后，接收 <code>results</code> 这个 chan，可以获得一致性引擎获得区块头的结果，如果是已经插入的区块，跳过；如果是未来的区块，时间距离不是很长，加入到 <code>futureBlocks</code> 中，否则返回一条错误信息；如果没能找到该区块祖先，但在 <code>futureBlocks</code> 能找到，也加入到 <code>futureBlocks</code> 中。</p>
<p>加入 <code>futureBlocks</code> 的过程结束后，通过 <code>core/state_processor.go</code> 中的 Process 改变世界状态（关于世界状态的管理，可以阅读后续的文章 <a href="#TODO">go-ethereum 源码笔记（core 模块-状态管理）</a>）。在返回收据，日志，使用的 Gas 后。通过 <code>bc.Validator().ValidateState</code> 再次验证，通过后，通过 <code>WriteBlockAndState</code> 写入区块以及相关状态到区块链，<code>WriteBlockAndState</code> 我们接下来会详谈。最后，如果我们生成了一个新的区块头，最新的区块头等于 <code>lastCanon</code> 的哈希值，发布一个 <code>ChainHeadEvent</code> 的事件。</p>
<p>现在我们来看看 <code>WriteBlockAndState</code> 是如何写入区块及相关状态到区块链的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) WriteBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) (status WriteStatus, err error) &#123;</div><div class="line">	ptd := bc.GetTd(block.ParentHash(), block.NumberU64()-1)</div><div class="line">	if ptd == nil &#123;</div><div class="line">		return NonStatTy, consensus.ErrUnknownAncestor</div><div class="line">	&#125;</div><div class="line">	// ...</div><div class="line">	currentBlock := bc.CurrentBlock()</div><div class="line">	localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</div><div class="line">	externTd := new(big.Int).Add(block.Difficulty(), ptd)</div><div class="line">	if err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd); err != nil &#123;</div><div class="line">		return NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	batch := bc.db.NewBatch()</div><div class="line">	if err := WriteBlock(batch, block); err != nil &#123;</div><div class="line">		return NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	root, err := state.Commit(bc.chainConfig.IsEIP158(block.Number()))</div><div class="line">	if err != nil &#123;</div><div class="line">		return NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	triedb := bc.stateCache.TrieDB()</div><div class="line"></div><div class="line">	if bc.cacheConfig.Disabled &#123;</div><div class="line">		if err := triedb.Commit(root, false); err != nil &#123;</div><div class="line">			return NonStatTy, err</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		triedb.Reference(root, common.Hash&#123;&#125;)</div><div class="line">		bc.triegc.Push(root, -float32(block.NumberU64()))</div><div class="line"></div><div class="line">		if current := block.NumberU64(); current &gt; triesInMemory &#123;</div><div class="line">			header := bc.GetHeaderByNumber(current - triesInMemory)</div><div class="line">			chosen := header.Number.Uint64()</div><div class="line"></div><div class="line">			var (</div><div class="line">				size  = triedb.Size()</div><div class="line">				limit = common.StorageSize(bc.cacheConfig.TrieNodeLimit) * 1024 * 1024</div><div class="line">			)</div><div class="line">			if size &gt; limit || bc.gcproc &gt; bc.cacheConfig.TrieTimeLimit &#123;</div><div class="line">				if chosen &lt; lastWrite+triesInMemory &#123;</div><div class="line">					switch &#123;</div><div class="line">					case size &gt;= 2*limit:</div><div class="line">						log.Warn(&quot;State memory usage too high, committing&quot;, &quot;size&quot;, size, &quot;limit&quot;, limit, &quot;optimum&quot;, float64(chosen-lastWrite)/triesInMemory)</div><div class="line">					case bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit:</div><div class="line">						log.Info(&quot;State in memory for too long, committing&quot;, &quot;time&quot;, bc.gcproc, &quot;allowance&quot;, bc.cacheConfig.TrieTimeLimit, &quot;optimum&quot;, float64(chosen-lastWrite)/triesInMemory)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				if chosen &gt;= lastWrite+triesInMemory || size &gt;= 2*limit || bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit &#123;</div><div class="line">					triedb.Commit(header.Root, true)</div><div class="line">					lastWrite = chosen</div><div class="line">					bc.gcproc = 0</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			for !bc.triegc.Empty() &#123;</div><div class="line">				root, number := bc.triegc.Pop()</div><div class="line">				if uint64(-number) &gt; chosen &#123;</div><div class="line">					bc.triegc.Push(root, number)</div><div class="line">					break</div><div class="line">				&#125;</div><div class="line">				triedb.Dereference(root.(common.Hash), common.Hash&#123;&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if err := WriteBlockReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil &#123;</div><div class="line">		return NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	reorg := externTd.Cmp(localTd) &gt; 0</div><div class="line">	currentBlock = bc.CurrentBlock()</div><div class="line">	if !reorg &amp;&amp; externTd.Cmp(localTd) == 0 &#123;</div><div class="line">		reorg = block.NumberU64() &lt; currentBlock.NumberU64() || (block.NumberU64() == currentBlock.NumberU64() &amp;&amp; mrand.Float64() &lt; 0.5)</div><div class="line">	&#125;</div><div class="line">	if reorg &#123;</div><div class="line">		if block.ParentHash() != currentBlock.Hash() &#123;</div><div class="line">			if err := bc.reorg(currentBlock, block); err != nil &#123;</div><div class="line">				return NonStatTy, err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if err := WriteTxLookupEntries(batch, block); err != nil &#123;</div><div class="line">			return NonStatTy, err</div><div class="line">		&#125;</div><div class="line">		if err := WritePreimages(bc.db, block.NumberU64(), state.Preimages()); err != nil &#123;</div><div class="line">			return NonStatTy, err</div><div class="line">		&#125;</div><div class="line">		status = CanonStatTy</div><div class="line">	&#125; else &#123;</div><div class="line">		status = SideStatTy</div><div class="line">	&#125;</div><div class="line">	if err := batch.Write(); err != nil &#123;</div><div class="line">		return NonStatTy, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if status == CanonStatTy &#123;</div><div class="line">		bc.insert(block)</div><div class="line">	&#125;</div><div class="line">	bc.futureBlocks.Remove(block.Hash())</div><div class="line">	return status, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WriteBlockWithState</code> 将区块以及相关所有的状态写入数据库。首先通过 <code>bc.GetTd(block.ParentHash(), block.NumberU64()-1)</code> 获取待插入区块的总难度，<code>bc.GetTd(bc.currentBlock.Hash(), bc.currentBlock.NumberU64())</code> 计算当前区块的区块链的总难度，<code>externTd := new(big.Int).Add(block.Difficulty(), ptd)</code> 获得新的区块链的总难度。通过 <code>bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd)</code> 写入区块 hash，高度，对应总难度。然后使用 <code>batch</code> 的方式写入区块的其他数据。插入数据后，判断这个区块的父区块是否为当前区块，如果不是，说明存在分叉，调用 <code>reorg</code> 重新组织区块链。插入成功后，调用 <code>bc.futureBlocks.Remove(block.Hash())</code> 从 <code>futureBlocks</code> 中移除区块。</p>
<p>下面我们来看看 <code>reorg</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) reorg(oldBlock, newBlock *types.Block) error &#123;</div><div class="line">	if oldBlock.NumberU64() &gt; newBlock.NumberU64() &#123;</div><div class="line">		for ; oldBlock != nil &amp;&amp; oldBlock.NumberU64() != newBlock.NumberU64(); oldBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()-1) &#123;</div><div class="line">			oldChain = append(oldChain, oldBlock)</div><div class="line">			deletedTxs = append(deletedTxs, oldBlock.Transactions()...)</div><div class="line"></div><div class="line">			collectLogs(oldBlock.Hash())</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		for ; newBlock != nil &amp;&amp; newBlock.NumberU64() != oldBlock.NumberU64(); newBlock = bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()-1) &#123;</div><div class="line">			newChain = append(newChain, newBlock)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if oldBlock == nil &#123;</div><div class="line">		return fmt.Errorf(&quot;Invalid old chain&quot;)</div><div class="line">	&#125;</div><div class="line">	if newBlock == nil &#123;</div><div class="line">		return fmt.Errorf(&quot;Invalid new chain&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		if oldBlock.Hash() == newBlock.Hash() &#123;</div><div class="line">			commonBlock = oldBlock</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		oldChain = append(oldChain, oldBlock)</div><div class="line">		newChain = append(newChain, newBlock)</div><div class="line">		deletedTxs = append(deletedTxs, oldBlock.Transactions()...)</div><div class="line">		collectLogs(oldBlock.Hash())</div><div class="line"></div><div class="line">		oldBlock, newBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()-1), bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()-1)</div><div class="line">		if oldBlock == nil &#123;</div><div class="line">			return fmt.Errorf(&quot;Invalid old chain&quot;)</div><div class="line">		&#125;</div><div class="line">		if newBlock == nil &#123;</div><div class="line">			return fmt.Errorf(&quot;Invalid new chain&quot;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if len(oldChain) &gt; 0 &amp;&amp; len(newChain) &gt; 0 &#123;</div><div class="line">		logFn := log.Debug</div><div class="line">		if len(oldChain) &gt; 63 &#123;</div><div class="line">			logFn = log.Warn</div><div class="line">		&#125;</div><div class="line">		logFn(&quot;Chain split detected&quot;, &quot;number&quot;, commonBlock.Number(), &quot;hash&quot;, commonBlock.Hash(),</div><div class="line">			&quot;drop&quot;, len(oldChain), &quot;dropfrom&quot;, oldChain[0].Hash(), &quot;add&quot;, len(newChain), &quot;addfrom&quot;, newChain[0].Hash())</div><div class="line">	&#125; else &#123;</div><div class="line">		log.Error(&quot;Impossible reorg, please file an issue&quot;, &quot;oldnum&quot;, oldBlock.Number(), &quot;oldhash&quot;, oldBlock.Hash(), &quot;newnum&quot;, newBlock.Number(), &quot;newhash&quot;, newBlock.Hash())</div><div class="line">	&#125;</div><div class="line">	var addedTxs types.Transactions</div><div class="line">	for i := len(newChain) - 1; i &gt;= 0; i-- &#123;</div><div class="line">		if err := WriteTxLookupEntries(bc.db, newChain[i]); err != nil &#123;</div><div class="line">			return err</div><div class="line">		&#125;</div><div class="line">		addedTxs = append(addedTxs, newChain[i].Transactions()...)</div><div class="line">	&#125;</div><div class="line">	diff := types.TxDifference(deletedTxs, addedTxs)</div><div class="line">	for _, tx := range diff &#123;</div><div class="line">		DeleteTxLookupEntry(bc.db, tx.Hash())</div><div class="line">	&#125;</div><div class="line">	if len(deletedLogs) &gt; 0 &#123;</div><div class="line">		go bc.rmLogsFeed.Send(RemovedLogsEvent&#123;deletedLogs&#125;)</div><div class="line">	&#125;</div><div class="line">	if len(oldChain) &gt; 0 &#123;</div><div class="line">		go func() &#123;</div><div class="line">			for _, block := range oldChain &#123;</div><div class="line">				bc.chainSideFeed.Send(ChainSideEvent&#123;Block: block&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提到，<code>reorg</code> 方法用来将新区块链替换本地区块链为规范链。对于老链比新链高的情况，减少老链，让它和新链一样高；否则的话减少新链，待后续插入。潜在的会丢失的交易会被当做事件发布。接着进入一个 for 循环，找到两条链共同的祖先。再将上述减少新链阶段保存的 <code>newChain</code> 一块块插入到链中，更新规范区块链的 key，并且写入交易的查询信息。最后是清理工作，删除交易查询信息，删除日志，并通过 <code>bc.rmLogsFeed.Send</code> 发送消息通知，删除了哪些旧链则通过 <code>bc.chainSideFeed.Send</code> 进行消息通知。</p>
<p>至此，插入区块的操作就完成了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">core-blockchain源码分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链区块链，即区块组成的链，不妨先从区块谈起。这一篇我们将着眼于区块链的一些基本操作。在区块链中，区块存储有效信息，在阅读源代码之前，我们应该对区块头，区块体，区块链这些基本的数据结构有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（cmd 模块-其他命令）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（cmd 模块-其他命令）/</id>
    <published>2018-03-10T14:34:59.000Z</published>
    <updated>2018-08-18T07:33:33.922Z</updated>
    
    <content type="html"><![CDATA[<p>cmd 包中除了 ethereum cli 客户端还包括很多其他可执行命令。下面我们将一一分析这些子命令，与上一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a>一样，我们不会深入到其他模块中，这一篇仅限于 cmd 模块。</p>
<a id="more"></a>
<h2 id="abigen"><a href="#abigen" class="headerlink" title="abigen"></a>abigen</h2><p>abigen 可以根据 sol 或 abi 文件生成特定语言的封装，支持 golang, objc, java 3种语言。它也能够编译 Solidity 原文件，使开发更便利。</p>
<p>ABI 指的是 Application binary interface，字面意思是应用二进制接口。它是与区块链以外的以太坊系统中的合约进行交互的标准方式，同时也是合约与合约交互的标准方式。</p>
<p>除了通过 RPC 的方式调用，部署合约，我们还可以使用 IPC 的方式，即使用 abigen 这种方式，使得部署合约更简单，更易于与代码集成。</p>
<p>可以写一个简单的 <code>test.sol</code> 文件试一下，通过 <code>abigen --sol test.sol -pkg main --lang go --out test.go</code> 先生成一个 test.go 文件，观察这个生成的绑定文件你会发现这个文件生成了与这个合约交互的所有方法，里面还包含了部署的方法，可以通过客户端来可以调用这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	if *abiFlag == &quot;&quot; &amp;&amp; *solFlag == &quot;&quot; &#123;</div><div class="line">		fmt.Printf(&quot;No contract ABI (--abi) or Solidity source (--sol) specified\n&quot;)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125; else if (*abiFlag != &quot;&quot; || *binFlag != &quot;&quot; || *typFlag != &quot;&quot;) &amp;&amp; *solFlag != &quot;&quot; &#123;</div><div class="line">		fmt.Printf(&quot;Contract ABI (--abi), bytecode (--bin) and type (--type) flags are mutually exclusive with the Solidity source (--sol) flag\n&quot;)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125;</div><div class="line">	if *pkgFlag == &quot;&quot; &#123;</div><div class="line">		fmt.Printf(&quot;No destination package specified (--pkg)\n&quot;)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125;</div><div class="line">	var lang bind.Lang</div><div class="line">	switch *langFlag &#123;</div><div class="line">	case &quot;go&quot;:</div><div class="line">		lang = bind.LangGo</div><div class="line">	case &quot;java&quot;:</div><div class="line">		lang = bind.LangJava</div><div class="line">	case &quot;objc&quot;:</div><div class="line">		lang = bind.LangObjC</div><div class="line">	default:</div><div class="line">		fmt.Printf(&quot;Unsupported destination language \&quot;%s\&quot; (--lang)\n&quot;, *langFlag)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125;</div><div class="line">	var (</div><div class="line">		abis  []string</div><div class="line">		bins  []string</div><div class="line">		types []string</div><div class="line">	)</div><div class="line">	if *solFlag != &quot;&quot; || *abiFlag == &quot;-&quot; &#123;</div><div class="line">		exclude := make(map[string]bool)</div><div class="line">		for _, kind := range strings.Split(*excFlag, &quot;,&quot;) &#123;</div><div class="line">			exclude[strings.ToLower(kind)] = true</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		var contracts map[string]*compiler.Contract</div><div class="line">		var err error</div><div class="line">		if *solFlag != &quot;&quot; &#123;</div><div class="line">			contracts, err = compiler.CompileSolidity(*solcFlag, *solFlag)</div><div class="line">			if err != nil &#123;</div><div class="line">				fmt.Printf(&quot;Failed to build Solidity contract: %v\n&quot;, err)</div><div class="line">				os.Exit(-1)</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			contracts, err = contractsFromStdin()</div><div class="line">			if err != nil &#123;</div><div class="line">				fmt.Printf(&quot;Failed to read input ABIs from STDIN: %v\n&quot;, err)</div><div class="line">				os.Exit(-1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for name, contract := range contracts &#123;</div><div class="line">			if exclude[strings.ToLower(name)] &#123;</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			abi, _ := json.Marshal(contract.Info.AbiDefinition) // Flatten the compiler parse</div><div class="line">			abis = append(abis, string(abi))</div><div class="line">			bins = append(bins, contract.Code)</div><div class="line"></div><div class="line">			nameParts := strings.Split(name, &quot;:&quot;)</div><div class="line">			types = append(types, nameParts[len(nameParts)-1])</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		abi, err := ioutil.ReadFile(*abiFlag)</div><div class="line">		if err != nil &#123;</div><div class="line">			fmt.Printf(&quot;Failed to read input ABI: %v\n&quot;, err)</div><div class="line">			os.Exit(-1)</div><div class="line">		&#125;</div><div class="line">		abis = append(abis, string(abi))</div><div class="line"></div><div class="line">		bin := []byte&#123;&#125;</div><div class="line">		if *binFlag != &quot;&quot; &#123;</div><div class="line">			if bin, err = ioutil.ReadFile(*binFlag); err != nil &#123;</div><div class="line">				fmt.Printf(&quot;Failed to read input bytecode: %v\n&quot;, err)</div><div class="line">				os.Exit(-1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		bins = append(bins, string(bin))</div><div class="line"></div><div class="line">		kind := *typFlag</div><div class="line">		if kind == &quot;&quot; &#123;</div><div class="line">			kind = *pkgFlag</div><div class="line">		&#125;</div><div class="line">		types = append(types, kind)</div><div class="line">	&#125;</div><div class="line">	code, err := bind.Bind(types, abis, bins, *pkgFlag, lang)</div><div class="line">	if err != nil &#123;</div><div class="line">		fmt.Printf(&quot;Failed to generate ABI binding: %v\n&quot;, err)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125;</div><div class="line">	if *outFlag == &quot;&quot; &#123;</div><div class="line">		fmt.Printf(&quot;%s\n&quot;, code)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if err := ioutil.WriteFile(*outFlag, []byte(code), 0600); err != nil &#123;</div><div class="line">		fmt.Printf(&quot;Failed to write ABI binding: %v\n&quot;, err)</div><div class="line">		os.Exit(-1)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>abigen</code> 命令的源码很简单，实际上就是调用 <code>accounts/abi</code> 以及 Solidity 编译器，主要的实现还是在 <code>accounts/abi</code> 里，这部分我们在后面的文章会继续深入。</p>
<h2 id="bootnode"><a href="#bootnode" class="headerlink" title="bootnode"></a>bootnode</h2><p>bootnode 是 geth 客户端的精简版本，只实现了网络节点发现协议，不运行更高级别的应用协议。它可以用作轻量级引导节点，帮助在私有网络中查找 peers。</p>
<p>以太坊在启动时至少需要一个对等节点，这样才能接入整个以太坊网络，bootnode 相当于一个第三方的中介，node 在启动时会将自己的信息注册到 bootnode 的路由中，并且会从 bootnode 得到其它节点的路由信息，一旦有了对等节点信息后就可以不需要连接 bootnode。公有链的节点硬编码了一些 bootnode 节点地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">	var (</div><div class="line">		listenAddr  = flag.String(&quot;addr&quot;, &quot;:30301&quot;, &quot;listen address&quot;)</div><div class="line">		genKey      = flag.String(&quot;genkey&quot;, &quot;&quot;, &quot;generate a node key&quot;)</div><div class="line">		writeAddr   = flag.Bool(&quot;writeaddress&quot;, false, &quot;write out the node&apos;s pubkey hash and quit&quot;)</div><div class="line">		nodeKeyFile = flag.String(&quot;nodekey&quot;, &quot;&quot;, &quot;private key filename&quot;)</div><div class="line">		nodeKeyHex  = flag.String(&quot;nodekeyhex&quot;, &quot;&quot;, &quot;private key as hex (for testing)&quot;)</div><div class="line">		natdesc     = flag.String(&quot;nat&quot;, &quot;none&quot;, &quot;port mapping mechanism (any|none|upnp|pmp|extip:&lt;IP&gt;)&quot;)</div><div class="line">		netrestrict = flag.String(&quot;netrestrict&quot;, &quot;&quot;, &quot;restrict network communication to the given IP networks (CIDR masks)&quot;)</div><div class="line">		runv5       = flag.Bool(&quot;v5&quot;, false, &quot;run a v5 topic discovery bootnode&quot;)</div><div class="line">		verbosity   = flag.Int(&quot;verbosity&quot;, int(log.LvlInfo), &quot;log verbosity (0-9)&quot;)</div><div class="line">		vmodule     = flag.String(&quot;vmodule&quot;, &quot;&quot;, &quot;log verbosity pattern&quot;)</div><div class="line"></div><div class="line">		nodeKey *ecdsa.PrivateKey</div><div class="line">		err     error</div><div class="line">	)</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	glogger := log.NewGlogHandler(log.StreamHandler(os.Stderr, log.TerminalFormat(false)))</div><div class="line">	glogger.Verbosity(log.Lvl(*verbosity))</div><div class="line">	glogger.Vmodule(*vmodule)</div><div class="line">	log.Root().SetHandler(glogger)</div><div class="line"></div><div class="line">	natm, err := nat.Parse(*natdesc)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;-nat: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	switch &#123;</div><div class="line">	case *genKey != &quot;&quot;:</div><div class="line">		nodeKey, err = crypto.GenerateKey()</div><div class="line">		if err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;could not generate key: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		if err = crypto.SaveECDSA(*genKey, nodeKey); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		return</div><div class="line">	case *nodeKeyFile == &quot;&quot; &amp;&amp; *nodeKeyHex == &quot;&quot;:</div><div class="line">		utils.Fatalf(&quot;Use -nodekey or -nodekeyhex to specify a private key&quot;)</div><div class="line">	case *nodeKeyFile != &quot;&quot; &amp;&amp; *nodeKeyHex != &quot;&quot;:</div><div class="line">		utils.Fatalf(&quot;Options -nodekey and -nodekeyhex are mutually exclusive&quot;)</div><div class="line">	case *nodeKeyFile != &quot;&quot;:</div><div class="line">		if nodeKey, err = crypto.LoadECDSA(*nodeKeyFile); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;-nodekey: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	case *nodeKeyHex != &quot;&quot;:</div><div class="line">		if nodeKey, err = crypto.HexToECDSA(*nodeKeyHex); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;-nodekeyhex: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if *writeAddr &#123;</div><div class="line">		fmt.Printf(&quot;%v\n&quot;, discover.PubkeyID(&amp;nodeKey.PublicKey))</div><div class="line">		os.Exit(0)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var restrictList *netutil.Netlist</div><div class="line">	if *netrestrict != &quot;&quot; &#123;</div><div class="line">		restrictList, err = netutil.ParseNetlist(*netrestrict)</div><div class="line">		if err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;-netrestrict: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	addr, err := net.ResolveUDPAddr(&quot;udp&quot;, *listenAddr)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;-ResolveUDPAddr: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	conn, err := net.ListenUDP(&quot;udp&quot;, addr)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;-ListenUDP: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	realaddr := conn.LocalAddr().(*net.UDPAddr)</div><div class="line">	if natm != nil &#123;</div><div class="line">		if !realaddr.IP.IsLoopback() &#123;</div><div class="line">			go nat.Map(natm, nil, &quot;udp&quot;, realaddr.Port, realaddr.Port, &quot;ethereum discovery&quot;)</div><div class="line">		&#125;</div><div class="line">		if ext, err := natm.ExternalIP(); err == nil &#123;</div><div class="line">			realaddr = &amp;net.UDPAddr&#123;IP: ext, Port: realaddr.Port&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if *runv5 &#123;</div><div class="line">		if _, err := discv5.ListenUDP(nodeKey, conn, realaddr, &quot;&quot;, restrictList); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		cfg := discover.Config&#123;</div><div class="line">			PrivateKey:   nodeKey,</div><div class="line">			AnnounceAddr: realaddr,</div><div class="line">			NetRestrict:  restrictList,</div><div class="line">		&#125;</div><div class="line">		if _, err := discover.ListenUDP(conn, cfg); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	select &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码里可以看到，这部分功能主要来自于 p2p 模块。后续我们会深入到该模块。</p>
<h2 id="clef"><a href="#clef" class="headerlink" title="clef"></a>clef</h2><p>clef 可以用来签署交易和数据，并且可以代替 geth 的账户管理。这部分代码我没有深入研究，看起来像是账户管理的另一种封装，实际的实现在 signer 目录下。</p>
<p>可以参考：<a href="https://github.com/holiman/qtsigner/" target="_blank" rel="external">A Python/QT based graphical user interface for the ethereum signer</a></p>
<h2 id="ethkey"><a href="#ethkey" class="headerlink" title="ethkey"></a>ethkey</h2><p>ethkey 是一个可以用来操作以太坊 keyfile 的工具。 </p>
<h2 id="evm"><a href="#evm" class="headerlink" title="evm"></a>evm</h2><p>对 evm 进行一些封装</p>
<p>执行合约前，将 Transaction 类型转化为 message，创建虚拟机（EVM）对象，计算一些 Gas 消耗，执行交易完毕后创建收据（Recipet）对象返回。</p>
<h2 id="faucet"><a href="#faucet" class="headerlink" title="faucet"></a>faucet</h2><p>faucet 测试网相关代码。</p>
<p>参考：<a href="https://faucet.rinkeby.io" target="_blank" rel="external">https://faucet.rinkeby.io</a> 和 <a href="https://coincentral.com/ethereum-faucets/" target="_blank" rel="external">https://coincentral.com/ethereum-faucets/</a></p>
<h2 id="p2psim"><a href="#p2psim" class="headerlink" title="p2psim"></a>p2psim</h2><p>模拟 p2p API 请求的工具</p>
<h2 id="puppeth"><a href="#puppeth" class="headerlink" title="puppeth"></a>puppeth</h2><p>用于搭建，维护私有链</p>
<h2 id="rlpdump"><a href="#rlpdump" class="headerlink" title="rlpdump"></a>rlpdump</h2><p>RLP 是 Recursive Length Prefix 的简写。是以太坊中的序列化方法。这个模块的作用是提供 RLP 数据的格式化输出。</p>
<h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p>swarm 是一个去中心化的内容存储和分发服务，这个模块是其命令行客户端。没有细看这部分代码，swarm 看起来很像 ipfs，而且代码还在快速迭代中，就不展开了。</p>
<p><a href="https://github.com/ethersphere/go-ethereum/wiki/IPFS-&amp;-SWARM" target="_blank" rel="external">IPFS &amp; SWARM</a></p>
<h2 id="wnode"><a href="#wnode" class="headerlink" title="wnode"></a>wnode</h2><p>这是一个简单的 Whisper 节点。它可以用作独立的引导节点，还可以用于不同的测试和诊断目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">	processArgs()</div><div class="line">	initialize()</div><div class="line">	run()</div><div class="line">	shutdown()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cmd 模块下的其他命令的资料相对于 geth 命令的资料还是很少的，而且有几个工具看起来有个人开发工具的性质，看起来很有用。可能使用的人很少，没法集成到 geth 成为一个子命令，但不集成为一个单独的命令又太可惜；有的工具只是某些功能的一个封装，还有的是项目外的工具的封装，例如 Solidity，Swarm。如果未来对以太坊的功能，代码比较熟悉了，需要自己封装一个工具，这些代码是很有参考价值的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.cnblogs.com/baizx/p/7469125.html" target="_blank" rel="external">以太坊系列之十六: 使用golang与智能合约进行交互</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/wiki/Diagnostic-Tool-wnode" target="_blank" rel="external">Diagnostic Tool wnode</a></li>
<li><a href="https://solidity.readthedocs.io/en/develop/abi-spec.html#application-binary-interface-specification" target="_blank" rel="external">Application Binary Interface Specification</a></li>
<li><a href="https://bitshuo.com/topic/594a8c228e822fcb444317ec" target="_blank" rel="external">以太坊源码分析（3）深入解析ABI</a></li>
<li><a href="https://bitshuo.com/topic/58b41a0408d6a0f32a5bc0b7" target="_blank" rel="external">Ethereum的ABI详解</a></li>
<li><a href="http://qjpcpu.github.io/blog/2018/02/07/shen-ru-ethereumyuan-ma-whisperxie-yi-jie-du/" target="_blank" rel="external">深入ethereum源码-whisper协议解读</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27574253" target="_blank" rel="external">合约的另一种调用方式——IPC</a></li>
<li><a href="http://8btc.com/thread-31358-1-1.html" target="_blank" rel="external">DAG有向无环图是什么？</a></li>
<li><a href="https://g2ex.github.io/2017/09/12/ethereum-guidance/" target="_blank" rel="external">以太坊私有链搭建指南</a></li>
<li><a href="http://blog.csdn.net/DDFFR/article/details/78925410" target="_blank" rel="external">以太坊bootnode测试</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmd 包中除了 ethereum cli 客户端还包括很多其他可执行命令。下面我们将一一分析这些子命令，与上一篇 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（cmd 模块-geth 命令）&lt;/a&gt;一样，我们不会深入到其他模块中，这一篇仅限于 cmd 模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（cmd 模块-geth 命令）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（cmd 模块-geth 命令）/</id>
    <published>2018-03-10T14:34:58.000Z</published>
    <updated>2018-09-08T13:59:16.858Z</updated>
    
    <content type="html"><![CDATA[<p>cmd 模块包含了很多子模块，基本上每个子模块表示一个可执行的命令，其中最重要的是 geth 命令，它是以太坊的命令行客户端。</p>
<p>geth 命令是以太坊提供的一个强大的命令行工具，它是使用以太坊的入口。它包括了很多子命令，你可以通过 <code>geth --help</code> 获得更多帮助信息。其运行方法是：<code>geth [选项] 命令 [命令选项][参数…]</code>。</p>
<a id="more"></a>
<p>以下是 geth 包含的子命令以及对应的简单描述。</p>
<table>
<thead>
<tr>
<th style="text-align:center">子命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">account</td>
<td style="text-align:center">管理账户</td>
</tr>
<tr>
<td style="text-align:center">attach</td>
<td style="text-align:center">启动交互式JavaScript环境（连接到节点）</td>
</tr>
<tr>
<td style="text-align:center">bug</td>
<td style="text-align:center">给 github 源代码仓库提 issue</td>
</tr>
<tr>
<td style="text-align:center">console</td>
<td style="text-align:center">启动交互式 JavaScript 环境</td>
</tr>
<tr>
<td style="text-align:center">copydb</td>
<td style="text-align:center">从文件夹创建本地链</td>
</tr>
<tr>
<td style="text-align:center">dump</td>
<td style="text-align:center">取出一个特定的区块</td>
</tr>
<tr>
<td style="text-align:center">dumpconfig</td>
<td style="text-align:center">显示配置值</td>
</tr>
<tr>
<td style="text-align:center">export</td>
<td style="text-align:center">导出区块链到文件</td>
</tr>
<tr>
<td style="text-align:center">import</td>
<td style="text-align:center">导入一个区块链文件</td>
</tr>
<tr>
<td style="text-align:center">init</td>
<td style="text-align:center">启动并初始化一个新的创世纪块</td>
</tr>
<tr>
<td style="text-align:center">js</td>
<td style="text-align:center">执行指定的JavaScript文件(多个)</td>
</tr>
<tr>
<td style="text-align:center">license</td>
<td style="text-align:center">显示许可信息</td>
</tr>
<tr>
<td style="text-align:center">makecache</td>
<td style="text-align:center">生成ethash验证缓存(用于测试)</td>
</tr>
<tr>
<td style="text-align:center">makedag</td>
<td style="text-align:center">生成ethash 挖矿DAG(用于测试)</td>
</tr>
<tr>
<td style="text-align:center">monitor</td>
<td style="text-align:center">监控和可视化节点指标</td>
</tr>
<tr>
<td style="text-align:center">removedb</td>
<td style="text-align:center">删除区块链和状态数据库</td>
</tr>
<tr>
<td style="text-align:center">version</td>
<td style="text-align:center">打印版本号</td>
</tr>
<tr>
<td style="text-align:center">wallet</td>
<td style="text-align:center">管理Ethereum预售钱包</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">显示一个命令或帮助一个命令列表</td>
</tr>
</tbody>
</table>
<p>本文将逐一分析 geth 模块的源码，了解 geth 命令的实现原理。需要注意的是，这里我们不会深入分析每一个模块，因为这些模块的实现实际上是以太坊每个功能模块的实现，在后续的文章我们会一一分析。这里只分析 geth 命令的实现。</p>
<p>将涉及到 cmd, node 目录。</p>
<p>geth 的命令行是通过 <a href="https://github.com/urfave/cli" target="_blank" rel="external">github.com/urfave/cli</a> 这个库实现的，通过这个库，我们可以轻松定义命令行程序的子命令，命令选项，命令参数，描述信息等等，如果想要进一步了解，可以查看该库文档。</p>
<p>geth 模块的入口在 <code>cmd/geth/main.go</code> 中，它会调用 <code>urfave/cli</code> 的中 app 的 <code>run</code> 方法，而 app 在 <code>init</code> 函数中初始化，在 Golang 中，如果有 <code>init</code> 方法，那么会在 <code>main</code> 函数之前执行 <code>init</code> 函数，它用于程序执行前的初始化工作。在 geth 模块中，<code>init()</code> 函数定义了命令行的入口是 <code>geth</code>，并且定义了 geth 的子命令、全局的命令选项、子命令的命令选项，按照 <code>urfave/cli</code> 的做法，不输入子命令会默认调用 geth，而 geth 方法其实就6行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func geth(ctx *cli.Context) error &#123;</div><div class="line">	node := makeFullNode(ctx)</div><div class="line">	startNode(ctx, node)</div><div class="line">	node.Wait()</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会调用 <code>makeFullNode</code> 函数初始化一个全节点，该方法在 <code>geth/config.go</code> 中，接着通过 <code>startNode</code> 函数启动一个全节点，以阻塞的方式运行，等待着节点被终止。</p>
<p>我们先深入到 <code>makeFullNode</code> 函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func makeFullNode(ctx *cli.Context) *node.Node &#123;</div><div class="line">	stack, cfg := makeConfigNode(ctx)</div><div class="line">	utils.RegisterEthService(stack, &amp;cfg.Eth)</div><div class="line">	if ctx.GlobalBool(utils.DashboardEnabledFlag.Name) &#123;</div><div class="line">		utils.RegisterDashboardService(stack, &amp;cfg.Dashboard, gitCommit)</div><div class="line">	&#125;</div><div class="line">	// whether enable whisper ...</div><div class="line">	// whether register eth stats ...</div><div class="line">	return stack</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心的逻辑是首先通过配置文件和 flag 生成系统级的配置，然后将服务注入到节点。<br>先说 <code>makeConfigNode</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func makeConfigNode(ctx *cli.Context) (*node.Node, gethConfig) &#123;</div><div class="line">	cfg := gethConfig&#123;</div><div class="line">		Eth:       eth.DefaultConfig,</div><div class="line">		Shh:       whisper.DefaultConfig,</div><div class="line">		Node:      defaultNodeConfig(),</div><div class="line">		Dashboard: dashboard.DefaultConfig,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if file := ctx.GlobalString(configFileFlag.Name); file != &quot;&quot; &#123;</div><div class="line">		if err := loadConfig(file, &amp;cfg); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	stack, err := node.New(&amp;cfg.Node)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to create the protocol stack: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	utils.SetEthConfig(ctx, stack, &amp;cfg.Eth)</div><div class="line">	if ctx.GlobalIsSet(utils.EthStatsURLFlag.Name) &#123;</div><div class="line">		cfg.Ethstats.URL = ctx.GlobalString(utils.EthStatsURLFlag.Name)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	utils.SetShhConfig(ctx, stack, &amp;cfg.Shh)</div><div class="line">	utils.SetDashboardConfig(ctx, &amp;cfg.Dashboard)</div><div class="line"></div><div class="line">	return stack, cfg</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>makeConfigNode</code> 会先载入默认配置，再载入配置文件中的配置，然后通过上下文的配置(在 <code>cmd/geth/main.go</code> 中的 <code>init</code> 方法中定义)进行设置。我们深入到 <code>RegisterEthService</code> 方法来查看服务是如何注入到节点中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func RegisterEthService(stack *node.Node, cfg *eth.Config) &#123;</div><div class="line">	var err error</div><div class="line">	if cfg.SyncMode == downloader.LightSync &#123;</div><div class="line">		err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) &#123;</div><div class="line">			return les.New(ctx, cfg)</div><div class="line">		&#125;)</div><div class="line">	&#125; else &#123;</div><div class="line">		err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) &#123;</div><div class="line">			fullNode, err := eth.New(ctx, cfg)</div><div class="line">			if fullNode != nil &amp;&amp; cfg.LightServ &gt; 0 &#123;</div><div class="line">				ls, _ := les.NewLesServer(fullNode, cfg)</div><div class="line">				fullNode.AddLesServer(ls)</div><div class="line">			&#125;</div><div class="line">			return fullNode, err</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">	if err != nil &#123;</div><div class="line">		Fatalf(&quot;Failed to register the Ethereum service: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RegisterEthService</code> 的代码在 <code>cmd/utils/flags.go</code> 中，如果同步模式是轻量级同步模式，启动轻量级客户端，否则启动全节点，实际的注册方法是 <code>stack.Register</code>。注入服务其实就是将新的服务注入到 <code>node</code> 对象的 <code>serviceFuncs</code> 数组中。这些内容将<a href="#TODO">go-ethereum 源码笔记（node 模块）</a> 描述。</p>
<p>接下来我们继续看 <code>geth/main.go</code> 的 <code>startNode</code> 函数，看看如何启动节点，这个方法在 <code>cmd/geth/main.go</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">func startNode(ctx *cli.Context, stack *node.Node) &#123;</div><div class="line">	debug.Memsize.Add(&quot;node&quot;, stack)</div><div class="line">	utils.StartNode(stack)</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[0].(*keystore.KeyStore)</div><div class="line"></div><div class="line">	passwords := utils.MakePasswordList(ctx)</div><div class="line">	unlocks := strings.Split(ctx.GlobalString(utils.UnlockedAccountFlag.Name), &quot;,&quot;)</div><div class="line">	for i, account := range unlocks &#123;</div><div class="line">		if trimmed := strings.TrimSpace(account); trimmed != &quot;&quot; &#123;</div><div class="line">			unlockAccount(ctx, ks, trimmed, i, passwords)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	events := make(chan accounts.WalletEvent, 16)</div><div class="line">	stack.AccountManager().Subscribe(events)</div><div class="line"></div><div class="line">	go func() &#123;</div><div class="line">		rpcClient, err := stack.Attach()</div><div class="line">		if err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Failed to attach to self: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		stateReader := ethclient.NewClient(rpcClient)</div><div class="line"></div><div class="line">		for _, wallet := range stack.AccountManager().Wallets() &#123;</div><div class="line">			if err := wallet.Open(&quot;&quot;); err != nil &#123;</div><div class="line">				log.Warn(&quot;Failed to open wallet&quot;, &quot;url&quot;, wallet.URL(), &quot;err&quot;, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for event := range events &#123;</div><div class="line">			switch event.Kind &#123;</div><div class="line">			case accounts.WalletArrived:</div><div class="line">				if err := event.Wallet.Open(&quot;&quot;); err != nil &#123;</div><div class="line">					log.Warn(&quot;New wallet appeared, failed to open&quot;, &quot;url&quot;, event.Wallet.URL(), &quot;err&quot;, err)</div><div class="line">				&#125;</div><div class="line">			case accounts.WalletOpened:</div><div class="line">				status, _ := event.Wallet.Status()</div><div class="line">				log.Info(&quot;New wallet appeared&quot;, &quot;url&quot;, event.Wallet.URL(), &quot;status&quot;, status)</div><div class="line"></div><div class="line">				if event.Wallet.URL().Scheme == &quot;ledger&quot; &#123;</div><div class="line">					event.Wallet.SelfDerive(accounts.DefaultLedgerBaseDerivationPath, stateReader)</div><div class="line">				&#125; else &#123;</div><div class="line">					event.Wallet.SelfDerive(accounts.DefaultBaseDerivationPath, stateReader)</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			case accounts.WalletDropped:</div><div class="line">				log.Info(&quot;Old wallet dropped&quot;, &quot;url&quot;, event.Wallet.URL())</div><div class="line">				event.Wallet.Close()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	if ctx.GlobalBool(utils.MiningEnabledFlag.Name) || ctx.GlobalBool(utils.DeveloperFlag.Name) &#123;</div><div class="line">		if ctx.GlobalBool(utils.LightModeFlag.Name) || ctx.GlobalString(utils.SyncModeFlag.Name) == &quot;light&quot; &#123;</div><div class="line">			utils.Fatalf(&quot;Light clients do not support mining&quot;)</div><div class="line">		&#125;</div><div class="line">		var ethereum *eth.Ethereum</div><div class="line">		if err := stack.Service(&amp;ethereum); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Ethereum service not running: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		if threads := ctx.GlobalInt(utils.MinerThreadsFlag.Name); threads &gt; 0 &#123;</div><div class="line">			type threaded interface &#123;</div><div class="line">				SetThreads(threads int)</div><div class="line">			&#125;</div><div class="line">			if th, ok := ethereum.Engine().(threaded); ok &#123;</div><div class="line">				th.SetThreads(threads)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ethereum.TxPool().SetGasPrice(utils.GlobalBig(ctx, utils.GasPriceFlag.Name))</div><div class="line">		if err := ethereum.StartMining(true); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Failed to start mining: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>startNode</code> 方法启动节点，会开启所有已经注册的协议，解锁请求的账户，开启 RPC/IPC 接口，并开始挖矿。这里我们不再深入。</p>
<p>举两个例子。想要查阅某个命令或某些参数的帮助信息，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ geth --help</div></pre></td></tr></table></figure>
<p>查看各种命令，参数的提示信息。</p>
<p>如果想要启动一条私有链，可以使用下面的命令进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ geth  --datadir &quot;./&quot; init genesis.json</div></pre></td></tr></table></figure>
<p>其中 genesis.json 是创始区块的配置信息。</p>
<p>然后执行下面的命令，创建私有链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ geth --datadir &quot;./&quot; --nodiscover console 2&gt;&gt;geth.log</div></pre></td></tr></table></figure>
<p>上述就是直接运行 geth，不输入其他子命令的情况。geth 还有很多子命令，这些子命令在 <code>init()</code> 的 <code>app.Commands</code> 赋值语句中可以看到，接下来会概述这些子命令。</p>
<h2 id="chaincmd-go"><a href="#chaincmd-go" class="headerlink" title="chaincmd.go"></a>chaincmd.go</h2><h3 id="initCommand-geth-init"><a href="#initCommand-geth-init" class="headerlink" title="initCommand: geth init"></a>initCommand: geth init</h3><p>这个命令会进行初始化，生成创始区块。对应调用的方法是 <code>initGenesis</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func initGenesis(ctx *cli.Context) error &#123;</div><div class="line">	genesisPath := ctx.Args().First()</div><div class="line">	if len(genesisPath) == 0 &#123;</div><div class="line">		utils.Fatalf(&quot;Must supply path to genesis JSON file&quot;)</div><div class="line">	&#125;</div><div class="line">	file, err := os.Open(genesisPath)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read genesis file: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer file.Close()</div><div class="line"></div><div class="line">	genesis := new(core.Genesis)</div><div class="line">	if err := json.NewDecoder(file).Decode(genesis); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;invalid genesis file: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	for _, name := range []string&#123;&quot;chaindata&quot;, &quot;lightchaindata&quot;&#125; &#123;</div><div class="line">		chaindb, err := stack.OpenDatabase(name, 0, 0)</div><div class="line">		if err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Failed to open database: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		_, hash, err := core.SetupGenesisBlock(chaindb, genesis)</div><div class="line">		if err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Failed to write genesis block: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">		log.Info(&quot;Successfully wrote genesis state&quot;, &quot;database&quot;, name, &quot;hash&quot;, hash)</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终会调用 <code>core/geth/chaincmd</code> 的 <code>SetupGenesisBlock</code>，这里具体的实现细节我们将在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 介绍。</p>
<h3 id="importCommand-geth-import"><a href="#importCommand-geth-import" class="headerlink" title="importCommand: geth import"></a>importCommand: geth import</h3><p>导入一个区块链文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">func importChain(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) &lt; 1 &#123;</div><div class="line">		utils.Fatalf(&quot;This command requires an argument.&quot;)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, stack)</div><div class="line">	defer chainDb.Close()</div><div class="line"></div><div class="line">	var peakMemAlloc, peakMemSys uint64</div><div class="line">	go func() &#123;</div><div class="line">		stats := new(runtime.MemStats)</div><div class="line">		for &#123;</div><div class="line">			runtime.ReadMemStats(stats)</div><div class="line">			if atomic.LoadUint64(&amp;peakMemAlloc) &lt; stats.Alloc &#123;</div><div class="line">				atomic.StoreUint64(&amp;peakMemAlloc, stats.Alloc)</div><div class="line">			&#125;</div><div class="line">			if atomic.LoadUint64(&amp;peakMemSys) &lt; stats.Sys &#123;</div><div class="line">				atomic.StoreUint64(&amp;peakMemSys, stats.Sys)</div><div class="line">			&#125;</div><div class="line">			time.Sleep(5 * time.Second)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	if len(ctx.Args()) == 1 &#123;</div><div class="line">		if err := utils.ImportChain(chain, ctx.Args().First()); err != nil &#123;</div><div class="line">			log.Error(&quot;Import error&quot;, &quot;err&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		for _, arg := range ctx.Args() &#123;</div><div class="line">			if err := utils.ImportChain(chain, arg); err != nil &#123;</div><div class="line">				log.Error(&quot;Import error&quot;, &quot;file&quot;, arg, &quot;err&quot;, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	chain.Stop()</div><div class="line">	fmt.Printf(&quot;Import done in %v.\n\n&quot;, time.Since(start))</div><div class="line"></div><div class="line">	db := chainDb.(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	stats, err := db.LDB().GetProperty(&quot;leveldb.stats&quot;)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read database stats: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(stats)</div><div class="line"></div><div class="line">	ioStats, err := db.LDB().GetProperty(&quot;leveldb.iostats&quot;)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read database iostats: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(ioStats)</div><div class="line"></div><div class="line">	fmt.Printf(&quot;Trie cache misses:  %d\n&quot;, trie.CacheMisses())</div><div class="line">	fmt.Printf(&quot;Trie cache unloads: %d\n\n&quot;, trie.CacheUnloads())</div><div class="line"></div><div class="line">	mem := new(runtime.MemStats)</div><div class="line">	runtime.ReadMemStats(mem)</div><div class="line"></div><div class="line">	fmt.Printf(&quot;Object memory: %.3f MB current, %.3f MB peak\n&quot;, float64(mem.Alloc)/1024/1024, float64(atomic.LoadUint64(&amp;peakMemAlloc))/1024/1024)</div><div class="line">	fmt.Printf(&quot;System memory: %.3f MB current, %.3f MB peak\n&quot;, float64(mem.Sys)/1024/1024, float64(atomic.LoadUint64(&amp;peakMemSys))/1024/1024)</div><div class="line">	fmt.Printf(&quot;Allocations:   %.3f million\n&quot;, float64(mem.Mallocs)/1000000)</div><div class="line">	fmt.Printf(&quot;GC pause:      %v\n\n&quot;, time.Duration(mem.PauseTotalNs))</div><div class="line"></div><div class="line">	if ctx.GlobalIsSet(utils.NoCompactionFlag.Name) &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	fmt.Println(&quot;Compacting entire database...&quot;)</div><div class="line">	if err = db.LDB().CompactRange(util.Range&#123;&#125;); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Compaction failed: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Compaction done in %v.\n\n&quot;, time.Since(start))</div><div class="line"></div><div class="line">	stats, err = db.LDB().GetProperty(&quot;leveldb.stats&quot;)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read database stats: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(stats)</div><div class="line"></div><div class="line">	ioStats, err = db.LDB().GetProperty(&quot;leveldb.iostats&quot;)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read database iostats: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(ioStats)</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正的逻辑在 <code>utils/cmd.go</code> 中的 <code>ImportChain</code>。</p>
<h3 id="exportCommand-geth-export"><a href="#exportCommand-geth-export" class="headerlink" title="exportCommand: geth export"></a>exportCommand: geth export</h3><p>导出一个区块链文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">func exportChain(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) &lt; 1 &#123;</div><div class="line">		utils.Fatalf(&quot;This command requires an argument.&quot;)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, _ := utils.MakeChain(ctx, stack)</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	var err error</div><div class="line">	fp := ctx.Args().First()</div><div class="line">	if len(ctx.Args()) &lt; 3 &#123;</div><div class="line">		err = utils.ExportChain(chain, fp)</div><div class="line">	&#125; else &#123;</div><div class="line">		first, ferr := strconv.ParseInt(ctx.Args().Get(1), 10, 64)</div><div class="line">		last, lerr := strconv.ParseInt(ctx.Args().Get(2), 10, 64)</div><div class="line">		if ferr != nil || lerr != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Export error in parsing parameters: block number not an integer\n&quot;)</div><div class="line">		&#125;</div><div class="line">		if first &lt; 0 || last &lt; 0 &#123;</div><div class="line">			utils.Fatalf(&quot;Export error: block number must be greater than 0\n&quot;)</div><div class="line">		&#125;</div><div class="line">		err = utils.ExportAppendChain(chain, fp, uint64(first), uint64(last))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Export error: %v\n&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Export done in %v\n&quot;, time.Since(start))</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>导出区块链的真正逻辑在 <code>utils/cmd.go</code> 中的 <code>ExportChain</code> 里。将导出一个 gz 文件。</p>
<h3 id="importPreimagesCommand-geth-import-preimages"><a href="#importPreimagesCommand-geth-import-preimages" class="headerlink" title="importPreimagesCommand: geth import-preimages"></a>importPreimagesCommand: geth import-preimages</h3><p>将一个 preimages 导入当前节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func importPreimages(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) &lt; 1 &#123;</div><div class="line">		utils.Fatalf(&quot;This command requires an argument.&quot;)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	diskdb := utils.MakeChainDatabase(ctx, stack).(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	if err := utils.ImportPreimages(diskdb, ctx.Args().First()); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Export error: %v\n&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Export done in %v\n&quot;, time.Since(start))</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="exportPreimagesCommand-geth-export-preimages"><a href="#exportPreimagesCommand-geth-export-preimages" class="headerlink" title="exportPreimagesCommand: geth export-preimages"></a>exportPreimagesCommand: geth export-preimages</h3><p>从当前节点导出一个 image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func exportPreimages(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) &lt; 1 &#123;</div><div class="line">		utils.Fatalf(&quot;This command requires an argument.&quot;)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	diskdb := utils.MakeChainDatabase(ctx, stack).(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	if err := utils.ExportPreimages(diskdb, ctx.Args().First()); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Export error: %v\n&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Export done in %v\n&quot;, time.Since(start))</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="copydbCommand-geth-copydb"><a href="#copydbCommand-geth-copydb" class="headerlink" title="copydbCommand: geth copydb"></a>copydbCommand: <code>geth copydb</code></h3><p>复制一个本地区块文件到文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">func copyDb(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) != 1 &#123;</div><div class="line">		utils.Fatalf(&quot;Source chaindata directory path argument missing&quot;)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, stack)</div><div class="line"></div><div class="line">	syncmode := *utils.GlobalTextMarshaler(ctx, utils.SyncModeFlag.Name).(*downloader.SyncMode)</div><div class="line">	dl := downloader.New(syncmode, chainDb, new(event.TypeMux), chain, nil, nil)</div><div class="line"></div><div class="line">	db, err := ethdb.NewLDBDatabase(ctx.Args().First(), ctx.GlobalInt(utils.CacheFlag.Name), 256)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	hc, err := core.NewHeaderChain(db, chain.Config(), chain.Engine(), func() bool &#123; return false &#125;)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	peer := downloader.NewFakePeer(&quot;local&quot;, db, hc, dl)</div><div class="line">	if err = dl.RegisterPeer(&quot;local&quot;, 63, peer); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	currentHeader := hc.CurrentHeader()</div><div class="line">	if err = dl.Synchronise(&quot;local&quot;, currentHeader.Hash(), hc.GetTd(currentHeader.Hash(), currentHeader.Number.Uint64()), syncmode); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	for dl.Synchronising() &#123;</div><div class="line">		time.Sleep(10 * time.Millisecond)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Database copy done in %v\n&quot;, time.Since(start))</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	fmt.Println(&quot;Compacting entire database...&quot;)</div><div class="line">	if err = chainDb.(*ethdb.LDBDatabase).LDB().CompactRange(util.Range&#123;&#125;); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Compaction failed: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Compaction done in %v.\n\n&quot;, time.Since(start))</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一个文件夹中创建一个本地区块链。有意思的是这个过程并不是直接复制过去的，而是通过 <code>downloader</code> 模块里的 <code>NewFakePeer</code> 创建一个虚拟对等节点，然后再进行数据同步完成的。</p>
<h3 id="removedbCommand-geth-removedb"><a href="#removedbCommand-geth-removedb" class="headerlink" title="removedbCommand: geth removedb"></a>removedbCommand: <code>geth removedb</code></h3><p>在当前数据库中移除区块链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func removeDB(ctx *cli.Context) error &#123;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line"></div><div class="line">	for _, name := range []string&#123;&quot;chaindata&quot;, &quot;lightchaindata&quot;&#125; &#123;</div><div class="line">		logger := log.New(&quot;database&quot;, name)</div><div class="line"></div><div class="line">		dbdir := stack.ResolvePath(name)</div><div class="line">		if !common.FileExist(dbdir) &#123;</div><div class="line">			logger.Info(&quot;Database doesn&apos;t exist, skipping&quot;, &quot;path&quot;, dbdir)</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		fmt.Println(dbdir)</div><div class="line">		confirm, err := console.Stdin.PromptConfirm(&quot;Remove this database?&quot;)</div><div class="line">		switch &#123;</div><div class="line">		case err != nil:</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		case !confirm:</div><div class="line">			logger.Warn(&quot;Database deletion aborted&quot;)</div><div class="line">		default:</div><div class="line">			start := time.Now()</div><div class="line">			os.RemoveAll(dbdir)</div><div class="line">			logger.Info(&quot;Database successfully deleted&quot;, &quot;elapsed&quot;, common.PrettyDuration(time.Since(start)))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除数据库的过程倒是比较干脆，直接通过 <code>os</code> 模块移除这个文件夹。</p>
<h3 id="dumpCommand-geth-dump-lt-blockHash-gt-lt-blockNum-gt"><a href="#dumpCommand-geth-dump-lt-blockHash-gt-lt-blockNum-gt" class="headerlink" title="dumpCommand: geth dump [&lt;blockHash&gt; | &lt;blockNum&gt;]..."></a>dumpCommand: <code>geth dump [&lt;blockHash&gt; | &lt;blockNum&gt;]...</code></h3><p>dump 子命令可以移除一个或多个特定的区块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func dump(ctx *cli.Context) error &#123;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, stack)</div><div class="line">	for _, arg := range ctx.Args() &#123;</div><div class="line">		var block *types.Block</div><div class="line">		if hashish(arg) &#123;</div><div class="line">			block = chain.GetBlockByHash(common.HexToHash(arg))</div><div class="line">		&#125; else &#123;</div><div class="line">			num, _ := strconv.Atoi(arg)</div><div class="line">			block = chain.GetBlockByNumber(uint64(num))</div><div class="line">		&#125;</div><div class="line">		if block == nil &#123;</div><div class="line">			fmt.Println(&quot;&#123;&#125;&quot;)</div><div class="line">			utils.Fatalf(&quot;block not found&quot;)</div><div class="line">		&#125; else &#123;</div><div class="line">			state, err := state.New(block.Root(), state.NewDatabase(chainDb))</div><div class="line">			if err != nil &#123;</div><div class="line">				utils.Fatalf(&quot;could not create new state: %v&quot;, err)</div><div class="line">			&#125;</div><div class="line">			fmt.Printf(&quot;%s\n&quot;, state.Dump())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	chainDb.Close()</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先根据区块号获取区块，然后调用 state 的 <code>Dump</code> 移除即可，这部分的实现在之后<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a>会有描述。</p>
<h2 id="monitorcmd-go"><a href="#monitorcmd-go" class="headerlink" title="monitorcmd.go"></a>monitorcmd.go</h2><p>这部分代码不是核心内容，只是粗略的看了一下。</p>
<h3 id="monitorComand-geth-monitor"><a href="#monitorComand-geth-monitor" class="headerlink" title="monitorComand: geth monitor"></a>monitorComand: <code>geth monitor</code></h3><p>监控，图像化节点 metrics 数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">func monitor(ctx *cli.Context) error &#123;</div><div class="line">	var (</div><div class="line">		client *rpc.Client</div><div class="line">		err    error</div><div class="line">	)</div><div class="line">	endpoint := ctx.String(monitorCommandAttachFlag.Name)</div><div class="line">	if client, err = dialRPC(endpoint); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Unable to attach to geth node: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer client.Close()</div><div class="line"></div><div class="line">	metrics, err := retrieveMetrics(client)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to retrieve system metrics: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	monitored := resolveMetrics(metrics, ctx.Args())</div><div class="line">	if len(monitored) == 0 &#123;</div><div class="line">		list := expandMetrics(metrics, &quot;&quot;)</div><div class="line">		sort.Strings(list)</div><div class="line"></div><div class="line">		if len(list) &gt; 0 &#123;</div><div class="line">			utils.Fatalf(&quot;No metrics specified.\n\nAvailable:\n - %s&quot;, strings.Join(list, &quot;\n - &quot;))</div><div class="line">		&#125; else &#123;</div><div class="line">			utils.Fatalf(&quot;No metrics collected by geth (--%s).\n&quot;, utils.MetricsEnabledFlag.Name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sort.Strings(monitored)</div><div class="line">	if cols := len(monitored) / ctx.Int(monitorCommandRowsFlag.Name); cols &gt; 6 &#123;</div><div class="line">		utils.Fatalf(&quot;Requested metrics (%d) spans more that 6 columns:\n - %s&quot;, len(monitored), strings.Join(monitored, &quot;\n - &quot;))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if err := termui.Init(); err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Unable to initialize terminal UI: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer termui.Close()</div><div class="line"></div><div class="line">	rows := len(monitored)</div><div class="line">	if max := ctx.Int(monitorCommandRowsFlag.Name); rows &gt; max &#123;</div><div class="line">		rows = max</div><div class="line">	&#125;</div><div class="line">	cols := (len(monitored) + rows - 1) / rows</div><div class="line">	for i := 0; i &lt; rows; i++ &#123;</div><div class="line">		termui.Body.AddRows(termui.NewRow())</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	footer := termui.NewPar(&quot;&quot;)</div><div class="line">	footer.Block.Border = true</div><div class="line">	footer.Height = 3</div><div class="line"></div><div class="line">	charts := make([]*termui.LineChart, len(monitored))</div><div class="line">	units := make([]int, len(monitored))</div><div class="line">	data := make([][]float64, len(monitored))</div><div class="line">	for i := 0; i &lt; len(monitored); i++ &#123;</div><div class="line">		charts[i] = createChart((termui.TermHeight() - footer.Height) / rows)</div><div class="line">		row := termui.Body.Rows[i%rows]</div><div class="line">		row.Cols = append(row.Cols, termui.NewCol(12/cols, 0, charts[i]))</div><div class="line">	&#125;</div><div class="line">	termui.Body.AddRows(termui.NewRow(termui.NewCol(12, 0, footer)))</div><div class="line"></div><div class="line">	refreshCharts(client, monitored, data, units, charts, ctx, footer)</div><div class="line">	termui.Body.Align()</div><div class="line">	termui.Render(termui.Body)</div><div class="line"></div><div class="line">	termui.Handle(&quot;/sys/kbd/C-c&quot;, func(termui.Event) &#123;</div><div class="line">		termui.StopLoop()</div><div class="line">	&#125;)</div><div class="line">	termui.Handle(&quot;/sys/wnd/resize&quot;, func(termui.Event) &#123;</div><div class="line">		termui.Body.Width = termui.TermWidth()</div><div class="line">		for _, chart := range charts &#123;</div><div class="line">			chart.Height = (termui.TermHeight() - footer.Height) / rows</div><div class="line">		&#125;</div><div class="line">		termui.Body.Align()</div><div class="line">		termui.Render(termui.Body)</div><div class="line">	&#125;)</div><div class="line">	go func() &#123;</div><div class="line">		tick := time.NewTicker(time.Duration(ctx.Int(monitorCommandRefreshFlag.Name)) * time.Second)</div><div class="line">		for range tick.C &#123;</div><div class="line">			if refreshCharts(client, monitored, data, units, charts, ctx, footer) &#123;</div><div class="line">				termui.Body.Align()</div><div class="line">			&#125;</div><div class="line">			termui.Render(termui.Body)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	termui.Loop()</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="accountcmd-go"><a href="#accountcmd-go" class="headerlink" title="accountcmd.go"></a>accountcmd.go</h2><h3 id="accountCommand"><a href="#accountCommand" class="headerlink" title="accountCommand"></a>accountCommand</h3><p>管理账户，这部分的实现在后续的博客<a href="https://knarfeh.com/2018/03/10/go-ethereum%20源码笔记（accounts,%20transaction%20模块）/" target="_blank" rel="external">go-ethereum 源码笔记（accounts, transaction 模块）</a>有描述。</p>
<h4 id="list-geth-account-list"><a href="#list-geth-account-list" class="headerlink" title="list: geth account list"></a>list: <code>geth account list</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func accountList(ctx *cli.Context) error &#123;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	var index int</div><div class="line">	for _, wallet := range stack.AccountManager().Wallets() &#123;</div><div class="line">		for _, account := range wallet.Accounts() &#123;</div><div class="line">			fmt.Printf(&quot;Account #%d: &#123;%x&#125; %s\n&quot;, index, account.Address, &amp;account.URL)</div><div class="line">			index++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <code>accounts/manager.go</code> 的 <code>Wallets</code> 拿到所有账户。</p>
<h4 id="new-geth-account-new"><a href="#new-geth-account-new" class="headerlink" title="new: geth account new"></a>new: <code>geth account new</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func accountCreate(ctx *cli.Context) error &#123;</div><div class="line">	cfg := gethConfig&#123;Node: defaultNodeConfig()&#125;</div><div class="line">	if file := ctx.GlobalString(configFileFlag.Name); file != &quot;&quot; &#123;</div><div class="line">		if err := loadConfig(file, &amp;cfg); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	scryptN, scryptP, keydir, err := cfg.Node.AccountConfig()</div><div class="line"></div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to read configuration: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	password := getPassPhrase(&quot;Your new account is locked with a password. Please give a password. Do not forget this password.&quot;, true, 0, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	address, err := keystore.StoreKey(keydir, password, scryptN, scryptP)</div><div class="line"></div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to create account: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Address: &#123;%x&#125;\n&quot;, address)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个账户，成功后输出地址。通过 <code>accounts</code> 模块实现。</p>
<h4 id="update：geth-account-update-lt-address-gt"><a href="#update：geth-account-update-lt-address-gt" class="headerlink" title="update：geth account update &lt;address&gt;"></a>update：<code>geth account update &lt;address&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func accountUpdate(ctx *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) == 0 &#123;</div><div class="line">		utils.Fatalf(&quot;No accounts specified to update&quot;)</div><div class="line">	&#125;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[0].(*keystore.KeyStore)</div><div class="line"></div><div class="line">	for _, addr := range ctx.Args() &#123;</div><div class="line">		account, oldPassword := unlockAccount(ctx, ks, addr, 0, nil)</div><div class="line">		newPassword := getPassPhrase(&quot;Please give a new password. Do not forget this password.&quot;, true, 0, nil)</div><div class="line">		if err := ks.Update(account, oldPassword, newPassword); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Could not update the account: %v&quot;, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先通过 <code>AccountManager</code> 拿到 keystore，然后调用 <code>Update</code> 更新密码</p>
<h4 id="import-geth-account-import-lt-keyfile-gt"><a href="#import-geth-account-import-lt-keyfile-gt" class="headerlink" title="import: geth account import &lt;keyfile&gt;"></a>import: <code>geth account import &lt;keyfile&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func accountImport(ctx *cli.Context) error &#123;</div><div class="line">	keyfile := ctx.Args().First()</div><div class="line">	if len(keyfile) == 0 &#123;</div><div class="line">		utils.Fatalf(&quot;keyfile must be given as argument&quot;)</div><div class="line">	&#125;</div><div class="line">	key, err := crypto.LoadECDSA(keyfile)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to load the private key: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	passphrase := getPassPhrase(&quot;Your new account is locked with a password. Please give a password. Do not forget this password.&quot;, true, 0, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[0].(*keystore.KeyStore)</div><div class="line">	acct, err := ks.ImportECDSA(key, passphrase)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Could not create the account: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Address: &#123;%x&#125;\n&quot;, acct.Address)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先通过 <code>AccountManager</code> 拿到 keystore，调用 <code>ImportPreSaleKey</code> 导入账户。</p>
<h3 id="walletCommand-geth-wallet-import-path-to-my-presale-wallet"><a href="#walletCommand-geth-wallet-import-path-to-my-presale-wallet" class="headerlink" title="walletCommand: geth wallet import /path/to/my/presale.wallet"></a>walletCommand: <code>geth wallet import /path/to/my/presale.wallet</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func importWallet(ctx *cli.Context) error &#123;</div><div class="line">	keyfile := ctx.Args().First()</div><div class="line">	if len(keyfile) == 0 &#123;</div><div class="line">		utils.Fatalf(&quot;keyfile must be given as argument&quot;)</div><div class="line">	&#125;</div><div class="line">	keyJSON, err := ioutil.ReadFile(keyfile)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Could not read wallet file: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	passphrase := getPassPhrase(&quot;&quot;, false, 0, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[0].(*keystore.KeyStore)</div><div class="line">	acct, err := ks.ImportPreSaleKey(keyJSON, passphrase)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;%v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(&quot;Address: &#123;%x&#125;\n&quot;, acct.Address)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>AccountManager</code> 管理以太坊预售钱包。</p>
<h2 id="consolecmd-go"><a href="#consolecmd-go" class="headerlink" title="consolecmd.go"></a>consolecmd.go</h2><h3 id="consoleCommand-geth-console"><a href="#consoleCommand-geth-console" class="headerlink" title="consoleCommand: geth console"></a>consoleCommand: <code>geth console</code></h3><p>启动一个 Javascript 交互式环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">func localConsole(ctx *cli.Context) error &#123;</div><div class="line">	node := makeFullNode(ctx)</div><div class="line">	startNode(ctx, node)</div><div class="line">	defer node.Stop()</div><div class="line"></div><div class="line">	client, err := node.Attach()</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to attach to the inproc geth: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to start the JavaScript console: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer console.Stop(false)</div><div class="line"></div><div class="line">	if script := ctx.GlobalString(utils.ExecFlag.Name); script != &quot;&quot; &#123;</div><div class="line">		console.Evaluate(script)</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	console.Welcome()</div><div class="line">	console.Interactive()</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动本地的一个交互式 Javascript 环境，功能是通过 <code>console</code> 模块提供的，而 <code>console</code> 模块是对 <a href="https://github.com/robertkrimen/otto" target="_blank" rel="external">robertkrimen/otto</a> 的一个封装。otto 是一个 Golang 实现的 Javascript 解释器，可以实现在 Golang 中执行 Javascript，并且可以让在虚拟机里的 Javascript 调用 Golang 函数，实现 Golang 和 Javascript 的相互操作。</p>
<h3 id="attachCommand"><a href="#attachCommand" class="headerlink" title="attachCommand"></a>attachCommand</h3><p>启动一个 JS 交互式环境(连接到节点)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">func remoteConsole(ctx *cli.Context) error &#123;</div><div class="line">	endpoint := ctx.Args().First()</div><div class="line">	if endpoint == &quot;&quot; &#123;</div><div class="line">		path := node.DefaultDataDir()</div><div class="line">		if ctx.GlobalIsSet(utils.DataDirFlag.Name) &#123;</div><div class="line">			path = ctx.GlobalString(utils.DataDirFlag.Name)</div><div class="line">		&#125;</div><div class="line">		if path != &quot;&quot; &#123;</div><div class="line">			if ctx.GlobalBool(utils.TestnetFlag.Name) &#123;</div><div class="line">				path = filepath.Join(path, &quot;testnet&quot;)</div><div class="line">			&#125; else if ctx.GlobalBool(utils.RinkebyFlag.Name) &#123;</div><div class="line">				path = filepath.Join(path, &quot;rinkeby&quot;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		endpoint = fmt.Sprintf(&quot;%s/geth.ipc&quot;, path)</div><div class="line">	&#125;</div><div class="line">	client, err := dialRPC(endpoint)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Unable to attach to remote geth: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to start the JavaScript console: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer console.Stop(false)</div><div class="line"></div><div class="line">	if script := ctx.GlobalString(utils.ExecFlag.Name); script != &quot;&quot; &#123;</div><div class="line">		console.Evaluate(script)</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console.Welcome()</div><div class="line">	console.Interactive()</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过指定 endpoint 的方式，连接到某个节点的交互式 Javascript 环境。</p>
<h3 id="javascriptCommand-geth-js-lt-jsfile-gt-jsfile"><a href="#javascriptCommand-geth-js-lt-jsfile-gt-jsfile" class="headerlink" title="javascriptCommand: geth js &lt;jsfile&gt; [jsfile...]"></a>javascriptCommand: <code>geth js &lt;jsfile&gt; [jsfile...]</code></h3><p>执行 Javascript 文件中的命令(可以为多个文件)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func ephemeralConsole(ctx *cli.Context) error &#123;</div><div class="line">	node := makeFullNode(ctx)</div><div class="line">	startNode(ctx, node)</div><div class="line">	defer node.Stop()</div><div class="line"></div><div class="line">	client, err := node.Attach()</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to attach to the inproc geth: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Failed to start the JavaScript console: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	defer console.Stop(false)</div><div class="line">	for _, file := range ctx.Args() &#123;</div><div class="line">		if err = console.Execute(file); err != nil &#123;</div><div class="line">			utils.Fatalf(&quot;Failed to execute %s: %v&quot;, file, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	abort := make(chan os.Signal, 1)</div><div class="line">	signal.Notify(abort, syscall.SIGINT, syscall.SIGTERM)</div><div class="line"></div><div class="line">	go func() &#123;</div><div class="line">		&lt;-abort</div><div class="line">		os.Exit(0)</div><div class="line">	&#125;()</div><div class="line">	console.Stop(true)</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过遍历调用传输的文件路径，执行 <code>console.Execute</code>，执行 js 命令。</p>
<h2 id="misccmd-go"><a href="#misccmd-go" class="headerlink" title="misccmd.go"></a>misccmd.go</h2><h3 id="makecacheCommand-geth-makecache-lt-block-number-gt-lt-outputdir-gt"><a href="#makecacheCommand-geth-makecache-lt-block-number-gt-lt-outputdir-gt" class="headerlink" title="makecacheCommand: geth makecache &lt;block number&gt; &lt;outputdir&gt;"></a>makecacheCommand: <code>geth makecache &lt;block number&gt; &lt;outputdir&gt;</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func makecache(ctx *cli.Context) error &#123;</div><div class="line">	args := ctx.Args()</div><div class="line">	if len(args) != 2 &#123;</div><div class="line">		utils.Fatalf(`Usage: geth makecache &lt;block number&gt; &lt;outputdir&gt;`)</div><div class="line">	&#125;</div><div class="line">	block, err := strconv.ParseUint(args[0], 0, 64)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Invalid block number: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	ethash.MakeCache(block, args[1])</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成 ethash 的验证缓存。这部分内容将在<a href="#TODO">go-ethereum 源码笔记（miner，consensus 模块）</a>描述。</p>
<h3 id="makedagCommand-geth-makedag-lt-block-number-gt-lt-outputdir-gt"><a href="#makedagCommand-geth-makedag-lt-block-number-gt-lt-outputdir-gt" class="headerlink" title="makedagCommand: geth makedag &lt;block number&gt; &lt;outputdir&gt;"></a>makedagCommand: <code>geth makedag &lt;block number&gt; &lt;outputdir&gt;</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func makedag(ctx *cli.Context) error &#123;</div><div class="line">	args := ctx.Args()</div><div class="line">	if len(args) != 2 &#123;</div><div class="line">		utils.Fatalf(`Usage: geth makedag &lt;block number&gt; &lt;outputdir&gt;`)</div><div class="line">	&#125;</div><div class="line">	block, err := strconv.ParseUint(args[0], 0, 64)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils.Fatalf(&quot;Invalid block number: %v&quot;, err)</div><div class="line">	&#125;</div><div class="line">	ethash.MakeDataset(block, args[1])</div><div class="line"></div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 ethash 的 <code>MakeDataset</code>，生成挖矿需要的 DAG 数据集。</p>
<h3 id="versionCommand-geth-version"><a href="#versionCommand-geth-version" class="headerlink" title="versionCommand: geth version"></a>versionCommand: <code>geth version</code></h3><p>输出版本号。</p>
<h3 id="bugCommand"><a href="#bugCommand" class="headerlink" title="bugCommand"></a>bugCommand</h3><p>给 <code>https://github.com/ethereum/go-ethereum/issues/new</code> 这个 url 拼接参数，给源代码仓库提一个 issue</p>
<h3 id="licenseCommand-geth-license"><a href="#licenseCommand-geth-license" class="headerlink" title="licenseCommand: geth license"></a>licenseCommand: <code>geth license</code></h3><p>输出 License 信息。</p>
<h2 id="config-go"><a href="#config-go" class="headerlink" title="config.go"></a>config.go</h2><h3 id="dumpConfigCommand-geth-dumpconfig"><a href="#dumpConfigCommand-geth-dumpconfig" class="headerlink" title="dumpConfigCommand: geth dumpconfig"></a>dumpConfigCommand: <code>geth dumpconfig</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func dumpConfig(ctx *cli.Context) error &#123;</div><div class="line">	_, cfg := makeConfigNode(ctx)</div><div class="line">	comment := &quot;&quot;</div><div class="line"></div><div class="line">	if cfg.Eth.Genesis != nil &#123;</div><div class="line">		cfg.Eth.Genesis = nil</div><div class="line">		comment += &quot;# Note: this config doesn&apos;t contain the genesis block.\n\n&quot;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	out, err := tomlSettings.Marshal(&amp;cfg)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	io.WriteString(os.Stdout, comment)</div><div class="line">	os.Stdout.Write(out)</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>makeConfigNode</code> 前面已经提过，这个方法用来获取当前配置信息，<code>dumpConfig</code> 函数通过 <code>makeConfigNode</code> 获取配置，然后将其输出在屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmd 模块包含了很多子模块，基本上每个子模块表示一个可执行的命令，其中最重要的是 geth 命令，它是以太坊的命令行客户端。&lt;/p&gt;
&lt;p&gt;geth 命令是以太坊提供的一个强大的命令行工具，它是使用以太坊的入口。它包括了很多子命令，你可以通过 &lt;code&gt;geth --help&lt;/code&gt; 获得更多帮助信息。其运行方法是：&lt;code&gt;geth [选项] 命令 [命令选项][参数…]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（基础知识）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（基础知识）/</id>
    <published>2018-03-10T14:34:57.000Z</published>
    <updated>2018-09-18T18:23:48.885Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将梳理以太坊的基本概念，说明一些值得注意的地方，这里不会讲解比特币的原理，代码，但会介绍以太坊与比特币的差异，所以最好看过比特币的论文，对比特币的基本原理、实现有所了解。这一篇将以太坊的白皮书作为重要参考，可以看做是以太坊白皮书的概述。以太坊的白皮书是一个非常好的学习资料，它在介绍以太坊前分析了比特币存在的问题，因此我们可以通过这份白皮书了解整个加密货币的生态。</p>
<a id="more"></a>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul>
<li>简单性</li>
<li>普遍性</li>
<li>模块化</li>
<li>敏捷性</li>
<li>不歧视，非审查</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>见上一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约是以太坊与比特币最大的不同。智能合约是不可篡改的合同，它运行在由以太坊组成的分布式计算机上，由一段支持图灵完备的程序实现。</p>
<p><strong>初学</strong>智能合约的最佳资料：<a href="https://cryptozombies.io/" target="_blank" rel="external">cryptozombies</a></p>
<p>智能合约与一般的程序有些不同：</p>
<ul>
<li>Address 类型可以定位用户，定位合约的代码</li>
<li>语言内嵌框架支持支付，所以提供了一些如 payable 的关键字，在语言层面支持支付</li>
<li>使用区块链作为存储</li>
<li>运行环境是去中心化的网络，比较强调合约或函数执行的调用方式。</li>
<li>一旦出现异常，所有的执行都会回撤，合约的执行具有原子性</li>
</ul>
<p>有四种专用语言可以写智能合约，Solidity，Serpent，Mutan，LLL。</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><h5 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h5><p>受 Javascript 启发。</p>
<p>是以太坊的首选语言，语法接近 Javascript，它是一种面向对象的语言，易于被掌握和使用，由于语法与 Javascript 相近，并且学习门栏相对较低，目前是使用人数最多的智能合约开发语言。编译器用 C++ 实现。</p>
<p>项目主页是：<a href="https://github.com/ethereum/solidity" target="_blank" rel="external">ethereum/solidity</a></p>
<h5 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a>Serpent</h5><p>受 Python 启发。兼顾底层语言效率和良好编程风格的同时尽可能追求简洁，加入了一些针对合约编程的特性。编译器用 C++ 实现。</p>
<p>项目主页是：<a href="https://github.com/ethereum/serpent" target="_blank" rel="external">ethereum/serpent</a></p>
<h5 id="Mutan"><a href="#Mutan" class="headerlink" title="Mutan"></a>Mutan</h5><p>受 Golang 启发。Golang 实现，2015年就被废弃了。</p>
<p>项目主页是：<a href="https://github.com/obscuren/mutan" target="_blank" rel="external">obscuren/mutan</a></p>
<h5 id="LLL-Lisp-Like-Language"><a href="#LLL-Lisp-Like-Language" class="headerlink" title="LLL(Lisp Like Language)"></a>LLL(Lisp Like Language)</h5><p>受 Lisp 启发。</p>
<h4 id="特征-来自知识星球-区块链学习小组-的讨论"><a href="#特征-来自知识星球-区块链学习小组-的讨论" class="headerlink" title="特征 (来自知识星球 区块链学习小组 的讨论)"></a>特征 (来自知识星球 <a href="https://t.zsxq.com/fiauZZJ" target="_blank" rel="external">区块链学习小组</a> 的讨论)</h4><ul>
<li>自治 一旦启动，不受干预</li>
<li>自足 程序自主控制其计算涉及的资源，有权限调配参与者的资金，财产</li>
<li>去中心化 不依赖某个单独的服务器，由分布式网络的节点共同支持运行</li>
</ul>
<h4 id="DApp-的优势"><a href="#DApp-的优势" class="headerlink" title="DApp 的优势"></a>DApp 的优势</h4><ul>
<li>DApp 大多为开源项目，公开透明</li>
<li>去中心化</li>
<li>具有激励机制</li>
<li>具有共识协议</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>信用卡的定期扣款(按月订阅的自动扣款)</li>
<li>飞机延误险(各类保险)</li>
<li>ICO</li>
<li>…</li>
</ul>
<h3 id="EVM-高级语言"><a href="#EVM-高级语言" class="headerlink" title="EVM 高级语言"></a>EVM 高级语言</h3><p>以太坊实现了一个叫做 Ethereum Virtual Machine 的运行时环境，类似于 JVM，它的主要工作是执行智能合约的字节码。</p>
<h3 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h3><p>以太坊中有两类账户，外部账户和合约账户，两类账户对于 EVM 来说没有区别，每个账户都有一个与之关联的账户状态和一个20字节的地址，都可以存储以太币。</p>
<p>外部账户：由私钥控制，没有代码与之关联，地址由公钥决定。私钥可用于对交易签名从而主动向其他账户发起交易（transaction）进行消息传递。</p>
<p>合约账户：由合约代码控制，有代码与之关联，其地址由合约创建者的地址和该地址发出过的交易数量 nonce 共同决定。不能主动向其他账户发起交易，但可以『响应』其他账户进行消息调用（message call）。</p>
<p>外部账户之间的消息传递是价值转移的过程，外部账户到合约账户的交易或合约账户到合约账户的消息会激发合约账户代码的执行，允许它执行如转移代币，写入内部存储，执行运算，创建合约等各种操作。</p>
<p>不论账户类型，账户状态都包含以下四个字段：</p>
<ul>
<li>nonce：由账户发出的交易数及创建的合约数量决定。</li>
<li>Balance：余额，账户拥有以太币数量，单位为 Wei，1Ether=10^18Wei。</li>
<li>storageRoot：存储根节点，账户内容的 Merkle Patricia 树根节点的哈希编码。</li>
<li>codeHash：代码哈希，与账户关联的 EVM 代码的哈希值，外部账户的 codeHash 为一个空字符串的哈希，创建后不可更改。状态数据库中包含所有代码片段哈希, 以便后续使用。</li>
</ul>
<h3 id="Gas-的设计"><a href="#Gas-的设计" class="headerlink" title="Gas 的设计"></a>Gas 的设计</h3><p>以太坊是一个能够运行智能合约的去中心化平台，它提供了一个以太坊虚拟机，简称 EVM，开发者可以在上面开发各种应用，而且它是图灵完备的，这意味着我们写的智能合约是可以运行死循环的。要知道，『不存在这样一个程序，它能够检测任何程序在给定输入上是否会结束』，这称为图灵停机问题。以太坊用一个很精彩的设计来解决这个问题，这就是 Gas。Gas 的设计基于这样一个想法：执行程序应该是消耗资源的，每一步操作，ADD 也好，DIV 也好，都应该消耗不同程度的资源，资源提前消耗完了，就强行终止程序。总的来说，Gas 是以太坊中对所有活动进行消耗资源计量的单位，包括但不限于：转账，合约创建，合约指令执行，扩展内存。Gas 是一个浮动的量，每一笔交易可以自行指定 Gas 价格(以以太币计算)，价格越高，矿工将你的交易打包进区块的优先级就越高。最终，Gas 的消耗等于消耗的 Gas 数量乘以 Gas 价格，这笔钱将奖励给矿工。交易完成后，剩余的 Gas 以购买时的价格退回到交易发送者账户，若交易过程中发生 Gas 不足异常(out-of-gas, OOG)，交易会被当做无效交易，已消耗 Gas 不会退回，仍作为矿工贡献计算资源的奖励。</p>
<p>更多细节请查阅：<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees" target="_blank" rel="external">wiki/Design-Rationale#gas-and-fees</a></p>
<h3 id="世界状态"><a href="#世界状态" class="headerlink" title="世界状态"></a>世界状态</h3><p>世界状态是地址(160位标示符)和账户状态(序列化为 RLP 的数据结构)间的映射，区块链不直接存储世界状态，而是在区块头中存储相关 Merkle Patricia 树根节点的哈希值。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>日志是 EVM 提供的一项功能。开发者可以在合约代码里记录各种事件产生的日志，这些日志可以帮助开发者调试代码，或者作为在区块链上发生交易的证据。</p>
<h3 id="各版本特性"><a href="#各版本特性" class="headerlink" title="各版本特性"></a>各版本特性</h3><ul>
<li>Frontier（边境）2015年7月发布，以太坊的第一个版本，只有命令行界面，主要使用者是开发者</li>
<li>Homestead（家园）2016年3月发布，第一个生产环境版本，加快了交易速度，增加图形界面，让普通用户也可以使用以太坊的功能</li>
<li>Metropolis（大都会）2017年10月发布，这个阶段分两个版本，先是拜占庭，2017年10月发布，然后是君士坦丁堡，预计2018年发布，增加浏览器，应用商店的特性，使用更方便，可以安装插件实现更多功能。更轻量、更快速、更安全。</li>
<li>Serenity（宁静）时间待定，使用 PoS，使用 Casper 共识算法。</li>
</ul>
<h2 id="以太坊和比特币的差异"><a href="#以太坊和比特币的差异" class="headerlink" title="以太坊和比特币的差异"></a>以太坊和比特币的差异</h2><h3 id="理念不同"><a href="#理念不同" class="headerlink" title="理念不同"></a>理念不同</h3><p>比特币想要实现的是电子现金系统，而以太坊想要实现的是图灵完备的智能合约平台。</p>
<h3 id="智能合约-VS-Script"><a href="#智能合约-VS-Script" class="headerlink" title="智能合约 VS Script"></a>智能合约 VS Script</h3><p>比特币协议本身也是可以实现智能协议的。在比特币中，有一个交易脚本语言，它是一种基于栈的执行语言，包含基本算数计算、基本逻辑（if 等）、报错及返回结果和一些加密指令，但不支持循环。</p>
<p>根据比特币协议的实现，在花费 UTXO 前，必须满足脚本的要求，即满足解锁 UTXO脚本，用私钥匹配解锁脚本（Signature script），以保证交易只能花费自己的比特币，即交易的输入，交易的输入指向的是锁定脚本（PubKey script），它确保签名能匹配输出地址。显然我们可以应用更复杂的脚本实现智能合约，没有循环也可以用重复的代码实现，显然这样的方法太糟糕了。</p>
<p>比特币的脚本语言存在的几处限制在 Vitalik 最初发布的白皮书里也有描述：</p>
<ul>
<li>缺乏图灵完整性，不支持循环语句</li>
<li>价值盲区，无法对 UTXO 进行精细化控制</li>
<li>不能保存状态，UTXO 只有用完和没用两种状态，没法实现多阶段期权合约</li>
<li>区块链盲区，UTXO 中没有区块链数据(随机数，时间戳，前一个区块哈希)，不能挖掘随机性的潜在价值</li>
</ul>
<p>更具体的描述可以查看<a href="https://github.com/knarfeh/papers/blob/master/Blockchain/Ethereum/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf" target="_blank" rel="external">这个地址</a>。</p>
<p>我们知道区块链的本质是一个分布式的公共数据库，它最早用来包括数字交易记录，这也是它到目前为止最为广泛的应用，区块链的特别之处在于，它不需要任何中央权威机构来维护，它是一个不需要第三方的 p2p 的框架。以太坊的智能合约让它与比特币又有了本质的不同，把区块链看做分布式数据库，那么以太坊就是一个能够能够在数据库上运行分布式应用的超级计算机，是智能合约让以太坊和比特币有了本质的不同，它是代码和数据（状态）的集合。</p>
<p>比特币的脚本有诸多限制，能够编写的程序有限，而以太坊的智能合约是图灵完备的，它非常适合于对信任、安全和持久性要求较高的应用场景，如：数字货币、数字资产、投票，保险、金融应用、预测市场，产权所有权管理、物联网等等。目前来说，除了数字货币之外，真正落地的应用还不多，因为区块链还存在诸多问题，比如亟需解决的交易性能问题，因此隔离见证，闪电网络，侧链等技术飞速发展，各种公链也针对某些问题提出自己的方案，这些既是挑战，也是机遇。</p>
<h3 id="Accounts-VS-UTXO"><a href="#Accounts-VS-UTXO" class="headerlink" title="Accounts VS UTXO"></a>Accounts VS UTXO</h3><p>比特币用 UTXO 方法计算某账户的余额，UTXO 即 Unspent Transaction Outputs。这个概念稍稍有点复杂，这里只做简单介绍。比特币整个系统的状态由未花费交易输出组成。每个 UTXO 都有拥有者和自身的价值属性，一笔交易会消费若干个 UTXO，同时也会生成若干个新的 UTXO，UTXO 有下面几点约束：</p>
<ol>
<li>每个被引用的输入必须有效，且未被使用过</li>
<li>交易的签名必须与每笔输入的所有者签名匹配</li>
<li>输入的总值必须等于或大于输出的总值</li>
</ol>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/en-transaction-propagation.png" alt="transaction of bitcoin, https://bitcoin.org/img/dev/en-transaction-propagation.svg"></p>
<p>个人认为理解 UTXO 的最佳方式是读这个<a href="https://github.com/Jeiwan/blockchain_go" target="_blank" rel="external">仓库</a>的源代码，这个作者写了7篇文章，实现了一个比特币的原型，Bitcoin Core 的代码是 C++ 写的，且代码复杂，年代久远，这个仓库使用 Golang，简单易懂，UTXO 的实现在 <a href="https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket" target="_blank" rel="external">Transactions 1</a>。感兴趣的朋友可以进一步阅读。</p>
<p>UTXO 的好处是（来自以太坊的维基）：</p>
<ol>
<li>匿名性更好，一个用户接收到一笔转账，这些转账的输入可以有多个私钥形成，但其实这些输入可以是同一个人的，这样能保证一定程度的匿名性。</li>
<li>UTXO 是无状态的，更具扩展性。</li>
</ol>
<p>以太坊没有采用 UTXO 的方式进行记账，而是采用了传统金融的记账方式–使用账户，每笔交易只有一个输入，一个输出，一个签名。使用单独的账户系统的好处是（来自以太坊维基）：</p>
<ol>
<li>节省大量存储空间。每笔交易只有一个输入和一个输出。</li>
<li>可替换性。可操控性可能更好一些，使用账户模型可以更轻松地实现黑名单这样的模式。</li>
<li>编码上更简单。获取账户余额时，只需要一个查询，而比特币需要整合指定地址所拥有的所有 UTXO 的总值。</li>
<li>可以更轻松地实现轻客户端。</li>
</ol>
<p>Vitalik 在一篇<a href="https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53" target="_blank" rel="external">博客</a>中还谈到 UTXO 可能引发拒绝服务漏洞。而且基于 UTXO 的模型与有状态的智能合约不太契合。以太坊最终选择使用账户模型。</p>
<p>以太坊使用状态（state）的概念来存储一系列账户，每个账户有自己的余额以及特定数据（代码或内部存储），如果交易发起方有足够余额支付交易费用，则交易有效，发起方账户扣除相应金额，接收账户增加余额。账户还用于智能合约的创建和执行，可以通过转账来触发接收账户对应的代码的执行，该账户的内部存储可能会发生变化，同时也可以创建额外信息发给其他账户，触发新的交易。从这一点可以看到，dapp 需要跟用户状态进行复杂的交互，通过 UTXO 实现会比较难满足需求。</p>
<h3 id="区块链设计的不同"><a href="#区块链设计的不同" class="headerlink" title="区块链设计的不同"></a>区块链设计的不同</h3><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><p>比特币的区块包括区块头和区块体两部分，区块头封装了前一个区块的哈希值、时间戳，随机数，默克尔树根值和当前区块的哈希值，区块体中包括交易计数和交易详情。区块结构如下图（摘自 Bitcoin 白皮书）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/bitcoin_block_from_bitcoinpaper.png" alt="bitcoin_block"></p>
<h4 id="以太坊-1"><a href="#以太坊-1" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊在比特币区块链基础上做了一些调整，区块主要由区块头、交易列表和叔区块头三部分组成。区块头包括父区块的哈希值、叔区块的哈希值、状态树根哈希值、交易树根哈希值、收据树根哈希值、时间戳、随机数，比较特别的是采用了改进的默克尔树，压缩前缀树的结构 MPT，这部分在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a> 会进一步探讨。区块结构如下图（摘自 <a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">Ethereum 博客</a>）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/ethblockchain_full.png" alt="ethereum_block"></p>
<h3 id="PoW-机制的不同"><a href="#PoW-机制的不同" class="headerlink" title="PoW 机制的不同"></a>PoW 机制的不同</h3><p>PoW，Proof of Work 的缩写，即工作量证明，又称挖矿，目前比特币，以太坊都基于 PoW 算法实现共识机制，即根据挖矿的贡献决定货币的分配。</p>
<h4 id="比特币-1"><a href="#比特币-1" class="headerlink" title="比特币"></a>比特币</h4><p>比特币的 PoW 的过程，需要不断调整 Nonce 值，对区块头做双重 SHA256 哈希运算，使得结果满足给定数量前导0的哈希值的过程。其中前导0的个数，取决于挖矿难度，前导 0 的个数越多，挖矿难度越大。</p>
<h4 id="以太坊-2"><a href="#以太坊-2" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊的 PoW 算法可以表示为如下公式：$RAND(h, n) &lt;= M/d$<br>其中 $RAND()$ 表示一个概念函数，代表一系列的复杂运算，h 和 n 为输入，即区块 Header 的哈希、以及 Header 中的 Nonce。M 表示一个极大的数，此处使用 $2^{256}-1$。d 为区块难度，即Header 中的 Difficulty。在 h 和 n 确定的情况下，d 越大，挖矿难度越大。需不断变更 Nonce，使$RAND(h, n)$ 满足 $RAND(h, n) &lt;= M / d$ 完成 PoW。</p>
<p>需要注意的是以太坊目前的 PoW 只是临时的，未来将会是 PoS 的形式，到时候不会再需要耗费大量电力进行挖矿。</p>
<h3 id="挖矿难度更新"><a href="#挖矿难度更新" class="headerlink" title="挖矿难度更新"></a>挖矿难度更新</h3><h4 id="比特币-2"><a href="#比特币-2" class="headerlink" title="比特币"></a>比特币</h4><p>比特币每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下：</p>
<ol>
<li>找到前2016个块的第一个块，计算生成这2016个块花费的时间。<br>即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。</li>
<li>计算前2016个块的难度总和，即单个块的难度x总时间。</li>
<li>计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。</li>
<li>要求新的难度，难度不低于参数定义的最小难度。</li>
</ol>
<h4 id="以太坊-3"><a href="#以太坊-3" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊每次挖矿都需计算当前区块难度。按版本不同有三种计算难度的规则，分别为：<code>calcDifficultyByzantium</code>（Byzantium 版本）、<code>calcDifficultyHomestead</code>（Homestead 版本）、<code>calcDifficultyFrontier</code>（Frontier 版本）。以 <code>calcDifficultyHomestead</code> 为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">本区块难度 = 父区块难度 + 难度调整 + 难度炸弹</div><div class="line">难度调整 = 父区块难度 // 2048 * MAX(1 - (block_timestamp - parent_timestamp) // 10, -99)</div><div class="line">难度炸弹 = INT(2**((block_number // 100000) - 2))</div></pre></td></tr></table></figure>
<p>以太坊的区块难度以单个区块为单位进行调整，所以可以比较快地适应算力变化，难度炸弹也是一个很有意思的设计，难度炸弹是指数级增长的，到某个阶段矿工会因为无利可图自动退场，这时 PoS 也应该成熟了，这对于矿工来说是一个预防针。</p>
<h3 id="奖励机制"><a href="#奖励机制" class="headerlink" title="奖励机制"></a>奖励机制</h3><h4 id="比特币-3"><a href="#比特币-3" class="headerlink" title="比特币"></a>比特币</h4><p>在比特币的设计中，最初每挖出一个区块会奖励50个 BTC，每挖出21万个，奖励就会减半，第1-210000个区块，每块奖励50btc，第210001-420000个区块，每块奖励25btc……以此类推。</p>
<p>因此 BTC 的总量为：210000×50(1+0.5+0.25+0.125+……)=2100万</p>
<h4 id="以太坊-4"><a href="#以太坊-4" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊提出了一个叔块的概念。叔块是指没能成为主链的，但在后面的区块放入了 uncles 字段中的区块。</p>
<p>相比于比特币，以太坊对叔块也有奖励，为什么这么做呢，我们知道以太坊的出块时间是15秒左右，相比于比特币，以太坊更容易出现临时分叉和孤块，因为出块时间比较短，区块在整个网络中也比较难传播，对于网速比较慢的矿工就不占优势了，因此挖矿的时候，对于叔块也是有奖励的。</p>
<p>我们知道以太坊是一个运行智能合约的去中心化的平台，它有一个以太坊虚拟机（Ethereum Virtual Machine，常用缩写 EVM）的概念，EVM 是就像一个超级计算机，它是图灵完备的，写程序的时候可能会出现死循环，而智能合约应该避免这种情况，这引出一个<a href="https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="external">停机问题</a>，简单来说就是不存在能够检测程序进入了死循环的方法，以太坊提出了一种设计解决这个问题，EVM 规定了每条指令都会消耗一定的 Gas，指令越复杂，消耗的 Gas 越多，程序运行前是有一个消耗 Gas 的上限的，运行过程中 Gas 消耗完了，无论程序有没有执行完都会被强行终止。智能合约运行时花费的 Gas 最终会奖励给矿工。</p>
<p>综上，以太坊的挖矿奖励包括两部分：</p>
<h5 id="普通区块奖励"><a href="#普通区块奖励" class="headerlink" title="普通区块奖励"></a>普通区块奖励</h5><ul>
<li>固定奖励5ETH</li>
<li>花费的 Gas</li>
<li>如果区块中包括叔块，每包含一个可以得到5ETH的1/32</li>
</ul>
<h5 id="叔块奖励"><a href="#叔块奖励" class="headerlink" title="叔块奖励"></a>叔块奖励</h5><p>叔块奖励 = ( 叔块高度 + 8 - 包含叔块的区块的高度 ) * 普通区块奖励 / 8</p>
<h3 id="其他一些细节上的差异"><a href="#其他一些细节上的差异" class="headerlink" title="其他一些细节上的差异"></a>其他一些细节上的差异</h3><ul>
<li>出块时间，比特币的出块时间是平均10分钟，以太坊的平均出块时间是15秒。以太坊相对于比特币有更大的系统吞吐量和更小的交易确认间隔，尽管从长远来看，这远远不够。</li>
<li>区块奖励，比特币诞生于2009年1月，刚开始时区块奖励是50 BTC，每四年减半一次，2012年11月到2016年7月是25 BTC，目前是12.5 BTC，到2020年的2月将变成6.25 BTC；以太坊的挖矿奖励5个以太币，大都会版本后改成3个以太币。</li>
<li>以太币最多可以显示小数点后18位，比特币最多是小数点后8位。</li>
<li>…</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://en.bitcoin.it/wiki/Script" target="_blank" rel="external">Script</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="external">ethereum white paper</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees" target="_blank" rel="external">wiki/Design-Rationale#gas-and-fees</a></li>
<li><a href="https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53" target="_blank" rel="external">Thoughts on UTXOs by Vitalik Buterin, Co-Founder of Ethereum</a></li>
<li><a href="https://ethfans.org/posts/thoughts-on-utxo" target="_blank" rel="external">关于 UTXO 的思考</a></li>
<li><a href="https://steemit.com/ethereum/@alexma/2-utxo-vs" target="_blank" rel="external">浅谈以太坊（2）——以太坊的不同之处之UTXO vs 账户余额</a></li>
<li><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/" target="_blank" rel="external">比特币脚本及交易分析 - 智能合约雏形</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28830859" target="_blank" rel="external">以太坊(Ethereum ETH)是如何计算难度的</a></li>
<li><a href="https://cryptozombies.io/" target="_blank" rel="external">cryptozombies</a></li>
<li><a href="https://eips.ethereum.org/EIPS" target="_blank" rel="external">EIPs</a></li>
<li><a href="https://github.com/EthFans/wiki/wiki/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6" target="_blank" rel="external">EthFans/wiki/智能合约</a></li>
<li><a href="https://dbarobin.com/2018/01/24/blockchain-smart-contract/" target="_blank" rel="external">理解智能合约</a></li>
<li><a href="http://www.8btc.com/the-beginners-guide-to-ethereum-s-2020-roadmap" target="_blank" rel="external">以太坊路线图入门指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/ethereum" target="_blank" rel="external">以太坊技术专栏</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇将梳理以太坊的基本概念，说明一些值得注意的地方，这里不会讲解比特币的原理，代码，但会介绍以太坊与比特币的差异，所以最好看过比特币的论文，对比特币的基本原理、实现有所了解。这一篇将以太坊的白皮书作为重要参考，可以看做是以太坊白皮书的概述。以太坊的白皮书是一个非常好的学习资料，它在介绍以太坊前分析了比特币存在的问题，因此我们可以通过这份白皮书了解整个加密货币的生态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（概览）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（概览）/</id>
    <published>2018-03-10T14:34:56.000Z</published>
    <updated>2018-10-27T09:27:54.303Z</updated>
    
    <content type="html"><![CDATA[<p>花了一点时间读以太坊的源代码，内容太多，所以一边看一边写，没想到越写越多，于是想着把笔记整理出来。</p>
<p>源码解读是一件费力不讨好的事情，因为看代码的时候我们看到的是最终解决方案，虽然可以看到 commit 的历史，但我们看不到作者的思路，踩过的坑，而且 geth 的设计文档，功能的相关讨论等信息不像 Kubernetes 那么规范透明，所以我看这些代码的时候很多地方也只是一知半解，欢迎有更多经验的朋友批评指正，不吝赐教，也欢迎有价值的讨论。看了一些书和文章，所以我这也算不上多原创，基本上所有看过的链接都记在 reference 里面了。有的代码暂时看不懂就只能靠猜了，等待之后的实践中验证想法。尽管如此，对于同样想要阅读 geth 的源代码的人来说总还是有些作用，对于我个人来说整理出来这些文章也是一个总结知识，把点连成面的过程，希望同时能帮到其他人。</p>
<p>geth 版本：master 分支，a1eb9c7d13240fd250866219a502d0cdc9924e06</p>
<a id="more"></a>
<p>这是第一篇，可以作为索引，后续发布其他文章后会不断更新👇</p>
<ul>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（基础知识）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-其他命令）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT的实现）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88accounts,%20transaction%20%E6%A8%A1%E5%9D%97-%E8%B4%A6%E6%88%B7%E5%92%8C%E8%BD%AC%E8%B4%A6%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-交易池模块）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88miner,%20consensus%20%E6%A8%A1%E5%9D%97-%E6%8C%96%E7%9F%BF%E5%92%8C%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（miner,consensus 模块-挖矿和共识算法)</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88ethdb%20%E6%A8%A1%E5%9D%97%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（ethdb 模块）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-EVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E9%93%BE%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%90%9C%E7%B4%A2%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）</a></li>
</ul>
<h2 id="涉及到的计算机专业知识"><a href="#涉及到的计算机专业知识" class="headerlink" title="涉及到的计算机专业知识"></a>涉及到的计算机专业知识</h2><ul>
<li>网络知识，p2p 网络（Kad 算法） ，rpc 等等</li>
<li>加密学，暂时不需要很深入，除非是像 <a href="http://teahour.fm/2018/07/08/how-to-build-blockchain-from-scratch.html" target="_blank" rel="external">How to build blockchain from scratch?</a> 说的需要构建加密函数相关的库，在大多数的场景下只需要知道加密函数的基本原理和使用。当然越深入越好，这一块也可以做出创新；安全对于很多行业是命脉，对于区块链来说更是如此。推荐阅读密码学入门经典：<a href="https://book.douban.com/subject/26265544/" target="_blank" rel="external">图解密码技术</a></li>
<li>编译原理，看 EVM 相关的实现时需要知道一些基本概念。</li>
<li>分布式系统原理(一致性算法)</li>
<li>智能合约</li>
<li>数据库(LevelDB)，了解 LSM 的特点，不需要太深入的了解，知道 API 调用即可。当然知道底层原理最好，这块也有改进的空间，微博上的<a href="https://weibo.com/1875401263/GtTacBjm2?filter=hot&amp;root_comment_id=0&amp;type=comment" target="_blank" rel="external">邓草原</a>同学在做这方面的工作，针对区块链的数据特点设计专门的存储引擎，TPS 有不小的提升，不过我还没有细看代码，从讨论来看应该是参考了 Kafka 的存储特点。</li>
<li>一些数据结构<ul>
<li>MPT</li>
<li>DAG</li>
<li>布隆过滤器</li>
<li>…</li>
</ul>
</li>
</ul>
<p>写完了这个系列可能会加个思维导图。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="总体架构图（来自-Ethereum-block-architecture）"><a href="#总体架构图（来自-Ethereum-block-architecture）" class="headerlink" title="总体架构图（来自 Ethereum block architecture）"></a>总体架构图（来自 <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" target="_blank" rel="external">Ethereum block architecture</a>）</h3><p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/stackexchange-ethereum-block-architecture.jpg" alt="https://i.stack.imgur.com/afWDt.jpg"></p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p><a href="https://book.douban.com/subject/30199891/" target="_blank" rel="external">以太坊技术详解与实战</a>这本书里介绍了以太坊的分层架构，其中的图片还挺有参考价值的，网络上没有找到原图，所以我自己画了一下：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/ethereum-leveld-architecture.png" alt="ethereum-leveld-architecture"></p>
<h4 id="底层服务"><a href="#底层服务" class="headerlink" title="底层服务"></a>底层服务</h4><p>底层服务包括 P2P 网络、LevelDB 数据库、密码学算法和分片优化等基础服务。</p>
<h4 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h4><p>核心层包括区块链、共识算法和以太坊虚拟机等。</p>
<h4 id="顶层应用"><a href="#顶层应用" class="headerlink" title="顶层应用"></a>顶层应用</h4><p>这一层包括 API 接口、智能合约以及去中心化应用。</p>
<h2 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h2><h3 id="core-types-block-go-区块的数据结构"><a href="#core-types-block-go-区块的数据结构" class="headerlink" title="/core/types/block.go 区块的数据结构"></a><code>/core/types/block.go</code> 区块的数据结构</h3><p>区块的数据结构在 <code>core/types/block.go</code> 中定义。先混个眼熟吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type Block struct &#123;</div><div class="line">	header       *Header</div><div class="line">	uncles       []*Header</div><div class="line">	transactions Transactions</div><div class="line">	hash atomic.Value</div><div class="line">	size atomic.Value</div><div class="line">	td *big.Int</div><div class="line">	ReceivedAt   time.Time</div><div class="line">	ReceivedFrom interface&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>重要字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>header 指向 Header 结构（之后会详细说明），header 存储一个区块的基本信息。</td>
</tr>
<tr>
<td>uncles</td>
<td>指向 Header 结构</td>
</tr>
<tr>
<td>transactions</td>
<td>一组 transaction 结构</td>
</tr>
<tr>
<td>hash</td>
<td>当前区块的哈希值</td>
</tr>
<tr>
<td>size</td>
<td>当前区块的大小</td>
</tr>
<tr>
<td>td</td>
<td>当前区块高度</td>
</tr>
<tr>
<td>ReceivedAt</td>
<td>接收时间</td>
</tr>
<tr>
<td>ReceivedFrom</td>
<td>来源</td>
</tr>
</tbody>
</table>
<p>交易组成区块，一个一个区块以单向链表的形式连在一起组成区块链，毋庸置疑，这是最基础的数据结构，在 geth 的源代码中大量用到。</p>
<p>其中 <code>Header</code> 的数据结构定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type Header struct &#123;</div><div class="line">	ParentHash  common.Hash    `json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</div><div class="line">	UncleHash   common.Hash    `json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</div><div class="line">	Coinbase    common.Address `json:&quot;miner&quot;            gencodec:&quot;required&quot;`</div><div class="line">	Root        common.Hash    `json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</div><div class="line">	TxHash      common.Hash    `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</div><div class="line">	ReceiptHash common.Hash    `json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</div><div class="line">	Bloom       Bloom          `json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</div><div class="line">	Difficulty  *big.Int       `json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</div><div class="line">	Number      *big.Int       `json:&quot;number&quot;           gencodec:&quot;required&quot;`</div><div class="line">	GasLimit    uint64         `json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</div><div class="line">	GasUsed     uint64         `json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</div><div class="line">	Time        *big.Int       `json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</div><div class="line">	Extra       []byte         `json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</div><div class="line">	MixDigest   common.Hash    `json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`</div><div class="line">	Nonce       BlockNonce     `json:&quot;nonce&quot;            gencodec:&quot;required&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ParentHash</td>
<td>父区块的哈希值</td>
</tr>
<tr>
<td>UncleHash</td>
<td>叔区块的哈希值</td>
</tr>
<tr>
<td>Coinbase</td>
<td>矿工得到奖励的账户，一般是矿工本地第一个账户</td>
</tr>
<tr>
<td>Root</td>
<td>表示当前所有用户状态</td>
</tr>
<tr>
<td>TxHash</td>
<td>本区块所有交易 Hash，即摘要</td>
</tr>
<tr>
<td>ReceiptHash</td>
<td>本区块所有收据 Hash，即摘要</td>
</tr>
<tr>
<td>Bloom</td>
<td>布隆过滤器，用来搜索收据</td>
</tr>
<tr>
<td>Difficulty</td>
<td>该区块难度，动态调整，与父区块和本区块挖矿时间有关。可参考 <code>github.com/ethereum/go-ethereum/consensus/ethash/consensus.go</code> 的 <code>CalcDifficulty</code></td>
</tr>
<tr>
<td>Number</td>
<td>该区块高度</td>
</tr>
<tr>
<td>GasLimit</td>
<td>gas 用量上限，该数值根据父区块 gas 用量调节，如果 <code>parentGasUsed &gt; parentGasLimit * (2/3)</code> ，则增大该数值，反之则减小该数值。可参看 <code>github.com/ethereum/go-ethereum/core/block_validator.go</code> 的 <code>CalcGasLimit</code></td>
</tr>
<tr>
<td>GasUsed</td>
<td>实际花费的 gas</td>
</tr>
<tr>
<td>Time</td>
<td>新区块的出块时间，严格来说是开始挖矿的时间</td>
</tr>
<tr>
<td>Extra</td>
<td>额外数据</td>
</tr>
<tr>
<td>MixDigest</td>
<td>混合哈希，与 nonce 结合使用</td>
</tr>
<tr>
<td>Nonce</td>
<td>加密学中的概念，在基本概念章节中有介绍</td>
</tr>
</tbody>
</table>
<p>它包含区块的属性信息，<code>ParentHash</code> 表示该区块的父区块哈希，我们通过 <code>ParentHash</code> 这个字段将一个一个区块连接起来组成区块链，但实际上我们并不会直接将链整个的存起来，它是以一定的数据结构一块一块存放的，geth 的底层数据库用的是 LevelDB，这是一个 key-value 数据库，要得到父区块时，我们通过 <code>ParentHash</code> 以及其他字符串组成 key，在 LevelDB 中查询该 key 对应的值，就能拿到父区块。</p>
<h3 id="core-blockchain-go-区块链的数据结构"><a href="#core-blockchain-go-区块链的数据结构" class="headerlink" title="/core/blockchain.go 区块链的数据结构"></a>/core/blockchain.go 区块链的数据结构</h3><p><code>core/blockchain.go</code> 的 <code>BlockChain</code> 结构体定义了区块链的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">type BlockChain struct &#123;</div><div class="line">	chainConfig *params.ChainConfig</div><div class="line">	cacheConfig *CacheConfig</div><div class="line"></div><div class="line">	db     ethdb.Database</div><div class="line">	triegc *prque.Prque</div><div class="line">	gcproc time.Duration</div><div class="line"></div><div class="line">	hc            *HeaderChain</div><div class="line">	rmLogsFeed    event.Feed</div><div class="line">	chainFeed     event.Feed</div><div class="line">	chainSideFeed event.Feed</div><div class="line">	chainHeadFeed event.Feed</div><div class="line">	logsFeed      event.Feed</div><div class="line">	scope         event.SubscriptionScope</div><div class="line">	genesisBlock  *types.Block</div><div class="line"></div><div class="line">	mu      sync.RWMutex</div><div class="line">	chainmu sync.RWMutex</div><div class="line">	procmu  sync.RWMutex</div><div class="line"></div><div class="line">	checkpoint       int</div><div class="line">	currentBlock     atomic.Value</div><div class="line">	currentFastBlock atomic.Value</div><div class="line"></div><div class="line">	stateCache   state.Database</div><div class="line">	bodyCache    *lru.Cache</div><div class="line">	bodyRLPCache *lru.Cache</div><div class="line">	blockCache   *lru.Cache</div><div class="line">	futureBlocks *lru.Cache</div><div class="line"></div><div class="line">	quit    chan struct&#123;&#125;</div><div class="line">	running int32</div><div class="line">	procInterrupt int32</div><div class="line">	wg            sync.WaitGroup</div><div class="line"></div><div class="line">	engine    consensus.Engine</div><div class="line">	processor Processor</div><div class="line">	validator Validator</div><div class="line">	vmConfig  vm.Config</div><div class="line"></div><div class="line">	badBlocks *lru.Cache</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UncleHash</code> 是 <code>Block</code> 结构体成员 <code>uncles</code> 的 RLP 哈希值，<code>uncles</code> 是一个 <code>Headers</code> 数组，关于叔区块，可以查阅以太坊的<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#uncle-incentivization" target="_blank" rel="external">设计原理</a>。在下一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（基础知识）</a> 会详细介绍叔区块。</p>
<p>Block 对象中还有一个比较重要的数据结构，那就是 <code>Transaction</code>，它是交易相关逻辑的基础。</p>
<h3 id="core-types-transaction-go-交易的数据结构"><a href="#core-types-transaction-go-交易的数据结构" class="headerlink" title="/core/types/transaction.go 交易的数据结构"></a><code>/core/types/transaction.go</code> 交易的数据结构</h3><p>交易的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type Transaction struct &#123;</div><div class="line">	data txdata</div><div class="line">	// caches</div><div class="line">	hash atomic.Value</div><div class="line">	size atomic.Value</div><div class="line">	from atomic.Value</div><div class="line">&#125;</div><div class="line"></div><div class="line">type txdata struct &#123;</div><div class="line">	AccountNonce uint64          `json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</div><div class="line">	Price        *big.Int        `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</div><div class="line">	GasLimit     uint64          `json:&quot;gas&quot;      gencodec:&quot;required&quot;`</div><div class="line">	Recipient    *common.Address `json:&quot;to&quot;       rlp:&quot;nil&quot;`</div><div class="line">	Amount       *big.Int        `json:&quot;value&quot;    gencodec:&quot;required&quot;`</div><div class="line">	Payload      []byte          `json:&quot;input&quot;    gencodec:&quot;required&quot;`</div><div class="line"></div><div class="line">	V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;`</div><div class="line">	R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;`</div><div class="line">	S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;`</div><div class="line"></div><div class="line">	Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转账的定义中只有转入方，转出方的地址没有直接暴露。每一笔转账都有独立的 Price 和 GasLimit，这是 Ethereum 的安全保护策略，是一个值得称赞的设计，如果你对这个不熟悉，请查阅：<a href="https://github.com/ethereum/wiki/wiki/Glossary" target="_blank" rel="external">wiki/Glossary</a>，在之后的文章中也会有介绍。</p>
<h2 id="geth-目录结构简述"><a href="#geth-目录结构简述" class="headerlink" title="geth 目录结构简述"></a>geth 目录结构简述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">accounts        实现以太坊账户管理</div><div class="line">build           编译和构建的一些脚本和配置</div><div class="line">cmd             命令行工具，又分了很多的命令行工具，下面会一个一个介绍</div><div class="line">    abigen      将以太坊智能合约定义转换为类型安全的 Go 或 Java 包的源码转换器</div><div class="line">    bootnode	启动一个用于网络发现的节点</div><div class="line">    evm         以太坊虚拟机的开发工具，用来提供一个可配置的，受隔离的代码调试环境</div><div class="line">    faucet		以太坊 faucet 测试网络</div><div class="line">    geth        以太坊命令行客户端，最重要的一个工具</div><div class="line">    p2psim      提供了一个工具来模拟 p2p 的 API</div><div class="line">    puppeth     创建一个新的以太坊网络的向导</div><div class="line">    rlpdump     提供了一个 RLP 数据的格式化输出</div><div class="line">    swarm       swarm 网络的接入点</div><div class="line">    util        提供了一些公共的工具</div><div class="line">    wnode       这是一个简单的 Whisper 节点。它可以用作独立的引导节点。此外可以用于不同的测试和诊断目的</div><div class="line">common      	提供了一些公共的工具类</div><div class="line">consensus       提供了以太坊的一些共识算法，比如 ethhash, clique(proof-of-authority)</div><div class="line">console         与终端交互相关的代码</div><div class="line">containers		Docker 容器相关的代码</div><div class="line">contracts		以太坊域名服务，票据支付方案</div><div class="line">core            以太坊的核心数据结构和算法(虚拟机，状态，区块链，布隆过滤器)</div><div class="line">crypto          加密和 hash 算法</div><div class="line">dashboard		以太坊后台管理 UI</div><div class="line">eth             实现了以太坊的协议</div><div class="line">ethclient       提供了以太坊的 RPC 客户端</div><div class="line">ethdb           封装 geth 的数据库(包括实际使用的 Leveldb 和供测试使用的内存数据库)</div><div class="line">ethstats        提供网络状态的报告</div><div class="line">event           处理实时的事件</div><div class="line">les             实现了以太坊的轻量级协议子集</div><div class="line">light           为以太坊轻量级客户端提供按需检索的功能</div><div class="line">log             提供对人机都友好的日志信息</div><div class="line">metrics         提供磁盘计数器</div><div class="line">miner           提供以太坊的区块创建和挖矿</div><div class="line">mobile          移动端使用的一些 warpper</div><div class="line">node            以太坊的多种类型的节点</div><div class="line">p2p             以太坊 p2p 网络协议</div><div class="line">rlp             以太坊编码算法</div><div class="line">rpc             远程方法调用</div><div class="line">swarm           swarm 网络</div><div class="line">tests           测试</div><div class="line">trie            实现以太坊中的默克尔帕特里夏树</div><div class="line">whisper         提供了 whisper 节点的协议</div></pre></td></tr></table></figure>
<h2 id="从编译源代码开始"><a href="#从编译源代码开始" class="headerlink" title="从编译源代码开始"></a>从编译源代码开始</h2><p>按照官方文档的建议设置好开发环境，在 go-ethereum 执行 <code>make build</code> 之后，我们可以在 build/bin 目录下找到 abigen, ethkey 等等可执行文件，实际上这些文件的入口函数都在 cmd 目录下，接下来的文章里我们会逐一介绍这些命令。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://bitcoin.org/en/developer-documentation" target="_blank" rel="external">bitcoin developer documentation</a></li>
<li><a href="lilymoana.github.io/ethereum_theory.html">以太坊工作原理概述</a></li>
<li><a href="http://ibloodline.com/articles/2018/02/05/go-ethereum.html" target="_blank" rel="external">go-ethereum 源码解读（一）</a></li>
<li><a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="external">ethereum 黄皮书</a></li>
<li><a href="https://ethereum.gitbooks.io/frontier-guide/content/index.html" target="_blank" rel="external">Ethereum Frontier Guide</a></li>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis" target="_blank" rel="external">go-ethereum-code-analysis</a></li>
<li><a href="https://github.com/libp2p/specs" target="_blank" rel="external">libp2p/specs</a></li>
<li><a href="https://github.com/wugang33/go-ethereum-code-analysis/blob/master/go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="external">go ethereum 目录介绍</a></li>
<li><a href="https://book.douban.com/subject/30199891/" target="_blank" rel="external">以太坊技术详解与实战</a></li>
<li><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="external">图解密码技术</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale" target="_blank" rel="external">以太坊设计原理</a> ，非常重要，建议多读几遍</li>
<li><a href="https://github.com/ethereum/pydevp2p" target="_blank" rel="external">ethereum/pydevp2p</a></li>
<li><a href="https://github.com/Jeiwan/blockchain_go" target="_blank" rel="external">Jeiwan/blockchain_go</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture/757" target="_blank" rel="external">Ethereum block architecture</a></li>
<li><a href="https://www.reddit.com/r/ethereum/" target="_blank" rel="external">Ethereum reddit</a></li>
<li><a href="https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369" target="_blank" rel="external">How does ethereum work anyway</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了一点时间读以太坊的源代码，内容太多，所以一边看一边写，没想到越写越多，于是想着把笔记整理出来。&lt;/p&gt;
&lt;p&gt;源码解读是一件费力不讨好的事情，因为看代码的时候我们看到的是最终解决方案，虽然可以看到 commit 的历史，但我们看不到作者的思路，踩过的坑，而且 geth 的设计文档，功能的相关讨论等信息不像 Kubernetes 那么规范透明，所以我看这些代码的时候很多地方也只是一知半解，欢迎有更多经验的朋友批评指正，不吝赐教，也欢迎有价值的讨论。看了一些书和文章，所以我这也算不上多原创，基本上所有看过的链接都记在 reference 里面了。有的代码暂时看不懂就只能靠猜了，等待之后的实践中验证想法。尽管如此，对于同样想要阅读 geth 的源代码的人来说总还是有些作用，对于我个人来说整理出来这些文章也是一个总结知识，把点连成面的过程，希望同时能帮到其他人。&lt;/p&gt;
&lt;p&gt;geth 版本：master 分支，a1eb9c7d13240fd250866219a502d0cdc9924e06&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>Docker 清理卫士</title>
    <link href="http://knarfeh.github.io/2017/12/15/Docker%20%E6%B8%85%E7%90%86%E5%8D%AB%E5%A3%AB/"/>
    <id>http://knarfeh.github.io/2017/12/15/Docker 清理卫士/</id>
    <published>2017-12-15T05:24:57.000Z</published>
    <updated>2018-10-19T16:10:17.360Z</updated>
    
    <content type="html"><![CDATA[<p>本文对释放 Docker 占的磁盘，网络，数据卷的命令做一个整理。内容部分来自网络，一部分来自自己的总结。</p>
<a id="more"></a>
<h2 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h2><p>来自 <a href="https://github.com/chadoe/docker-cleanup-volumes" target="_blank" rel="external">chadoe/docker-cleanup-volumes</a></p>
<p>清理所有没有打标签的 volume：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker volume rm $(docker volume ls -qf dangling=true)</div></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker volume ls -qf dangling=true | xargs -r docker volume rm</div></pre></td></tr></table></figure>
<h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><p>列出本机创建的所有 network：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network ls</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network ls | grep &quot;bridge&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network rm $(docker network ls | grep &quot;bridge&quot; | awk &apos;/ / &#123; print $1 &#125;&apos;)</div></pre></td></tr></table></figure>
<h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p>来自 <a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker images</div><div class="line">$ docker rmi $(docker images --filter &quot;dangling=true&quot; -q --no-trunc)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker images | grep &quot;none&quot;</div><div class="line">$ docker rmi $(docker images | grep &quot;none&quot; | awk &apos;/ / &#123; print $3 &#125;&apos;)</div></pre></td></tr></table></figure>
<h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>来自 <a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></p>
<p>删除所有已经退出的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker rm $(docker ps -qa --no-trunc --filter &quot;status=exited&quot;)</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm `docker ps -a | grep -i &apos;exited&apos; | awk &#123;&apos;print $1&apos;&#125;`</div></pre></td></tr></table></figure>
<h2 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h2><p>从<a href="https://github.com/moby/moby/blob/master/CHANGELOG.md#1130-2017-01-18" target="_blank" rel="external">1.13.0</a>版本开始，docker 引入了 <code>docker system prune</code> 命令，可以用来清理主机的磁盘空间。该命令可以一键清理所有已停止的容器；所有未被容器引用的 volume（dangling volume）；所有未被容器引用的网络；所有 dangling 的镜像。命令执行完后可以看到释放的空间的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker system prune</div></pre></td></tr></table></figure>
<p>如果要移除所有未被使用的镜像（不仅仅是 dangling 的），可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker system prune -a</div></pre></td></tr></table></figure>
<p>dangling 的镜像的定义是未被其他镜像引用的镜像，如果构建了新的镜像，但该镜像没有被打上一个新的标签，那么之前打了这个标签的镜像就是 dangling 镜像，它的 name 属性是 none。总的来说，如果一个镜像与任何一个打上标签的镜像没有关联，它就是 dangling 镜像。如果镜像的 repository 和 tag 都是 none，称为 intermediate 镜像。</p>
<p>prune 方法的实现在 <a href="https://github.com/moby/moby/blob/master/daemon/prune.go" target="_blank" rel="external"><code>https://github.com/moby/moby/blob/master/daemon/prune.go</code></a> 里，有兴趣的话可以看看这个方法的实现。</p>
<h3 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image prune</div></pre></td></tr></table></figure>
<h2 id="k8s-的-PodGC"><a href="#k8s-的-PodGC" class="headerlink" title="k8s 的 PodGC"></a>k8s 的 PodGC</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/" target="_blank" rel="external">Garbage Collection</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.calazan.com/docker-cleanup-commands/" target="_blank" rel="external">docker-cleanup-commands</a></li>
<li><a href="https://github.com/chadoe/docker-cleanup-volumes" target="_blank" rel="external">chadoe/docker-cleanup-volumes</a></li>
<li><a href="https://gist.github.com/bastman/5b57ddb3c11942094f8d0a97d461b430" target="_blank" rel="external">Docker - How to cleanup (unused) resources</a></li>
<li><a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></li>
<li><a href="https://github.com/spotify/docker-gc" target="_blank" rel="external">spotify/docker-gc</a></li>
<li><a href="https://blog.docker.com/2017/01/whats-new-in-docker-1-13/" target="_blank" rel="external">whats-new-in-docker-1-13</a></li>
<li><a href="https://stackoverflow.com/questions/45142528/docker-what-is-a-dangling-image-and-what-is-an-unused-image" target="_blank" rel="external">Docker: What is a dangling image and what is an unused image?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对释放 Docker 占的磁盘，网络，数据卷的命令做一个整理。内容部分来自网络，一部分来自自己的总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://knarfeh.github.io/tags/Docker/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
</feed>
