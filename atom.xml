<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frank&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://knarfeh.github.io/"/>
  <updated>2018-10-20T14:25:58.576Z</updated>
  <id>http://knarfeh.github.io/</id>
  
  <author>
    <name>Frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 源码笔记（kubeadm）</title>
    <link href="http://knarfeh.github.io/2018/07/28/Kubernetes%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88kubeadm%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/07/28/Kubernetes 源码笔记（kubeadm）/</id>
    <published>2018-07-27T16:15:05.000Z</published>
    <updated>2018-10-20T14:25:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 发展初期，部署 Kubernetes 一直是一件让初学者头疼的事情，Kubernetes 也开始重视这个问题，2017年，在社区志愿者的推动下，社区发起了一个独立的部署 Kubernetes 的项目，<a href="https://github.com/kubernetes/kubeadm" target="_blank" rel="external">kubeadm</a>。</p>
<p>经过一年多的发展，kubeadm 已经可以一键式进行 Kubernetes 集群的快速初始化和安装，极大地简化了部署过程。值得一提的是，在很长一段时间里 kubeadm 有个比较欠缺的地方是无法做到一键部署一个高可用的 Kubernetes 集群，这是 kubeadm 目前的工作重点，好在这个功能已经在 1.11 版本刚刚发布，可以参考 <a href="https://kubernetes.io/docs/setup/independent/high-availability/" target="_blank" rel="external">Creating Highly Available Clusters with kubeadm</a>。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Kubernetes 是一个管理容器的平台，所以用容器来部署自身的组件是一件自然而然的事情，kube-apiserver, scheduler 等组件还好解决，比较麻烦的是 kubelet 组件，因为 kubelet 需要承担与容器运行时交互的工作，还需要解决容器运行时网络，存储的配置问题，这些都需要直接操作宿主机的，如果 kubelet 本身就运行在容器里，这些问题倒也不是不能解决，只是需要做各种方式的 hack，部署 Kubernetes 的这个需求会变得更为复杂。kubeadm 的方案是 kubelet 直接运行在宿主机上，其他的 Kubernetes 组件使用容器部署。</p>
<p>所以使用 kubeadm 的第一步手动安装 kubeadm，kubelet，kubectl 这3个二进制文件，可以参考我的 <a href="https://github.com/knarfeh/k8s-digitalocean-terraform/blob/9c7d1208d4f5e50204f95d1d353e1c914e837ea8/install-kubeadm.sh#L23" target="_blank" rel="external">k8s-digitalocean-terraform</a> 项目，里面有需要安装的依赖。<br>这是运行 kubeadm 的前提。</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>kubeadm 中比较关键的工作流程就两步，1. <code>kubeadm init</code> 进行初始化。2. <code>kubeadm join master-ip:master:port</code> 将 worker 节点连接到 master 节点，组成集群。</p>
<h4 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a><code>kubeadm init</code></h4><p>以下内容均考虑使用默认参数的情况。</p>
<p><code>kubeadm init</code> 首先会做一系列的检查工作，以确保当前机器是可以部署 Kubernetes 的。这一步叫做 Preflight Checks，包括：</p>
<ul>
<li>Linux 内核版本是否在 3.10 以上</li>
<li>Linux cgroups 是否可用</li>
<li>hostname 是否符合 DNS 命名规范(RFC 1123)</li>
<li>kubeadm 和 kubelet 版本是否匹配</li>
<li>是否安装了 Kubernetes 的二进制文件</li>
<li>10250，10251，10252 端口是否可用</li>
<li>ip、mount 工具是否已经存在</li>
<li>是否安装了 Docker</li>
</ul>
<p>接着 kubeadm 会生成 Kubernetes 对外提供服务所需的安全证书。</p>
<p>这个过程完成后，kubeadm 会为 Master 组件生成 Pod 的 yaml 格式的配置文件，存放在 <code>/etc/kubernetes/manifests</code>，kubelet 会使用一种叫做 Static Pod 的特殊的容器启动方法，根据 yaml 格式文件在机器上启动 kube-apiserver、kube-controller-manager、kube-scheduler、etcd 这四个组件。kubeadm 可以根据配置使用已有的 etcd 集群，不一定非得自己创建。</p>
<p>kubeadm 会监控 <code>/etc/kubernetes/manifests</code> 目录下的内容，一旦生成 yaml 文件，kubelet 就会创建这些 yaml 定义的 Pod，Master 节点的各个组件启动之后，kubeadm 会检查 <code>localhost:6443/healthz</code> 健康状态，直到 Master 节点完全运行起来。</p>
<p>再接下来 kubeadm 会为集群生成一个 bootstrap token，worker 节点可以通过这个 token 加入到集群里。生成 token  后，master 节点的重要信息会通过 cluster-info 这个 ConfigMap 保存到 etcd 里。</p>
<p>最后 kubeadm 会安装插件，有两个默认的必装的插件，一个是 kube-proxy，默认使用 iptable，未来 ipvs 会是默认选项；另一个是 DNS，默认安装 kubedns + dnsmsaq，未来趋势是转向 CoreDNS。插件会通过 Kubernetes 客户端进行创建。</p>
<h4 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a><code>kubeadm join</code></h4><p>其他节点加入到 Master 节点需要保证机器之间是网络互通的，这是将来容器之间网络互通的前提。执行完 <code>kubeadm init</code> 之后可以看到 <code>kubeadm join</code> 的使用方法，在其他机器上运行这行命令即可。</p>
<p><code>kubeadm join</code> 也会检测依赖环境，相比于 <code>kubeadm init</code> 要简单得多，通过检测时候，根据 token 从 kube-apiserver 拿到 <code>cluster-info</code>，获取 kube-apiserver 的证书，这时 kubelet 就接入了集群中。</p>
<p>如果机器很多，手工操作当然不酷，自动化才是未来，可以参考一下 <a href="https://github.com/knarfeh/k8s-digitalocean-terraform" target="_blank" rel="external">结合 Terraform 在 DigitalOcean 上一键式部署 Kubernetes</a> 这个项目。</p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>上面已经把流程描述了一遍，可以看出来，就代码实现来说，不会有什么很复杂的东西，其实代码里也真的是一股脑一个流程走到底，尽管如此我们还是继续研读一下代码，挖掘一些有价值的东西。</p>
<p>基于 v1.10.0-rc.1 代码版本进行分析。</p>
<h3 id="kubeadm-init-1"><a href="#kubeadm-init-1" class="headerlink" title="kubeadm init"></a>kubeadm init</h3><p><code>init</code> 方法的入口在 <code>cmd/kubeadm/app/cmd/init.go</code> </p>
<p>在 cobra 对应的 init 子命令下，先调用 <code>NewInit</code> 方法，进行 Preflight Checks 操作，确保本机可以运行 kubeadm，接着调用 <code>Init</code> 的 <code>Run</code> 方法进行 Master 节点的初始化操作。</p>
<h4 id="系统状态检查"><a href="#系统状态检查" class="headerlink" title="系统状态检查"></a>系统状态检查</h4><p>在 <code>NewInit</code> 里会调用 <code>RunInitMasterChecks</code> 用来完成安装前的检测，这部分内容都在 <code>cmd/kubeadm/preflight/checks.go</code> 里。核心逻辑是定义一堆 checks，然后进行变量，全部通过则满足 <code>Preflight Checks</code> 的要求。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="string">checks :</span>= []Checker&#123;</div><div class="line">	KubernetesVersionCheck&#123;<span class="string">KubernetesVersion:</span> cfg.KubernetesVersion, <span class="string">KubeadmVersion:</span> kubeadmversion.Get().GitVersion&#125;,</div><div class="line">	SystemVerificationCheck&#123;<span class="string">CRISocket:</span> cfg.CRISocket&#125;,</div><div class="line">	IsPrivilegedUserCheck&#123;&#125;,</div><div class="line">	HostnameCheck&#123;<span class="string">nodeName:</span> cfg.NodeName&#125;,</div><div class="line">	KubeletVersionCheck&#123;<span class="string">KubernetesVersion:</span> cfg.KubernetesVersion, <span class="string">exec:</span> execer&#125;,</div><div class="line">	ServiceCheck&#123;<span class="string">Service:</span> <span class="string">"kubelet"</span>, <span class="string">CheckIfActive:</span> <span class="literal">false</span>&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	FirewalldCheck&#123;<span class="string">ports:</span> []<span class="keyword">int</span>&#123;<span class="keyword">int</span>(cfg.API.BindPort), <span class="number">10250</span>&#125;&#125;,</div><div class="line">	PortOpenCheck&#123;<span class="string">port:</span> <span class="keyword">int</span>(cfg.API.BindPort)&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	FileAvailableCheck&#123;<span class="string">Path:</span> kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeAPIServer, manifestsDir)&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	InPathCheck&#123;<span class="string">executable:</span> <span class="string">"ip"</span>, <span class="string">mandatory:</span> <span class="literal">true</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	criCtlChecker,</div><div class="line">	ExtraArgsCheck&#123;</div><div class="line"><span class="symbol">		APIServerExtraArgs:</span>         cfg.APIServerExtraArgs,</div><div class="line"><span class="symbol">		ControllerManagerExtraArgs:</span> cfg.ControllerManagerExtraArgs,</div><div class="line"><span class="symbol">		SchedulerExtraArgs:</span>         cfg.SchedulerExtraArgs,</div><div class="line">	&#125;,</div><div class="line">	HTTPProxyCheck&#123;<span class="string">Proto:</span> <span class="string">"https"</span>, <span class="string">Host:</span> cfg.API.AdvertiseAddress&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>生成证书的操作在 <code>Init</code> 的 <code>Run</code> 方法里的 PHASE 1。调用 <code>certsphase.CreatePKIAssets</code> 实现。</p>
<p>这部分代码在 <code>cmd/kubeadm/app/cmd/phases/certs.go</code> 里，依次调用了一下函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CreateCACertAndKeyFiles,</div><div class="line">CreateAPIServerCertAndKeyFiles,</div><div class="line">CreateAPIServerKubeletClientCertAndKeyFiles,</div><div class="line">CreateEtcdCACertAndKeyFiles,</div><div class="line">CreateEtcdServerCertAndKeyFiles,</div><div class="line">CreateEtcdPeerCertAndKeyFiles,</div><div class="line">CreateEtcdHealthcheckClientCertAndKeyFiles,</div><div class="line">CreateAPIServerEtcdClientCertAndKeyFiles,</div><div class="line">CreateServiceAccountKeyAndPublicKeyFiles,</div><div class="line">CreateFrontProxyCACertAndKeyFiles,</div><div class="line">CreateFrontProxyClientCertAndKeyFiles,</div></pre></td></tr></table></figure>
<p>为确保安全，Kubernetes 的各个组件需要使用 <code>x509</code> 证书对通信进行加密和认证，如果是使用手动安装的话，整个过程很复杂，所以 kbeadm 将这个过程自动化了。</p>
<p>首先通过 <code>CreateCACertAndKeyFiles</code> 创建 CA，用来签名后续创建的其他证书，对证书进行管理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCACertAndKeyFiles</span><span class="params">(cfg *kubeadmapi.MasterConfiguration)</span> <span class="title">error</span></span> &#123;</div><div class="line">	caCert, caKey, err := NewCACertAndKey()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> writeCertificateAuthorithyFilesIfNotExist(</div><div class="line">		cfg.CertificatesDir,</div><div class="line">		kubeadmconstants.CACertAndKeyBaseName,</div><div class="line">		caCert,</div><div class="line">		caKey,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCACertAndKey</span><span class="params">()</span> <span class="params">(*x509.Certificate, *rsa.PrivateKey, error)</span></span> &#123;</div><div class="line">	caCert, caKey, err := pkiutil.NewCertificateAuthority()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failure while generating CA certificate and key: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> caCert, caKey, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pkiutil 模块的 <code>NewCertificateAuthority</code> 在 <code>cmd/kubeadm/app/phases/certs/pkiutil/pki_helpers.go</code> 里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertificateAuthority</span><span class="params">()</span> <span class="params">(*x509.Certificate, *rsa.PrivateKey, error)</span></span> &#123;</div><div class="line">	key, err := certutil.NewPrivateKey()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create private key [%v]"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	config := certutil.Config&#123;</div><div class="line">		CommonName: <span class="string">"kubernetes"</span>,</div><div class="line">	&#125;</div><div class="line">	cert, err := certutil.NewSelfSignedCACert(config, key)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create self-signed certificate [%v]"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> cert, key, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>私钥通过 <code>k8s.io/client-go/util/cert</code> 包里的函数实现，其中 <code>NewPrivateKey</code> 只是对 rsa 库函数的封装。</p>
<p>以 <code>CreateAPIServerCertAndKeyFiles</code> 为例，我们再看 kube-apiserver 的证书是怎么生成的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAPIServerCertAndKeyFiles</span><span class="params">(cfg *kubeadmapi.MasterConfiguration)</span> <span class="title">error</span></span> &#123;</div><div class="line">	caCert, caKey, err := loadCertificateAuthority(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	apiCert, apiKey, err := NewAPIServerCertAndKey(cfg, caCert, caKey)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> writeCertificateFilesIfNotExist(</div><div class="line">		cfg.CertificatesDir,</div><div class="line">		kubeadmconstants.APIServerCertAndKeyBaseName,</div><div class="line">		caCert,</div><div class="line">		apiCert,</div><div class="line">		apiKey,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerCertAndKey</span><span class="params">(cfg *kubeadmapi.MasterConfiguration, caCert *x509.Certificate, caKey *rsa.PrivateKey)</span> <span class="params">(*x509.Certificate, *rsa.PrivateKey, error)</span></span> &#123;</div><div class="line"></div><div class="line">	altNames, err := pkiutil.GetAPIServerAltNames(cfg)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failure while composing altnames for API server: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	config := certutil.Config&#123;</div><div class="line">		CommonName: kubeadmconstants.APIServerCertCommonName,</div><div class="line">		AltNames:   *altNames,</div><div class="line">		Usages:     []x509.ExtKeyUsage&#123;x509.ExtKeyUsageServerAuth&#125;,</div><div class="line">	&#125;</div><div class="line">	apiCert, apiKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failure while creating API server key and certificate: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> apiCert, apiKey, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertAndKey</span><span class="params">(caCert *x509.Certificate, caKey *rsa.PrivateKey, config certutil.Config)</span> <span class="params">(*x509.Certificate, *rsa.PrivateKey, error)</span></span> &#123;</div><div class="line">	key, err := certutil.NewPrivateKey()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create private key [%v]"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cert, err := certutil.NewSignedCert(config, key, caCert, caKey)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to sign certificate [%v]"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> cert, key, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致流程和生成 ca 时类似，只是进行配置时需要生成 AltName，这是 master 的地址；最后生成证书是需要用 ca 添加数字签名，生成证书。</p>
<h4 id="生成-master-各组件所需的-kubeconfig"><a href="#生成-master-各组件所需的-kubeconfig" class="headerlink" title="生成 master 各组件所需的 kubeconfig"></a>生成 master 各组件所需的 kubeconfig</h4><p>这部分代码在 <code>cmd/kubeadm/app/phases/kubeconfig/kubeconfig.go</code> 里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateInitKubeConfigFiles</span><span class="params">(outDir <span class="keyword">string</span>, cfg *kubeadmapi.MasterConfiguration)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> createKubeConfigFiles(</div><div class="line">		outDir,</div><div class="line">		cfg,</div><div class="line">		kubeadmconstants.AdminKubeConfigFileName,</div><div class="line">		kubeadmconstants.KubeletKubeConfigFileName,</div><div class="line">		kubeadmconstants.ControllerManagerKubeConfigFileName,</div><div class="line">		kubeadmconstants.SchedulerKubeConfigFileName,</div><div class="line">	)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createKubeConfigFiles</span><span class="params">(outDir <span class="keyword">string</span>, cfg *kubeadmapi.MasterConfiguration, kubeConfigFileNames ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	specs, err := getKubeConfigSpecs(cfg)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, kubeConfigFileName := <span class="keyword">range</span> kubeConfigFileNames &#123;</div><div class="line">		spec, exists := specs[kubeConfigFileName]</div><div class="line">		<span class="keyword">if</span> !exists &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't retrive KubeConfigSpec for %s"</span>, kubeConfigFileName)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		config, err := buildKubeConfigFromSpec(spec)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err = createKubeConfigFileIfNotExists(outDir, kubeConfigFileName, config); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据配置获取 spec，然后根据根据 spec 依次生成 <code>admin.conf</code>, <code>controller-manager.conf</code>, <code>kubelet.conf</code>, <code>scheduler.conf</code> 文件。</p>
<h4 id="生成-Static-Pod-静态文件"><a href="#生成-Static-Pod-静态文件" class="headerlink" title="生成 Static Pod 静态文件"></a>生成 Static Pod 静态文件</h4><p>前面已经提过原理，kubelet 会监控 <code>/etc/kubernetes/manifests</code> 目录，加载所有的 Pod Yaml 文件，然后在本机上启动这些 Pod。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createStaticPodFiles</span><span class="params">(manifestDir <span class="keyword">string</span>, cfg *kubeadmapi.MasterConfiguration, componentNames ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	k8sVersion, err := version.ParseSemantic(cfg.KubernetesVersion)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	specs := GetStaticPodSpecs(cfg, k8sVersion)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, componentName := <span class="keyword">range</span> componentNames &#123;</div><div class="line">		spec, exists := specs[componentName]</div><div class="line">		<span class="keyword">if</span> !exists &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't retrive StaticPodSpec for %s"</span>, componentName)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err := staticpodutil.WriteStaticPodToDisk(componentName, manifestDir, spec); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create static pod manifest file for %q: %v"</span>, componentName, err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		fmt.Printf(<span class="string">"[controlplane] Wrote Static Pod manifest for component %s to %q\n"</span>, componentName, kubeadmconstants.GetStaticPodFilepath(componentName, manifestDir))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有配置外部的 etcd 集群，默认情况下也会根据这种方式创建 etcd。原理一样，不过代码在 <code>cmd/kubeadm/app/phases/etcd/local.go</code></p>
<h4 id="等待-master-启动"><a href="#等待-master-启动" class="headerlink" title="等待 master 启动"></a>等待 master 启动</h4><p>接下来的操作需要等待 master 的组件完全启动后才能进行，这一步需要拉取 kube-apiserver, kube-scheduler, kube-controller-manager, etcd 的镜像，可能会花费比较长的时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForAPIAndKubelet</span><span class="params">(waiter apiclient.Waiter)</span> <span class="title">error</span></span> &#123;</div><div class="line">	errorChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory %q.\n"</span>, kubeadmconstants.GetStaticPodDirectory())</div><div class="line">	fmt.Println(<span class="string">"[init] This might take a minute or longer if the control plane images have to be pulled."</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(errC <span class="keyword">chan</span> error, waiter apiclient.Waiter)</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err := waiter.WaitForHealthyKubelet(<span class="number">40</span>*time.Second, <span class="string">"http://localhost:10255/healthz"</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">			errC &lt;- err</div><div class="line">		&#125;</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(errC <span class="keyword">chan</span> error, waiter apiclient.Waiter)</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err := waiter.WaitForHealthyKubelet(<span class="number">60</span>*time.Second, <span class="string">"http://localhost:10255/healthz/syncloop"</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">			errC &lt;- err</div><div class="line">		&#125;</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(errC <span class="keyword">chan</span> error, waiter apiclient.Waiter)</span></span> &#123;</div><div class="line">		errC &lt;- waiter.WaitForAPI()</div><div class="line">	&#125;(errorChan, waiter)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &lt;-errorChan</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kubeadm 会不断检查 <code>http://localhost:6443/healthz</code> 这个健康检查的接口 以及 <code>http://localhost:10255/healthz</code>, <code>http://localhost:10255/healthz/syncloop</code> 这两个 kubelet 的可读接口，等待 Master 组件完全运行起来。</p>
<h4 id="存储-ConfigMap"><a href="#存储-ConfigMap" class="headerlink" title="存储 ConfigMap"></a>存储 ConfigMap</h4><p>这一步没什么特别的，通过 api-client 把 Master 的配置上传到 Kubernetes 的 ConfigMap。代码在 <code>cmd/kubeadm/app/phases/uploadconfig/uploadconfig.go</code>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func UploadConfiguration(cfg *kubeadmapi<span class="selector-class">.MasterConfiguration</span>, client clientset.Interface) error &#123;</div><div class="line">	fmt.Printf(<span class="string">"[uploadconfig] Storing the configuration used in ConfigMap %q in the %q Namespace\n"</span>, kubeadmconstants<span class="selector-class">.MasterConfigurationConfigMap</span>, metav1.NamespaceSystem)</div><div class="line"></div><div class="line">	externalcfg := &amp;kubeadmapiext.MasterConfiguration&#123;&#125;</div><div class="line">	legacyscheme<span class="selector-class">.Scheme</span><span class="selector-class">.Convert</span>(cfg, externalcfg, nil)</div><div class="line"></div><div class="line">	externalcfg<span class="selector-class">.Token</span> = <span class="string">""</span></div><div class="line"></div><div class="line">	cfgYaml, err := yaml.Marshal(*externalcfg)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return apiclient.CreateOrUpdateConfigMap(client, &amp;v1.ConfigMap&#123;</div><div class="line">		ObjectMeta: metav1.ObjectMeta&#123;</div><div class="line">			Name:      kubeadmconstants<span class="selector-class">.MasterConfigurationConfigMap</span>,</div><div class="line">			Namespace: metav1<span class="selector-class">.NamespaceSystem</span>,</div><div class="line">		&#125;,</div><div class="line">		Data: map[string]string&#123;</div><div class="line">			kubeadmconstants<span class="selector-class">.MasterConfigurationConfigMapKey</span>: string(cfgYaml),</div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 apiclient 是 kubeadm 对 api-client 的简单封装，代码在 <code>cmd/kubeadm/app/util/apiclient/idempotency.go</code></p>
<h4 id="创建-token"><a href="#创建-token" class="headerlink" title="创建 token"></a>创建 token</h4><p>生成的这个 token 让 worker 节点有权限可以拿到 cluster-info 这个 ConfigMap 里的信息，包括 api-server 的地址，认证信息等。</p>
<p>这部分代码在 <code>cmd/kubeadm/app/phases/bootstraptoken/node/token.go</code>。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">func UpdateOrCreateToken(client clientset.Interface, <span class="keyword">token</span> string, failIfExists bool, tokenDuration time.Duration, usages []string, extraGroups []string, description string) <span class="keyword">error</span> &#123;</div><div class="line">	tokenID, tokenSecret, <span class="keyword">err</span> := tokenutil.ParseToken(<span class="keyword">token</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	secretName := fmt.Sprintf(<span class="string">"%s%s"</span>, bootstrapapi.BootstrapTokenSecretPrefix, tokenID)</div><div class="line">	<span class="keyword">var</span> lastErr <span class="keyword">error</span></div><div class="line">	<span class="keyword">for</span> i := 0; i &lt; tokenCreateRetries; i++ &#123;</div><div class="line">		secret, <span class="keyword">err</span> := client.CoreV1().Secrets(metav1.NamespaceSystem).<span class="built_in">Get</span>(secretName, metav1.GetOptions&#123;&#125;)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> == nil &#123;</div><div class="line">			<span class="keyword">if</span> failIfExists &#123;</div><div class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"a token with id %q already exists"</span>, tokenID)</div><div class="line">			&#125;</div><div class="line">			tokenSecretData, <span class="keyword">err</span> := encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, extraGroups, description)</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">			&#125;</div><div class="line">			secret.Data = tokenSecretData</div><div class="line">			<span class="keyword">if</span> _, <span class="keyword">err</span> := client.CoreV1().Secrets(metav1.NamespaceSystem).<span class="keyword">Update</span>(secret); <span class="keyword">err</span> == nil &#123;</div><div class="line">				<span class="keyword">return</span> nil</div><div class="line">			&#125;</div><div class="line">			lastErr = <span class="keyword">err</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> apierrors.IsNotFound(<span class="keyword">err</span>) &#123;</div><div class="line">			tokenSecretData, <span class="keyword">err</span> := encodeTokenSecretData(tokenID, tokenSecret, tokenDuration, usages, extraGroups, description)</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			secret = &amp;v1.Secret&#123;</div><div class="line">				ObjectMeta: metav1.ObjectMeta&#123;</div><div class="line">					Name: secretName,</div><div class="line">				&#125;,</div><div class="line">				<span class="keyword">Type</span>: v1.SecretType(bootstrapapi.SecretTypeBootstrapToken),</div><div class="line">				Data: tokenSecretData,</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> _, <span class="keyword">err</span> := client.CoreV1().Secrets(metav1.NamespaceSystem).Create(secret); <span class="keyword">err</span> == nil &#123;</div><div class="line">				<span class="keyword">return</span> nil</div><div class="line">			&#125;</div><div class="line">			lastErr = <span class="keyword">err</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(</div><div class="line">		<span class="string">"unable to create bootstrap token after %d attempts [%v]"</span>,</div><div class="line">		tokenCreateRetries,</div><div class="line">		lastErr,</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 Kubernetes 的 secret 创建。</p>
<h4 id="安装-dns，kube-proxy-插件"><a href="#安装-dns，kube-proxy-插件" class="headerlink" title="安装 dns，kube-proxy 插件"></a>安装 dns，kube-proxy 插件</h4><p>dns，kube-proxy 是 Kubernetes 里默认的，必装的插件。</p>
<p>coreDNS 的 Deployment, ConfigMap, ClusterRole 等 yaml 配置直接用字符串定义在 <code>cmd/kubeadm/app/phases/addons/dns/manifests.go</code> 文件里。</p>
<p>代码基本就是根据配置渲染模板，通过 Kubernetes 的 api 创建，没什么特别的。</p>
<p>kube-proxy 的情况类似，yaml 配置在 <code>cmd/kubeadm/app/phases/addons/proxy/manifests.go</code> 文件里定义。</p>
<h3 id="kubeadm-join-1"><a href="#kubeadm-join-1" class="headerlink" title="kubeadm join"></a>kubeadm join</h3><p>join 方法跟 init 方法类似，但要简单得多，首先调用 <code>NewJoin</code>，先调用 <code>RunJoinNodeChecks</code> 来完成初始化前的检测，然后调用 <code>Run</code> 方法将本节点加入到集群里。</p>
<h4 id="系统状态检查-1"><a href="#系统状态检查-1" class="headerlink" title="系统状态检查"></a>系统状态检查</h4><p>worker 节点的 preflight checks 跟 master 节点的略微不同。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">checks :</span>= []Checker&#123;</div><div class="line">	SystemVerificationCheck&#123;<span class="string">CRISocket:</span> cfg.CRISocket&#125;,</div><div class="line">	IsPrivilegedUserCheck&#123;&#125;,</div><div class="line">	HostnameCheck&#123;cfg.NodeName&#125;,</div><div class="line">	KubeletVersionCheck&#123;<span class="string">exec:</span> execer&#125;,</div><div class="line">	ServiceCheck&#123;<span class="string">Service:</span> <span class="string">"kubelet"</span>, <span class="string">CheckIfActive:</span> <span class="literal">false</span>&#125;,</div><div class="line">	PortOpenCheck&#123;<span class="string">port:</span> <span class="number">10250</span>&#125;,</div><div class="line">	DirAvailableCheck&#123;<span class="string">Path:</span> filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.ManifestsSubDirName)&#125;,</div><div class="line">	FileAvailableCheck&#123;<span class="string">Path:</span> cfg.CACertPath&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了一些常规的检测外，worker 节点还需要确保 ip, ipables, mount 命令已经安装好了。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"linux"</span> &#123;</div><div class="line">		checks = append(checks,</div><div class="line">			FileContentCheck&#123;<span class="string">Path:</span> bridgenf, <span class="string">Content:</span> []<span class="keyword">byte</span>&#123;<span class="string">'1'</span>&#125;&#125;,</div><div class="line">			SwapCheck&#123;&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"ip"</span>, <span class="string">mandatory:</span> <span class="literal">true</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"iptables"</span>, <span class="string">mandatory:</span> <span class="literal">true</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"mount"</span>, <span class="string">mandatory:</span> <span class="literal">true</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"nsenter"</span>, <span class="string">mandatory:</span> <span class="literal">true</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"ebtables"</span>, <span class="string">mandatory:</span> <span class="literal">false</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"ethtool"</span>, <span class="string">mandatory:</span> <span class="literal">false</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"socat"</span>, <span class="string">mandatory:</span> <span class="literal">false</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"tc"</span>, <span class="string">mandatory:</span> <span class="literal">false</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			InPathCheck&#123;<span class="string">executable:</span> <span class="string">"touch"</span>, <span class="string">mandatory:</span> <span class="literal">false</span>, <span class="string">exec:</span> execer&#125;,</div><div class="line">			criCtlChecker)</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func (j *Join) <span class="keyword">Run</span>(<span class="keyword">out</span> io.Writer) <span class="keyword">error</span> &#123;</div><div class="line">	cfg, <span class="keyword">err</span> := discovery.<span class="keyword">For</span>(j.cfg)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	kubeconfigFile := filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.KubeletBootstrapKubeConfigFileName)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := kubeconfigutil.WriteToDisk(kubeconfigFile, cfg); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't save bootstrap-kubelet.conf to disk: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">cluster</span> := cfg.Contexts[cfg.CurrentContext].<span class="keyword">Cluster</span></div><div class="line">	<span class="keyword">err</span> = certutil.WriteCert(j.cfg.CACertPath, cfg.Clusters[<span class="keyword">cluster</span>].CertificateAuthorityData)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't save the CA certificate to disk: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> features.Enabled(j.cfg.FeatureGates, features.DynamicKubeletConfig) &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := kubeletphase.ConsumeBaseKubeletConfiguration(j.cfg.NodeName); <span class="keyword">err</span> != nil &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error consuming base kubelet configuration: %v"</span>, <span class="keyword">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Fprintf(<span class="keyword">out</span>, joinDoneMsgf)</div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>join 命令会调用 <code>func (j *Join) Run(out io.Writer) error</code> 方法，先根据 token 获取 <code>cluster-info</code> 里的信息，写入 <code>bootstrap-kubelet.conf</code> 文件，然后向 Master 提交一个 certificate signing request (CSR)，通过后 worker 节点保存 <code>ca.crt</code> 和 <code>kubelet.conf</code> 文件，<code>bootstrap-kubelet.conf</code> 会被删除，这时应用 <code>kubelet.conf</code> 本节点就加入了集群。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kubeadm 是 Kubernetes 项目的原生部署工具，使用 kubeadm 部署一个 Kubernetes 集群，对于理解 Kubernetes 组件的架构很有帮助。从实现来看，kubeadm 简洁明了，对于最新版的 Kubernetes 支持很好，而且和 k8s 一样是用 Golang 写的，只需要运行一个二进制文件就行，很轻便。深入代码，我们会发现 kubeadm 完全没有如何考虑部署高可用的 Kubernetes 集群，比如创建 kube-proxy 不能配置 kube-apiserver 的地址；运行 kubeadm join 时不能对 kube-apiserver 地址进行配置。几乎没有实现高可用的扩展性，这一功能的缺失使得整个社区诞生了很多的更复杂的部署工具，有的基于 Ansible，有的是提供了一堆 shell 脚本，还有的基于 kubeadm 做修改，有的甚至用 Golang 重新写了一套部署工具，百花齐放，只是质量参差不齐，光是调研这些工具就需要很多成本和精力。值得期待的是，kubeadm 在往『部署高可用集群』这个方向努力，等到这个特性稳定之后有机会我们再研读一下代码。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/knarfeh/k8s-digitalocean-terraform" target="_blank" rel="external">knarfeh/k8s-digitalocean-terraform</a></li>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="external">Creating a single master cluster with kubeadm</a></li>
<li><a href="https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md" target="_blank" rel="external">kubeadm design_v1.10</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Kubernetes 发展初期，部署 Kubernetes 一直是一件让初学者头疼的事情，Kubernetes 也开始重视这个问题，2017年，在社区志愿者的推动下，社区发起了一个独立的部署 Kubernetes 的项目，&lt;a href=&quot;https://github.com/kubernetes/kubeadm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kubeadm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;经过一年多的发展，kubeadm 已经可以一键式进行 Kubernetes 集群的快速初始化和安装，极大地简化了部署过程。值得一提的是，在很长一段时间里 kubeadm 有个比较欠缺的地方是无法做到一键部署一个高可用的 Kubernetes 集群，这是 kubeadm 目前的工作重点，好在这个功能已经在 1.11 版本刚刚发布，可以参考 &lt;a href=&quot;https://kubernetes.io/docs/setup/independent/high-availability/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Creating Highly Available Clusters with kubeadm&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Telegram Bot 的长轮询 VS Webhook</title>
    <link href="http://knarfeh.github.io/2018/03/20/Telegram%20Bot%20%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2%20VS%20Webhook/"/>
    <id>http://knarfeh.github.io/2018/03/20/Telegram Bot 的长轮询 VS Webhook/</id>
    <published>2018-03-20T01:42:59.000Z</published>
    <updated>2018-09-04T16:58:36.856Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th></th>
<th>长轮询（long polling）</th>
<th>Webhook</th>
</tr>
</thead>
<tbody>
<tr>
<td>简述</td>
<td>利用 API 中的 getUpdates 方法， 如果 Bot <strong>上次标记完成后</strong>没有收到信息，或消息已保存超过24小时，该方法会保持等待直到超时，在等待期间收到信息将会立刻返回结果；反之，该方法会返回一组包含了24小时内所有未标记信息的 Updates。利用 offset 参数可以将部分消息标记为已处理。</td>
<td>利用  setWebhook 方法告知服务器一个 url， 服务器将会在收到新消息时，通过 POST 方法将 json 格式的 Update 对象发送到指定的 url 地址。如果发送失败，Telegram 会重试一定次数。这个 url 必须是 https 的。</td>
</tr>
<tr>
<td>性能</td>
<td>没法做负载均衡，数据量比较大的情况话，性能瓶颈可能出现在 worker 上。</td>
<td>与传统服务器没有太大差异，可以做负载均衡（高可用），可以横向扩展。未来可以对接 Serverless，可扩展性更强</td>
</tr>
<tr>
<td>开发效率</td>
<td>不需要搭建服务器，不需要处理 https 证书，有一个机器人的 token 就可以在本地开发</td>
<td>在不搭建服务器的情况下，可以用 google script 开发，但只能用类 Javascript 语言。如果要用其他语言开发，需搭建服务器，需 https</td>
</tr>
<tr>
<td>交互体验</td>
<td>响应速度较 Webhook 慢</td>
<td>响应速度取决于网络延迟，体验一般比长轮询好</td>
</tr>
</tbody>
</table>
<p>结论：如果追求开发速度，并且不需要考虑服务的高可用性，在可预知用户量不会增长过快的情况下，建议使用长轮询的方式，未来用户增长比较多再改也来得及，否则用 Webhook 的方式。如果对交互体验要求高的话，最好采用 Webhook 的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;长轮询（long polling）&lt;/th&gt;
&lt;th&gt;Webhook&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简述&lt;/td&gt;
&lt;td&gt;利用 API 中的 getUpdates 
    
    </summary>
    
    
      <category term="Telegram" scheme="http://knarfeh.github.io/tags/Telegram/"/>
    
      <category term="robot" scheme="http://knarfeh.github.io/tags/robot/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E9%93%BE%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core, eth 模块-链的索引，搜索）/</id>
    <published>2018-03-10T14:35:09.000Z</published>
    <updated>2018-10-26T04:35:19.707Z</updated>
    
    <content type="html"><![CDATA[<p>阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="事件和日志"><a href="#事件和日志" class="headerlink" title="事件和日志"></a>事件和日志</h3><p>在以太坊中，事件和日志的概念经常被混用可能会让人觉得困惑，所以我们先理清这两者关系。在 Solidity 和 web3.js 里，这个概念叫做 Event，常用中文翻译是事件，它的作用是在智能合约的运行中，将一些比较重要的数据记录到区块链上，在 geth 里称为日志，这些日志与合约地址是相关联的，geth 会不断地对事件，或者说日志进行索引，也会通过暴露 API 的方式让用户可以过滤，查找日志。比较典型的应用场景是，用户在页面上调用了智能合约，在智能合约里发生了一次转账的操作，这时记录一个事件，应用程序通过 web3.js 监听事件，一旦事件发生了，可以触发回调函数，进行下一步处理，比如在 UI 上做出响应。</p>
<p>每一笔交易的收据可能会包含0个到多个日志记录，它们代表着智能合约在运行过程中触发的事件。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>在 geth 中，日志的索引，过滤通过布隆过滤器来实现。</p>
<p>布隆过滤器可以用来判断一个元素是否在一个集合中，对于这种场景，最简单的方式是采用 HashTable 的方式来存储，好处是快速，精确，但会耗费大量的存储空间。1970年布隆提出一种空间复杂度和空间复杂度都很低的数据结构，利用位数组来表示一个集合，键值经过 k 个独立哈希函数后，将对应的值的位数置1，查找时进行同样的哈希计算，如果对应位全为1说明该值存在，它的缺点是有一定的错误率，它不能告诉你某个元素一定在集合内，但它可以告诉你某个元素一定不在集合内或可能在集合内。误算率的大小与数据的数量，布隆过滤器的长度，以及哈希函数有关。</p>
<p>如果想要深入了解布隆过滤器，建议浏览：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a> </li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
</ul>
<h4 id="误算率推导"><a href="#误算率推导" class="headerlink" title="误算率推导"></a>误算率推导</h4><p>假设布隆过滤器有 m 比特，里面有 n 个元素，每个元素对应 k 个哈希函数处理后的比特位，插入一个元素时，哈希函数会把过滤器中的某个比特位置置为1，对于一个特定的位置，如果这个元素经哈希过的 k 个比特位都没有把它置为 1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^k$</p>
<p>如果插入了 n 个元素还没有把某个特定的比特位置为1，其概率是：</p>
<p>$\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>因此，插入了 n 个元素，某个特定比特位置为1的概率为：</p>
<p>$1-\left(1-\frac{1}{m}\right)^{kn}$</p>
<p>对于一个错误识别的元素，经哈希过的 k 个比特位均为1，概率为：</p>
<p>$\left(1-\left[1-\frac{1}{m}\right]^{kn}\right)^k$</p>
<p>有 $\lim_{x\to0}\frac{e^x-1}{x}=1$ ，则 $m\to\infty$时，上述公式近似于：</p>
<p>$\left( 1-e^{\frac{-kn}{m}} \right)^k$</p>
<p>设 $a=e^{\frac{n}{m}}$, 错误识别的概率为：</p>
<p>$f(k) = (1-a^{-k})^{k}$</p>
<p>我们需要知道，在 k 取什么值时，$f(k)$ 可以取到最值。先两边取对数：</p>
<p>$\frac{f’(k)}{f(k)}=\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}$</p>
<p>令导数 $f’(k)$为0，有：</p>
<p>$\ln\left(1-a^{-k}\right)+k\cdot\frac{a^{-k}\cdot\ln{a}}{1-a^{-k}}=0$</p>
<p>$(1-a^{-k})\cdot\ln\left(1-a^{-k}\right)=a^{-k}\cdot\ln{a}^{-k}$</p>
<p>对于 $f(x)=xlnx$，可证，不存在 $x_1+x_2=1$，使得 $f(x_1) = f(x_2)$</p>
<p>可得 $a^{k}=2$</p>
<p>即 $k=\frac{m}{n}\cdot ln{2}$ 时，误判率 $f(k)$ 可取到最小值，为 $2^{-ln 2\cdot\frac{m}{n}}$</p>
<p>还有一个结论，当 $k=\frac{m}{n}\cdot ln{2}$，$\left(1-\frac{1}{m}\right)^{kn}=\frac{1}{2}$ 也就是说某个 bit 位在插入 n 个元素后未被置1的概率为 $\frac{1}{2}$，即空间使用率为 50%，也就是说，要保持错误率低，布隆过滤器的空间使用率应小于 50%。根据空间使用率，我们可以推导 n，k 确定的情况下，要保持错误率最低，所需的最小内存空间（即 m 的大小）是多少，这个值应该为 n*k 的两倍。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>Bigtable 使用布隆过滤器查找不存在的行或列，以减少磁盘查找的 IO 次数</li>
<li>Google Chrome 浏览器使用布隆过滤器加速安全浏览服务</li>
<li>LevelDB, Hbase, Accumulo 等 key-value 数据库使用布隆过滤器加速查询过程，避免很多不必要的磁盘 IO 操作</li>
</ul>
<h2 id="geth-的实现"><a href="#geth-的实现" class="headerlink" title="geth 的实现"></a>geth 的实现</h2><p>geth 的索引，过滤功能包括对交易，区块，区块头，最新日志，特定日志的过滤，代码涉及到 <code>eth/filters</code>, <code>eth/bloombits.go</code>, <code>core/chain_indexer.go</code>, <code>core/bloombits</code> 等模块。内部的实现其实挺复杂，重构一下可能会好很多，深入到这些功能的实现，还是要有章法，采用从上之下的方式是比较好的，否则直接阅读内部实现的话，可能线索会比较错乱，不如先从 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 提供的几个 API 入手，从入口开始剖析。geth 的索引过滤功能底层的实现主要依赖布隆过滤器，读者如果在阅读下文之前就熟悉布隆过滤器自然再好不过，不了解的话可以先从 API 调用入手，在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%EF%BC%89/#%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="external">过滤功能的使用</a>这小节结束后再好好学习相关基础知识以加强理解。</p>
<h3 id="过滤功能的使用"><a href="#过滤功能的使用" class="headerlink" title="过滤功能的使用"></a>过滤功能的使用</h3><p>这里指的使用是指比较高层次的，通过 web3.js 可以直接进行交互的调用。</p>
<p>使用布隆过滤器的代码主要在 <code>eth/filter</code> 文件夹里。</p>
<p><code>eth/filter</code> 模块比较直观地提供了日志过滤的功能，这里我们可以先将布隆过滤器的实现视为黑盒，看看所谓的日志，收据的过滤到底是一个什么功能。</p>
<p>先看 <code>eth/filters/api.go</code> 里的内容。</p>
<h4 id="api-go"><a href="#api-go" class="headerlink" title="api.go"></a>api.go</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> filter <span class="keyword">struct</span> &#123;</div><div class="line">	typ      Type</div><div class="line">	deadline *time.Timer</div><div class="line">	hashes   []common.Hash</div><div class="line">	crit     FilterCriteria</div><div class="line">	logs     []*types.Log</div><div class="line">	s        *Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> PublicFilterAPI <span class="keyword">struct</span> &#123;</div><div class="line">	backend   Backend</div><div class="line">	mux       *event.TypeMux</div><div class="line">	quit      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	chainDb   ethdb.Database</div><div class="line">	events    *EventSystem</div><div class="line">	filtersMu sync.Mutex</div><div class="line">	filters   <span class="keyword">map</span>[rpc.ID]*filter</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>filter</code> 结构体用来存储过滤器的一些元信息，<code>PublicFilterAPI</code> 用来创建和管理这些过滤器，供外部客户端调用，它暴露的 API 在 Backend 里定义，这部分内容在 <code>eth/filters/filter.go</code> 里面，在之后会详细看这部分。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><code>PublicFilterAPI</code> 初始化的逻辑很简单，就一个 New 外加 <code>go api.timeoutLoop()</code> 一行而已，这里不再给出初始化的代码了。由于需要注册 API，同其他 backend 一样，调用 <code>NewPublicFilterAPI</code> 进行服务注册的部分在 <code>eth/backend.go</code> 中，有兴趣的话读者可以自己看看。</p>
<h5 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">timeoutLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	ticker := time.NewTicker(<span class="number">5</span> * time.Minute)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		&lt;-ticker.C</div><div class="line">		api.filtersMu.Lock()</div><div class="line">		<span class="keyword">for</span> id, f := <span class="keyword">range</span> api.filters &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-f.deadline.C:</div><div class="line">				f.s.Unsubscribe()</div><div class="line">				<span class="built_in">delete</span>(api.filters, id)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		api.filtersMu.Unlock()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PublicFilterAPI</code> 初始化时只用了一个 goroutine 来启动 <code>timeoutLoop()</code>，<code>timeoutLoop()</code> 做的事情很简单，对于加入到 <code>PublicFilterAPI</code> 的 filters，每过5分钟检查一次，如果过期了就删除 filter。</p>
<h5 id="增加-filter"><a href="#增加-filter" class="headerlink" title="增加 filter"></a>增加 filter</h5><p><code>PublicFilterAPI</code> 的主循环会处理 <code>filter</code>，那么 <code>filter</code> 是怎么添加的，其实是通过 <code>NewPendingTransactionFilter</code> 来添加，这个 API 也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter" target="_blank" rel="external">JSON-RPC</a> 直接调用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactionFilter</span><span class="params">()</span> <span class="title">rpc</span>.<span class="title">ID</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		pendingTxs   = <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash)</div><div class="line">		pendingTxSub = api.events.SubscribePendingTxs(pendingTxs)</div><div class="line">	)</div><div class="line"></div><div class="line">	api.filtersMu.Lock()</div><div class="line">	api.filters[pendingTxSub.ID] = &amp;filter&#123;typ: PendingTransactionsSubscription, deadline: time.NewTimer(deadline), hashes: <span class="built_in">make</span>([]common.Hash, <span class="number">0</span>), s: pendingTxSub&#125;</div><div class="line">	api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> ph := &lt;-pendingTxs:</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="keyword">if</span> f, found := api.filters[pendingTxSub.ID]; found &#123;</div><div class="line">					f.hashes = <span class="built_in">append</span>(f.hashes, ph...)</div><div class="line">				&#125;</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">			<span class="keyword">case</span> &lt;-pendingTxSub.Err():</div><div class="line">				api.filtersMu.Lock()</div><div class="line">				<span class="built_in">delete</span>(api.filters, pendingTxSub.ID)</div><div class="line">				api.filtersMu.Unlock()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> pendingTxSub.ID</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于非长连接的情况，也就是说对于使用 HTTP 的方式进行过滤的情况，可以使用这个 API，它可以用来创建一个 filter，当有新交易时，会存储到 filter 的哈希池里。</p>
<p>然后客户端可以通过轮询该 filter 来获取过滤的结果。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetFilterChanges</span><span class="params">(id rpc.ID)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	api.filtersMu.Lock()</div><div class="line">	<span class="keyword">defer</span> api.filtersMu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f, found := api.filters[id]; found &#123;</div><div class="line">		<span class="keyword">if</span> !f.deadline.Stop() &#123;</div><div class="line">			&lt;-f.deadline.C</div><div class="line">		&#125;</div><div class="line">		f.deadline.Reset(deadline)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> f.typ &#123;</div><div class="line">		<span class="keyword">case</span> PendingTransactionsSubscription, BlocksSubscription:</div><div class="line">			hashes := f.hashes</div><div class="line">			f.hashes = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnHashes(hashes), <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> LogsSubscription:</div><div class="line">			logs := f.logs</div><div class="line">			f.logs = <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span> returnLogs(logs), <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;, fmt.Errorf(<span class="string">"filter not found"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分也可以通过 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterchanges" target="_blank" rel="external">JSON-RPC</a> 进行调用。</p>
<p>对于长连接的情况，可以使用 rpc 包的发送订阅模式功能，直接调用 <code>NewPendingTransactions</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">NewPendingTransactions</span><span class="params">(ctx context.Context)</span> <span class="params">(*rpc.Subscription, error)</span></span> &#123;</div><div class="line">	notifier, supported := rpc.NotifierFromContext(ctx)</div><div class="line">	<span class="keyword">if</span> !supported &#123;</div><div class="line">		<span class="keyword">return</span> &amp;rpc.Subscription&#123;&#125;, rpc.ErrNotificationsUnsupported</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	rpcSub := notifier.CreateSubscription()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		txHashes := <span class="built_in">make</span>(<span class="keyword">chan</span> []common.Hash, <span class="number">128</span>)</div><div class="line">		pendingTxSub := api.events.SubscribePendingTxs(txHashes)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> hashes := &lt;-txHashes:</div><div class="line">				<span class="keyword">for</span> _, h := <span class="keyword">range</span> hashes &#123;</div><div class="line">					notifier.Notify(rpcSub.ID, h)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> &lt;-rpcSub.Err():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-notifier.Closed():</div><div class="line">				pendingTxSub.Unsubscribe()</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> rpcSub, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是对交易的过滤，此外 <code>PublicFilterAPI</code> 还提供了对区块，区块头，最新日志的过滤，如果有兴趣的话可以看 <code>func (api *PublicFilterAPI) NewBlockFilter()</code>, <code>func (api *PublicFilterAPI) NewHeads</code>, <code>func (api *PublicFilterAPI) Logs</code> 这几个方法的实现。这些只是交易，区块等内容的过滤，对于获取特定条件的日志的功能则在 <code>NewFilter</code>, <code>GetLogs</code>, <code>GetFilterLogs</code>, <code>GetFilterChanges</code> 这几个方法的帮助下完成。比如 <code>GetLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PublicFilterAPI)</span> <span class="title">GetLogs</span><span class="params">(ctx context.Context, crit FilterCriteria)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filter *Filter</div><div class="line">	<span class="keyword">if</span> crit.BlockHash != <span class="literal">nil</span> &#123;</div><div class="line">		filter = NewBlockFilter(api.backend, *crit.BlockHash, crit.Addresses, crit.Topics)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		begin := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.FromBlock != <span class="literal">nil</span> &#123;</div><div class="line">			begin = crit.FromBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		end := rpc.LatestBlockNumber.Int64()</div><div class="line">		<span class="keyword">if</span> crit.ToBlock != <span class="literal">nil</span> &#123;</div><div class="line">			end = crit.ToBlock.Int64()</div><div class="line">		&#125;</div><div class="line">		filter = NewRangeFilter(api.backend, begin, end, crit.Addresses, crit.Topics)</div><div class="line">	&#125;</div><div class="line">	logs, err := filter.Logs(ctx)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> returnLogs(logs), err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以根据开始区块，结束区块，地址，Topics 来获取符合条件的日志。可以看到获取日志主要通过 filter 的 Logs 方法得到，这就引入了 Filter 对象，这部分内容在 <code>eth/filters/filter.go</code> 里。</p>
<h4 id="filter-go"><a href="#filter-go" class="headerlink" title="filter.go"></a>filter.go</h4><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</div><div class="line">	ChainDb() ethdb.Database</div><div class="line">	EventMux() *event.TypeMux</div><div class="line">	HeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Header, error)</div><div class="line">	GetReceipts(ctx context.Context, blockHash common.Hash) (types.Receipts, error)</div><div class="line">	GetLogs(ctx context.Context, blockHash common.Hash) ([][]*types.Log, error)</div><div class="line"></div><div class="line">	SubscribeNewTxsEvent(<span class="keyword">chan</span>&lt;- core.NewTxsEvent) event.Subscription</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- core.ChainEvent) event.Subscription</div><div class="line">	SubscribeRemovedLogsEvent(ch <span class="keyword">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</div><div class="line">	SubscribeLogsEvent(ch <span class="keyword">chan</span>&lt;- []*types.Log) event.Subscription</div><div class="line"></div><div class="line">	BloomStatus() (<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</div><div class="line">	ServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter <span class="keyword">struct</span> &#123;</div><div class="line">	backend Backend</div><div class="line"></div><div class="line">	db         ethdb.Database</div><div class="line">	begin, end <span class="keyword">int64</span></div><div class="line">	addresses  []common.Address</div><div class="line">	topics     [][]common.Hash</div><div class="line"></div><div class="line">	matcher *bloombits.Matcher</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 结构体中定义了 <code>Backend</code> 接口，<code>Backend</code> 接口定义了布隆过滤器实现的接口，这些接口的实现是在 <code>eth/api_backend.go</code> 里的 L212-234，可以说是比较低层次的 API。而 Matcher 是布隆过滤器的 Matcher，这部分我们将在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#Matcher" target="_blank" rel="external">Matcher</a> 进行分析</p>
<h5 id="Filter-的初始化"><a href="#Filter-的初始化" class="headerlink" title="Filter 的初始化"></a>Filter 的初始化</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(backend Backend, begin, end <span class="keyword">int64</span>, addresses []common.Address, topics [][]common.Hash)</span> *<span class="title">Filter</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> filters [][][]<span class="keyword">byte</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(addresses))</div><div class="line">		<span class="keyword">for</span> i, address := <span class="keyword">range</span> addresses &#123;</div><div class="line">			filter[i] = address.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, topicList := <span class="keyword">range</span> topics &#123;</div><div class="line">		filter := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(topicList))</div><div class="line">		<span class="keyword">for</span> i, topic := <span class="keyword">range</span> topicList &#123;</div><div class="line">			filter[i] = topic.Bytes()</div><div class="line">		&#125;</div><div class="line">		filters = <span class="built_in">append</span>(filters, filter)</div><div class="line">	&#125;</div><div class="line">	size, _ := backend.BloomStatus()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;Filter&#123;</div><div class="line">		backend:   backend,</div><div class="line">		begin:     begin,</div><div class="line">		end:       end,</div><div class="line">		addresses: addresses,</div><div class="line">		topics:    topics,</div><div class="line">		db:        backend.ChainDb(),</div><div class="line">		matcher:   bloombits.NewMatcher(size, filters),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 Filter 的参数中包含 addresses 或 topics，则都将其加入到 filters 容器中，在 matcher 的阶段会用到。</p>
<h5 id="过滤日志"><a href="#过滤日志" class="headerlink" title="过滤日志"></a>过滤日志</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">Logs</span><span class="params">(ctx context.Context)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	header, _ := f.backend.HeaderByNumber(ctx, rpc.LatestBlockNumber)</div><div class="line">	<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	head := header.Number.Uint64()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> f.begin == <span class="number">-1</span> &#123;</div><div class="line">		f.begin = <span class="keyword">int64</span>(head)</div><div class="line">	&#125;</div><div class="line">	end := <span class="keyword">uint64</span>(f.end)</div><div class="line">	<span class="keyword">if</span> f.end == <span class="number">-1</span> &#123;</div><div class="line">		end = head</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		logs []*types.Log</div><div class="line">		err  error</div><div class="line">	)</div><div class="line">	size, sections := f.backend.BloomStatus()</div><div class="line">	<span class="keyword">if</span> indexed := sections * size; indexed &gt; <span class="keyword">uint64</span>(f.begin) &#123;</div><div class="line">		<span class="keyword">if</span> indexed &gt; end &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, end)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			logs, err = f.indexedLogs(ctx, indexed<span class="number">-1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	rest, err := f.unindexedLogs(ctx, end)</div><div class="line">	logs = <span class="built_in">append</span>(logs, rest...)</div><div class="line">	<span class="keyword">return</span> logs, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Logs</code> 会从区块链中找到匹配的 log 项。首先根据最新的区块号拿到最新区块，这样如果没有 end 参数的，搜索的区间的 end 就是最新区块。接着调用 <code>BloomStatus()</code> 拿到索引的状态，需要注意的是，尽管每个区块头都有 logBloom，日志的过滤不会直接依次检索这些区块头的 logBloom，因为遍历区块头的话效率太低了，需要多次的磁盘 IO，geth 会在 LevelDB 里维护另一套索引，以4096个区块为一个 section，在一个 section 内的 logBloom 会存在一起，所以对于位于已索引的区块这一区间的搜索，会调用 <code>indexedLogs</code> 进行搜索，对于在已索引区间外的区块，会调用 <code>unindexedLogs</code> 进行搜索。我们先看 <code>indexedLogs</code> 的实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">indexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	matches := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="number">64</span>)</div><div class="line">	session, err := f.matcher.Start(ctx, <span class="keyword">uint64</span>(f.begin), end, matches)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line">	f.backend.ServiceFilter(ctx, session)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> number, ok := &lt;-matches:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				err := session.Error()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">					f.begin = <span class="keyword">int64</span>(end) + <span class="number">1</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			f.begin = <span class="keyword">int64</span>(number) + <span class="number">1</span></div><div class="line">			header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(number))</div><div class="line">			<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">			<span class="keyword">return</span> logs, ctx.Err()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>indexedLogs</code> 会调用 <code>Matcher 的 Start</code> 方法启动 session，其结果会返回到 matches 这个 channel 里，找到区块后，通过调用 <code>checkMatches</code> 以验证该区块确实在区块链中（因为布隆过滤器有一定几率误判），验证完成后，结果会增加到 logs 这个变量中，直到接收到 Done 消息，然后返回 logs。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">checkMatches</span><span class="params">(ctx context.Context, header *types.Header)</span> <span class="params">(logs []*types.Log, err error)</span></span> &#123;</div><div class="line">	logsList, err := f.backend.GetLogs(ctx, header.Hash())</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> unfiltered []*types.Log</div><div class="line">	<span class="keyword">for</span> _, logs := <span class="keyword">range</span> logsList &#123;</div><div class="line">		unfiltered = <span class="built_in">append</span>(unfiltered, logs...)</div><div class="line">	&#125;</div><div class="line">	logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> logs[<span class="number">0</span>].TxHash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			receipts, err := f.backend.GetReceipts(ctx, header.Hash())</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			unfiltered = unfiltered[:<span class="number">0</span>]</div><div class="line">			<span class="keyword">for</span> _, receipt := <span class="keyword">range</span> receipts &#123;</div><div class="line">				unfiltered = <span class="built_in">append</span>(unfiltered, receipt.Logs...)</div><div class="line">			&#125;</div><div class="line">			logs = filterLogs(unfiltered, <span class="literal">nil</span>, <span class="literal">nil</span>, f.addresses, f.topics)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>checkMatches</code> 做的事情简单来说就是根据 <code>header</code> 的哈希值，从 <code>backend</code> 拿到所有的收据，然后调用 <code>filterLogs</code> 对 topics 一一进行匹配，匹配上了则可以确定该 logs 确实在区块链中（布隆过滤器没有误判）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterLogs</span><span class="params">(logs []*types.Log, fromBlock, toBlock *big.Int, addresses []common.Address, topics [][]common.Hash)</span> []*<span class="title">types</span>.<span class="title">Log</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> ret []*types.Log</div><div class="line">Logs:</div><div class="line">	<span class="keyword">for</span> _, log := <span class="keyword">range</span> logs &#123;</div><div class="line">		<span class="keyword">if</span> fromBlock != <span class="literal">nil</span> &amp;&amp; fromBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; fromBlock.Uint64() &gt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> toBlock != <span class="literal">nil</span> &amp;&amp; toBlock.Int64() &gt;= <span class="number">0</span> &amp;&amp; toBlock.Uint64() &lt; log.BlockNumber &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &amp;&amp; !includes(addresses, log.Address) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(topics) &gt; <span class="built_in">len</span>(log.Topics) &#123;</div><div class="line">			<span class="keyword">continue</span> Logs</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> i, topics := <span class="keyword">range</span> topics &#123;</div><div class="line">			fmt.Println(topics)</div><div class="line">			match := <span class="built_in">len</span>(topics) == <span class="number">0</span></div><div class="line">			<span class="keyword">for</span> _, topic := <span class="keyword">range</span> topics &#123;</div><div class="line">				<span class="keyword">if</span> log.Topics[i] == topic &#123;</div><div class="line">					match = <span class="literal">true</span></div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !match &#123;</div><div class="line">				<span class="keyword">continue</span> Logs</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ret = <span class="built_in">append</span>(ret, log)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>filterLogs</code> 方法的逻辑很简单，遍历 <code>topics</code>，如果能和 log 中的 Topics 匹配上则添加到需返回的 logs 中。</p>
<p><code>indexedLogs</code> 方法是对有索引的日志的查询，前面有介绍到在 Logs 方法中，还有一个对未索引日志的查询，即 <code>unindexedLogs</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Filter)</span> <span class="title">unindexedLogs</span><span class="params">(ctx context.Context, end <span class="keyword">uint64</span>)</span> <span class="params">([]*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> logs []*types.Log</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ; f.begin &lt;= <span class="keyword">int64</span>(end); f.begin++ &#123;</div><div class="line">		header, err := f.backend.HeaderByNumber(ctx, rpc.BlockNumber(f.begin))</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> logs, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomFilter(header.Bloom, f.addresses, f.topics) &#123;</div><div class="line">			found, err := f.checkMatches(ctx, header)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> logs, err</div><div class="line">			&#125;</div><div class="line">			logs = <span class="built_in">append</span>(logs, found...)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> logs, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会根据传入的 <code>end</code>，遍历所有区块，首先通过 header 的 Bloom 判断 topics 是否可能存在，如果有可能存在，直接调用 <code>checkMatches</code> 来查看是否匹配。至此通过对已索引，未索引的日志进行过滤，就可以通过条件获取特定的日志。</p>
<p>以上就是对 geth 过滤功能的概览，可以说是过滤功能的高层次调用，接下来我们将深入这些模块的实现。</p>
<h3 id="创建索引的实现"><a href="#创建索引的实现" class="headerlink" title="创建索引的实现"></a>创建索引的实现</h3><p>要实现布隆过滤器，首先需要给区块链创建索引，这样才能实现快速响应用户的日志搜索功能。这部分代码主要在 <code>core/chain_indexer</code> 模块里。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChainIndexerBackend <span class="keyword">interface</span> &#123;</div><div class="line">	Reset(section <span class="keyword">uint64</span>, prevHead common.Hash) error</div><div class="line">	Process(header *types.Header)</div><div class="line">	Commit() error</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> ChainIndexerChain <span class="keyword">interface</span> &#123;</div><div class="line">	SubscribeChainEvent(ch <span class="keyword">chan</span>&lt;- ChainEvent) event.Subscription</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ChainIndexer <span class="keyword">struct</span> &#123;</div><div class="line">	chainDb  ethdb.Database</div><div class="line">	indexDb  ethdb.Database</div><div class="line">	backend  ChainIndexerBackend</div><div class="line">	children []*ChainIndexer</div><div class="line"></div><div class="line">	active <span class="keyword">uint32</span></div><div class="line">	update <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	quit   <span class="keyword">chan</span> <span class="keyword">chan</span> error</div><div class="line"></div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	confirmsReq <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	storedSections <span class="keyword">uint64</span></div><div class="line">	knownSections  <span class="keyword">uint64</span></div><div class="line">	cascadedHead   <span class="keyword">uint64</span></div><div class="line"></div><div class="line">	throttling time.Duration</div><div class="line"></div><div class="line">	log  log.Logger</div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要了解一些定义，这部分代码中经常出现的 section 是指一组区块头，而这个一组的数量默认为 4096。</p>
<p><code>ChainIndexerBackend</code> 是一个接口，它定义了处理区块链 section 的方法，这个接口目前有 <code>BloomIndexer</code> 这个实现。其中 <code>Reset(section uint64)</code> 用来初始化一个新的区块链 section，可能会终止任何没有完成的操作；<code>Process(header *types.Header)</code> 对区块链 section 中的下一个区块头进行处理，增加新区块头到 index，调用者需要确保区块头的连续顺序；<code>Commit() error</code> 完成区块链 section 的元数据提交，并将其存储到数据库。</p>
<p>以下是 <code>ChainIndexer</code> 结构体中较重要的一些属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">chainDb</td>
<td style="text-align:center">区块链所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">indexDb</td>
<td style="text-align:center">索引所在的数据库</td>
</tr>
<tr>
<td style="text-align:center">backend</td>
<td style="text-align:center">生成索引的后端，它实现了 <code>ChainIndexerBacken</code> 所定义的接口，这里的实现我们只探讨 <code>eth/bloombits</code> 中的 BloomIndexer，在 light 模式中有其他实现</td>
</tr>
<tr>
<td style="text-align:center">children</td>
<td style="text-align:center">子链的索引，这是为了处理临时分叉的情况</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">事件循环是否开始的标志</td>
</tr>
<tr>
<td style="text-align:center">update</td>
<td style="text-align:center">新生成区块头发送到这个 channel</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">退出事件循环的 channel</td>
</tr>
<tr>
<td style="text-align:center">sectionSize</td>
<td style="text-align:center">索引器会一组一组处理区块头，默认的大小是 4096</td>
</tr>
<tr>
<td style="text-align:center">confirmReq</td>
<td style="text-align:center">处理完成的 section 之前的确认次数</td>
</tr>
<tr>
<td style="text-align:center">storedSections</td>
<td style="text-align:center">已经成功进行索引的 section 的数量</td>
</tr>
<tr>
<td style="text-align:center">knownSections</td>
<td style="text-align:center">已知的 section 数量</td>
</tr>
<tr>
<td style="text-align:center">cascadedHead</td>
<td style="text-align:center">级联到子索引最后一个完成的 section 的区块数</td>
</tr>
<tr>
<td style="text-align:center">throttling</td>
<td style="text-align:center">对磁盘的限制，防止大量区块进行索引</td>
</tr>
</tbody>
</table>
<h4 id="初始化-ChainIndexer"><a href="#初始化-ChainIndexer" class="headerlink" title="初始化 ChainIndexer"></a>初始化 ChainIndexer</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChainIndexer</span><span class="params">(chainDb, indexDb ethdb.Database, backend ChainIndexerBackend, section, confirm <span class="keyword">uint64</span>, throttling time.Duration, kind <span class="keyword">string</span>)</span> *<span class="title">ChainIndexer</span></span> &#123;</div><div class="line">	c := &amp;ChainIndexer&#123;</div><div class="line">		chainDb:     chainDb,</div><div class="line">		indexDb:     indexDb,</div><div class="line">		backend:     backend,</div><div class="line">		update:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</div><div class="line">		quit:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error),</div><div class="line">		sectionSize: section,</div><div class="line">		confirmsReq: confirm,</div><div class="line">		throttling:  throttling,</div><div class="line">		log:         log.New(<span class="string">"type"</span>, kind),</div><div class="line">	&#125;</div><div class="line">	c.loadValidSections()</div><div class="line">	<span class="keyword">go</span> c.updateLoop()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化 <code>ChainIndexer</code> 时，先调用 <code>loadValidSections</code>，从数据库中加载之前处理过的信息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">loadValidSections</span><span class="params">()</span></span> &#123;</div><div class="line">	data, _ := c.indexDb.Get([]<span class="keyword">byte</span>(<span class="string">"count"</span>))</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">8</span> &#123;</div><div class="line">		c.storedSections = binary.BigEndian.Uint64(data[:])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来会以一个 goroutine 的方式进入一个事件循环，它会调用 backend 处理区块链 section。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">updateLoop</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		updating <span class="keyword">bool</span></div><div class="line">		updated  time.Time</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> errc := &lt;-c.quit:</div><div class="line">			errc &lt;- <span class="literal">nil</span></div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-c.update:</div><div class="line">			c.lock.Lock()</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				<span class="keyword">if</span> time.Since(updated) &gt; <span class="number">8</span>*time.Second &#123;</div><div class="line">					<span class="keyword">if</span> c.knownSections &gt; c.storedSections+<span class="number">1</span> &#123;</div><div class="line">						updating = <span class="literal">true</span></div><div class="line">						c.log.Info(<span class="string">"Upgrading chain index"</span>, <span class="string">"percentage"</span>, c.storedSections*<span class="number">100</span>/c.knownSections)</div><div class="line">					&#125;</div><div class="line">					updated = time.Now()</div><div class="line">				&#125;</div><div class="line">				section := c.storedSections</div><div class="line">				<span class="keyword">var</span> oldHead common.Hash</div><div class="line">				<span class="keyword">if</span> section &gt; <span class="number">0</span> &#123;</div><div class="line">					oldHead = c.SectionHead(section - <span class="number">1</span>)</div><div class="line">				&#125;</div><div class="line">				c.lock.Unlock()</div><div class="line">				newHead, err := c.processSection(section, oldHead)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					c.log.Error(<span class="string">"Section processing failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">				&#125;</div><div class="line">				c.lock.Lock()</div><div class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; oldHead == c.SectionHead(section<span class="number">-1</span>) &#123;</div><div class="line">					c.setSectionHead(section, newHead)</div><div class="line">					c.setValidSections(section + <span class="number">1</span>)</div><div class="line">					<span class="keyword">if</span> c.storedSections == c.knownSections &amp;&amp; updating &#123;</div><div class="line">						updating = <span class="literal">false</span></div><div class="line">						c.log.Info(<span class="string">"Finished upgrading chain index"</span>)</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					c.cascadedHead = c.storedSections*c.sectionSize - <span class="number">1</span></div><div class="line">					<span class="keyword">for</span> _, child := <span class="keyword">range</span> c.children &#123;</div><div class="line">						c.log.Trace(<span class="string">"Cascading chain index update"</span>, <span class="string">"head"</span>, c.cascadedHead)</div><div class="line">						child.newHead(c.cascadedHead, <span class="literal">false</span>)</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					c.log.Debug(<span class="string">"Chain index processing failed"</span>, <span class="string">"section"</span>, section, <span class="string">"err"</span>, err)</div><div class="line">					c.knownSections = c.storedSections</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> c.knownSections &gt; c.storedSections &#123;</div><div class="line">				time.AfterFunc(c.throttling, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> c.update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</div><div class="line">					<span class="keyword">default</span>:</div><div class="line">					&#125;</div><div class="line">				&#125;)</div><div class="line">			&#125;</div><div class="line">			c.lock.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当索引需要更新时，其他 goroutine 会往 <code>update</code> 这个 channel 发送消息，主要的逻辑代码都在这个 case 分支。当已知的 section 数大于存储的 section 数，这时需要开始索引，先通过调用 <code>SectionHead</code> 拿到上一个 section 的最后一个区块的哈希值，接着调用 <code>processSection</code> 开始新 section 的索引。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainIndexer)</span> <span class="title">processSection</span><span class="params">(section <span class="keyword">uint64</span>, lastHead common.Hash)</span> <span class="params">(common.Hash, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Reset(section, lastHead); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.setValidSections(<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> number := section * c.sectionSize; number &lt; (section+<span class="number">1</span>)*c.sectionSize; number++ &#123;</div><div class="line">		hash := GetCanonicalHash(c.chainDb, number)</div><div class="line">		<span class="keyword">if</span> hash == (common.Hash&#123;&#125;) &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"canonical block #%d unknown"</span>, number)</div><div class="line">		&#125;</div><div class="line">		header := GetHeader(c.chainDb, hash, number)</div><div class="line">		<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"block #%d [%x…] not found"</span>, number, hash[:<span class="number">4</span>])</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> header.ParentHash != lastHead &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, fmt.Errorf(<span class="string">"chain reorged during section processing"</span>)</div><div class="line">		&#125;</div><div class="line">		c.backend.Process(header)</div><div class="line">		lastHead = header.Hash()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := c.backend.Commit(); err != <span class="literal">nil</span> &#123;</div><div class="line">		c.log.Error(<span class="string">"Section commit failed"</span>, <span class="string">"error"</span>, err)</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> lastHead, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只探讨 <code>eth/bloombits</code> 的实现，首先看 <code>Reset</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Reset</span><span class="params">(section <span class="keyword">uint64</span>, lastSectionHead common.Hash)</span> <span class="title">error</span></span> &#123;</div><div class="line">	gen, err := bloombits.NewGenerator(<span class="keyword">uint</span>(b.size))</div><div class="line">	b.gen, b.section, b.head = gen, section, common.Hash&#123;&#125;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的 <code>lastSectionHead</code> 参数其实没有用到，在 light 模式的实现中是有用到的，这里我们先不深究。实际上 reset 方法只是简单的初始化 <code>core/bloombits/generator</code>，这部分我们在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core,%20eth%20%E6%A8%A1%E5%9D%97-LOG%20%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%87%E6%BB%A4%EF%BC%89/#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">布隆过滤器的实现</a>这一小结会讨论，先跳过这部分。回到 <code>processSection</code> 方法，如果 <code>Reset</code> 方法返回错误了，我们会重置已经存储的 section。接下来我们遍历当前 section，通过调用 <code>GetCanonicalHash</code> 获得当前区块哈希，然后拿到当前区块链中的 header，通过调用 <code>Process(header)</code> 添加当前的区块索引到布隆过滤器的 bit 数组中。</p>
<p>这部分代码在 eth/bloombits.go 中</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BloomIndexer)</span> <span class="title">Process</span><span class="params">(header *types.Header)</span></span> &#123;</div><div class="line">	b.gen.AddBloom(<span class="keyword">uint</span>(header.Number.Uint64()-b.section*b.size), header.Bloom)</div><div class="line">	b.head = header.Hash()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 <code>AddBloom</code> 在 <code>core/bloombits/generator.go</code> 中。generator 用来生成基于 section 的布隆过滤器索引数据的对象，其内部的结构是：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Generator <span class="keyword">struct</span> &#123;</div><div class="line">	blooms   [types.BloomBitLength][]<span class="keyword">byte</span></div><div class="line">	sections <span class="keyword">uint</span></div><div class="line">	nextSec  <span class="keyword">uint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>bloom[2048][4096]</code> 这个类型用来存储索引的数据，比如第20个 header 的 <code>logBloom</code> 存储在 <code>bloom[2048][20]</code> 里。<code>sections</code> 指明操作的 section 的数量，<code>nextSec</code> 表示增加一个 bloom 的时候，需要设置的下一个 bit。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Generator)</span> <span class="title">AddBloom</span><span class="params">(index <span class="keyword">uint</span>, bloom types.Bloom)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> b.nextBit &gt;= b.sections &#123;</div><div class="line">		<span class="keyword">return</span> errSectionOutOfBounds</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> b.nextBit != index &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"bloom filter with unexpected index"</span>)</div><div class="line">	&#125;</div><div class="line">	byteIndex := b.nextBit / <span class="number">8</span></div><div class="line">	bitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(<span class="number">7</span>-b.nextBit%<span class="number">8</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; types.BloomBitLength; i++ &#123;</div><div class="line">		bloomByteIndex := types.BloomByteLength - <span class="number">1</span> - i/<span class="number">8</span></div><div class="line">		bloomBitMask := <span class="keyword">byte</span>(<span class="number">1</span>) &lt;&lt; <span class="keyword">byte</span>(i%<span class="number">8</span>)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (bloom[bloomByteIndex] &amp; bloomBitMask) != <span class="number">0</span> &#123;</div><div class="line">			b.blooms[i][byteIndex] |= bitMask</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	b.nextBit++</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AddBloom</code> 增加一个区块的 bit 数组。当 <code>nextBit</code> 超过 sections 时，返回超出 section 最大数量的错误，确保 <code>nextBit</code> 始终等于 index，即 bloom 在 section 里的下标，通过 <code>nextBit/8</code> 得到需要设置的 byte 位置，接着就是根据 <code>BloomBitLength</code> 变量，生成一个 bloom 数据。</p>
<h3 id="过滤功能的实现"><a href="#过滤功能的实现" class="headerlink" title="过滤功能的实现"></a>过滤功能的实现</h3><p>前面创建索引的时候有涉及到布隆过滤器的一部分功能，接下来我们来深入探讨一下布隆过滤器功能的实现。这部分代码主要在 <code>core/bloombits</code> 里。<code>core/bloombits</code> 目录下，逻辑代码都在 <code>generator.go</code>，<code>matcher.go</code>，<code>scheduler.go</code> 中，其中 generator 生成基于 section 的布隆过滤器索引数据的对象，matcher 用来匹配查询操作，scheduler 基于 section 的布隆过滤器的单个 bit 值检索进行调度。上文已经介绍了 <code>generator.go</code> 的功能，我们继续来看 <code>scheduler.go</code> 和 <code>matcher.go</code>。</p>
<h4 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h4><p>scheduler 用来调度检索操作，作为调度器，它还承担删除重复数据，缓存结果的功能，以保证在复杂的过滤条件下降低 IO 的开销。</p>
<h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">request</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	section uint64</div><div class="line">	bit     <span class="keyword">uint</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">response</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	cached []byte</div><div class="line">	done   chan <span class="class"><span class="keyword">struct</span>&#123;</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">scheduler</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	bit       <span class="keyword">uint</span></div><div class="line">	responses map[uint64]*response</div><div class="line">	lock      sync.Mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>request</code> 表示一个布隆检索任务。其中<code>section</code> 表示区块段号，每段 4096 个区块，bit 代表检索的是布隆过滤器的哪一位(一共2048位)。在同一个 section 的 logBloom 会存储在一起，对于每个 section，用一个二维数组 <code>A[2048][4096]</code> 来存储，上文已简略提到，第一维2048代表布隆过滤器的长度为2048个字节，第二位4096表示一个 section 里的所有区块，每个位置按照顺序代表其中一个区块。<code>response</code> 表示当前调度的请求的状态，该属性会在 scheduler 被引用。每产生一个请求，都会生成一个 <code>response</code> 对象来表示这个请求的状态，cached 会用来缓存这个 section 的结果。</p>
<p><code>scheduler</code> 的 bit 用来表示请求的是布隆过滤器的哪一个 bit 位(0-2047)，而 <code>response</code> 记录当前正在进行的请求或已经缓存的结果。</p>
<p><code>scheduler</code> 的 <code>run</code> 方法是调度逻辑代码的入口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">run</span><span class="params">(sections <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	pend := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(dist))</div><div class="line"></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> s.scheduleRequests(sections, dist, pend, quit, wg)</div><div class="line">	<span class="keyword">go</span> s.scheduleDeliveries(pend, done, quit, wg)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中参数 <code>sections</code> 是需要检索的区块段的 channel，<code>dist</code> 是输出通道，表示从本地检索还是从网络中检索，往这个 channel 发送请求，结果可以从 done 通道中拿到。<code>pend := make(chan uint64, cap(dist))</code> 在请求和响应之间创建一个与分发通道大小相同的转发器通道。</p>
<p>先看 <code>scheduleRequests</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleRequests</span><span class="params">(reqs <span class="keyword">chan</span> <span class="keyword">uint64</span>, dist <span class="keyword">chan</span> *request, pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pend)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> section, ok := &lt;-reqs:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			unique := <span class="literal">false</span></div><div class="line"></div><div class="line">			s.lock.Lock()</div><div class="line">			<span class="keyword">if</span> s.responses[section] == <span class="literal">nil</span> &#123;</div><div class="line">				s.responses[section] = &amp;response&#123;</div><div class="line">					done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">				&#125;</div><div class="line">				unique = <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Unlock()</div><div class="line">			<span class="keyword">if</span> unique &#123;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> dist &lt;- &amp;request&#123;bit: s.bit, section: section&#125;:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> pend &lt;- section:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>schedulerRequests</code> 会从 reqs 这个 channel 接收到 section 消息，然后将接收到的 section 封装成 request 发送到 dist 这个 channel，构建对象 <code>response[section]</code>，接着 section 还会发送给 pend 队列，<code>run</code> 方法调用的 <code>scheduleDeliveries</code> 会进行处理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">scheduleDeliveries</span><span class="params">(pend <span class="keyword">chan</span> <span class="keyword">uint64</span>, done <span class="keyword">chan</span> []<span class="keyword">byte</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-quit:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> idx, ok := &lt;-pend:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			s.lock.Lock()</div><div class="line">			res := s.responses[idx]</div><div class="line">			s.lock.Unlock()</div><div class="line"></div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-res.done:</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> done &lt;- res.cached:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleDelivers</code> 接收到 <code>pend</code> 消息后，会阻塞在 <code>response[section].done</code> 上。接着等待外部调用 <code>deliver</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scheduler)</span> <span class="title">deliver</span><span class="params">(sections []<span class="keyword">uint64</span>, data [][]<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	s.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> s.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, section := <span class="keyword">range</span> sections &#123;</div><div class="line">		<span class="keyword">if</span> res := s.responses[section]; res != <span class="literal">nil</span> &amp;&amp; res.cached == <span class="literal">nil</span> &#123; </div><div class="line">			res.cached = data[i]</div><div class="line">			<span class="built_in">close</span>(res.done)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 deliver 方法，section 的 <code>request</code> 请求结果会写入 <code>response[section].cached</code>，然后关闭 <code>response[section].done</code> 这个 channel 。</p>
<p><code>scheduleDelivers</code> 接收到 <code>response[section].done</code> 信息后，<code>response[section].cached</code> 会发送到 <code>done</code> 这个channel，至此，一次检索的调度就结束了。</p>
<p>在下面的 Matcher 中，distributor 就有调用 schedule 的 deliver 方法的例子。</p>
<h4 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h4><p>Matcher 完成真正的匹配工作，对 filter 进行二进制的与/或操作。</p>
<p>大致流程（下面的语句需转换为流程图，文字用到代码的描述里了）：</p>
<p>/*</p>
<ol>
<li>Matcher 根据传入的 filter 个数，创建对应个数 subMatch，每个 subMatch 对应一个 filter 对象，每个 subMatch 会把自己的查找结果和上一个查找结果按照与的方式得到新的结果。这样可以实现短路算法。</li>
<li>Matcher 根据 filters 的布隆过滤器组合下标个数启动对应个数的 schedule，subMatch 会把请求发送给对应的 schedule。</li>
<li>schedule 调度请求，通过 dist 发送给 disrupter，在 disrupter 中管理起来</li>
<li>启动多个 Multiplex 线程，从 distributor 中获取请求，然后把请求发送给 bloomRequests 队列，startBloomHandlers 会访问数据库，拿到数据后返回给 Multiplex</li>
<li>Multiplex 通过 deliveries 通过将回答告诉 distributor</li>
<li>distributor 调用 schedule 的 deliver 方法，将结果发送给 schedule，schedule 把结果返回给 subMatch</li>
<li>subMatch 把结果计算后发送给下一个 subMatch 进行处理。如果是最后一个 subMatch，那么结果会进行处理后发送给 results channel。<br>*/</li>
</ol>
<h5 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> partialMatches <span class="keyword">struct</span> &#123;</div><div class="line">	section <span class="keyword">uint64</span></div><div class="line">	bitset  []<span class="keyword">byte</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Retrieval <span class="keyword">struct</span> &#123;</div><div class="line">	Bit      <span class="keyword">uint</span></div><div class="line">	Sections []<span class="keyword">uint64</span></div><div class="line">	Bitsets  [][]<span class="keyword">byte</span></div><div class="line"></div><div class="line">	Context context.Context</div><div class="line">	Error   error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Matcher <span class="keyword">struct</span> &#123;</div><div class="line">	sectionSize <span class="keyword">uint64</span></div><div class="line">	filters    [][]bloomIndexes</div><div class="line">	schedulers <span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler</div><div class="line"></div><div class="line">	retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	counters   <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	retrievals <span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval</div><div class="line">	deliveries <span class="keyword">chan</span> *Retrieval</div><div class="line">	running <span class="keyword">uint32</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>partialMatches</code> 表示部分匹配的结果，<code>Retrieval</code> 表示一次区块布隆过滤器的检索工作，在使用过程中，该对象会被发送给 <code>eth/bloombits.go</code> 中的 <code>startBloomHandlers</code> 来处理，该方法从数据库中加载布隆过滤器索引，然后放在 Bitsets 里返回（待确认）。Matcher 是一个操作调度器（scheduler）和匹配器（matcher）的流水线系统，它会对比特流进行二进制的与/或操作，对数据内容进行检索，创建可能的区块。</p>
<p>构造 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMatcher</span><span class="params">(sectionSize <span class="keyword">uint64</span>, filters [][][]<span class="keyword">byte</span>)</span> *<span class="title">Matcher</span></span> &#123;</div><div class="line">	m := &amp;Matcher&#123;</div><div class="line">		sectionSize: sectionSize,</div><div class="line">		schedulers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*scheduler),</div><div class="line">		retrievers:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		counters:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span>),</div><div class="line">		retrievals:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval),</div><div class="line">		deliveries:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Retrieval),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(filter) == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		bloomBits := <span class="built_in">make</span>([]bloomIndexes, <span class="built_in">len</span>(filter))</div><div class="line">		<span class="keyword">for</span> i, clause := <span class="keyword">range</span> filter &#123;</div><div class="line">			<span class="keyword">if</span> clause == <span class="literal">nil</span> &#123;</div><div class="line">				bloomBits = <span class="literal">nil</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			bloomBits[i] = calcBloomIndexes(clause)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> bloomBits != <span class="literal">nil</span> &#123;</div><div class="line">			m.filters = <span class="built_in">append</span>(m.filters, bloomBits)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, bloomIndexLists := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		<span class="keyword">for</span> _, bloomIndexList := <span class="keyword">range</span> bloomIndexLists &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomIndex := <span class="keyword">range</span> bloomIndexList &#123;</div><div class="line">				m.addScheduler(bloomIndex)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> m</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewMatcher</code> 根据传入的 filters 分别进行初始化操作，接着可以在可以在 <code>Start</code> 中创建对应数量的 schedule，subMatch。</p>
<p>启动 Matcher：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">Start</span><span class="params">(ctx context.Context, begin, end <span class="keyword">uint64</span>, results <span class="keyword">chan</span> <span class="keyword">uint64</span>)</span> <span class="params">(*MatcherSession, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> atomic.SwapUint32(&amp;m.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"matcher already running"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> atomic.StoreUint32(&amp;m.running, <span class="number">0</span>)</div><div class="line">	session := &amp;MatcherSession&#123;</div><div class="line">		matcher: m,</div><div class="line">		quit:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		kill:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		ctx:     ctx,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, scheduler := <span class="keyword">range</span> m.schedulers &#123;</div><div class="line">		scheduler.reset()</div><div class="line">	&#125;</div><div class="line">	sink := m.run(begin, end, <span class="built_in">cap</span>(results), session)</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> res, ok := &lt;-sink:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				sectionStart := res.section * m.sectionSize</div><div class="line"></div><div class="line">				first := sectionStart</div><div class="line">				<span class="keyword">if</span> begin &gt; first &#123;</div><div class="line">					first = begin</div><div class="line">				&#125;</div><div class="line">				last := sectionStart + m.sectionSize - <span class="number">1</span></div><div class="line">				<span class="keyword">if</span> end &lt; last &#123;</div><div class="line">					last = end</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> i := first; i &lt;= last; i++ &#123;</div><div class="line">					next := res.bitset[(i-sectionStart)/<span class="number">8</span>]</div><div class="line">					<span class="keyword">if</span> next == <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">if</span> i%<span class="number">8</span> == <span class="number">0</span> &#123;</div><div class="line">							i += <span class="number">7</span></div><div class="line">						&#125;</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> bit := <span class="number">7</span> - i%<span class="number">8</span>; next&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span> &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> results &lt;- i:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> session, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Start</code> 方法首先启动一个 session，这个 session 会被返回，它可以用来管理日志过滤的生命周期，调用者会将它作为 <code>ServiceFilter</code> 的参数，根据 <code>bloomFilterThreads</code> 这个常数值（默认为3），启动 <code>bloomFilterThreads</code> 个 session 的 <code>Multiplex</code>，该方法会不断地从 distributor 领取任务，将任务投递给 bloomRequest 队列，从队列中获取结果，然后投递给 distributor，这个 Multiplex 非常重要。</p>
<p>接下来会调用 run 方法，该方法会返回一个 channel，该 channel 会一直返回搜索的结果，直到返回一个退出的信号，<code>Start</code> 方法才会结束，对于过滤的结果，其中包括 section 和 bitmap，bitmap 表明了 section 中哪些区块可能存在值，这时需要遍历这个 bitmap，找到被置位的区块，然后把区块号返回到 results 通道。接下来我们看 <code>run</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">run</span><span class="params">(begin, end <span class="keyword">uint64</span>, buffer <span class="keyword">int</span>, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	source := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, buffer)</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(source)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> i := begin / m.sectionSize; i &lt;= end/m.sectionSize; i++ &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> source &lt;- &amp;partialMatches&#123;i, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0xff</span>&#125;, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))&#125;:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	next := source</div><div class="line">	dist := <span class="built_in">make</span>(<span class="keyword">chan</span> *request, buffer)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, bloom := <span class="keyword">range</span> m.filters &#123;</div><div class="line">		next = m.subMatch(next, dist, bloom, session)</div><div class="line">	&#125;</div><div class="line">	session.pend.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> m.distributor(dist, session)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>run 方法会创建一个子匹配器的流水线，一个用于地址集合，一个用于 topic 集合。之所以称为流水线是因为它会一个一个地调用子匹配器，之前的子匹配器找到了匹配的区块后才会调用下一个子匹配器，接收到的结果会与自身结果匹配后结合，发到下一个子匹配器。最终返回一个接收结果的接收器通道。该方法首先起一个 go routine, 构造 subMatch 的第一个输入源，这个源的 bitset 字段是 0xff，表示完全匹配，这个结果会作为第一个子匹配器的输入。在结尾还会用新线程的方式调用 <code>distributor</code>，这个方法我们之后再谈，接下来我们看 <code>subMatch</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">subMatch</span><span class="params">(source <span class="keyword">chan</span> *partialMatches, dist <span class="keyword">chan</span> *request, bloom []bloomIndexes, session *MatcherSession)</span> <span class="title">chan</span> *<span class="title">partialMatches</span></span> &#123;</div><div class="line">	sectionSources := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	sectionSinks := <span class="built_in">make</span>([][<span class="number">3</span>]<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">len</span>(bloom))</div><div class="line">	<span class="keyword">for</span> i, bits := <span class="keyword">range</span> bloom &#123;</div><div class="line">		<span class="keyword">for</span> j, bit := <span class="keyword">range</span> bits &#123;</div><div class="line">			sectionSources[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="built_in">cap</span>(source))</div><div class="line">			sectionSinks[i][j] = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">			m.schedulers[bit].run(sectionSources[i][j], dist, sectionSinks[i][j], session.quit, &amp;session.pend)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	process := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> *partialMatches, <span class="built_in">cap</span>(source))</div><div class="line"></div><div class="line">	session.pend.Add(<span class="number">2</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(process)</div><div class="line"></div><div class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">				<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">					<span class="built_in">close</span>(bitSource)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-source:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">for</span> _, bloomSources := <span class="keyword">range</span> sectionSources &#123;</div><div class="line">					<span class="keyword">for</span> _, bitSource := <span class="keyword">range</span> bloomSources &#123;</div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> bitSource &lt;- subres.section:</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> process &lt;- subres:</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> session.pend.Done()</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> subres, ok := &lt;-process:</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">var</span> orVector []<span class="keyword">byte</span></div><div class="line">				<span class="keyword">for</span> _, bloomSinks := <span class="keyword">range</span> sectionSinks &#123;</div><div class="line">					<span class="keyword">var</span> andVector []<span class="keyword">byte</span></div><div class="line">					<span class="keyword">for</span> _, bitSink := <span class="keyword">range</span> bloomSinks &#123;</div><div class="line">						<span class="keyword">var</span> data []<span class="keyword">byte</span></div><div class="line">						<span class="keyword">select</span> &#123;</div><div class="line">						<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">							<span class="keyword">return</span></div><div class="line">						<span class="keyword">case</span> data = &lt;-bitSink:</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">if</span> andVector == <span class="literal">nil</span> &#123;</div><div class="line">							andVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">							<span class="built_in">copy</span>(andVector, data)</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							bitutil.ANDBytes(andVector, andVector, data)</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">						orVector = andVector</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						bitutil.ORBytes(orVector, orVector, andVector)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> orVector == <span class="literal">nil</span> &#123;</div><div class="line">					orVector = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(m.sectionSize/<span class="number">8</span>))</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> subres.bitset != <span class="literal">nil</span> &#123;</div><div class="line">					bitutil.ANDBytes(orVector, orVector, subres.bitset)</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> bitutil.TestBytes(orVector) &#123;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> &lt;-session.quit:</div><div class="line">						<span class="keyword">return</span></div><div class="line">					<span class="keyword">case</span> results &lt;- &amp;partialMatches&#123;subres.section, orVector&#125;:</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> results</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>subMatch 会创建一个子匹配器，用于过滤一组 address 或 topic，在组内会进行 bit 位的或操作，然后将上一个结果与当前过滤结果进行位的与操作，如果结果不全为空，结果传递到下一个子匹配器。每个 address/topic 的匹配通过获取属于该 address/topics 的三个布隆过滤器位索引的给定部分以及这些向量二进制做与的运算。</p>
<p>注意这里的 bloom 参数的类型是 <code>[]bloomIndexes</code>，首先根据这个值创建相应个数的 schedulers，调用其对应的 run 方法。前面我们有介绍 schedulers 的 run 方法，它的作用是根据后端的实现（从硬盘或网络中）执行过滤操作，结果可以通过调用 scheduler 的 deliver 获得。</p>
<p>我们继续看上面提到的 <code>distributor</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Matcher)</span> <span class="title">distributor</span><span class="params">(dist <span class="keyword">chan</span> *request, session *MatcherSession)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> session.pend.Done()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		requests   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>][]<span class="keyword">uint64</span>)</div><div class="line">		unallocs   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]<span class="keyword">struct</span>&#123;&#125;)</div><div class="line">		retrievers <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint</span></div><div class="line">	)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		allocs   <span class="keyword">int</span></div><div class="line">		shutdown = session.quit</div><div class="line">	)</div><div class="line">	assign := <span class="function"><span class="keyword">func</span><span class="params">(bit <span class="keyword">uint</span>)</span></span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievers:</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			retrievers = m.retrievers</div><div class="line">			unallocs[bit] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-shutdown:</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			shutdown = <span class="literal">nil</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> &lt;-session.kill:</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> req := &lt;-dist:</div><div class="line">			queue := requests[req.bit]</div><div class="line">			index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= req.section &#125;)</div><div class="line">			requests[req.bit] = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;req.section&#125;, queue[index:]...)...)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</div><div class="line">				assign(req.bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-retrievers:</div><div class="line">			bit, best := <span class="keyword">uint</span>(<span class="number">0</span>), <span class="keyword">uint64</span>(math.MaxUint64)</div><div class="line">			<span class="keyword">for</span> idx := <span class="keyword">range</span> unallocs &#123;</div><div class="line">				<span class="keyword">if</span> requests[idx][<span class="number">0</span>] &lt; best &#123;</div><div class="line">					bit, best = idx, requests[idx][<span class="number">0</span>]</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">delete</span>(unallocs, bit)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(unallocs) == <span class="number">0</span> &#123;</div><div class="line">				retrievers = <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			allocs++</div><div class="line">			fetcher &lt;- bit</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.counters:</div><div class="line">			fetcher &lt;- <span class="keyword">uint</span>(<span class="built_in">len</span>(requests[&lt;-fetcher]))</div><div class="line"></div><div class="line">		<span class="keyword">case</span> fetcher := &lt;-m.retrievals:</div><div class="line">			task := &lt;-fetcher</div><div class="line">			<span class="keyword">if</span> want := <span class="built_in">len</span>(task.Sections); want &gt;= <span class="built_in">len</span>(requests[task.Bit]) &#123;</div><div class="line">				task.Sections = requests[task.Bit]</div><div class="line">				<span class="built_in">delete</span>(requests, task.Bit)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				task.Sections = <span class="built_in">append</span>(task.Sections[:<span class="number">0</span>], requests[task.Bit][:want]...)</div><div class="line">				requests[task.Bit] = <span class="built_in">append</span>(requests[task.Bit][:<span class="number">0</span>], requests[task.Bit][want:]...)</div><div class="line">			&#125;</div><div class="line">			fetcher &lt;- task</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requests[task.Bit]) &gt; <span class="number">0</span> &#123;</div><div class="line">				assign(task.Bit)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> result := &lt;-m.deliveries:</div><div class="line">			<span class="keyword">var</span> (</div><div class="line">				sections = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">				bitsets  = <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Bitsets))</div><div class="line">				missing  = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(result.Sections))</div><div class="line">			)</div><div class="line">			<span class="keyword">for</span> i, bitset := <span class="keyword">range</span> result.Bitsets &#123;</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(bitset) == <span class="number">0</span> &#123;</div><div class="line">					missing = <span class="built_in">append</span>(missing, result.Sections[i])</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				sections = <span class="built_in">append</span>(sections, result.Sections[i])</div><div class="line">				bitsets = <span class="built_in">append</span>(bitsets, bitset)</div><div class="line">			&#125;</div><div class="line">			m.schedulers[result.Bit].deliver(sections, bitsets)</div><div class="line">			allocs--</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(missing) &gt; <span class="number">0</span> &#123;</div><div class="line">				queue := requests[result.Bit]</div><div class="line">				<span class="keyword">for</span> _, section := <span class="keyword">range</span> missing &#123;</div><div class="line">					index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= section &#125;)</div><div class="line">					queue = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;section&#125;, queue[index:]...)...)</div><div class="line">				&#125;</div><div class="line">				requests[result.Bit] = queue</div><div class="line"></div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="built_in">len</span>(missing) &#123;</div><div class="line">					assign(result.Bit)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> allocs == <span class="number">0</span> &amp;&amp; shutdown == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>distributor 接收来自 scheduler 的请求，首先根据 <code>dist</code> 参数，进入下面的分支：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> req := &lt;-dist:</div><div class="line">	<span class="comment">// New retrieval request arrived to be distributed to some fetcher process</span></div><div class="line">	queue := requests[req.bit]</div><div class="line">	index := sort.Search(<span class="built_in">len</span>(queue), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> queue[i] &gt;= req.section &#125;)</div><div class="line">	requests[req.bit] = <span class="built_in">append</span>(queue[:index], <span class="built_in">append</span>([]<span class="keyword">uint64</span>&#123;req.section&#125;, queue[index:]...)...)</div><div class="line"></div><div class="line">	<span class="comment">// If it's a new bit and we have waiting fetchers, allocate to them</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</div><div class="line">		assign(req.bit)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>如果是新的 bit，通过 assign 指派给等待的 fetcher。这时通过 <code>Multiplex</code>, <code>AllocateSections</code> 的作用，最终会进入到 <code>case fetcher := &lt;-m.retrievals:</code> 分支。回顾一下 <code>Multiplex</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MatcherSession)</span> <span class="title">Multiplex</span><span class="params">(batch <span class="keyword">int</span>, wait time.Duration, mux <span class="keyword">chan</span> <span class="keyword">chan</span> *Retrieval)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		bit, ok := s.AllocateRetrieval()</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> s.PendingSections(bit) &lt; batch &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-s.quit:</div><div class="line">				<span class="comment">// Session terminating, we can't meaningfully service, abort</span></div><div class="line">				s.AllocateSections(bit, <span class="number">0</span>)</div><div class="line">				s.DeliverSections(bit, []<span class="keyword">uint64</span>&#123;&#125;, [][]<span class="keyword">byte</span>&#123;&#125;)</div><div class="line">				<span class="keyword">return</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> &lt;-time.After(wait):</div><div class="line">				<span class="comment">// Throttling up, fetch whatever's available</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sections := s.AllocateSections(bit, batch)</div><div class="line">		request := <span class="built_in">make</span>(<span class="keyword">chan</span> *Retrieval)</div><div class="line"></div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-s.quit:</div><div class="line">			s.DeliverSections(bit, sections, <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(sections)))</div><div class="line">			<span class="keyword">return</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> mux &lt;- request:</div><div class="line">			request &lt;- &amp;Retrieval&#123;Bit: bit, Sections: sections, Context: s.ctx&#125;</div><div class="line"></div><div class="line">			result := &lt;-request</div><div class="line">			<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</div><div class="line">				s.err.Store(result.Error)</div><div class="line">				s.Close()</div><div class="line">			&#125;</div><div class="line">			s.DeliverSections(result.Bit, result.Sections, result.Bitsets)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Multiplex 会不断领取任务，投递给 bloomRequest 队列，从队列中获取结果后，又通过 <code>DeliverSections</code> 发送给 deliveries 这个 channel，从而调用 schedulers 的 deliver 方法，在前面 schedule 的讲解中，我们知道这个结果会发到 <code>done</code> 这个 channel 中，这个结果最终会被 subMatch 接收(查看 scheduler 的 run 方法)，一层层发送给最后一个 subMath，最终返回 results。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ethereum/go-ethereum/issues/1897" target="_blank" rel="external">issues 1897, eth_listTransactions</a></li>
<li><a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="external">【原】布隆过滤器 (Bloom Filter) 详解</a></li>
<li><a href="http://dmod.eu/deca/ft_gateway.cfm.pdf" target="_blank" rel="external">Space/Time Trade-offs in Hash Coding with Allowable Errors </a></li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Bloom filter wiki</a></li>
<li><a href="https://web.stanford.edu/~balaji/papers/bloom.pdf" target="_blank" rel="external">Bloom Filters: Design Innovations and Novel Applications</a></li>
<li><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf" target="_blank" rel="external">Bloom Filters — A Tutorial, Analysis, and Survey</a></li>
<li><a href="https://www.youtube.com/watch?v=bEmBh1HtYrw" target="_blank" rel="external">Bloom Filters by Yoav Freund</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读这部分代码之前需要对 Solidity 里的事件，以太坊的日志有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-EVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-EVM-虚拟机的实现）/</id>
    <published>2018-03-10T14:35:08.000Z</published>
    <updated>2018-10-20T06:56:31.927Z</updated>
    
    <content type="html"><![CDATA[<p>前面的文章 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a> 讨论了 geth 中对交易的处理，其中有一个阶段需要通过 EVM 执行，如果交易转入方地址为空，则调用 EVM 的 Create 函数创建合约；如果不为空，则为普通转账，调用 Call() 函数。这一篇我们将深入以太坊的虚拟机看看具体的过程。</p>
<p>这一篇需要对智能合约， ERC-20 标准，编译原理（了解编译器，解释器，虚拟机等概念），计算机组成原理（了解基于栈的虚拟机与基于寄存器的虚拟机的区别）有所了解。</p>
<a id="more"></a>
<p>以太坊与比特币最大的不同是以太坊设计了图灵完备的虚拟机用于执行合约代码，geth 中的 EVM 本质上就是一个字节码执行引擎。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>在以太坊的<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#virtual-machine" target="_blank" rel="external">设计原理</a>中描述了 EVM 的设计目标:</p>
<ul>
<li><strong>简单</strong>：操作码尽可能的简单，低级，数据类型尽可能少，虚拟机结构尽可能少。</li>
<li><strong>结果明确</strong>：在 VM 规范里，没有任何可能产生歧义的空间，结果应该是完全确定的，此外，计算步骤应该是精确的，以便可以计量 gas 消耗量。</li>
<li><strong>节约空间</strong>：EVM 汇编码应该尽可能紧凑。</li>
<li><strong>预期应用应具备专业化能力</strong>：在 VM 上构建的应用能够处理20字节的地址，以及32位的自定义加密值，拥有用于自定义加密的模数运算、读取区块和交易数据和状态交互等能力。</li>
<li><strong>简单安全</strong>：能够容易地建立一套操作的 gas 消耗成本模型，让 VM 不被利用。</li>
<li><strong>优化友好</strong>：应该易于优化，以便即时编译(JIT)和 VM 的加速版本能够构建出来。</li>
</ul>
<p>特点：</p>
<ul>
<li>区分临时存储（Memory，存在于每个 VM 实例中，并在 VM 执行结束后消失）和永久存储（Storage，存在于区块链的状态层）。</li>
<li>采用基于栈（stack）的架构。</li>
<li>机器码长度为32字节。</li>
<li>没有重用 Java，或其他一些 Lisp 方言，Lua 的虚拟机，自定义虚拟机。</li>
<li>使用可变的可扩展内存大小。</li>
<li>限制调用深度为 1024。</li>
<li>没有类型。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通常智能合约的开发流程是使用 solidity 编写逻辑代码，通过编译器编译成 bytecode，然后发布到以太坊上，以太坊底层通过 EVM 模块支持合约的执行和调用，调用时根据合约地址获取到代码，即合约的字节码，生成环境后载入到 EVM 执行。</p>
<p>大致流程如下图1，指令的执行过程如下图2，从 EVM code 中不断取出指令执行，利用 Gas 来实现限制循环，利用栈来进行操作，内存存储临时变量，账户状态中的 storage 用来存储数据。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/evm_process.jpg" alt="evm_process"></p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/evm_code_executed.png" alt="evm_code_executed"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>EVM 模块的文件比较多，这里先给出每个文件的简述，先对每个文件提供的功能有个简单的了解。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── analysis<span class="selector-class">.go</span>            <span class="comment">// 跳转目标判定</span></div><div class="line">├── common<span class="selector-class">.go</span></div><div class="line">├── contract<span class="selector-class">.go</span>            <span class="comment">// 合约的数据结构</span></div><div class="line">├── contracts<span class="selector-class">.go</span>           <span class="comment">// 预编译好的合约</span></div><div class="line">├── errors<span class="selector-class">.go</span></div><div class="line">├── evm<span class="selector-class">.go</span>                 <span class="comment">// 对外提供的接口   </span></div><div class="line">├── gas<span class="selector-class">.go</span>                 <span class="comment">// 用来计算指令耗费的 gas</span></div><div class="line">├── gas_table<span class="selector-class">.go</span>           <span class="comment">// 指令耗费计算函数表</span></div><div class="line">├── gen_structlog<span class="selector-class">.go</span>       </div><div class="line">├── instructions<span class="selector-class">.go</span>        <span class="comment">// 指令操作</span></div><div class="line">├── interface<span class="selector-class">.go</span>           <span class="comment">// 定义 StateDB 的接口</span></div><div class="line">├── interpreter<span class="selector-class">.go</span>         <span class="comment">// 解释器</span></div><div class="line">├── intpool<span class="selector-class">.go</span>             <span class="comment">// 存放大整数</span></div><div class="line">├── int_pool_verifier_empty<span class="selector-class">.go</span></div><div class="line">├── int_pool_verifier<span class="selector-class">.go</span></div><div class="line">├── jump_table<span class="selector-class">.go</span>           <span class="comment">// 指令和指令操作（操作，花费，验证）对应表</span></div><div class="line">├── logger<span class="selector-class">.go</span>               <span class="comment">// 状态日志</span></div><div class="line">├── memory<span class="selector-class">.go</span>               <span class="comment">// EVM 内存</span></div><div class="line">├── memory_table<span class="selector-class">.go</span>         <span class="comment">// EVM 内存操作表，用来衡量操作所需内存大小</span></div><div class="line">├── noop<span class="selector-class">.go</span></div><div class="line">├── opcodes<span class="selector-class">.go</span>              <span class="comment">// 指令以及一些对应关系     </span></div><div class="line">├── runtime</div><div class="line">│   ├── env<span class="selector-class">.go</span>              <span class="comment">// 执行环境 </span></div><div class="line">│   ├── fuzz<span class="selector-class">.go</span></div><div class="line">│   └── runtime<span class="selector-class">.go</span>          <span class="comment">// 运行接口，测试使用</span></div><div class="line">├── stack<span class="selector-class">.go</span>                <span class="comment">// 栈</span></div><div class="line">└── stack_table<span class="selector-class">.go</span>          <span class="comment">// 栈验证</span></div></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在 EVM 模块中，有两个高层次的结构体，分别是 Context，EVM。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Context</span> struct &#123;</div><div class="line">	<span class="type">CanTransfer</span> <span class="type">CanTransferFunc</span></div><div class="line">	<span class="type">Transfer</span> <span class="type">TransferFunc</span></div><div class="line">	<span class="type">GetHash</span> <span class="type">GetHashFunc</span></div><div class="line">	<span class="type">Origin</span>   common.<span class="type">Address</span></div><div class="line">	<span class="type">GasPrice</span> *big.<span class="type">Int</span></div><div class="line">	<span class="type">Coinbase</span>    common.<span class="type">Address</span></div><div class="line">	<span class="type">GasLimit</span>    uint64</div><div class="line">	<span class="type">BlockNumber</span> *big.<span class="type">Int</span></div><div class="line">	<span class="type">Time</span>        *big.<span class="type">Int</span></div><div class="line">	<span class="type">Difficulty</span>  *big.<span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> <span class="type">EVM</span> struct &#123;</div><div class="line">	<span class="type">Context</span></div><div class="line">	<span class="type">StateDB</span> <span class="type">StateDB</span></div><div class="line">	depth int</div><div class="line">	chainConfig *params.<span class="type">ChainConfig</span></div><div class="line">	chainRules params.<span class="type">Rules</span></div><div class="line">	vmConfig <span class="type">Config</span></div><div class="line">	interpreter *<span class="type">Interpreter</span></div><div class="line">	abort int32</div><div class="line">	callGasTemp uint64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Context 给 EVM 提供运行合约的上下文信息，其中 <code>CanTransfer</code> 是返回账户是否有足够余额的函数，<code>Transfer</code> 可以用来完成转账操作，<code>GetHash</code> 返回第 n 个区块的哈希值。其他的属性在之前文章有过描述，代码中也有注释，这里不再赘述。EVM 结构体中稍值得一提的是 interpreter，它根据代码以及 jump_table 中对应的指令逐条执行合约，这部分我们将在稍后看到。</p>
<p>我们先从<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a> 中谈到的 Create，Call 方法谈起。</p>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>Create 方法可以用来创建一个新合约。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">func (evm *EVM) create(caller ContractRef, code []byte, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) &#123;</div><div class="line">	<span class="attribute">if evm.depth &gt; int(params.CallCreateDepth) &#123;</span></div><div class="line">		return nil, common.Address&#123;&#125;, gas, ErrDepth</div><div class="line">	&#125;</div><div class="line">	if !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</div><div class="line">		return nil, common.Address&#123;&#125;, gas, ErrInsufficientBalance</div><div class="line">	&#125;</div><div class="line">	nonce := evm<span class="variable">.StateDB</span><span class="variable">.GetNonce</span>(caller<span class="variable">.Address</span>())</div><div class="line">	evm<span class="variable">.StateDB</span><span class="variable">.SetNonce</span>(caller<span class="variable">.Address</span>(), nonce+1)</div><div class="line"></div><div class="line">	contractHash := evm<span class="variable">.StateDB</span><span class="variable">.GetCodeHash</span>(address)</div><div class="line">	if evm<span class="variable">.StateDB</span><span class="variable">.GetNonce</span>(address) != 0 || (contractHash != (common<span class="variable">.Hash</span>&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</div><div class="line">		return nil, common<span class="variable">.Address</span>&#123;&#125;, 0, ErrContractAddressCollision</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	snapshot := evm<span class="variable">.StateDB</span><span class="variable">.Snapshot</span>()</div><div class="line">	evm<span class="variable">.StateDB</span><span class="variable">.CreateAccount</span>(address)</div><div class="line">	if evm<span class="variable">.ChainConfig</span>()<span class="variable">.IsEIP</span>158(evm<span class="variable">.BlockNumber</span>) &#123;</div><div class="line">		evm<span class="variable">.StateDB</span><span class="variable">.SetNonce</span>(address, 1)</div><div class="line">	&#125;</div><div class="line">	evm<span class="variable">.Transfer</span>(evm<span class="variable">.StateDB</span>, caller<span class="variable">.Address</span>(), address, value)</div><div class="line"></div><div class="line">	contract := NewContract(caller, AccountRef(address), value, gas)</div><div class="line">	contract<span class="variable">.SetCallCode</span>(&amp;address, crypto<span class="variable">.Keccak</span>256Hash(code), code)</div><div class="line"></div><div class="line">	if evm<span class="variable">.vmConfig</span><span class="variable">.NoRecursion</span> &amp;&amp; evm<span class="variable">.depth</span> &gt; 0 &#123;</div><div class="line">		return nil, address, gas, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if evm<span class="variable">.vmConfig</span><span class="variable">.Debug</span> &amp;&amp; evm<span class="variable">.depth</span> == 0 &#123;</div><div class="line">		evm<span class="variable">.vmConfig</span><span class="variable">.Tracer</span><span class="variable">.CaptureStart</span>(caller<span class="variable">.Address</span>(), address, true, code, gas, value)</div><div class="line">	&#125;</div><div class="line">	start := time<span class="variable">.Now</span>()</div><div class="line"></div><div class="line">	ret, err := run(evm, contract, nil)</div><div class="line"></div><div class="line">	maxCodeSizeExceeded := evm<span class="variable">.ChainConfig</span>()<span class="variable">.IsEIP</span>158(evm<span class="variable">.BlockNumber</span>) &amp;&amp; len(ret) &gt; params<span class="variable">.MaxCodeSize</span></div><div class="line"></div><div class="line">	if err == nil &amp;&amp; !maxCodeSizeExceeded &#123;</div><div class="line">		createDataGas := uint64(len(ret)) * params<span class="variable">.CreateDataGas</span></div><div class="line">		if contract<span class="variable">.UseGas</span>(createDataGas) &#123;</div><div class="line">			evm<span class="variable">.StateDB</span><span class="variable">.SetCode</span>(address, ret)</div><div class="line">		&#125; else &#123;</div><div class="line">			err = ErrCodeStoreOutOfGas</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if maxCodeSizeExceeded || (err != nil &amp;&amp; (evm<span class="variable">.ChainConfig</span>()<span class="variable">.IsHomestead</span>(evm<span class="variable">.BlockNumber</span>) || err != ErrCodeStoreOutOfGas)) &#123;</div><div class="line">		evm<span class="variable">.StateDB</span><span class="variable">.RevertToSnapshot</span>(snapshot)</div><div class="line">		if err != errExecutionReverted &#123;</div><div class="line">			contract<span class="variable">.UseGas</span>(contract<span class="variable">.Gas</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if maxCodeSizeExceeded &amp;&amp; err == nil &#123;</div><div class="line">		err = errMaxCodeSizeExceeded</div><div class="line">	&#125;</div><div class="line">	if evm<span class="variable">.vmConfig</span><span class="variable">.Debug</span> &amp;&amp; evm<span class="variable">.depth</span> == 0 &#123;</div><div class="line">		evm<span class="variable">.vmConfig</span><span class="variable">.Tracer</span><span class="variable">.CaptureEnd</span>(ret, gas-contract<span class="variable">.Gas</span>, time<span class="variable">.Since</span>(start), err)</div><div class="line">	&#125;</div><div class="line">	return ret, address, contract<span class="variable">.Gas</span>, err</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会进行一系列验证，调用栈的深度不能超过 1024；调用的账户有足够多的余额；对调用者地址的 nonce+1，通过地址和 nonce 生成合约地址，通过合约地址获取合约哈希值，确保调用的地址不能已经存在合约。接着利用 StateDB 创建一个快照，如果之后的调用出现问题可以回滚。在进行了这一系列初始化之后，发起一笔转账操作，发送方地址余额减 value 值，合约账户的余额加 value 值，接着通过调用 contract 的 <code>SetCallCode</code> ，根据发送方地址，合约地址，金额 value，gas，合约代码，代码哈希初始化合约对象，然后调用 <code>run(evm, contract, nil)</code>执行合约的初始化代码，这个生成的代码有一定的长度限制，当合约创建成功，没有错误返回，则计算存储代码所需的 gas，如果没有足够 gas 则进行报错。之后就是错误处理了，如果存在错误，需要回滚到之前创建的状态快照，没有错误则返回创建成功。可以看到，合约代码通过 state 模块的 SetCode，保存在账户中 codehash 指向的存储区域，这部分的代码都属于对世界状态的修改。</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>当进行转账或执行合约代码，会调用 Call 方法，合约里的 call 指令也会调用这个方法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">func (evm *EVM) Call(caller ContractRef, addr common<span class="selector-class">.Address</span>, <span class="selector-tag">input</span> []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) &#123;</div><div class="line">	<span class="keyword">if</span> evm<span class="selector-class">.vmConfig</span><span class="selector-class">.NoRecursion</span> &amp;&amp; evm<span class="selector-class">.depth</span> &gt; <span class="number">0</span> &#123;</div><div class="line">		return nil, gas, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> evm<span class="selector-class">.depth</span> &gt; int(params.CallCreateDepth) &#123;</div><div class="line">		return nil, gas, ErrDepth</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !evm<span class="selector-class">.Context</span><span class="selector-class">.CanTransfer</span>(evm<span class="selector-class">.StateDB</span>, caller.Address(), value) &#123;</div><div class="line">		return nil, gas, ErrInsufficientBalance</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="selector-tag">var</span> (</div><div class="line">		to       = AccountRef(addr)</div><div class="line">		snapshot = evm<span class="selector-class">.StateDB</span><span class="selector-class">.Snapshot</span>()</div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> !evm<span class="selector-class">.StateDB</span><span class="selector-class">.Exist</span>(addr) &#123;</div><div class="line">		precompiles := PrecompiledContractsHomestead</div><div class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</div><div class="line">			precompiles = PrecompiledContractsByzantium</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Debug</span> &amp;&amp; evm<span class="selector-class">.depth</span> == <span class="number">0</span> &#123;</div><div class="line">				evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Tracer</span><span class="selector-class">.CaptureStart</span>(caller.Address(), addr, false, <span class="selector-tag">input</span>, gas, value)</div><div class="line">				evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Tracer</span><span class="selector-class">.CaptureEnd</span>(ret, <span class="number">0</span>, <span class="number">0</span>, nil)</div><div class="line">			&#125;</div><div class="line">			return nil, gas, nil</div><div class="line">		&#125;</div><div class="line">		evm<span class="selector-class">.StateDB</span><span class="selector-class">.CreateAccount</span>(addr)</div><div class="line">	&#125;</div><div class="line">	evm.Transfer(evm<span class="selector-class">.StateDB</span>, caller.Address(), to.Address(), value)</div><div class="line"></div><div class="line">	contract := NewContract(caller, to, value, gas)</div><div class="line">	contract.SetCallCode(&amp;addr, evm<span class="selector-class">.StateDB</span><span class="selector-class">.GetCodeHash</span>(addr), evm<span class="selector-class">.StateDB</span><span class="selector-class">.GetCode</span>(addr))</div><div class="line"></div><div class="line">	start := <span class="selector-tag">time</span>.Now()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Debug</span> &amp;&amp; evm<span class="selector-class">.depth</span> == <span class="number">0</span> &#123;</div><div class="line">		evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Tracer</span><span class="selector-class">.CaptureStart</span>(caller.Address(), addr, false, <span class="selector-tag">input</span>, gas, value)</div><div class="line"></div><div class="line">		defer func() &#123;</div><div class="line">			evm<span class="selector-class">.vmConfig</span><span class="selector-class">.Tracer</span><span class="selector-class">.CaptureEnd</span>(ret, gas-contract<span class="selector-class">.Gas</span>, <span class="selector-tag">time</span>.Since(start), err)</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	ret, err = run(evm, contract, input)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		evm<span class="selector-class">.StateDB</span><span class="selector-class">.RevertToSnapshot</span>(snapshot)</div><div class="line">		<span class="keyword">if</span> err != errExecutionReverted &#123;</div><div class="line">			contract.UseGas(contract.Gas)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return ret, contract<span class="selector-class">.Gas</span>, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 Create 方法类似，不过 Create 方法的资金转移发生在创建合约用户账户和合约账户之间，而 Call 方法的资金转移发生在合约发送方和合约接收方之间。Call 方法需要先检查合约调用深度；确保账户有足够余额；调用 Call 方法的可能是一个转账操作，也可能是一个运行合约的操作，所以接下来会通过 StateDB 查看指定的地址是否存在，如果不存在的话，接着查看该地址是否为内置合约，这些预编译的合约在 <code>core/vm/constracts.go</code> 中定义，主要是用于加密操作，如果本地确实没有合约接收方的账户，创建一个接收方的账户，更新本地的状态数据库。接着 evm 会调用 Transfer 方法（即 Context 里的 TransferFunc）进行转账。最后，通过 StateDB 的 <code>GetCode</code> 拿到该地址对应的代码，通过 <code>run(evm, contract, input)</code> 运行合约，如果是单纯的转账，通过 <code>GetCode</code> 拿到的代码是空，自然也没有合约的运行。这一步完成后，就可以返回执行结果了。合约产生的 gas 总数会加入到矿工账户，作为矿工收入。</p>
<h4 id="解释器执行合约指令"><a href="#解释器执行合约指令" class="headerlink" title="解释器执行合约指令"></a>解释器执行合约指令</h4><p>我们已经大致了解了合约是怎么创建和执行的，执行合约的关键在于 Call 方法的最后通过 <code>run(evm, contract, input)</code> 运行合约，接下来我们就深入到 <code>run</code> 函数，看看 evm 中解释器执行合约的过程。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func <span class="keyword">run</span>(evm *EVM, <span class="keyword">contract</span> *<span class="keyword">Contract</span>, <span class="keyword">input</span> []byte) ([]byte, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">contract</span>.CodeAddr != nil &#123;</div><div class="line">		precompiles := PrecompiledContractsHomestead</div><div class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</div><div class="line">			precompiles = PrecompiledContractsByzantium</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> p := precompiles[*<span class="keyword">contract</span>.CodeAddr]; p != nil &#123;</div><div class="line">			<span class="keyword">return</span> RunPrecompiledContract(p, <span class="keyword">input</span>, <span class="keyword">contract</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> evm.interpreter.<span class="keyword">Run</span>(<span class="keyword">contract</span>, <span class="keyword">input</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 run 方法中，首先检查调用的是否是之前编译好的原生合约，如果是原生合约则调用原生合约，否则调用解释器执行合约。解释器的代码在 <code>core/vm/interpreter.go</code> 中。</p>
<p>要理解虚拟机中解释器的的执行过程，首先需要知道该解释器的初始化过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func NewInterpreter(<span class="name">evm</span> *EVM, cfg Config) *Interpreter &#123;</div><div class="line">	if !cfg.JumpTable[STOP].valid &#123;</div><div class="line">		switch &#123;</div><div class="line">		case evm.ChainConfig().IsConstantinople(<span class="name">evm</span>.BlockNumber):</div><div class="line">			cfg.JumpTable = constantinopleInstructionSet</div><div class="line">		case evm.ChainConfig().IsByzantium(<span class="name">evm</span>.BlockNumber):</div><div class="line">			cfg.JumpTable = byzantiumInstructionSet</div><div class="line">		case evm.ChainConfig().IsHomestead(<span class="name">evm</span>.BlockNumber):</div><div class="line">			cfg.JumpTable = homesteadInstructionSet</div><div class="line">		default:</div><div class="line">			cfg.JumpTable = frontierInstructionSet</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return <span class="symbol">&amp;Interpreter</span>&#123;</div><div class="line">		evm:      evm,</div><div class="line">		cfg:      cfg,</div><div class="line">		gasTable: evm.ChainConfig().GasTable(<span class="name">evm</span>.BlockNumber),</div><div class="line">		intPool:  newIntPool(),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Interpreter 中很重要的一个配置是 Jumptable，它保存的是指令集，在不同的以太坊版本有不同的指令集。查看 <code>core/vm/jump_table.go</code> 中的 <code>newFrontierInstructionSet</code>, <code>newHomesteadInstructionSet</code>, <code>newByzantiumInstructionSet</code>, <code>newConstantinopleInstructionSet</code> 方法，你会发现指令集是向前兼容的。</p>
<p>这里以 ADD 指令为例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ADD</span>: &#123;</div><div class="line">	<span class="attribute">execute</span>:       opAdd,</div><div class="line">	gasCost:       <span class="built_in">constGasFunc</span>(GasFastestStep),</div><div class="line">	validateStack: <span class="built_in">makeStackFunc</span>(2, 1),</div><div class="line">	valid:         true,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>ADD 指令对应的方法 <code>opAdd</code> 在 <code>core/vm/instructions.go</code> 中。其中 <code>execute</code> 指的是对应的操作函数，<code>gasCost</code> 对应的是 gas 消耗，<code>validateStack</code> 用来验证栈深度，<code>valid</code> 指明操作是否有效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">opAdd</span><span class="params">(pc *<span class="keyword">uint64</span>, evm *EVM, contract *Contract, memory *Memory, stack *Stack)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	x, y := stack.pop(), stack.peek()</div><div class="line">	math.U256(y.Add(x, y))</div><div class="line"></div><div class="line">	evm.interpreter.intPool.put(x)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过栈拿到需要进行运算的 x, y 值（弹出一个值，取一个值，进行运算后这个值就变成结果值），在进行加法运算后，该结果会被缓存。不同的指令的实现自然不同，指令不多，但这里也不一一介绍了。还需要了解的一点是，这些指令都对应了一个编码，这些是在 <code>core/vm/opcodes.go</code> 中定义的，这个编码是一个 byte，合约编译出来的 bytecode，一个 OpCode 就对应其中的一位(可以参考<a href="https://github.com/trailofbits/evm-opcodes" target="_blank" rel="external">EVM指令集</a>)。</p>
<p>了解了指令集后，我们再看 <code>Run</code> 方法。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">in</span> *Interpreter) <span class="keyword">Run</span>(<span class="keyword">contract</span> *<span class="keyword">Contract</span>, <span class="keyword">input</span> []byte) (<span class="keyword">ret</span> []byte, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">in</span>.evm.depth++</div><div class="line">	defer func() &#123; <span class="keyword">in</span>.evm.depth-- &#125;()</div><div class="line"></div><div class="line">	<span class="keyword">in</span>.returnData = nil</div><div class="line"></div><div class="line">	<span class="keyword">if</span> len(<span class="keyword">contract</span>.Code) == 0 &#123;</div><div class="line">		<span class="keyword">return</span> nil, nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		op    OpCode</div><div class="line">		mem   = NewMemory()</div><div class="line">		<span class="keyword">stack</span> = newstack()</div><div class="line">		pc   = uint64(0)</div><div class="line">		cost uint64</div><div class="line">		pcCopy  uint64</div><div class="line">		gasCopy uint64</div><div class="line">		logged  bool</div><div class="line">	)</div><div class="line">	<span class="keyword">contract</span>.<span class="keyword">Input</span> = <span class="keyword">input</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="keyword">in</span>.cfg.Debug &#123;</div><div class="line">		defer func() &#123;</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				<span class="keyword">if</span> !logged &#123;</div><div class="line">					<span class="keyword">in</span>.cfg.Tracer.CaptureState(<span class="keyword">in</span>.evm, pcCopy, op, gasCopy, cost, mem, <span class="keyword">stack</span>, <span class="keyword">contract</span>, <span class="keyword">in</span>.evm.depth, <span class="keyword">err</span>)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">in</span>.cfg.Tracer.CaptureFault(<span class="keyword">in</span>.evm, pcCopy, op, gasCopy, cost, mem, <span class="keyword">stack</span>, <span class="keyword">contract</span>, <span class="keyword">in</span>.evm.depth, <span class="keyword">err</span>)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> atomic.LoadInt32(&amp;<span class="keyword">in</span>.evm.abort) == 0 &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">in</span>.cfg.Debug &#123;</div><div class="line">			logged, pcCopy, gasCopy = false, pc, <span class="keyword">contract</span>.Gas</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		op = <span class="keyword">contract</span>.GetOp(pc)</div><div class="line">		operation := <span class="keyword">in</span>.cfg.JumpTable[op]</div><div class="line">		<span class="keyword">if</span> !operation.valid &#123;</div><div class="line">			<span class="keyword">return</span> nil, fmt.Errorf(<span class="string">"invalid opcode 0x%x"</span>, int(op))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := operation.validateStack(<span class="keyword">stack</span>); <span class="keyword">err</span> != nil &#123;</div><div class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">in</span>.enforceRestrictions(op, operation, <span class="keyword">stack</span>); <span class="keyword">err</span> != nil &#123;</div><div class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> memorySize uint64</div><div class="line">		<span class="keyword">if</span> operation.memorySize != nil &#123;</div><div class="line">			<span class="keyword">memSize</span>, overflow := bigUint64(operation.memorySize(<span class="keyword">stack</span>))</div><div class="line">			<span class="keyword">if</span> overflow &#123;</div><div class="line">				<span class="keyword">return</span> nil, errGasUintOverflow</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> memorySize, overflow = math.SafeMul(toWordSize(<span class="keyword">memSize</span>), 32); overflow &#123;</div><div class="line">				<span class="keyword">return</span> nil, errGasUintOverflow</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cost, <span class="keyword">err</span> = operation.gasCost(<span class="keyword">in</span>.gasTable, <span class="keyword">in</span>.evm, <span class="keyword">contract</span>, <span class="keyword">stack</span>, mem, memorySize)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil || !<span class="keyword">contract</span>.UseGas(cost) &#123;</div><div class="line">			<span class="keyword">return</span> nil, ErrOutOfGas</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> memorySize &gt; 0 &#123;</div><div class="line">			mem.Resize(memorySize)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="keyword">in</span>.cfg.Debug &#123;</div><div class="line">			<span class="keyword">in</span>.cfg.Tracer.CaptureState(<span class="keyword">in</span>.evm, pc, op, gasCopy, cost, mem, <span class="keyword">stack</span>, <span class="keyword">contract</span>, <span class="keyword">in</span>.evm.depth, <span class="keyword">err</span>)</div><div class="line">			logged = true</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		res, <span class="keyword">err</span> := operation.execute(&amp;pc, <span class="keyword">in</span>.evm, <span class="keyword">contract</span>, mem, <span class="keyword">stack</span>)</div><div class="line">		<span class="keyword">if</span> verifyPool &#123;</div><div class="line">			verifyIntegerPool(<span class="keyword">in</span>.intPool)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> operation.returns &#123;</div><div class="line">			<span class="keyword">in</span>.returnData = res</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		switch &#123;</div><div class="line">		case <span class="keyword">err</span> != nil:</div><div class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">		case operation.reverts:</div><div class="line">			<span class="keyword">return</span> res, errExecutionReverted</div><div class="line">		case operation.halts:</div><div class="line">			<span class="keyword">return</span> res, nil</div><div class="line">		case !operation.jumps:</div><div class="line">			pc++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> nil, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Run 方法会循环执行合约的代码，主要逻辑在 for 循环中，直到遇到 STOP，RETURN，SELFDESTRUCT 指令被执行，或者是遇到任意错误，或者说 done 标志被父 context 设置。这个循环才会结束。大致的执行过程是首先通过 <code>op = contract.GetOp(pc)</code> 拿到下一个需要执行的指令，接着通过 <code>operation := in.cfg.JumpTable[op]</code> 拿到对应的 operation，operation 的类型在 <code>core/vm/jump_table.go</code> 中定义，其中包括指令对应的方法，计算 gas 的方法，验证栈溢出的方法，计算内存的方法等。进行一系列检查后再通过 <code>operation.execute</code> 执行指令。最后一个指令的执行结果会决定整个合约代码的执行结果。到这一步，我们就完整地过了一遍以太坊虚拟机的执行过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>EVM 是一个256位的机器，以32字节来处理数据最佳</li>
<li>EVM 选择基于栈的虚拟机的原因其实不难理解，基于栈的虚拟机代码尺寸更小（因为可以用更小的空间放更多的指令），而且移植性更好（不需要通用寄存器），代码生成也更简单，不需要考虑为临时变量分配空间的问题。但从速度上来说，基于寄存器的架构更占优势。</li>
<li>在以太坊中部署的智能合约是完全不可修改的，只能通过部署新的合约来部署新的合约</li>
<li>Solidity 等编译器的优化一般以减少 gas 的使用为目标</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://ethereum.gitbooks.io/frontier-guide/content/contracts_and_transactions_intro.html" target="_blank" rel="external">contracts_and_transactions_intro</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="external">EIP 20: ERC-20 Token Standard</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-158" target="_blank" rel="external">EIP 158: State clearing</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethereum-Virtual-Machine-(EVM" target="_blank" rel="external">Ethereum Virtual Machine (EVM) Awesome List</a>-Awesome-List)</li>
<li><a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall" target="_blank" rel="external">Difference between CALL, CALLCODE and DELEGATECALL</a></li>
<li><a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30" target="_blank" rel="external">Diving Into The Ethereum VM</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale" target="_blank" rel="external">Design-Rationale</a></li>
<li><a href="https://github.com/takenobu-hs/ethereum-evm-illustrated" target="_blank" rel="external">takenobu-hs/ethereum-evm-illustrated</a></li>
<li><a href="https://paper.seebug.org/640/" target="_blank" rel="external">以太坊智能合约 OPCODE 逆向之理论基础篇</a></li>
<li><a href="https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf" target="_blank" rel="external">Virtual Machine Showdown: Stack Versus Registers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的文章 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）&lt;/a&gt; 讨论了 geth 中对交易的处理，其中有一个阶段需要通过 EVM 执行，如果交易转入方地址为空，则调用 EVM 的 Create 函数创建合约；如果不为空，则为普通转账，调用 Call() 函数。这一篇我们将深入以太坊的虚拟机看看具体的过程。&lt;/p&gt;
&lt;p&gt;这一篇需要对智能合约， ERC-20 标准，编译原理（了解编译器，解释器，虚拟机等概念），计算机组成原理（了解基于栈的虚拟机与基于寄存器的虚拟机的区别）有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）/</id>
    <published>2018-03-10T14:35:07.000Z</published>
    <updated>2018-10-19T02:09:39.522Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的文章，我们了解了 geth 的大致原理，知道了区块链是怎么组织构成的，有了 rlp，MPT 这些数据结构的基础，也知道了账户是怎么组织的，交易是如何管理的，挖矿是一个什么样的流程，这一篇我们将深入到交易的具体处理过程，看看交易过程中是如何修改世界状态，生成交易收据的。</p>
<p>这篇文章将涉及到 <code>core/types/transaction.go</code>, <code>core/state</code> 模块，需要对交易池，账户等基本概念有所了解。</p>
<a id="more"></a>
<p><code>core/state</code> 包提供了用户和合约的状态管理的功能。包括 trie，数据库，cache，日志和回滚相关功能。还记得<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a> 中曾给出的总体架构图吗？</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/stackexchange-ethereum-block-architecture.jpg" alt="https://i.stack.imgur.com/afWDt.jpg"> 按照定义，日志应该属于交易树的部分，但 <code>core/state</code> 中的 <code>journal.go</code> 却提供了日志的管理，这里有点不符合逻辑，可以稍稍注意一下。</p>
<p>前面的文章中有提过，在 geth 中存在三棵主要的 MPT 树，状态树，交易树，收据树。在交易上链的过程中，状态树，收据树会不断改变，</p>
<p>世界状态其实是一个账户地址和账户状态的映射，不管是外部账户还是合约账户，账户状态都包括：</p>
<ul>
<li>nonce，如果账户是一个外部拥有账户，nonce 代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce 代表此账户创建的合约序号</li>
<li>balance，该地址拥有 Wei 的数量。1Ether=10^18Wei</li>
<li>storageRoot， MPT 树的根节点哈希值。这个 MPT 会将此账户存储内容的哈希值进行编码，默认是空值</li>
<li>codeHash，该账户 EVM 代码的哈希值。对于合约账户，就是被哈希之后的代码，以 codeHash 保存。对于外部拥有账户，codeHash 是一个空字符串的哈希值</li>
</ul>
<p>以太坊还会为每笔交易生成收据，每张收据都包含有关交易的某些信息。包括以下内容：</p>
<ul>
<li>区块号</li>
<li>区块哈希</li>
<li>事务哈希值</li>
<li>当前交易使用的 gas</li>
<li>在当前交易执行后当前块中使用的 gas</li>
<li>执行当前事务时创建的日志</li>
</ul>
<p>我们先从收据树入手。</p>
<h2 id="插入区块更新状态"><a href="#插入区块更新状态" class="headerlink" title="插入区块更新状态"></a>插入区块更新状态</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>还记得在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 这一篇的 insertChain 方法中，有一个调用 <code>receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</code> 的动作，这是在插入转账区块后，更新状态树，收据树，我们来看看 <code>Process</code> 具体做了什么。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func (<span class="selector-tag">p</span> *StateProcessor) Process(block *types<span class="selector-class">.Block</span>, statedb *state<span class="selector-class">.StateDB</span>, cfg vm.Config) (types<span class="selector-class">.Receipts</span>, []*types<span class="selector-class">.Log</span>, uint64, error) &#123;</div><div class="line">	<span class="selector-tag">var</span> (</div><div class="line">		receipts types<span class="selector-class">.Receipts</span></div><div class="line">		usedGas  = new(uint64)</div><div class="line">		<span class="selector-tag">header</span>   = block.Header()</div><div class="line">		allLogs  []*types<span class="selector-class">.Log</span></div><div class="line">		gp       = new(GasPool).AddGas(block.GasLimit())</div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.config</span><span class="selector-class">.DAOForkSupport</span> &amp;&amp; <span class="selector-tag">p</span><span class="selector-class">.config</span><span class="selector-class">.DAOForkBlock</span> != nil &amp;&amp; <span class="selector-tag">p</span><span class="selector-class">.config</span><span class="selector-class">.DAOForkBlock</span><span class="selector-class">.Cmp</span>(block.Number()) == <span class="number">0</span> &#123;</div><div class="line">		misc.ApplyDAOHardFork(statedb)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> <span class="selector-tag">i</span>, tx := range block.Transactions() &#123;</div><div class="line">		statedb.Prepare(tx.Hash(), block.Hash(), i)</div><div class="line">		receipt, _, err := ApplyTransaction(<span class="selector-tag">p</span><span class="selector-class">.config</span>, <span class="selector-tag">p</span><span class="selector-class">.bc</span>, nil, gp, statedb, <span class="selector-tag">header</span>, tx, usedGas, cfg)</div><div class="line">		<span class="keyword">if</span> err != nil &#123;</div><div class="line">			return nil, nil, <span class="number">0</span>, err</div><div class="line">		&#125;</div><div class="line">		receipts = append(receipts, receipt)</div><div class="line">		allLogs = append(allLogs, receipt<span class="selector-class">.Logs</span>...)</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">p</span><span class="selector-class">.engine</span><span class="selector-class">.Finalize</span>(<span class="selector-tag">p</span><span class="selector-class">.bc</span>, <span class="selector-tag">header</span>, statedb, block.Transactions(), block.Uncles(), receipts)</div><div class="line"></div><div class="line">	return receipts, allLogs, *usedGas, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Process</code> 根据以太坊规则运行交易来对改变 statedb 的状态，以奖励挖矿者或其他的叔父节点。<code>Process</code> 会返回执行过程中累计的收据和日志，并返回过程中使用的 gas，如果 gas 不足导致任何交易执行失败，返回错误。</p>
<p><code>Process</code> 首先会声明变量，值得注意的是 GasPool 变量，它告诉你剩下还有多少 Gas 可以使用，在每一个交易的执行过程中，以太坊设计了 refund 的机制进行处理，偿还的 gas 也会加到 GasPool 中。接着处理 DAO 事件的硬分叉，接着遍历区块中的所有交易，通过调用 <code>ApplyTransaction</code> 获得每个交易的收据。这个过程结束后，调用一致性引擎的 <code>Finalize</code>，拿到区块奖励或叔块奖励，最终将世界状态写入到区块链中，也就是说 stateTrie 随着每次交易的执行变化，这个过程在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a> 也有提及，它通过 StateDB 的 <code>IntermediateRoot()</code> 方法实现。我们先深入到 <code>ApplyTransaction</code> 看看每一个交易是如何构成收据的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func ApplyTransaction(config *params<span class="selector-class">.ChainConfig</span>, bc ChainContext, author *common<span class="selector-class">.Address</span>, gp *GasPool, statedb *state<span class="selector-class">.StateDB</span>, <span class="selector-tag">header</span> *types<span class="selector-class">.Header</span>, tx *types<span class="selector-class">.Transaction</span>, usedGas *uint64, cfg vm.Config) (*types<span class="selector-class">.Receipt</span>, uint64, error) &#123;</div><div class="line">	msg, err := tx.AsMessage(types.MakeSigner(config, <span class="selector-tag">header</span>.Number))</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return nil, <span class="number">0</span>, err</div><div class="line">	&#125;</div><div class="line">	vmenv := vm.NewEVM(context, statedb, config, cfg)</div><div class="line">	_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return nil, <span class="number">0</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">var</span> root []byte</div><div class="line">	<span class="keyword">if</span> config.IsByzantium(<span class="selector-tag">header</span>.Number) &#123;</div><div class="line">		statedb.Finalise(true)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		root = statedb.IntermediateRoot(config.IsEIP158(<span class="selector-tag">header</span>.Number)).Bytes()</div><div class="line">	&#125;</div><div class="line">	*usedGas += gas</div><div class="line"></div><div class="line">	receipt := types.NewReceipt(root, failed, *usedGas)</div><div class="line">	receipt<span class="selector-class">.TxHash</span> = tx.Hash()</div><div class="line">	receipt<span class="selector-class">.GasUsed</span> = gas</div><div class="line">	<span class="keyword">if</span> msg.To() == nil &#123;</div><div class="line">		receipt<span class="selector-class">.ContractAddress</span> = crypto.CreateAddress(vmenv<span class="selector-class">.Context</span><span class="selector-class">.Origin</span>, tx.Nonce())</div><div class="line">	&#125;</div><div class="line">	receipt<span class="selector-class">.Logs</span> = statedb.GetLogs(tx.Hash())</div><div class="line">	receipt<span class="selector-class">.Bloom</span> = types.CreateBloom(types.Receipts&#123;receipt&#125;)</div><div class="line"></div><div class="line">	return receipt, gas, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每个交易，都会创建一个新的虚拟机环境，即根据输入参数封装 EVM 对象，接着调用 <code>ApplyMessage</code> 将交易应用于当前的状态中，<code>Finalise</code> 方法会调用 update 方法，将存放在 cache 的修改写入 trie 数据库中，返回的是使用的 gas，这部分代码涉及到 <code>core/state_transition.go</code>。</p>
<p>接着，如果是拜占庭硬分叉，直接调用 <code>statedb.Finalise(true)</code>，否则调用 <code>statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</code>，最后，初始化一个收据对象，其 <code>TxHash</code> 为交易哈希，<code>Logs</code> 字段通过 <code>statedb.GetLogs(tx.Hash())</code> 拿到，<code>Bloom</code> 字段通过 <code>types.CreateBloom(types.Receipts{receipt})</code> 创建，最后返回收据和消耗的 gas。</p>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>Process 部分的代码是插入区块时被调用的，而我们发现 Process 在处理每一个交易时，最终会调用 <code>core/state_transition.go</code> 中的 <code>Finalise</code>，实际上，如果说 <code>core/state_processor.go</code> 是用来处理区块级别的交易，那么可以说 <code>core/state_transition.go</code> 是用来处理一个一个的交易，最终将获得世界状态，收据，gas 等信息。</p>
<p>Transition 完成世界状态转换的工作，它会利用世界状态来执行交易，然后改变当前的世界状态。我们可以细看一下 <code>TransitionDb()</code> 的执行过程。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">st</span> *StateTransition) TransitionDb() (<span class="keyword">ret</span> []byte, usedGas uint64, failed bool, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> = <span class="keyword">st</span>.preCheck(); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	msg := <span class="keyword">st</span>.msg</div><div class="line">	sender := vm.AccountRef(msg.From())</div><div class="line">	homestead := <span class="keyword">st</span>.evm.ChainConfig().IsHomestead(<span class="keyword">st</span>.evm.BlockNumber)</div><div class="line">	contractCreation := msg.To() == nil</div><div class="line"></div><div class="line">	gas, <span class="keyword">err</span> := IntrinsicGas(<span class="keyword">st</span>.data, contractCreation, homestead)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, 0, false, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> = <span class="keyword">st</span>.useGas(gas); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, 0, false, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		evm = <span class="keyword">st</span>.evm</div><div class="line">		vmerr <span class="keyword">error</span></div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> contractCreation &#123;</div><div class="line">		<span class="keyword">ret</span>, _, <span class="keyword">st</span>.gas, vmerr = evm.Create(sender, <span class="keyword">st</span>.data, <span class="keyword">st</span>.gas, <span class="keyword">st</span>.value)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">st</span>.state.SetNonce(msg.From(), <span class="keyword">st</span>.state.GetNonce(sender.Address())+1)</div><div class="line">		<span class="keyword">ret</span>, <span class="keyword">st</span>.gas, vmerr = evm.Call(sender, <span class="keyword">st</span>.to(), <span class="keyword">st</span>.data, <span class="keyword">st</span>.gas, <span class="keyword">st</span>.value)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> vmerr != nil &#123;</div><div class="line">		<span class="keyword">log</span>.Debug(<span class="string">"VM returned with error"</span>, <span class="string">"err"</span>, vmerr)</div><div class="line">		<span class="keyword">if</span> vmerr == vm.ErrInsufficientBalance &#123;</div><div class="line">			<span class="keyword">return</span> nil, 0, false, vmerr</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">st</span>.refundGas()</div><div class="line">	<span class="keyword">st</span>.state.AddBalance(<span class="keyword">st</span>.evm.Coinbase, new(big.Int).Mul(new(big.Int).SetUint64(<span class="keyword">st</span>.gasUsed()), <span class="keyword">st</span>.gasPrice))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">ret</span>, <span class="keyword">st</span>.gasUsed(), vmerr != nil, <span class="keyword">err</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TransitionDb</code> 首先会调用 <code>preCheck</code>，<code>preCheck</code> 的作用是检测 Nonce 的值是否正确，然后通过 <code>buyGas()</code> 购买 Gas。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">st</span> *StateTransition) buyGas() <span class="keyword">error</span> &#123;</div><div class="line">	mgval := new(big.Int).Mul(new(big.Int).SetUint64(<span class="keyword">st</span>.msg.Gas()), <span class="keyword">st</span>.gasPrice)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">st</span>.state.GetBalance(<span class="keyword">st</span>.msg.From()).Cmp(mgval) &lt; 0 &#123;</div><div class="line">		<span class="keyword">return</span> errInsufficientBalanceForGas</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">st</span>.gp.SubGas(<span class="keyword">st</span>.msg.Gas()); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">st</span>.gas += <span class="keyword">st</span>.msg.Gas()</div><div class="line"></div><div class="line">	<span class="keyword">st</span>.initialGas = <span class="keyword">st</span>.msg.Gas()</div><div class="line">	<span class="keyword">st</span>.state.SubBalance(<span class="keyword">st</span>.msg.From(), mgval)</div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>buyGas</code> 会从交易的转出方账户扣除 <code>GasLimit * gasPrice</code>，GasPool 也会减掉这笔 Gas 消耗。</p>
<p>回到 <code>TransitionDb</code> 方法，在 <code>preCheck()</code> 之后，会调用 <code>IntrinsicGas</code> 方法，计算交易的固有 Gas 消耗，这个消耗有两部分，一部分是交易（或创建合约）预设消耗量，一部分是根据交易 data 的非0字节和0字节长度决定的消耗量，<code>TransitionDb</code> 方法中最终会从 gas 中减去这笔消耗。再接下来就是 EVM 的执行，如果是创建合约，调用的是 <code>evm.Create(sender, st.data, st.gas, st.value)</code>，如果是普通的交易，调用的是 <code>evm.Call(sender, st.to(), st.data, st.gas, st.value)</code>，这两个方法很重要，在接下来的 (go-ethereum 源码笔记（core 模块-EVM）)[#TODO] 这篇文章中会有讲解，这两个方法同样也会消耗 gas。接着调用 <code>refundGas</code> 方法执行退 gas 的操作。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (st *StateTransition) refundGas() &#123;</div><div class="line">	<span class="attribute">refund</span> := st<span class="variable">.gasUsed</span>() / 2</div><div class="line">	if refund &gt; st<span class="variable">.state</span><span class="variable">.GetRefund</span>() &#123;</div><div class="line">		refund = st<span class="variable">.state</span><span class="variable">.GetRefund</span>()</div><div class="line">	&#125;</div><div class="line">	st<span class="variable">.gas</span> += refund</div><div class="line"></div><div class="line">	remaining := new(big<span class="variable">.Int</span>)<span class="variable">.Mul</span>(new(big<span class="variable">.Int</span>)<span class="variable">.SetUint</span>64(st<span class="variable">.gas</span>), st<span class="variable">.gasPrice</span>)</div><div class="line">	st<span class="variable">.state</span><span class="variable">.AddBalance</span>(st<span class="variable">.msg</span><span class="variable">.From</span>(), remaining)</div><div class="line">	st<span class="variable">.gp</span><span class="variable">.AddGas</span>(st<span class="variable">.gas</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>refundGas</code> 首先会将用户剩下的 gas 还回去，但退回的金额不会超过用户使用的 gas 的 1/2。</p>
<p><code>TransitionDb</code> 最后会通过 <code>st.state.AddBalance</code> 奖励区块的挖掘者，这笔钱等于 <code>gasPrice*(initialGas-gas)</code>，至此，这个交易的 gas 消耗量计算就完成了。</p>
<h2 id="state-模块"><a href="#state-模块" class="headerlink" title="state 模块"></a>state 模块</h2><p>在上面的 Process, Transition 小节，我们了解了 geth 中状态管理的部分功能，实际上就管理世界状态而言，<code>core/state</code> 还提供了很多其他功能，不过这些功能大多只是在 EVM 进行合约的操作时才使用到，例如 <code>core/vm/instructions.go</code> 中的 makeLog 指令，在进行出栈操作后，最终还是会通过 StateDB 的 AddLog 方法实现写日志的功能。这里我们将深入 <code>core/state</code> 模块的实现，限于篇幅，无法面面俱到，我们只分析几个应用场景。</p>
<h3 id="存储以太坊合约和账户-StateDB"><a href="#存储以太坊合约和账户-StateDB" class="headerlink" title="存储以太坊合约和账户 StateDB"></a>存储以太坊合约和账户 StateDB</h3><p>stateDB 用来与以太坊中的世界状态进行交互，它可以与状态树进行交互，提供了检索合约，账户的功能。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">type StateDB struct &#123;</div><div class="line">	db   Database</div><div class="line">	trie Trie</div><div class="line">	</div><div class="line">	<span class="keyword">state</span>Objects      map[common.Address]*<span class="keyword">state</span>Object</div><div class="line">	<span class="keyword">state</span>ObjectsDirty map[common.Address]struct&#123;&#125;</div><div class="line"></div><div class="line">	dbErr error</div><div class="line">	refund uint64</div><div class="line"></div><div class="line">	thash, bhash common.Hash</div><div class="line">	txIndex      int</div><div class="line">	logs         map[common.Hash][]*types.Log</div><div class="line">	<span class="keyword">log</span>Size      uint</div><div class="line"></div><div class="line">	preimages map[common.Hash][]byte</div><div class="line"></div><div class="line">	journal        *journal</div><div class="line">	validRevisions []revision</div><div class="line">	nextRevisionId int</div><div class="line"></div><div class="line">	lock sync.Mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>stateObjects</code> 用来缓存状态对象，<code>stateObjectsDirty</code> 用来缓存被修改过的对象，这部分代码在 <code>core/state/state_object.go</code> 里。<code>stateObject</code> 主要依赖于 <code>core/state/database.go</code>，<code>core/state/database.go</code> 中的 Database（也是 StateDB 中的 Database） 封装了一下对 MPT 树的操作，可以增删改查世界状态，余额等。<br>journal 表示操作日志，<code>core/state/journal.go</code> 针对各种操作日志提供了对应的回滚功能，可以基于这个日志做一些事务类型的操作。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</div><div class="line">	tr, err := db.OpenTrie(root)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> &amp;StateDB&#123;</div><div class="line">		db:                db,</div><div class="line">		trie:              tr,</div><div class="line">		stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*stateObject),</div><div class="line">		stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		logs:              <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]*types.Log),</div><div class="line">		preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span>),</div><div class="line">		journal:           newJournal(),</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化的时候会利用 <code>OpenTrie</code> 获取 trie，这部分功能由 <code>core/state/database.go</code> 提供，<code>core/state/database.go</code> 封装了与数据库交互的代码，从 database 提供的接口中可以一窥一二。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Database</span> interface &#123;</div><div class="line">	<span class="type">OpenTrie</span>(root common.<span class="type">Hash</span>) (<span class="type">Trie</span>, error)</div><div class="line">	<span class="type">OpenStorageTrie</span>(addrHash, root common.<span class="type">Hash</span>) (<span class="type">Trie</span>, error)</div><div class="line">	<span class="type">CopyTrie(Trie)</span> <span class="type">Trie</span></div><div class="line">	<span class="type">ContractCode</span>(addrHash, codeHash common.<span class="type">Hash</span>) ([]byte, error)</div><div class="line">	<span class="type">ContractCodeSize</span>(addrHash, codeHash common.<span class="type">Hash</span>) (int, error)</div><div class="line">	<span class="type">TrieDB</span>() *trie.<span class="type">Database</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OpenTrie</code> 的会先从缓存中查找 trie，如果没有缓存的话构建个 trie 返回。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *cachingDB) OpenTrie(root common.Hash) (Trie, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">db</span>.mu.Lock()</div><div class="line">	defer <span class="keyword">db</span>.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := len(<span class="keyword">db</span>.pastTries) - 1; i &gt;= 0; i-- &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">db</span>.pastTries[i].Hash() == root &#123;</div><div class="line">			<span class="keyword">return</span> cachedTrie&#123;<span class="keyword">db</span>.pastTries[i].<span class="keyword">Copy</span>(), <span class="keyword">db</span>&#125;, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	tr, <span class="keyword">err</span> := trie.NewSecure(root, <span class="keyword">db</span>.<span class="keyword">db</span>, MaxTrieCacheGen)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> cachedTrie&#123;tr, <span class="keyword">db</span>&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Database 中还有 <code>OpenStorage</code> 方法，该方法和 OpenTrie 类似；<code>ContractCode</code> 可以用来访问合约代码；<code>ContractCodeSize</code> 用来获取合约的大小；<code>CopyTrie</code> 返回一个指定 trie 的 copy。代码都没有什么特别的，这里不再赘述，</p>
<p>我们接着看 <code>stateDB</code> 提供的功能。我们通过几个例子看看 StateDB 如何与 stateObject，journal，Database 进行交互的。</p>
<h4 id="AddBalance-增加余额"><a href="#AddBalance-增加余额" class="headerlink" title="AddBalance 增加余额"></a>AddBalance 增加余额</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func (<span class="literal">self</span> *StateDB) AddBalance(addr common.Address, amount *big.Int) &#123;</div><div class="line">	<span class="keyword">state</span>Object := <span class="literal">self</span>.GetOrNewStateObject(addr)</div><div class="line">	if <span class="keyword">state</span>Object != nil &#123;</div><div class="line">		<span class="keyword">state</span>Object.AddBalance(amount)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>core/state/state_object.go</code> 中 <code>AddBalance</code> 方法为：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func (c *<span class="keyword">state</span>Object) AddBalance(amount *big.Int) &#123;</div><div class="line">	if amount.Sign() == <span class="number">0</span> &#123;</div><div class="line">		if c.empty() &#123;</div><div class="line">			c.touch()</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	c.SetBalance(new(big.Int).Add(c.Balance(), amount))</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (<span class="literal">self</span> *<span class="keyword">state</span>Object) SetBalance(amount *big.Int) &#123;</div><div class="line">	<span class="literal">self</span>.db.journal.append(balanceChange&#123;</div><div class="line">		account: &amp;<span class="literal">self</span>.address,</div><div class="line">		prev:    new(big.Int).Set(<span class="literal">self</span>.data.Balance),</div><div class="line">	&#125;)</div><div class="line">	<span class="literal">self</span>.<span class="built_in">set</span>Balance(amount)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (<span class="literal">self</span> *<span class="keyword">state</span>Object) <span class="built_in">set</span>Balance(amount *big.Int) &#123;</div><div class="line">	<span class="literal">self</span>.data.Balance = amount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 journal 记录了一条日志，方便回滚操作：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">j </span>*<span class="keyword">journal) </span>append(entry <span class="keyword">journalEntry) </span>&#123;</div><div class="line">	<span class="keyword">j.entries </span>= append(<span class="keyword">j.entries, </span>entry)</div><div class="line">	if <span class="keyword">addr </span>:= entry.<span class="keyword">dirtied(); </span><span class="keyword">addr </span>!= nil &#123;</div><div class="line">		<span class="keyword">j.dirties[*addr]++</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GetBalance-获取余额"><a href="#GetBalance-获取余额" class="headerlink" title="GetBalance 获取余额"></a>GetBalance 获取余额</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (<span class="literal">self</span> *StateDB) GetBalance(addr common.Address) *big.Int &#123;</div><div class="line">	<span class="keyword">state</span>Object := <span class="literal">self</span>.getStateObject(addr)</div><div class="line">	if <span class="keyword">state</span>Object != nil &#123;</div><div class="line">		return <span class="keyword">state</span>Object.Balance()</div><div class="line">	&#125;</div><div class="line">	return common.Big0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>core/state/state_object.go</code> 中，Balance 方法为：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (<span class="literal">self</span> *<span class="keyword">state</span>Object) Balance() *big.Int &#123;</div><div class="line">	return <span class="literal">self</span>.data.Balance</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>data 是 账户类型，在 stateObject 中已有缓存。</p>
<p>通过写入余额，获取余额的两个例子，我们知道了 StateDB 提供的功能，以及 journal，state_object 模块的职责，可以看到目前为止这些功能还是在内存里操作的，而世界状态最终还是会写到 LevelDB 里。</p>
<h4 id="Commit-提交当前状态"><a href="#Commit-提交当前状态" class="headerlink" title="Commit 提交当前状态"></a>Commit 提交当前状态</h4><p>通过 StateDB 的 Commit 方法可以写入当前的世界状态到数据库中。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">func (s *StateDB) Commit(deleteEmptyObjects bool) (root common.Hash, err error) &#123;</div><div class="line">	defer s.clearJournalAndRefund()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> addr := range s.journal.dirties &#123;</div><div class="line">		s.<span class="keyword">state</span>ObjectsDirty[addr] = struct&#123;&#125;&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> addr, <span class="keyword">state</span>Object := range s.<span class="keyword">state</span>Objects &#123;</div><div class="line">		_, isDirty := s.<span class="keyword">state</span>ObjectsDirty[addr]</div><div class="line">		switch &#123;</div><div class="line">		case <span class="keyword">state</span>Object.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; <span class="keyword">state</span>Object.empty()):</div><div class="line">			s.deleteStateObject(<span class="keyword">state</span>Object)</div><div class="line">		case isDirty:</div><div class="line">			if <span class="keyword">state</span>Object.code != nil &amp;&amp; <span class="keyword">state</span>Object.dirtyCode &#123;</div><div class="line">				s.db.TrieDB().InsertBlob(common.BytesToHash(<span class="keyword">state</span>Object.CodeHash()), <span class="keyword">state</span>Object.code)</div><div class="line">				<span class="keyword">state</span>Object.dirtyCode = false</div><div class="line">			&#125;</div><div class="line">			if err := <span class="keyword">state</span>Object.CommitTrie(s.db); err != nil &#123;</div><div class="line">				return common.Hash&#123;&#125;, err</div><div class="line">			&#125;</div><div class="line">			s.updateStateObject(<span class="keyword">state</span>Object)</div><div class="line">		&#125;</div><div class="line">		delete(s.<span class="keyword">state</span>ObjectsDirty, addr)</div><div class="line">	&#125;</div><div class="line">	root, err = s.trie.Commit(func(leaf []byte, parent common.Hash) error &#123;</div><div class="line">		var account Account</div><div class="line">		if err := rlp.DecodeBytes(leaf, &amp;account); err != nil &#123;</div><div class="line">			return nil</div><div class="line">		&#125;</div><div class="line">		if account.Root != emptyState &#123;</div><div class="line">			s.db.TrieDB().Reference(account.Root, parent)</div><div class="line">		&#125;</div><div class="line">		code := common.BytesToHash(account.CodeHash)</div><div class="line">		if code != emptyCode &#123;</div><div class="line">			s.db.TrieDB().Reference(code, parent)</div><div class="line">		&#125;</div><div class="line">		return nil</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">log</span>.Debug(<span class="string">"Trie cache stats after commit"</span>, <span class="string">"misses"</span>, trie.CacheMisses(), <span class="string">"unloads"</span>, trie.CacheUnloads())</div><div class="line">	return root, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终通过 <code>core/state/database.go</code> 中的 Commit 实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m cachedTrie)</span> <span class="title">Commit</span><span class="params">(onleaf trie.LeafCallback)</span> <span class="params">(common.Hash, error)</span></span> &#123;</div><div class="line">	root, err := m.SecureTrie.Commit(onleaf)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		m.db.pushTrie(m.SecureTrie)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> root, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="IntermediateRoot-获取当前世界状态哈希"><a href="#IntermediateRoot-获取当前世界状态哈希" class="headerlink" title="IntermediateRoot 获取当前世界状态哈希"></a><code>IntermediateRoot</code> 获取当前世界状态哈希</h4><p>还记得我们在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a>  提到 <code>stateTrie</code> 比较特别，交易执行时，<code>stateTrie</code> 一直在变化，前文中提到，交易执行的入口函数 <code>StateProcessor.Process()</code> 会调用 <code>Engine</code> 的 <code>Finalize()</code> 方法，而 <code>Finalize</code> 方法最终会调用 <code>IntermediateRoot</code>  方法获取世界状态的当前 root 值并返回给 header.Root 进行赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">IntermediateRoot</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</div><div class="line">	s.Finalise(deleteEmptyObjects)</div><div class="line">	<span class="keyword">return</span> s.trie.Hash()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到这个方法会在交易执行的过程中被调用，返回的哈希值会被存到交易收据树里。</p>
<h4 id="snapshot-快照功能"><a href="#snapshot-快照功能" class="headerlink" title="snapshot 快照功能"></a>snapshot 快照功能</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *StateDB)</span></span> <span class="type">Snapshot</span>() int &#123;</div><div class="line">	id := <span class="keyword">self</span>.nextRevisionId</div><div class="line">	<span class="keyword">self</span>.nextRevisionId++</div><div class="line">	<span class="keyword">self</span>.validRevisions = append(<span class="keyword">self</span>.validRevisions, revision&#123;id, <span class="keyword">self</span>.journal.length()&#125;)</div><div class="line">	<span class="keyword">return</span> id</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *StateDB)</span></span> <span class="type">RevertToSnapshot</span>(revid int) &#123;</div><div class="line">	idx := <span class="built_in">sort</span>.<span class="type">Search</span>(len(<span class="keyword">self</span>.validRevisions), <span class="function"><span class="keyword">func</span><span class="params">(i int)</span></span> bool &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.validRevisions[i].id &gt;= revid</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">if</span> idx == len(<span class="keyword">self</span>.validRevisions) || <span class="keyword">self</span>.validRevisions[idx].id != revid &#123;</div><div class="line">		panic(fmt.<span class="type">Errorf</span>(<span class="string">"revision id %v cannot be reverted"</span>, revid))</div><div class="line">	&#125;</div><div class="line">	snapshot := <span class="keyword">self</span>.validRevisions[idx].journalIndex</div><div class="line"></div><div class="line">	<span class="keyword">self</span>.journal.revert(<span class="keyword">self</span>, snapshot)</div><div class="line">	<span class="keyword">self</span>.validRevisions = <span class="keyword">self</span>.validRevisions[:idx]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Snapshot</code> 方法用来创建当前世界状态的快照，<code>RevertToSnapshot</code> 可以根据快照 id 进行回滚，这个功能通过 <code>core/state/journal.go</code> 的 <code>revert</code> 实现。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">j </span>*<span class="keyword">journal) </span>revert(statedb *StateDB, snapshot int) &#123;</div><div class="line">	for i := len(<span class="keyword">j.entries) </span>- <span class="number">1</span><span class="comment">; i &gt;= snapshot; i-- &#123;</span></div><div class="line">		<span class="keyword">j.entries[i].revert(statedb)</span></div><div class="line"></div><div class="line">		if <span class="keyword">addr </span>:= <span class="keyword">j.entries[i].dirtied(); </span><span class="keyword">addr </span>!= nil &#123;</div><div class="line">			if <span class="keyword">j.dirties[*addr]--; </span><span class="keyword">j.dirties[*addr] </span>== <span class="number">0</span> &#123;</div><div class="line">				delete(<span class="keyword">j.dirties, </span>*<span class="keyword">addr)</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">j.entries </span>= <span class="keyword">j.entries[:snapshot]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/core-state%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">core-state源码分析</a></li>
<li><a href="http://www.wjblog.top/articles/d8361364/" target="_blank" rel="external">How does Ethereum work, anyway?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面的文章，我们了解了 geth 的大致原理，知道了区块链是怎么组织构成的，有了 rlp，MPT 这些数据结构的基础，也知道了账户是怎么组织的，交易是如何管理的，挖矿是一个什么样的流程，这一篇我们将深入到交易的具体处理过程，看看交易过程中是如何修改世界状态，生成交易收据的。&lt;/p&gt;
&lt;p&gt;这篇文章将涉及到 &lt;code&gt;core/types/transaction.go&lt;/code&gt;, &lt;code&gt;core/state&lt;/code&gt; 模块，需要对交易池，账户等基本概念有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（ethdb 模块）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88ethdb%20%E6%A8%A1%E5%9D%97%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（ethdb 模块）/</id>
    <published>2018-03-10T14:35:06.000Z</published>
    <updated>2018-10-19T15:35:12.469Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的文章，我们知道了有工作量证明的区块链是怎么构建的，然而区块链一直在内存中当然是不行的，我们需要将区块链持久化到数据库中。<br><a id="more"></a></p>
<p>区块链的本质是一个分布式数据库，尽管如此，底层使用的数据库并没有太大要求，不需要分布式，分片等等特性，这些特性是在数据库的上层做的。所有的节点都是一个完整的实例，是它们组成了一个分布式系统。就实现业务来说，我们只需要一个简单的 k-v 数据库就够了。</p>
<p>geth 采用的是 LevelDB，回头来看这个选择还是有很多可以反思的地方，LevelDB 在顺序读写的场景下性能很好，但 geth 在运行智能合约时，面临的更多的场景是大量时间耗费在世界状态的读写上，通过前面对 MPT 的分析我们知道，这些 IO 大多是离散随机的，这导致了 geth 的性能瓶颈，特别是在合约里的数据大量分布在 Storage Trie 的情况下，因为树的高度可能很高，而每加载一个节点都需要进行一次 IO。这一点在<a href="https://zhuanlan.zhihu.com/p/39262324" target="_blank" rel="external">以太坊(Ethereum) 的执行交易性能瓶颈</a>这篇文章中有论述。<a href="https://www.weibo.com/dcaoyuan" target="_blank" rel="external">邓草原</a> 正在开发的 Kesque 也可以关注一下。这不是本文重点，就不展开了。</p>
<p>中本聪的最初论文并没有提具体要用什么数据库，尽管如此，社区使用最多的参考实现 Bitcoin Core 最初使用的是 Berkeley DB，后来转而使用 levelDB 存区块链索引，以太坊的 Go，C++, Python 实现的客户端使用的是 LevelDB 数据库，Rust 客户端 Parity 使用的是 RocksDB。</p>
<p>go-ethereum 对 LevelDB 的增删改查是通过 ethdb 这个模块来交互的。ethdb 实际上是对 github.com/syndtr/goleveldb/leveldb 这个库的封装，其中增加了收集 metric 的功能。</p>
<p>如果想要对 LevelDB 有更深层次的了解可以自行查询相关资料。</p>
<p>ethdb 模块的功能比较单一，就4个文件：</p>
<ul>
<li>interface.go 定义数据库增删改查的接口</li>
<li>database.go 封装 levelDB 的代码</li>
<li>memory_database.go 基于内存的数据库，不会持久化到文件，只在测试时使用</li>
<li>database_test.go 测试用例</li>
</ul>
<h2 id="interface-go"><a href="#interface-go" class="headerlink" title="interface.go"></a>interface.go</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Database</span> interface &#123;</div><div class="line">	<span class="type">Putter</span></div><div class="line">	<span class="type">Get</span>(key []byte) ([]byte, error)</div><div class="line">	<span class="type">Has</span>(key []byte) (bool, error)</div><div class="line">	<span class="type">Delete</span>(key []byte) error</div><div class="line">	<span class="type">Close</span>()</div><div class="line">	<span class="type">NewBatch</span>() <span class="type">Batch</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Database 接口定义了所有数据库操作，Putter 接口定义批量操作和普通操作的接口。批量操作不能多线程同时使用。</p>
<h2 id="memory-database-go"><a href="#memory-database-go" class="headerlink" title="memory_database.go"></a>memory_database.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MemDatabase <span class="keyword">struct</span> &#123;</div><div class="line">	db   <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span></div><div class="line">	lock sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个文件跟 LevelDB 没什么关系，它只是封装了内存里的 key-value 结构，暴露的增删改查的接口(Put，Has，Get，Keys，Delete 等等)跟对 LevelDB 的封装基本一致。加了锁以在多线程的情况下对资源进行保护。</p>
<h2 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h2><p>封装了 levelDB 接口，在 go-ethereum 中大量使用。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type LDBDatabase struct &#123;</div><div class="line">	fn string</div><div class="line">	db *leveldb<span class="selector-class">.DB</span></div><div class="line"></div><div class="line">	compTimeMeter  metrics<span class="selector-class">.Meter</span></div><div class="line">	compReadMeter  metrics<span class="selector-class">.Meter</span></div><div class="line">	compWriteMeter metrics<span class="selector-class">.Meter</span></div><div class="line">	diskReadMeter  metrics<span class="selector-class">.Meter</span></div><div class="line">	diskWriteMeter metrics<span class="selector-class">.Meter</span></div><div class="line"></div><div class="line">	quitLock sync<span class="selector-class">.Mutex</span></div><div class="line">	quitChan chan chan error</div><div class="line"></div><div class="line">	log log<span class="selector-class">.Logger</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Path, Put, Has, Get 等方法是对 levelDB 的封装，没有什么特别的，也不需要用锁，因为 github.com/syndtr/goleveldb/leveldb 支持多线程访问。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Path</span><span class="params">()</span> <span class="title">string</span> &#123;</span></div><div class="line">	<span class="keyword">return</span> db.fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Put</span><span class="params">(key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> db.db.Put(key, value, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Has"><a href="#Has" class="headerlink" title="Has"></a>Has</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Has</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> db.db.Has(key, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	dat, err := db.db.Get(key, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dat, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> db.db.Delete(key, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p><code>compTimeMeter</code>, <code>compReadMeter</code>, <code>compWriteMeter</code>, <code>diskReadMeter</code>, <code>diskWriteMeter</code> 这几个方法都通过 <code>metrics.NewRegisteredMeter</code> 注册得到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Meter</span><span class="params">(prefix <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !metrics.Enabled &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	db.compTimeMeter = metrics.NewRegisteredMeter(prefix+<span class="string">"compact/time"</span>, <span class="literal">nil</span>)</div><div class="line">	db.compReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">"compact/input"</span>, <span class="literal">nil</span>)</div><div class="line">	db.compWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">"compact/output"</span>, <span class="literal">nil</span>)</div><div class="line">	db.diskReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">"disk/read"</span>, <span class="literal">nil</span>)</div><div class="line">	db.diskWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">"disk/write"</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">	db.quitLock.Lock()</div><div class="line">	db.quitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error)</div><div class="line">	db.quitLock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> db.meter(<span class="number">3</span> * time.Second)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过一个 goroutine 调用 db.meter。</p>
<p>该方法是一个死循环，过三秒钟就通过 <code>db.db.GetProperty(&quot;leveldb.iostats&quot;)</code> 获取一次 leveldb 的 stats，然后发到 metrics 系统。如果收到 quitChan 的信号就退出死循环。</p>
<h2 id="业务相关代码"><a href="#业务相关代码" class="headerlink" title="业务相关代码"></a>业务相关代码</h2><p>与业务直接相关的代码在 <code>core/rawdb</code> 目录下，基本上所有与底层数据库交互的代码都在这里，没有很复杂的内容，不过了解这些底层的数据结构对于理解业务很有帮助，可以自行浏览。</p>
<h2 id="key-gt-value"><a href="#key-gt-value" class="headerlink" title="key-&gt;value"></a>key-&gt;value</h2><p>以下是一些 geth 中常见的 key-value 对（在 <code>core/rawdb/schema.go</code> 中定义）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">value</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“h” + num + hash</td>
<td style="text-align:center">区块头的数据</td>
<td style="text-align:center">根据区块高度和区块哈希找到区块头数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“h” + num + hash + “t”</td>
<td style="text-align:center">区块总难度</td>
<td style="text-align:center">根据区块高度，区块哈希找到 totalDifficulty，即累计的区块难度的和</td>
</tr>
<tr>
<td style="text-align:center">“h” + num + “n”</td>
<td style="text-align:center">区块头哈希值</td>
<td style="text-align:center">根据存储的规范区块链高度找到区块头哈希值</td>
</tr>
<tr>
<td style="text-align:center">“H” + hash</td>
<td style="text-align:center">区块高度</td>
<td style="text-align:center">根据哈希值找到区块高度</td>
</tr>
<tr>
<td style="text-align:center">“b” + num + hash</td>
<td style="text-align:center">区块体的数据</td>
<td style="text-align:center">根据区块高度，区块哈希找到区块体的数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“r” + num + hash</td>
<td style="text-align:center">收据的数据</td>
<td style="text-align:center">根据区块高度，区块哈希找到收据的数据（RLP 编码）</td>
</tr>
<tr>
<td style="text-align:center">“l” + hash</td>
<td style="text-align:center">交易，收据查找的 metadata</td>
<td style="text-align:center">根据哈希值找到交易，收据查找的 metadata</td>
</tr>
<tr>
<td style="text-align:center">“B” + bit + section + hash</td>
<td style="text-align:center">布隆过滤器的结果</td>
<td style="text-align:center">用于日志的过滤</td>
</tr>
</tbody>
</table>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/syndtr/goleveldb" target="_blank" rel="external">LevelDB 的 Golang 实现</a></li>
<li><a href="https://github.com/google/leveldb" target="_blank" rel="external">LevelDB 的 C++ 实现</a></li>
<li><a href="https://www.zhihu.com/question/19887265/answer/78839142" target="_blank" rel="external">LSM 算法的原理是什么？</a></li>
<li><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/" target="_blank" rel="external">Log Structured Merge Trees</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39262324" target="_blank" rel="external">以太坊(Ethereum) 的执行交易性能瓶颈</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面的文章，我们知道了有工作量证明的区块链是怎么构建的，然而区块链一直在内存中当然是不行的，我们需要将区块链持久化到数据库中。&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（miner,consensus 模块-挖矿和共识算法）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88miner,%20consensus%20%E6%A8%A1%E5%9D%97-%E6%8C%96%E7%9F%BF%E5%92%8C%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（miner, consensus 模块-挖矿和共识算法）/</id>
    <published>2018-03-10T14:35:05.000Z</published>
    <updated>2018-09-22T08:23:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>前面的章节 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 描述了区块链世界的核心：区块，区块链。我们已经知道区块链可以用来存储交易的数据，也知道了如何在区块链里发起一笔交易，而问题是，往区块链中增加数据应该是一个较困难的操作，按照比特币论文里的说法，即需要一个 PoW（Proof of Work，工作量证明），否则每个人都能轻易往区块链中增加数据，安全性和一致性无法保证。这一点上，以太坊法和比特币类似，尽管略有不同，但大致都需要矿工的角色贡献计算力，完成一个复杂的计算，即找到一个区块的哈希值，验证正确之后才能加入到区块链中。这个过程就叫做挖矿。矿工们去做这件事当然是有一定利益驱使的，每完成一次挖矿，他们就能获得一些以太币奖励。</p>
<a id="more"></a>
<p>挖矿涉及的 Ethash 算法涉及到 miner, consensu 模块。</p>
<p>geth 中的挖矿是 CPU 挖矿，现在挖矿基本都是 GPU 挖矿了，因为这两者的效率已经不在一个数量级。但是研究 geth 的代码能给我们一个很好的参考，可以帮助我们了解挖矿的原理。关于 GPU 的挖矿可以参考：<a href="https://github.com/ethereum-mining/ethminer" target="_blank" rel="external">ethereum-mining/ethminer</a>，不过这块我还没有深入研究，有开发经验的朋友可以一起来讨论。</p>
<h1 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h1><p>以太坊从一开始就计划采用 PoS（Proof of Stack），但现阶段仍采用 PoW 的方式，尽管是临时的，以太坊的 PoW 从设计到实现都算得上精美。比特币诞生之初的设计理念是『一CPU一票』，随着显卡挖矿，ASIC 矿机的出现，这个价值回归用户的口号似乎成为空词，实际上矿机的出现是技术和生产力的进步，本质上和一CPU一票没有不同，云挖矿的模式也早就出现，不管是 CPU 还是显卡，矿机，其实质都是『一份资产的投入可低一票』。话虽如此，现在 PoW 的貌似畸形的模式还是给普通民众留下口实。</p>
<p>geth 使用的 Ethash 算法，之前叫做 Dagger-Hashimoto，从名字也可以看出来这是两个算法的结合体。Dagger-Hashimoto 算法的目标是（来自 <a href="https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md" target="_blank" rel="external">wiki /Dagger-Hashimoto.md</a>）：</p>
<ul>
<li>抵制矿机(ASIC，专门用于挖矿的芯片)</li>
<li>轻客户端验证</li>
<li>全链式存储</li>
</ul>
<h2 id="Hashimoto-算法"><a href="#Hashimoto-算法" class="headerlink" title="Hashimoto 算法"></a>Hashimoto 算法</h2><p><a href="https://github.com/knarfeh/papers/blob/master/Blockchain/Hashimoto%2C%20I%3AO%20bound%20proof%20of%20work.pdf" target="_blank" rel="external">Hashimoto：I/O bound proof of work</a></p>
<p>作者是 Thaddeus Dryja，这个算法的目标是通过 IO 限制来抵制矿机。</p>
<h2 id="Dagger-算法"><a href="#Dagger-算法" class="headerlink" title="Dagger 算法"></a>Dagger 算法</h2><p><a href="http://www.hashcash.org/papers/dagger.html" target="_blank" rel="external">Dagger: A Memory-Hard to Compute, Memory-Easy to Verify Scrypt Alternative</a></p>
<p>作者是 Vitalik，算法利用了 DAG(有向非循环图) 数据结构，目的是将挖矿操作限制为必须使用大内存，以抵抗矿机。</p>
<h2 id="Ethash"><a href="#Ethash" class="headerlink" title="Ethash"></a>Ethash</h2><p>Ethash 是以太坊使用的 PoW 算法，其原理可以用一个公式来概括：</p>
<p>$RAND(h, n) &lt;= \frac{M}{d}$</p>
<p>其中 h 是区块头的哈希值（没有 Nonce），n 是 Nonce 值，M 是一个极大的数字，d 指挖矿难度，RAND 是一个根据参数生成随机值的操作，挖矿的过程简单来说就是寻找适合的 nonce，使上述不等式成立。原理和比特币的基本相同，但 Ethash 稍特别一点，因为 geth 的开发者在设计初期就考虑了抵制矿机的问题里，Ethash 的具体步骤为：</p>
<ol>
<li>对于每个区块，先算出一个种子。种子的计算只依赖当前区块信息。</li>
<li>使用种子生成伪随机数据集，称为 cache。轻客户端需要保存 cache</li>
<li>基于 cache 生成 1GB 大小的数据集，称为 the DAG。这个数据集的每一个元素都依赖于 cache 中的某几个元素，只要有 cache 就可以快速计算出 DAG 中指定位置的元素。完整可挖矿客户端需要保存 DAG。</li>
<li>挖矿可以概括为从 DAG 中随机选择元素，然后暴力枚举选择一个 nonce 值，对其进行哈希计算，使其符合约定的难度，而这个难度其实就是要求哈希值的前缀包括多少个0。验证的时候，基于 cache 计算指定位置 DAG 元素，然后验证这个元素集合的哈希值结果小于某个值，这个过程只需要普通 CPU 和普通内存。</li>
<li>cache 和 DAG 每过一个周期更新一次，一个周期长度是 30000 个区块。DAG 只取决于区块数量，大小会随着时间推移线性增长，从 1GB 开始，每年大约增加 7GB。由于 DAG 需要很长时间生成，所以 geth 每次会维护2个 DAG 集合。</li>
</ol>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="miner-模块"><a href="#miner-模块" class="headerlink" title="miner 模块"></a>miner 模块</h2><p>挖矿的入口在 <code>miner/miner.go</code> 中的 Miner：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Miner</span> struct &#123;</div><div class="line">	mux *event.<span class="type">TypeMux</span></div><div class="line">	worker *worker</div><div class="line">	coinbase common.<span class="type">Address</span></div><div class="line">	mining   int32</div><div class="line">	eth      <span class="type">Backend</span></div><div class="line">	engine   consensus.<span class="type">Engine</span></div><div class="line">	canStart    int32</div><div class="line">	shouldStart int32</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>func New(eth Backend, config *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine)</code> 方法，可以获得一个 Miner 实例(见 <code>eth/backend.go</code> 的 <code>eth.miner = miner.New(eth, eth.chainConfig, eth.EventMux(), eth.engine)</code>)，在实例化的过程中，会通过一个 goroutine 调用 <code>miner.update()</code>。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (self *Miner) update() &#123;</div><div class="line">	<span class="attribute">events</span> := self<span class="variable">.mux</span><span class="variable">.Subscribe</span>(downloader<span class="variable">.StartEvent</span>&#123;&#125;, downloader<span class="variable">.DoneEvent</span>&#123;&#125;, downloader<span class="variable">.FailedEvent</span>&#123;&#125;)</div><div class="line">out:</div><div class="line">	for ev := range events<span class="variable">.Chan</span>() &#123;</div><div class="line">		switch ev<span class="variable">.Data</span>.(type) &#123;</div><div class="line">		case downloader<span class="variable">.StartEvent</span>:</div><div class="line">			atomic<span class="variable">.StoreInt</span>32(&amp;self<span class="variable">.canStart</span>, 0)</div><div class="line">			if self<span class="variable">.Mining</span>() &#123;</div><div class="line">				self<span class="variable">.Stop</span>()</div><div class="line">				atomic<span class="variable">.StoreInt</span>32(&amp;self<span class="variable">.shouldStart</span>, 1)</div><div class="line">				log<span class="variable">.Info</span>("Mining aborted due to sync")</div><div class="line">			&#125;</div><div class="line">		case downloader<span class="variable">.DoneEvent</span>, downloader<span class="variable">.FailedEvent</span>:</div><div class="line">			shouldStart := atomic<span class="variable">.LoadInt</span>32(&amp;self<span class="variable">.shouldStart</span>) == 1</div><div class="line"></div><div class="line">			atomic<span class="variable">.StoreInt</span>32(&amp;self<span class="variable">.canStart</span>, 1)</div><div class="line">			atomic<span class="variable">.StoreInt</span>32(&amp;self<span class="variable">.shouldStart</span>, 0)</div><div class="line">			if shouldStart &#123;</div><div class="line">				self<span class="variable">.Start</span>(self<span class="variable">.coinbase</span>)</div><div class="line">			&#125;</div><div class="line">			events<span class="variable">.Unsubscribe</span>()</div><div class="line">			break out</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动消息监听，当收到 downloader 的 <code>StartEvent</code>，表示本节点正在从其他节点下载新区块，这是 miner 会停止进行中的挖掘工作；如果收到 downloader 的 DoneEvent 或 FailEvent 方法，表明本节点的下载任务已经结束，这时可以开始挖掘新区块。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *Miner)</span></span> <span class="type">Start</span>(coinbase common.<span class="type">Address</span>) &#123;</div><div class="line">	atomic.<span class="type">StoreInt32</span>(&amp;<span class="keyword">self</span>.shouldStart, <span class="number">1</span>)</div><div class="line">	<span class="keyword">self</span>.<span class="type">SetEtherbase</span>(coinbase)</div><div class="line">	<span class="keyword">if</span> atomic.<span class="type">LoadInt32</span>(&amp;<span class="keyword">self</span>.canStart) == <span class="number">0</span> &#123;</div><div class="line">		log.<span class="type">Info</span>(<span class="string">"Network syncing, will start miner afterwards"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	atomic.<span class="type">StoreInt32</span>(&amp;<span class="keyword">self</span>.mining, <span class="number">1</span>)</div><div class="line">	log.<span class="type">Info</span>(<span class="string">"Starting mining operation"</span>)</div><div class="line">	<span class="keyword">self</span>.worker.start()</div><div class="line">	<span class="keyword">self</span>.worker.commitNewWork()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Miner</code> struct 中有一个 worker 类型成员变量，它指向 worker 中的 Work struct，当我们需要开始挖矿时，我们通过 <code>miner.Start()</code> 开始（见 <code>eth/backend.go</code> 中的 <code>StartMining</code>，L358）。在设置好 coinbase 和等待网络同步完成后，继续调用 <code>self.worker.start()</code>。</p>
<p><code>miner/woker.go</code> 负责管理挖矿，它有一组 agent，每个 agent 单独完成挖矿过程。见 worker.go 中的 L203-L213</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *worker)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// spin up agents</span></div><div class="line">	<span class="keyword">for</span> agent := <span class="keyword">range</span> self.agents &#123;</div><div class="line">		agent.Start()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>agent 指的是实现了共识算法的 agent。这个我们接下来再详细描述。需要注意的是，实例化 Worker 的时候，也就是在 miner.go 的 New 方法调用 <code>newWorker(config, engine, common.Address{}, eth, mux)</code> 的过程中，我们会以 goroutine 的方式调用其他 worker 的其他方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func newWorker(config *params<span class="selector-class">.ChainConfig</span>, engine consensus<span class="selector-class">.Engine</span>, coinbase common<span class="selector-class">.Address</span>, eth Backend, mux *event.TypeMux) *worker &#123;</div><div class="line">	...</div><div class="line">	worker<span class="selector-class">.txSub</span> = eth.TxPool().SubscribeTxPreEvent(worker.txCh)</div><div class="line">	worker<span class="selector-class">.chainHeadSub</span> = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)</div><div class="line">	worker<span class="selector-class">.chainSideSub</span> = eth.BlockChain().SubscribeChainSideEvent(worker.chainSideCh)</div><div class="line">	go worker.update()</div><div class="line">	go worker.wait()</div><div class="line">	worker.commitNewWork()</div><div class="line">	return worker</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>go worker.update()</code>, <code>go worker.wait()</code>, <code>worker.commitNewWork()</code> 这三行很重要，我们依次来看。</p>
<h3 id="worker-update"><a href="#worker-update" class="headerlink" title="worker.update()"></a>worker.update()</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func (self *worker) update() &#123;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		select &#123;</div><div class="line">		case &lt;-self<span class="selector-class">.chainHeadCh</span>:</div><div class="line">			self.commitNewWork()</div><div class="line">		case ev := &lt;-self<span class="selector-class">.chainSideCh</span>:</div><div class="line">			self<span class="selector-class">.uncleMu</span><span class="selector-class">.Lock</span>()</div><div class="line">			self<span class="selector-class">.possibleUncles</span>[ev<span class="selector-class">.Block</span><span class="selector-class">.Hash</span>()] = ev<span class="selector-class">.Block</span></div><div class="line">			self<span class="selector-class">.uncleMu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		case ev := &lt;-self<span class="selector-class">.txCh</span>:</div><div class="line">			<span class="keyword">if</span> atomic.LoadInt32(&amp;self.mining) == <span class="number">0</span> &#123;</div><div class="line">				self<span class="selector-class">.currentMu</span><span class="selector-class">.Lock</span>()</div><div class="line">				acc, _ := types.Sender(self<span class="selector-class">.current</span><span class="selector-class">.signer</span>, ev.Tx)</div><div class="line">				txs := map[common.Address]types.Transactions&#123;acc: &#123;ev.Tx&#125;&#125;</div><div class="line">				txset := types.NewTransactionsByPriceAndNonce(self<span class="selector-class">.current</span><span class="selector-class">.signer</span>, txs)</div><div class="line"></div><div class="line">				self<span class="selector-class">.current</span><span class="selector-class">.commitTransactions</span>(self<span class="selector-class">.mux</span>, txset, self<span class="selector-class">.chain</span>, self.coinbase)</div><div class="line">				self<span class="selector-class">.currentMu</span><span class="selector-class">.Unlock</span>()</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span> self<span class="selector-class">.config</span><span class="selector-class">.Clique</span> != nil &amp;&amp; self<span class="selector-class">.config</span><span class="selector-class">.Clique</span><span class="selector-class">.Period</span> == <span class="number">0</span> &#123;</div><div class="line">					self.commitNewWork()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>worker.update</code> 会监听 <code>ChainHeadEvent</code>，<code>ChainSideEvent</code>，<code>TxPreEvent</code> 3个事件。通过 <code>chainHeadCh</code>, <code>chainSideCh</code>, <code>txCh</code> 这3个 channel 来实现。<code>ChainHeadEvent</code> 事件指的是区块链中已经加入一个新的区块作为链头，这时候 worker 会开始挖掘下一个区块(在代码库中搜索 ChainHeadEvent，可以在 <code>blockchain.go</code> 中的 L1191 看到该事件是怎么触发的)。<code>ChainSideEvent</code> 指区块链中加入了一个新区块作为当前链头的分支，woker 会把这个区块放在 <code>possibleUncles</code> 数组，作为下一个挖掘区块可能的 Uncle 之一。当一个新的交易 <code>tx</code> 被加入 <code>TxPool</code> 中，会触发 <code>TxPreEvent</code>，如果这时 <code>worker</code> 没有在挖矿，那么开始执行，并把 <code>tx</code> 加入到 <code>Work.txs</code> 数组中，下次挖掘新区块可以使用。 </p>
<h3 id="worker-wait"><a href="#worker-wait" class="headerlink" title="worker.wait()"></a>worker.wait()</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">func (self *worker) wait() &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		mustCommitNewWork := true</div><div class="line">		<span class="keyword">for</span> result := range self<span class="selector-class">.recv</span> &#123;</div><div class="line">			atomic.AddInt32(&amp;self<span class="selector-class">.atWork</span>, -<span class="number">1</span>)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> result == nil &#123;</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			block := result<span class="selector-class">.Block</span></div><div class="line">			work := result<span class="selector-class">.Work</span></div><div class="line"></div><div class="line">			<span class="keyword">for</span> _, r := range work<span class="selector-class">.receipts</span> &#123;</div><div class="line">				<span class="keyword">for</span> _, l := range r<span class="selector-class">.Logs</span> &#123;</div><div class="line">					l<span class="selector-class">.BlockHash</span> = block.Hash()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> _, log := range work<span class="selector-class">.state</span><span class="selector-class">.Logs</span>() &#123;</div><div class="line">				log<span class="selector-class">.BlockHash</span> = block.Hash()</div><div class="line">			&#125;</div><div class="line">			stat, err := self<span class="selector-class">.chain</span><span class="selector-class">.WriteBlockWithState</span>(block, work<span class="selector-class">.receipts</span>, work.state)</div><div class="line">			<span class="keyword">if</span> err != nil &#123;</div><div class="line">				log.Error(<span class="string">"Failed writing block to chain"</span>, <span class="string">"err"</span>, err)</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> stat == core<span class="selector-class">.CanonStatTy</span> &#123;</div><div class="line">				mustCommitNewWork = false</div><div class="line">			&#125;</div><div class="line">			log.Error(<span class="string">"I got new block"</span>)</div><div class="line">			self<span class="selector-class">.mux</span><span class="selector-class">.Post</span>(core.NewMinedBlockEvent&#123;Block: block&#125;)</div><div class="line">			<span class="selector-tag">var</span> (</div><div class="line">				events []interface&#123;&#125;</div><div class="line">				logs   = work<span class="selector-class">.state</span><span class="selector-class">.Logs</span>()</div><div class="line">			)</div><div class="line">			events = append(events, core.ChainEvent&#123;Block: block, Hash: block.Hash(), Logs: logs&#125;)</div><div class="line">			<span class="keyword">if</span> stat == core<span class="selector-class">.CanonStatTy</span> &#123;</div><div class="line">				events = append(events, core.ChainHeadEvent&#123;Block: block&#125;)</div><div class="line">			&#125;</div><div class="line">			self<span class="selector-class">.chain</span><span class="selector-class">.PostChainEvents</span>(events, logs)</div><div class="line"></div><div class="line">			self<span class="selector-class">.unconfirmed</span>.(block.NumberU64(), block.Hash())</div><div class="line"></div><div class="line">			<span class="keyword">if</span> mustCommitNewWork &#123;</div><div class="line">				self.commitNewWork()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>worker.wait</code> 执行挖完一个区块后的操作，通过 Result 这个 chan 实现，agent 完成挖矿后，从 chan 中获取 Block 和 Work 对象，Block 会被写到数据库中，加入本地的区块链，成为新的链头。完成这个操作后，会发送一条 <code>NewMinedBlockEvent</code> 事件，其他节点会决定是否接受这个新区块成为区块链新的链头。</p>
<h3 id="worker-commitNewWork"><a href="#worker-commitNewWork" class="headerlink" title="worker.commitNewWork()"></a>worker.commitNewWork()</h3><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line">func (<span class="built_in">self</span> *worker) commitNewWork() &#123;</div><div class="line">	<span class="built_in">self</span>.mu.Lock()</div><div class="line">	defer <span class="built_in">self</span>.mu.Unlock()</div><div class="line">	<span class="built_in">self</span>.uncleMu.Lock()</div><div class="line">	defer <span class="built_in">self</span>.uncleMu.Unlock()</div><div class="line">	<span class="built_in">self</span>.currentMu.Lock()</div><div class="line">	defer <span class="built_in">self</span>.currentMu.Unlock()</div><div class="line"></div><div class="line">	tstart := time.Now()</div><div class="line">	parent := <span class="built_in">self</span>.chain.CurrentBlock()</div><div class="line"></div><div class="line">	tstamp := tstart.Unix()</div><div class="line">	<span class="keyword">if</span> parent.Time().Cmp(<span class="keyword">new</span>(big.Int).SetInt64(tstamp)) &gt;= <span class="number">0</span> &#123;</div><div class="line">		tstamp = parent.Time().Int64() + <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> now := time.Now().Unix(); tstamp &gt; now+<span class="number">1</span> &#123;</div><div class="line">		wait := time.Duration(tstamp-now) * time.Second</div><div class="line">		<span class="built_in">log</span>.Info(<span class="string">"Mining too far in the future"</span>, <span class="string">"wait"</span>, common.PrettyDuration(wait))</div><div class="line">		time.Sleep(wait)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	num := parent.Number()</div><div class="line">	header := &amp;types.Header&#123;</div><div class="line">		ParentHash: parent.Hash(),</div><div class="line">		Number:     num.Add(num, common.Big1),</div><div class="line">		GasLimit:   core.CalcGasLimit(parent),</div><div class="line">		Extra:      <span class="built_in">self</span>.extra,</div><div class="line">		Time:       big.NewInt(tstamp),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">self</span>.isRunning() &#123;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">self</span>.coinbase == (common.Address&#123;&#125;) &#123;</div><div class="line">			<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Refusing to mine without etherbase"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		header.Coinbase = <span class="built_in">self</span>.coinbase</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := <span class="built_in">self</span>.engine.Prepare(<span class="built_in">self</span>.chain, header); err != nil &#123;</div><div class="line">		<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Failed to prepare header for mining"</span>, <span class="string">"err"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> daoBlock := <span class="built_in">self</span>.config.DAOForkBlock; daoBlock != nil &#123;</div><div class="line">		limit := <span class="keyword">new</span>(big.Int).Add(daoBlock, params.DAOForkExtraRange)</div><div class="line">		<span class="keyword">if</span> header.Number.Cmp(daoBlock) &gt;= <span class="number">0</span> &amp;&amp; header.Number.Cmp(limit) &lt; <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> <span class="built_in">self</span>.config.DAOForkSupport &#123;</div><div class="line">				header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</div><div class="line">				header.Extra = []byte&#123;&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	err := <span class="built_in">self</span>.makeCurrent(parent, header)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Failed to create mining context"</span>, <span class="string">"err"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	env := <span class="built_in">self</span>.current</div><div class="line">	<span class="keyword">if</span> <span class="built_in">self</span>.config.DAOForkSupport &amp;&amp; <span class="built_in">self</span>.config.DAOForkBlock != nil &amp;&amp; <span class="built_in">self</span>.config.DAOForkBlock.Cmp(header.Number) == <span class="number">0</span> &#123;</div><div class="line">		misc.ApplyDAOHardFork(env.state)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		uncles    []*types.Header</div><div class="line">		badUncles []common.Hash</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> hash, uncle := range <span class="built_in">self</span>.possibleUncles &#123;</div><div class="line">		<span class="keyword">if</span> len(uncles) == <span class="number">2</span> &#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := <span class="built_in">self</span>.commitUncle(env, uncle.Header()); err != nil &#123;</div><div class="line">			<span class="built_in">log</span>.Trace(<span class="string">"Bad uncle found and will be removed"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			<span class="built_in">log</span>.Trace(fmt.Sprint(uncle))</div><div class="line"></div><div class="line">			badUncles = append(badUncles, hash)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">log</span>.Debug(<span class="string">"Committing new uncle to block"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			uncles = append(uncles, uncle.Header())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, hash := range badUncles &#123;</div><div class="line">		delete(<span class="built_in">self</span>.possibleUncles, hash)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var (</div><div class="line">		emptyBlock *types.Block</div><div class="line">		fullBlock  *types.Block</div><div class="line">	)</div><div class="line"></div><div class="line">	emptyState := env.state.Copy()</div><div class="line">	<span class="keyword">if</span> emptyBlock, err = <span class="built_in">self</span>.engine.Finalize(<span class="built_in">self</span>.chain, header, emptyState, nil, uncles, nil); err != nil &#123;</div><div class="line">		<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Failed to finalize block for temporary sealing"</span>, <span class="string">"err"</span>, err)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">self</span>.isRunning() &#123;</div><div class="line">			<span class="built_in">log</span>.Info(<span class="string">"Commit new empty mining work"</span>, <span class="string">"number"</span>, emptyBlock.Number(), <span class="string">"uncles"</span>, len(uncles))</div><div class="line">			<span class="built_in">self</span>.push(&amp;Package&#123;nil, emptyState, emptyBlock&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	pending, err := <span class="built_in">self</span>.eth.TxPool().Pending()</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Failed to fetch pending transactions"</span>, <span class="string">"err"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	txs := types.NewTransactionsByPriceAndNonce(<span class="built_in">self</span>.current.signer, pending)</div><div class="line">	env.commitTransactions(<span class="built_in">self</span>.mux, txs, <span class="built_in">self</span>.chain, <span class="built_in">self</span>.coinbase)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> fullBlock, err = <span class="built_in">self</span>.engine.Finalize(<span class="built_in">self</span>.chain, header, env.state, env.txs, uncles, env.receipts); err != nil &#123;</div><div class="line">		<span class="built_in">log</span>.<span class="built_in">Error</span>(<span class="string">"Failed to finalize block for sealing"</span>, <span class="string">"err"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">self</span>.isRunning() &#123;</div><div class="line">		<span class="built_in">log</span>.Info(<span class="string">"Commit new full mining work"</span>, <span class="string">"number"</span>, fullBlock.Number(), <span class="string">"txs"</span>, env.tcount, <span class="string">"uncles"</span>, len(uncles), <span class="string">"elapsed"</span>, common.PrettyDuration(time.Since(tstart)))</div><div class="line">		<span class="built_in">self</span>.unconfirmed.Shift(fullBlock.NumberU64() - <span class="number">1</span>)</div><div class="line">		<span class="built_in">self</span>.push(&amp;Package&#123;env.receipts, env.state, fullBlock&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">self</span>.updateSnapshot()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commitNewWork</code> 的作用是完成待挖掘区块的组装，最后通过 <code>func (self *worker) push(p *Package)</code> 让 agent 开始工作。具体来说，首先获取以系统当前时间作为新区块的时间，但要确保父区块的时间要早于新区块时间，否则进行 sleep 操作；接着构造区块头，确定父区块哈希值，当前区块编号，Gas 消耗数，附加数据，时间等，区块头的其他属性会在公式算法中确定；然后调用 <code>engine.Prepare</code>，准备好 Header 对象；处理 DAO 硬分叉的情况，增加附加数据；再接下来会从交易池里获取交易，加入到新区块的交易列表中，从 <code>possibleUncles</code> 获取叔区块；最后调用一致性引擎的 <code>Finalize()</code> 方法，给区块头增加 <code>Root</code>, <code>TxHash</code>, <code>ReceiptHash</code> 等属性，将创建的 <code>Package</code> 通过 channel 发送给 agent，进行挖矿操作。</p>
<h2 id="consensus-模块"><a href="#consensus-模块" class="headerlink" title="consensus 模块"></a>consensus 模块</h2><p>通过以上的分析，我们了解到 <code>miner/miner.go</code>, <code>miner/worker.go</code> 这几个模块的只是一些对 chan 的创建和订阅，封装挖矿所需数据的操作，真正的挖矿的过程在 <code>agent</code> 里面。<code>miner/worker.go</code> 中定义了 <code>agent</code> 的接口：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Agent</span> interface &#123;</div><div class="line">	<span class="type">Work</span>() chan&lt;- *<span class="type">Work</span></div><div class="line">	<span class="type">SetReturnCh</span>(chan&lt;- *<span class="type">Result</span>)</div><div class="line">	<span class="type">Stop</span>()</div><div class="line">	<span class="type">Start</span>()</div><div class="line">	<span class="type">GetHashRate</span>() int64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实现在 <code>miner/agent.go</code> 中，而 <code>miner/agent.go</code> 的代码实际上是 consensus 模块的封装，我们先来看看 <code>miner/agent.go</code> 的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *CpuAgent)</span></span> <span class="type">Start</span>() &#123;</div><div class="line">	<span class="keyword">if</span> !atomic.<span class="type">CompareAndSwapInt32</span>(&amp;<span class="keyword">self</span>.isMining, <span class="number">0</span>, <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	go <span class="keyword">self</span>.update()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *CpuAgent)</span></span> update() &#123;</div><div class="line">out:</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		select &#123;</div><div class="line">		<span class="keyword">case</span> p := &lt;-<span class="keyword">self</span>.taskCh:</div><div class="line">			<span class="keyword">self</span>.mu.<span class="type">Lock</span>()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">self</span>.quitCurrentOp != <span class="literal">nil</span> &#123;</div><div class="line">				close(<span class="keyword">self</span>.quitCurrentOp)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">self</span>.quitCurrentOp = make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;)</div><div class="line">			go <span class="keyword">self</span>.mine(p, <span class="keyword">self</span>.quitCurrentOp)</div><div class="line">			<span class="keyword">self</span>.mu.<span class="type">Unlock</span>()</div><div class="line">		<span class="keyword">case</span> &lt;-<span class="keyword">self</span>.stop:</div><div class="line">			<span class="keyword">self</span>.mu.<span class="type">Lock</span>()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">self</span>.quitCurrentOp != <span class="literal">nil</span> &#123;</div><div class="line">				close(<span class="keyword">self</span>.quitCurrentOp)</div><div class="line">				<span class="keyword">self</span>.quitCurrentOp = <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">self</span>.mu.<span class="type">Unlock</span>()</div><div class="line">			<span class="keyword">break</span> out</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们提到 <code>commitNewWork</code> 提供挖矿数据的组装，然后通过 <code>func (self *worker) push(p *Package)</code> 将数据写入 <code>update()</code> 的 <code>taskCh</code> 这个 chan 中，<code>CpuAgent</code> 通过这个 chan 拿到 <code>Package</code> 对象，然后调用 <code>self.mine(work, self, quitCurrentOp)</code>，如果收到停止的消息，就退出相关操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">self</span> *CpuAgent)</span></span> mine(work *<span class="type">Work</span>, stop &lt;-chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;) &#123;</div><div class="line">	<span class="keyword">if</span> result, err := <span class="keyword">self</span>.engine.<span class="type">Seal</span>(<span class="keyword">self</span>.chain, work.<span class="type">Block</span>, stop); result != <span class="literal">nil</span> &#123;</div><div class="line">		log.<span class="type">Info</span>(<span class="string">"Successfully sealed new block"</span>, <span class="string">"number"</span>, result.<span class="type">Number</span>(), <span class="string">"hash"</span>, result.<span class="type">Hash</span>())</div><div class="line">		<span class="keyword">self</span>.returnCh &lt;- &amp;<span class="type">Result</span>&#123;work, result&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.<span class="type">Warn</span>(<span class="string">"Block sealing failed"</span>, <span class="string">"err"</span>, err)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">self</span>.returnCh &lt;- <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>mine</code> 方法是 <code>engine.Seal</code> 的简单封装，共识算法会对传入的区块进行真正的挖矿操作，如果成功，<code>Block</code> 和 <code>work</code> 对象会通过 chan 传给 <code>work.wait</code> 进行处理。</p>
<h3 id="共识算法-ethash"><a href="#共识算法-ethash" class="headerlink" title="共识算法 ethash"></a>共识算法 ethash</h3><p>共识算法 Engine 接口的定义在 <code>consensus/consensus.go</code> 中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type Engine interface &#123;</div><div class="line">	Author(<span class="selector-tag">header</span> *types.Header) (common<span class="selector-class">.Address</span>, error)</div><div class="line">	VerifyHeader(chain ChainReader, <span class="selector-tag">header</span> *types<span class="selector-class">.Header</span>, seal bool) error</div><div class="line">	VerifyHeaders(chain ChainReader, headers []*types<span class="selector-class">.Header</span>, seals []bool) (chan&lt;- struct&#123;&#125;, &lt;-chan error)</div><div class="line">	VerifySeal(chain ChainReader, <span class="selector-tag">header</span> *types.Header) error</div><div class="line">	Prepare(chain ChainReader, <span class="selector-tag">header</span> *types.Header) error</div><div class="line">	Finalize(chain ChainReader, <span class="selector-tag">header</span> *types<span class="selector-class">.Header</span>, state *state<span class="selector-class">.StateDB</span>, txs []*types<span class="selector-class">.Transaction</span>,</div><div class="line">		uncles []*types<span class="selector-class">.Header</span>, receipts []*types.Receipt) (*types<span class="selector-class">.Block</span>, error)</div><div class="line">	Seal(chain ChainReader, block *types<span class="selector-class">.Block</span>, stop &lt;-chan struct&#123;&#125;) (*types<span class="selector-class">.Block</span>, error)</div><div class="line">	CalcDifficulty(chain ChainReader, <span class="selector-tag">time</span> uint64, parent *types.Header) *big<span class="selector-class">.Int</span></div><div class="line">	APIs(chain ChainReader) []rpc<span class="selector-class">.API</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有两个实现，一个是 ethash, 一个是 clique，clique 只在测试网络中有使用，这里我们主要讨论 ethash。在公式算法的引擎中，最重要的两个方法大概是 <code>Seal</code> 和 <code>VerifySeal</code>，一个用来挖矿，找到 nonce，一个用来验证挖矿结果，下面我们将讨论 ethash 中的 <code>Seal</code>，<code>VerifySeal</code> 的实现。</p>
<p>最开始我们简述了 Dagger-Hashimoto 算法，然后我们从 CPU 挖矿的入口函数开始，层层剖析，最终发现挖矿的核心逻辑在 consensus 目录下，接下来我们就来看看 CPU 挖矿到底是怎么实现的。</p>
<p>前面说到，挖矿需要一个基于一个数据集，那么我们先来看看数据集是怎么生成的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) dataset(block uint64) *dataset &#123;</div><div class="line">	epoch := block / epochLength</div><div class="line">	currentI, futureI := ethash<span class="selector-class">.datasets</span><span class="selector-class">.get</span>(epoch)</div><div class="line">	current := currentI.(*dataset)</div><div class="line">	current.generate(ethash<span class="selector-class">.config</span><span class="selector-class">.DatasetDir</span>, ethash<span class="selector-class">.config</span><span class="selector-class">.DatasetsOnDisk</span>, ethash<span class="selector-class">.config</span><span class="selector-class">.PowMode</span> == ModeTest)</div><div class="line">	<span class="keyword">if</span> futureI != nil &#123;</div><div class="line">		future := futureI.(*dataset)</div><div class="line">		go future.generate(ethash<span class="selector-class">.config</span><span class="selector-class">.DatasetDir</span>, ethash<span class="selector-class">.config</span><span class="selector-class">.DatasetsOnDisk</span>, ethash<span class="selector-class">.config</span><span class="selector-class">.PowMode</span> == ModeTest)</div><div class="line">	&#125;</div><div class="line">	return current</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>consensus/ethash/ethash.go</code>中，dataset 方法对数据集进行了封装。首先尝试从内存中取得，如果不存在则在文件目录中取得，如果还是不存在则通过 <code>func (d *dataset) generate(dir string, limit int, test bool)</code> 生成。具体来说，首先，我们计算 epoch，前面说到，每 30000 个区块就会换 DAG，这里的 30000 也就是 epochLength，也就是说 epoch 不变的的话，DAG 也不需要变。</p>
<p>先通过 <code>get</code> 尝试从内存中取得 dataset。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func (lru *lru) get(epoch uint64) (item, future interface&#123;&#125;) &#123;</div><div class="line">	lru<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">	defer lru<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">	item, ok := lru<span class="selector-class">.cache</span><span class="selector-class">.Get</span>(epoch)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">if</span> lru<span class="selector-class">.future</span> &gt; <span class="number">0</span> &amp;&amp; lru<span class="selector-class">.future</span> == epoch &#123;</div><div class="line">			item = lru<span class="selector-class">.futureItem</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			log.Trace(<span class="string">"Requiring new ethash "</span>+lru<span class="selector-class">.what</span>, <span class="string">"epoch"</span>, epoch)</div><div class="line">			item = lru.new(epoch)</div><div class="line">		&#125;</div><div class="line">		lru<span class="selector-class">.cache</span><span class="selector-class">.Add</span>(epoch, item)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch-<span class="number">1</span> &amp;&amp; lru<span class="selector-class">.future</span> &lt; epoch+<span class="number">1</span> &#123;</div><div class="line">		log.Trace(<span class="string">"Requiring new future ethash "</span>+lru<span class="selector-class">.what</span>, <span class="string">"epoch"</span>, epoch+<span class="number">1</span>)</div><div class="line">		future = lru.new(epoch + <span class="number">1</span>)</div><div class="line">		lru<span class="selector-class">.future</span> = epoch + <span class="number">1</span></div><div class="line">		lru<span class="selector-class">.futureItem</span> = future</div><div class="line">	&#125;</div><div class="line">	return item, future</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get 方法会返回两个 interface(实际类型为 dataset)，第一个是当前 epoch 对应的 dataset，第二个值是未来会用到的 dataset（epoch +1），如果不为空，表明需要重新生成，如果为空，表明之前已经生成过了。回到 dataset 方法，我们看看 DAG 是怎么通过 <code>generate</code> 方法生成的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dataset)</span> <span class="title">generate</span><span class="params">(dir <span class="keyword">string</span>, limit <span class="keyword">int</span>, test <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">	d.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		csize := cacheSize(d.epoch*epochLength + <span class="number">1</span>)</div><div class="line">		dsize := datasetSize(d.epoch*epochLength + <span class="number">1</span>)</div><div class="line">		seed := seedHash(d.epoch*epochLength + <span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span> test &#123;</div><div class="line">			csize = <span class="number">1024</span></div><div class="line">			dsize = <span class="number">32</span> * <span class="number">1024</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> dir == <span class="string">""</span> &#123;</div><div class="line">			cache := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, csize/<span class="number">4</span>)</div><div class="line">			generateCache(cache, d.epoch, seed)</div><div class="line"></div><div class="line">			d.dataset = <span class="built_in">make</span>([]<span class="keyword">uint32</span>, dsize/<span class="number">4</span>)</div><div class="line">			generateDataset(d.dataset, d.epoch, cache)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">var</span> endian <span class="keyword">string</span></div><div class="line">		<span class="keyword">if</span> !isLittleEndian() &#123;</div><div class="line">			endian = <span class="string">".be"</span></div><div class="line">		&#125;</div><div class="line">		path := filepath.Join(dir, fmt.Sprintf(<span class="string">"full-R%d-%x%s"</span>, algorithmRevision, seed[:<span class="number">8</span>], endian))</div><div class="line">		logger := log.New(<span class="string">"epoch"</span>, d.epoch)</div><div class="line"></div><div class="line">		runtime.SetFinalizer(d, (*dataset).finalizer)</div><div class="line"></div><div class="line">		d.dump, d.mmap, d.dataset, err = memoryMap(path)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			logger.Debug(<span class="string">"Loaded old ethash dataset from disk"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		logger.Debug(<span class="string">"Failed to load old ethash dataset"</span>, <span class="string">"err"</span>, err)</div><div class="line">		cache := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, csize/<span class="number">4</span>)</div><div class="line">		generateCache(cache, d.epoch, seed)</div><div class="line"></div><div class="line">		d.dump, d.mmap, d.dataset, err = memoryMapAndGenerate(path, dsize, <span class="function"><span class="keyword">func</span><span class="params">(buffer []<span class="keyword">uint32</span>)</span></span> &#123; generateDataset(buffer, d.epoch, cache) &#125;)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			logger.Error(<span class="string">"Failed to generate mapped ethash dataset"</span>, <span class="string">"err"</span>, err)</div><div class="line"></div><div class="line">			d.dataset = <span class="built_in">make</span>([]<span class="keyword">uint32</span>, dsize/<span class="number">2</span>)</div><div class="line">			generateDataset(d.dataset, d.epoch, cache)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> ep := <span class="keyword">int</span>(d.epoch) - limit; ep &gt;= <span class="number">0</span>; ep-- &#123;</div><div class="line">			seed := seedHash(<span class="keyword">uint64</span>(ep)*epochLength + <span class="number">1</span>)</div><div class="line">			path := filepath.Join(dir, fmt.Sprintf(<span class="string">"full-R%d-%x%s"</span>, algorithmRevision, seed[:<span class="number">8</span>], endian))</div><div class="line">			os.Remove(path)</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过 <code>csize := cacheSize(d.epoch*epochLength + 1)</code>，<code>dsize := datasetSize(d.epoch*epochLength + 1)</code> 这两个调用得到缓存大小和数据集大小，前面有介绍，这两个大小是根据区块数量线性增长的，深入到这两个方法中，你会发现 <code>cacheSize</code> 调用 <code>calcCacheSize</code> 这样的一层层调用，ethereum 的维基页面里给出的 Python 代码可能更直观一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cache_size</span><span class="params">(block_number)</span>:</span></div><div class="line">    sz = CACHE_BYTES_INIT + CACHE_BYTES_GROWTH * (block_number // EPOCH_LENGTH)</div><div class="line">    sz -= HASH_BYTES</div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isprime(sz / HASH_BYTES):</div><div class="line">        sz -= <span class="number">2</span> * HASH_BYTES</div><div class="line">    <span class="keyword">return</span> sz</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_full_size</span><span class="params">(block_number)</span>:</span></div><div class="line">    sz = DATASET_BYTES_INIT + DATASET_BYTES_GROWTH * (block_number // EPOCH_LENGTH)</div><div class="line">    sz -= MIX_BYTES</div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isprime(sz / MIX_BYTES):</div><div class="line">        sz -= <span class="number">2</span> * MIX_BYTES</div><div class="line">    <span class="keyword">return</span> sz</div></pre></td></tr></table></figure>
<p>前 6140000 个区块的缓存大小和数据集大小已经硬编码在 <code>consensus/ethash/algorithm.go</code> 的 <code>datasetSizes</code> 和 <code>cacheSizes</code> 中，显然这样能加快得到这两个集合的速度。接下来我们通过 <code>seedHash</code> 来生成 seed。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">seedHash</span><span class="params">(block <span class="keyword">uint64</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	seed := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</div><div class="line">	<span class="keyword">if</span> block &lt; epochLength &#123;</div><div class="line">		<span class="keyword">return</span> seed</div><div class="line">	&#125;</div><div class="line">	keccak256 := makeHasher(sha3.NewKeccak256())</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(block/epochLength); i++ &#123;</div><div class="line">		keccak256(seed, seed)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> seed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续看 <code>generate</code> 方法，可以看到，主要逻辑在 <code>generateCache</code>， <code>generateDataset</code> 这两个方法，我们依次来看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateCache</span><span class="params">(dest []<span class="keyword">uint32</span>, epoch <span class="keyword">uint64</span>, seed []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	logger := log.New(<span class="string">"epoch"</span>, epoch)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		elapsed := time.Since(start)</div><div class="line"></div><div class="line">		logFn := logger.Debug</div><div class="line">		<span class="keyword">if</span> elapsed &gt; <span class="number">3</span>*time.Second &#123;</div><div class="line">			logFn = logger.Info</div><div class="line">		&#125;</div><div class="line">		logFn(<span class="string">"Generated ethash verification cache"</span>, <span class="string">"elapsed"</span>, common.PrettyDuration(elapsed))</div><div class="line">	&#125;()</div><div class="line">	header := *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest))</div><div class="line">	header.Len *= <span class="number">4</span></div><div class="line">	header.Cap *= <span class="number">4</span></div><div class="line">	cache := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;header))</div><div class="line"></div><div class="line">	size := <span class="keyword">uint64</span>(<span class="built_in">len</span>(cache))</div><div class="line">	rows := <span class="keyword">int</span>(size) / hashBytes</div><div class="line"></div><div class="line">	<span class="keyword">var</span> progress <span class="keyword">uint32</span></div><div class="line"></div><div class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</div><div class="line">				logger.Info(<span class="string">"Generating ethash verification cache"</span>, <span class="string">"percentage"</span>, atomic.LoadUint32(&amp;progress)*<span class="number">100</span>/<span class="keyword">uint32</span>(rows)/<span class="number">4</span>, <span class="string">"elapsed"</span>, common.PrettyDuration(time.Since(start)))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line"></div><div class="line">	keccak512(cache, seed)</div><div class="line">	<span class="keyword">for</span> offset := <span class="keyword">uint64</span>(hashBytes); offset &lt; size; offset += hashBytes &#123;</div><div class="line">		keccak512(cache[offset:], cache[offset-hashBytes:offset])</div><div class="line">		atomic.AddUint32(&amp;progress, <span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	temp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, hashBytes)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cacheRounds; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; rows; j++ &#123;</div><div class="line">			<span class="keyword">var</span> (</div><div class="line">				srcOff = ((j - <span class="number">1</span> + rows) % rows) * hashBytes</div><div class="line">				dstOff = j * hashBytes</div><div class="line">				xorOff = (binary.LittleEndian.Uint32(cache[dstOff:]) % <span class="keyword">uint32</span>(rows)) * hashBytes</div><div class="line">			)</div><div class="line">			bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBytes], cache[xorOff:xorOff+hashBytes])</div><div class="line">			keccak512(cache[dstOff:], temp)</div><div class="line"></div><div class="line">			atomic.AddUint32(&amp;progress, <span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !isLittleEndian() &#123;</div><div class="line">		swap(cache)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>generateCache</code> 方法会根据 <code>epoch</code>，<code>seed</code> 的值生成 cache。整个过程可以用下面的 Python 代码描述：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkcache</span><span class="params">(cache_size, seed)</span>:</span></div><div class="line">    n = cache_size // HASH_BYTES</div><div class="line">    o = [sha3_512(seed)]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</div><div class="line">        o.append(sha3_512(o[<span class="number">-1</span>]))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(CACHE_ROUNDS):</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            v = o[i][<span class="number">0</span>] % n</div><div class="line">            o[i] = sha3_512(map(xor, o[(i<span class="number">-1</span>+n) % n], o[v]))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o</div></pre></td></tr></table></figure>
<p>生成数据集</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateDataset</span><span class="params">(dest []<span class="keyword">uint32</span>, epoch <span class="keyword">uint64</span>, cache []<span class="keyword">uint32</span>)</span></span> &#123;</div><div class="line">	logger := log.New(<span class="string">"epoch"</span>, epoch)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		elapsed := time.Since(start)</div><div class="line"></div><div class="line">		logFn := logger.Debug</div><div class="line">		<span class="keyword">if</span> elapsed &gt; <span class="number">3</span>*time.Second &#123;</div><div class="line">			logFn = logger.Info</div><div class="line">		&#125;</div><div class="line">		logFn(<span class="string">"Generated ethash verification cache"</span>, <span class="string">"elapsed"</span>, common.PrettyDuration(elapsed))</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	swapped := !isLittleEndian()</div><div class="line"></div><div class="line">	header := *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest))</div><div class="line">	header.Len *= <span class="number">4</span></div><div class="line">	header.Cap *= <span class="number">4</span></div><div class="line">	dataset := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;header))</div><div class="line"></div><div class="line">	threads := runtime.NumCPU()</div><div class="line">	size := <span class="keyword">uint64</span>(<span class="built_in">len</span>(dataset))</div><div class="line"></div><div class="line">	<span class="keyword">var</span> pend sync.WaitGroup</div><div class="line">	pend.Add(threads)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> progress <span class="keyword">uint32</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> pend.Done()</div><div class="line"></div><div class="line">			keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line">			batch := <span class="keyword">uint32</span>((size + hashBytes*<span class="keyword">uint64</span>(threads) - <span class="number">1</span>) / (hashBytes * <span class="keyword">uint64</span>(threads)))</div><div class="line">			first := <span class="keyword">uint32</span>(id) * batch</div><div class="line">			limit := first + batch</div><div class="line">			<span class="keyword">if</span> limit &gt; <span class="keyword">uint32</span>(size/hashBytes) &#123;</div><div class="line">				limit = <span class="keyword">uint32</span>(size / hashBytes)</div><div class="line">			&#125;</div><div class="line">			percent := <span class="keyword">uint32</span>(size / hashBytes / <span class="number">100</span>)</div><div class="line">			<span class="keyword">for</span> index := first; index &lt; limit; index++ &#123;</div><div class="line">				item := generateDatasetItem(cache, index, keccak512)</div><div class="line">				<span class="keyword">if</span> swapped &#123;</div><div class="line">					swap(item)</div><div class="line">				&#125;</div><div class="line">				<span class="built_in">copy</span>(dataset[index*hashBytes:], item)</div><div class="line"></div><div class="line">				<span class="keyword">if</span> status := atomic.AddUint32(&amp;progress, <span class="number">1</span>); status%percent == <span class="number">0</span> &#123;</div><div class="line">					logger.Info(<span class="string">"Generating DAG in progress"</span>, <span class="string">"percentage"</span>, <span class="keyword">uint64</span>(status*<span class="number">100</span>)/(size/hashBytes), <span class="string">"elapsed"</span>, common.PrettyDuration(time.Since(start)))</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	pend.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何生成数据集后，现在我们来看看 ethash 算法是如何根据数据集进行挖矿的。</p>
<p>前面有说到，ethash 的 <code>mine</code> 方法实际上是 <code>engine.Seal</code> 的简单封装。<code>engine.Seal</code> 接口在 <code>consensu/consensus.go</code> 中定义，而实现是在 <code>consensus/ethash/sealer.go</code> 中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Seal</span><span class="params">(chain consensus.ChainReader, block *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*types.Block, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</div><div class="line">		header := block.Header()</div><div class="line">		header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</div><div class="line">		<span class="keyword">return</span> block.WithSeal(header), <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ethash.shared.Seal(chain, block, stop)</div><div class="line">	&#125;</div><div class="line">	abort := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">	found := <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Block)</div><div class="line"></div><div class="line">	ethash.lock.Lock()</div><div class="line">	threads := ethash.threads</div><div class="line">	<span class="keyword">if</span> ethash.rand == <span class="literal">nil</span> &#123;</div><div class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			ethash.lock.Unlock()</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64()))</div><div class="line">	&#125;</div><div class="line">	ethash.lock.Unlock()</div><div class="line">	<span class="keyword">if</span> threads == <span class="number">0</span> &#123;</div><div class="line">		threads = runtime.NumCPU()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> threads &lt; <span class="number">0</span> &#123;</div><div class="line">		threads = <span class="number">0</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> pend sync.WaitGroup</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</div><div class="line">		pend.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, nonce <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> pend.Done()</div><div class="line">			ethash.mine(block, id, nonce, abort, found)</div><div class="line">		&#125;(i, <span class="keyword">uint64</span>(ethash.rand.Int63()))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> result *types.Block</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-stop:</div><div class="line">		<span class="built_in">close</span>(abort)</div><div class="line">	<span class="keyword">case</span> result = &lt;-found:</div><div class="line">		<span class="built_in">close</span>(abort)</div><div class="line">	<span class="keyword">case</span> &lt;-ethash.update:</div><div class="line">		<span class="built_in">close</span>(abort)</div><div class="line">		pend.Wait()</div><div class="line">		<span class="keyword">return</span> ethash.Seal(chain, block, stop)</div><div class="line">	&#125;</div><div class="line">	pend.Wait()</div><div class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 fake 模式，立即返回 0 nonce，这部分是为了方便单元测试。<br>如果是共享 pow，转到它的共享对象执行 seal 操作。<br>接下来通过多个 goroutine 调用 <code>ethash.mine</code>，因此需要上锁，保证缓存的安全。<br><code>Seal</code> 的核心还是在 <code>ethash.mine(block, id, nonce, abort, found)</code> 这一行，不过我们先往后面看。<br><code>seal</code> 最后会监听 <code>stop</code>, <code>found</code>, <code>ethash.update</code> 这几个 channel，如果外部意外终止了，停止所有挖矿线程，如果其中有一个线程挖到正确区块，终止其他线程，如果 ethash 对象发生了变化，停止当前所有操作，重新调用 <code>ethash.Seal</code>。</p>
<p>接下来我们来看看 ethash 的 <code>mine</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">mine</span><span class="params">(block *types.Block, id <span class="keyword">int</span>, seed <span class="keyword">uint64</span>, abort <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, found <span class="keyword">chan</span> *types.Block)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		header  = block.Header()</div><div class="line">		hash    = header.HashNoNonce().Bytes()</div><div class="line">		target  = <span class="built_in">new</span>(big.Int).Div(maxUint256, header.Difficulty)</div><div class="line">		number  = header.Number.Uint64()</div><div class="line">		dataset = ethash.dataset(number)</div><div class="line">	)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		attempts = <span class="keyword">int64</span>(<span class="number">0</span>)</div><div class="line">		nonce    = seed</div><div class="line">	)</div><div class="line">	logger := log.New(<span class="string">"miner"</span>, id)</div><div class="line">	logger.Trace(<span class="string">"Started ethash search for new nonces"</span>, <span class="string">"seed"</span>, seed)</div><div class="line">search:</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-abort:</div><div class="line">			logger.Trace(<span class="string">"Ethash nonce search aborted"</span>, <span class="string">"attempts"</span>, nonce-seed)</div><div class="line">			ethash.hashrate.Mark(attempts)</div><div class="line">			<span class="keyword">break</span> search</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			attempts++</div><div class="line">			<span class="keyword">if</span> (attempts % (<span class="number">1</span> &lt;&lt; <span class="number">15</span>)) == <span class="number">0</span> &#123;</div><div class="line">				ethash.hashrate.Mark(attempts)</div><div class="line">				attempts = <span class="number">0</span></div><div class="line">			&#125;</div><div class="line">			digest, result := hashimotoFull(dataset.dataset, hash, nonce)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">new</span>(big.Int).SetBytes(result).Cmp(target) &lt;= <span class="number">0</span> &#123;</div><div class="line">				header = types.CopyHeader(header)</div><div class="line">				header.Nonce = types.EncodeNonce(nonce)</div><div class="line">				header.MixDigest = common.BytesToHash(digest)</div><div class="line"></div><div class="line">				<span class="keyword">select</span> &#123;</div><div class="line">				<span class="keyword">case</span> found &lt;- block.WithSeal(header):</div><div class="line">					logger.Trace(<span class="string">"Ethash nonce found and reported"</span>, <span class="string">"attempts"</span>, nonce-seed, <span class="string">"nonce"</span>, nonce)</div><div class="line">				<span class="keyword">case</span> &lt;-abort:</div><div class="line">					logger.Trace(<span class="string">"Ethash nonce found but discarded"</span>, <span class="string">"attempts"</span>, nonce-seed, <span class="string">"nonce"</span>, nonce)</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">break</span> search</div><div class="line">			&#125;</div><div class="line">			nonce++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	runtime.KeepAlive(dataset)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是变量的初始化，从区块头部提取一些数据，得到哈希值，目标值等等，注意 <code>target  = new(big.Int).Div(maxUint256, header.Difficulty)</code> 这一行， 难度越高，target 也就越小，也就越难得到正确的结果。接下来 <code>nonse</code> 会初始化为 seed 值，然后进入一个死循环，不断增加 <code>nonce</code> 的值，通过调用 hashimotoFull 算法不断尝试，直到找到正确 <code>nonse</code>，写入到 <code>found</code> 这个 chan 里。</p>
<p>接下来进入到 <code>hashimotoFull</code> 算法中，看看 pow 的核心算法，这部分在 <code>ethash/algorithm.go</code> 文件中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoFull</span><span class="params">(dataset []<span class="keyword">uint32</span>, hash []<span class="keyword">byte</span>, nonce <span class="keyword">uint64</span>)</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123;</div><div class="line">		offset := index * hashWords</div><div class="line">		<span class="keyword">return</span> dataset[offset : offset+hashWords]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hashimoto(hash, nonce, <span class="keyword">uint64</span>(<span class="built_in">len</span>(dataset))*<span class="number">4</span>, lookup)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>hashimotoFull</code> 和 <code>hashimotoLight</code>的区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoLight</span><span class="params">(size <span class="keyword">uint64</span>, cache []<span class="keyword">uint32</span>, hash []<span class="keyword">byte</span>, nonce <span class="keyword">uint64</span>)</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	keccak512 := makeHasher(sha3.NewKeccak512())</div><div class="line"></div><div class="line">	lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123;</div><div class="line">		rawData := generateDatasetItem(cache, index, keccak512)</div><div class="line"></div><div class="line">		data := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="built_in">len</span>(rawData)/<span class="number">4</span>)</div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</div><div class="line">			data[i] = binary.LittleEndian.Uint32(rawData[i*<span class="number">4</span>:])</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> data</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hashimoto(hash, nonce, size, lookup)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>hashimotoLight</code> 的 <code>lookup</code> 函数不需要一个完整的 <code>dataset</code>，只需要一个占存储空间很小的 cache，然后临时生成一个 dataset，而 <code>hashimotoFull</code> 是直接从 dataset 拿到所需数据。因此 <code>hashimotoLight</code> 可以用于轻量级客户端的验证。<code>hashimotoLight</code> 和 <code>hashimotoFull</code> 最终会调用 <code>hashimoto</code>，我们继续分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimoto</span><span class="params">(hash []<span class="keyword">byte</span>, nonce <span class="keyword">uint64</span>, size <span class="keyword">uint64</span>, lookup <span class="keyword">func</span>(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span>) <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	rows := <span class="keyword">uint32</span>(size / mixBytes)</div><div class="line">	seed := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">40</span>)</div><div class="line">	<span class="built_in">copy</span>(seed, hash)</div><div class="line">	binary.LittleEndian.PutUint64(seed[<span class="number">32</span>:], nonce)</div><div class="line">	seed = crypto.Keccak512(seed)</div><div class="line">	seedHead := binary.LittleEndian.Uint32(seed)</div><div class="line">	mix := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, mixBytes/<span class="number">4</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</div><div class="line">		mix[i] = binary.LittleEndian.Uint32(seed[i%<span class="number">16</span>*<span class="number">4</span>:])</div><div class="line">	&#125;</div><div class="line">	temp := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="built_in">len</span>(mix))</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; loopAccesses; i++ &#123;</div><div class="line">		parent := fnv(<span class="keyword">uint32</span>(i)^seedHead, mix[i%<span class="built_in">len</span>(mix)]) % rows</div><div class="line">		<span class="keyword">for</span> j := <span class="keyword">uint32</span>(<span class="number">0</span>); j &lt; mixBytes/hashBytes; j++ &#123;</div><div class="line">			<span class="built_in">copy</span>(temp[j*hashWords:], lookup(<span class="number">2</span>*parent+j))</div><div class="line">		&#125;</div><div class="line">		fnvHash(mix, temp)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i += <span class="number">4</span> &#123;</div><div class="line">		mix[i/<span class="number">4</span>] = fnv(fnv(fnv(mix[i], mix[i+<span class="number">1</span>]), mix[i+<span class="number">2</span>]), mix[i+<span class="number">3</span>])</div><div class="line">	&#125;</div><div class="line">	mix = mix[:<span class="built_in">len</span>(mix)/<span class="number">4</span>]</div><div class="line">	digest := <span class="built_in">make</span>([]<span class="keyword">byte</span>, common.HashLength)</div><div class="line">	<span class="keyword">for</span> i, val := <span class="keyword">range</span> mix &#123;</div><div class="line">		binary.LittleEndian.PutUint32(digest[i*<span class="number">4</span>:], val)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> digest, crypto.Keccak256(<span class="built_in">append</span>(seed, digest...))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法的流程可以概括为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashimoto</span><span class="params">(header, nonce, full_size, dataset_lookup)</span>:</span></div><div class="line">    n = full_size / HASH_BYTES</div><div class="line">    w = MIX_BYTES // WORD_BYTES</div><div class="line">    mixhashes = MIX_BYTES / HASH_BYTES</div><div class="line">    s = sha3_512(header + nonce[::<span class="number">-1</span>])</div><div class="line">    mix = []</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(MIX_BYTES / HASH_BYTES):</div><div class="line">        mix.extend(s)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(ACCESSES):</div><div class="line">        p = fnv(i ^ s[<span class="number">0</span>], mix[i % w]) % (n // mixhashes) * mixhashes</div><div class="line">        newdata = []</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(MIX_BYTES / HASH_BYTES):</div><div class="line">            newdata.extend(dataset_lookup(p + j))</div><div class="line">        mix = map(fnv, mix, newdata)</div><div class="line">    cmix = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(mix), <span class="number">4</span>):</div><div class="line">        cmix.append(fnv(fnv(fnv(mix[i], mix[i+<span class="number">1</span>]), mix[i+<span class="number">2</span>]), mix[i+<span class="number">3</span>]))</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">"mix digest"</span>: serialize_hash(cmix),</div><div class="line">        <span class="string">"result"</span>: serialize_hash(sha3_256(s+cmix))</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其数据流可以用一张图片表示：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/pow_hashimoto.png" alt="hashimoto"></p>
<p>上图摘自 <a href="https://blog.csdn.net/metal1/article/details/79682636" target="_blank" rel="external">[以太坊源代码分析]III. 挖矿和共识算法的奥秘</a> </p>
<p>其流程是（参考以太坊源代码分析]III. 挖矿和共识算法的奥秘的描述）：</p>
<ul>
<li>首先，将 hash 和 nonce 合并成一个40 bytes长的数组，取它的 SHA-512 哈希值取名 seed，长度为64 bytes。</li>
<li>然后，将 <code>seed[]</code> 转化成以 uint32 为元素的数组 <code>mix[]</code>，注意一个 uint32 数等于4 bytes，所以 <code>seed[]</code> 只能转化成16个 uint32 数，而 <code>mix[]</code> 数组长度32，所以此时 <code>mix[]</code> 数组前后各半是等值的。</li>
<li>接着，使用 <code>lookup()</code> 函数。用一个循环，不断调用 <code>lookup()</code> 从外部数据集中取出 uint32 元素类型数组，向 <code>mix[]</code> 数组中混入未知的数据。循环的次数可用参数调节，目前设为64次。每次循环中，变化生成参数 index，从而使得每次调用 <code>lookup()</code> 函数取出的数组都各不相同。这里混入数据的方式是一种类似向量『异或』的操作，来自于 <a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="external">FNV 算法</a>。</li>
<li>待混淆数据完成后，得到一个基本上面目全非的 <code>mix[]</code>，长度为32的 uint32 数组。这时，将其折叠(压缩)成一个长度缩小成原长1/4的uint32数组，折叠的操作方法来自于 FNV 算法。</li>
<li>最后，将折叠后的 <code>mix[]</code> 由长度为8的 uint32 型数组直接转化成一个长度32的 byte 数组，这就是返回值 <code>digest</code>；同时将之前的 <code>seed[]</code> 数组与 <code>digest</code> 合并再取一次 SHA-256 哈希值，得到的长度32的 byte 数组，即返回值 result。</li>
</ul>
<p>经过多次多种哈希运算，<code>hashimoto</code> 返回两个长度均为32的 byte 数组 <code>digest</code> 和 <code>result</code>，前文已提到，在 <code>Ethash</code> 的 <code>mine</code> 方法里，挖矿时需要经过一个死循环，直到找到一个 <code>nonce</code>，使得 <code>hashimoto</code> 返回的 <code>result</code> 和 <code>target</code> 是相等的，这时就表示符合要求，<code>digest</code> 被取 SHA3-256 哈希后也会存到区块头的 <code>MixDigest</code> 字段里，待 <code>Ethash.VerifySeal()</code> 进行验证。</p>
<h3 id="VerifySeal-验证挖矿结果"><a href="#VerifySeal-验证挖矿结果" class="headerlink" title="VerifySeal 验证挖矿结果"></a>VerifySeal 验证挖矿结果</h3><p>谈完挖矿，我们看看如何验证挖矿结果。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func (ethash *Ethash) VerifySeal(chain consensus.ChainReader, <span class="built_in">header</span> *types.<span class="built_in">Header</span>) <span class="built_in">error</span> &#123;</div><div class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</div><div class="line">		<span class="built_in">time</span>.<span class="built_in">Sleep</span>(ethash.fakeDelay)</div><div class="line">		<span class="keyword">if</span> ethash.fakeFail == <span class="built_in">header</span>.Number.Uint64() &#123;</div><div class="line">			<span class="keyword">return</span> errInvalidPoW</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> nil</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> ethash.shared != nil &#123;</div><div class="line">		<span class="keyword">return</span> ethash.shared.VerifySeal(chain, <span class="built_in">header</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">header</span>.Difficulty.Sign() &lt;= <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> errInvalidDifficulty</div><div class="line">	&#125;</div><div class="line">	number := <span class="built_in">header</span>.Number.Uint64()</div><div class="line"></div><div class="line">	cache := ethash.cache(number)</div><div class="line">	size := datasetSize(number)</div><div class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeTest &#123;</div><div class="line">		size = <span class="number">32</span> * <span class="number">1024</span></div><div class="line">	&#125;</div><div class="line">	digest, result := hashimotoLight(size, cache.cache, <span class="built_in">header</span>.HashNoNonce().Bytes(), <span class="built_in">header</span>.Nonce.Uint64())</div><div class="line">	runtime.KeepAlive(cache)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !bytes.Equal(<span class="built_in">header</span>.MixDigest[:], digest) &#123;</div><div class="line">		<span class="keyword">return</span> errInvalidMixDigest</div><div class="line">	&#125;</div><div class="line">	target := <span class="keyword">new</span>(big.Int).Div(maxUint256, <span class="built_in">header</span>.Difficulty)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">new</span>(big.Int).SetBytes(result).Cmp(target) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> errInvalidPoW</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VerifySeal</code> 的核心是 <code>digest, result := hashimotoLight(size, cache.cache, header.HashNoNonce().Bytes(), header.Nonce.Uint64())</code> 这一行，这里不需要一个完整的 <code>dataset</code>，只需要 cache 生成就行了，与挖矿时的区别其实就两点，一，这个 Nonce 是区块头里面的。二，dataset 由 cache 临时生成。计算出 <code>digest</code> 后，与区块头的 <code>MixDigest</code> 进行比较即可。</p>
<h3 id="难度动态调整"><a href="#难度动态调整" class="headerlink" title="难度动态调整"></a>难度动态调整</h3><p>难度可以用来度量挖出一个区块平均需要的运算次数。</p>
<p>前面的<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/#%E4%BB%A5%E5%A4%AA%E5%9D%8A-3" target="_blank" rel="external">博文</a>里有提过以太坊的挖矿难度调整算法。其公式是：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">本区块难度 = 父区块难度 + 难度调整 + 难度炸弹</div><div class="line">难度调整 = 父区块难度 <span class="regexp">//</span> <span class="number">2048</span> * MAX(<span class="number">1</span> - (block_timestamp - parent_timestamp) <span class="regexp">//</span> <span class="number">10</span>, -<span class="number">99</span>)</div><div class="line">难度炸弹 = INT(<span class="number">2</span>**((block_number <span class="regexp">//</span> <span class="number">100000</span>) - <span class="number">2</span>))</div></pre></td></tr></table></figure>
<h2 id="Clique-算法"><a href="#Clique-算法" class="headerlink" title="Clique 算法"></a>Clique 算法</h2><p>Clique 算法只在测试网中使用，有机会再研究。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://medium.com/verifyas/why-dagger-hashimoto-for-ethereum-773f0792a689" target="_blank" rel="external">Why Dagger-Hashimoto for Ethereum?</a></li>
<li><a href="http://www.hashcash.org/" target="_blank" rel="external">hashcash.org</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethash" target="_blank" rel="external">wiki/Ethash</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Ethash-Design-Rationale" target="_blank" rel="external">Ethash Design Rationale</a></li>
<li><a href="http://www.ethdocs.org/en/latest/mining.html" target="_blank" rel="external">ethdocs mining</a></li>
<li><a href="http://ethdoc.cn/mining.html" target="_blank" rel="external">挖矿</a></li>
<li><a href="http://www.askmaclean.com/archives/eth-mining.html" target="_blank" rel="external">eth-mining</a></li>
<li><a href="https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md" target="_blank" rel="external">Dagger-Hashimoto</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" target="_blank" rel="external">Fowler–Noll–Vo hash function</a></li>
<li><a href="https://www.cnblogs.com/Evsward/p/ethash.html" target="_blank" rel="external">以太坊挖矿源码：ethash算法</a></li>
<li><a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="external">FNV Hash</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/projects/14" target="_blank" rel="external">Revamp the miner</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的章节 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（core 模块-区块链操作）&lt;/a&gt; 描述了区块链世界的核心：区块，区块链。我们已经知道区块链可以用来存储交易的数据，也知道了如何在区块链里发起一笔交易，而问题是，往区块链中增加数据应该是一个较困难的操作，按照比特币论文里的说法，即需要一个 PoW（Proof of Work，工作量证明），否则每个人都能轻易往区块链中增加数据，安全性和一致性无法保证。这一点上，以太坊法和比特币类似，尽管略有不同，但大致都需要矿工的角色贡献计算力，完成一个复杂的计算，即找到一个区块的哈希值，验证正确之后才能加入到区块链中。这个过程就叫做挖矿。矿工们去做这件事当然是有一定利益驱使的，每完成一次挖矿，他们就能获得一些以太币奖励。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-交易池）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-交易池）/</id>
    <published>2018-03-10T14:35:04.000Z</published>
    <updated>2018-09-15T02:31:43.401Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们探究了以太坊账户，转账的实现，在文末的时候挖了一个坑，调用了提交转账的 api 后我们就没有再继续往下走了。这一篇我们更进一步，看看交易池是怎么实现的。</p>
<a id="more"></a>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">type TxPool struct &#123;</div><div class="line">	config       TxPoolConfig</div><div class="line">	chainconfig  *params<span class="selector-class">.ChainConfig</span></div><div class="line">	chain        blockChain</div><div class="line">	gasPrice     *big<span class="selector-class">.Int</span></div><div class="line">	txFeed       event<span class="selector-class">.Feed</span></div><div class="line">	scope        event<span class="selector-class">.SubscriptionScope</span></div><div class="line">	chainHeadCh  chan ChainHeadEvent</div><div class="line">	chainHeadSub event<span class="selector-class">.Subscription</span></div><div class="line">	signer       types<span class="selector-class">.Signer</span></div><div class="line">	mu           sync<span class="selector-class">.RWMutex</span></div><div class="line"></div><div class="line">	currentState  *state<span class="selector-class">.StateDB</span></div><div class="line">	pendingState  *state<span class="selector-class">.ManagedState</span></div><div class="line">	currentMaxGas uint64</div><div class="line"></div><div class="line">	locals  *accountSet</div><div class="line">	journal *txJournal</div><div class="line"></div><div class="line">	pending map[common.Address]*txList</div><div class="line">	queue   map[common.Address]*txList</div><div class="line">	beats   map[common.Address]<span class="selector-tag">time</span><span class="selector-class">.Time</span></div><div class="line">	all     *txLookup</div><div class="line">	priced  *txPricedList</div><div class="line"></div><div class="line">	wg sync<span class="selector-class">.WaitGroup</span></div><div class="line">	homestead bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交易池用来存放当前的网络接收到的交易或本地提交的交易，如果已经加入到区块链中会被移除。</p>
<p>下面是重要字段的描述。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">TxPoolConfig 类型，包含了交易池的配置信息，如 PriceLimit，移除交易的最低 GasPrice 限制；PriceBump，替换相同 Nonce 的交易的价格的百分比；AccountSlots，每个账户 pending 的槽位的最小值；GlobalSlots，全局 pending 队列的最大值；AccountQueue，每个账户的 queueing 的槽位的最小值；GlobalQueue，全局 queueing 的最大值；Lifetime，在队列的最长等待时间</td>
</tr>
<tr>
<td style="text-align:center">chainconfig</td>
<td style="text-align:center">区块链的配置</td>
</tr>
<tr>
<td style="text-align:center">gasPrice</td>
<td style="text-align:center">最低的 GasPrice 限制</td>
</tr>
<tr>
<td style="text-align:center">txFeed</td>
<td style="text-align:center">可以通过 txFeed 来订阅 TxPool 的消息</td>
</tr>
<tr>
<td style="text-align:center">chainHeadCh</td>
<td style="text-align:center">可以通过 chainHeadCh 订阅区块头的消息</td>
</tr>
<tr>
<td style="text-align:center">signer</td>
<td style="text-align:center">封装了事务签名处理</td>
</tr>
</tbody>
</table>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">func NewTxPool(<span class="name">config</span> TxPoolConfig, chainconfig *params.ChainConfig, chain blockChain) *TxPool &#123;</div><div class="line">	config = (<span class="name">&amp;config</span>).sanitize()</div><div class="line"></div><div class="line">	pool <span class="symbol">:=</span> <span class="symbol">&amp;TxPool</span>&#123;</div><div class="line">		config:      config,</div><div class="line">		chainconfig: chainconfig,</div><div class="line">		chain:       chain,</div><div class="line">		signer:      types.NewEIP155Signer(<span class="name">chainconfig</span>.ChainID),</div><div class="line">		pending:     make(<span class="name">map</span>[common.Address]*txList),</div><div class="line">		queue:       make(map[common.Address]*txList),</div><div class="line">		beats:       make(<span class="name">map</span>[common.Address]time.Time),</div><div class="line">		all:         newTxLookup(),</div><div class="line">		chainHeadCh: make(<span class="name">chan</span> ChainHeadEvent, chainHeadChanSize),</div><div class="line">		gasPrice:    new(<span class="name">big</span>.Int).SetUint64(<span class="name">config</span>.PriceLimit),</div><div class="line">	&#125;</div><div class="line">	pool.locals = newAccountSet(<span class="name">pool</span>.signer)</div><div class="line">	pool.priced = newTxPricedList(<span class="name">pool</span>.all)</div><div class="line">	pool.reset(<span class="name">nil</span>, chain.CurrentBlock().Header())</div><div class="line"></div><div class="line">	if !config.NoLocals <span class="symbol">&amp;&amp;</span> config.Journal != <span class="string">""</span> &#123;</div><div class="line">		pool.journal = newTxJournal(<span class="name">config</span>.Journal)</div><div class="line"></div><div class="line">		if err <span class="symbol">:=</span> pool.journal.load(<span class="name">pool</span>.AddLocals)<span class="comment">; err != nil &#123;</span></div><div class="line">			log.Warn(<span class="string">"Failed to load transaction journal"</span>, <span class="string">"err"</span>, err)</div><div class="line">		&#125;</div><div class="line">		if err <span class="symbol">:=</span> pool.journal.rotate(<span class="name">pool</span>.local())<span class="comment">; err != nil &#123;</span></div><div class="line">			log.Warn(<span class="string">"Failed to rotate transaction journal"</span>, <span class="string">"err"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(<span class="name">pool</span>.chainHeadCh)</div><div class="line"></div><div class="line">	pool.wg.Add(<span class="number">1</span>)</div><div class="line">	go pool.loop()</div><div class="line"></div><div class="line">	return pool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化交易池后会调用 <code>reset</code> 方法，这个方法会检索区块链当前状态，确保交易池里的内容与区块链状态是匹配的。</p>
<p>在 <code>NewTxPool</code> 方法里，如果本地可以发起交易，并且配置的 Journal 目录不为空，那么从指定的目录加载交易日志。<code>NewTxPool</code> 方法的最后会用一个 goroutine 调用 <code>loop()</code>。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) loop() &#123;</div><div class="line">	<span class="attribute">defer pool.wg.Done()</span></div><div class="line">	var prevPending, prevQueued, prevStales int</div><div class="line"></div><div class="line">	report := time<span class="variable">.NewTicker</span>(statsReportInterval)</div><div class="line">	defer report<span class="variable">.Stop</span>()</div><div class="line"></div><div class="line">	evict := time<span class="variable">.NewTicker</span>(evictionInterval)</div><div class="line">	defer evict<span class="variable">.Stop</span>()</div><div class="line"></div><div class="line">	journal := time<span class="variable">.NewTicker</span>(pool<span class="variable">.config</span><span class="variable">.Rejournal</span>)</div><div class="line">	defer journal<span class="variable">.Stop</span>()</div><div class="line"></div><div class="line">	head := pool<span class="variable">.chain</span><span class="variable">.CurrentBlock</span>()</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case ev := &lt;-pool<span class="variable">.chainHeadCh</span>:</div><div class="line">			if ev<span class="variable">.Block</span> != nil &#123;</div><div class="line">				pool<span class="variable">.mu</span><span class="variable">.Lock</span>()</div><div class="line">				if pool<span class="variable">.chainconfig</span><span class="variable">.IsHomestead</span>(ev<span class="variable">.Block</span><span class="variable">.Number</span>()) &#123;</div><div class="line">					pool<span class="variable">.homestead</span> = true</div><div class="line">				&#125;</div><div class="line">				pool<span class="variable">.reset</span>(head<span class="variable">.Header</span>(), ev<span class="variable">.Block</span><span class="variable">.Header</span>())</div><div class="line">				head = ev<span class="variable">.Block</span></div><div class="line"></div><div class="line">				pool<span class="variable">.mu</span><span class="variable">.Unlock</span>()</div><div class="line">			&#125;</div><div class="line">		case &lt;-pool<span class="variable">.chainHeadSub</span><span class="variable">.Err</span>():</div><div class="line">			return</div><div class="line">		case &lt;-report<span class="variable">.C</span>:</div><div class="line">			pool<span class="variable">.mu</span><span class="variable">.RLock</span>()</div><div class="line">			pending, queued := pool<span class="variable">.stats</span>()</div><div class="line">			stales := pool<span class="variable">.priced</span><span class="variable">.stales</span></div><div class="line">			pool<span class="variable">.mu</span><span class="variable">.RUnlock</span>()</div><div class="line"></div><div class="line">			if pending != prevPending || queued != prevQueued || stales != prevStales &#123;</div><div class="line">				log<span class="variable">.Debug</span>("Transaction pool status report", "executable", pending, "queued", queued, "stales", stales)</div><div class="line">				prevPending, prevQueued, prevStales = pending, queued, stales</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		case &lt;-evict<span class="variable">.C</span>:</div><div class="line">			pool<span class="variable">.mu</span><span class="variable">.Lock</span>()</div><div class="line">			for addr := range pool<span class="variable">.queue</span> &#123;</div><div class="line">				if pool<span class="variable">.locals</span><span class="variable">.contains</span>(addr) &#123;</div><div class="line">					continue</div><div class="line">				&#125;</div><div class="line">				if time<span class="variable">.Since</span>(pool<span class="variable">.beats</span>[addr]) &gt; pool<span class="variable">.config</span><span class="variable">.Lifetime</span> &#123;</div><div class="line">					for _, tx := range pool<span class="variable">.queue</span>[addr]<span class="variable">.Flatten</span>() &#123;</div><div class="line">						pool<span class="variable">.removeTx</span>(tx<span class="variable">.Hash</span>(), true)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			pool<span class="variable">.mu</span><span class="variable">.Unlock</span>()</div><div class="line">		case &lt;-journal<span class="variable">.C</span>:</div><div class="line">			if pool<span class="variable">.journal</span> != nil &#123;</div><div class="line">				pool<span class="variable">.mu</span><span class="variable">.Lock</span>()</div><div class="line">				if err := pool<span class="variable">.journal</span><span class="variable">.rotate</span>(pool<span class="variable">.local</span>()); <span class="attribute">err != nil &#123;</span></div><div class="line">					log.Warn("Failed to rotate local tx journal", "err", err)</div><div class="line">				&#125;</div><div class="line">				pool.mu.Unlock()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loop()</code> 用来接收区块链的事件，负责处理超时的交易和定时写交易日志。</p>
<h3 id="处理交易"><a href="#处理交易" class="headerlink" title="处理交易"></a>处理交易</h3><p>先回顾一下。上一篇谈到，转账时，在 <code>submitTransaction</code> 中会调用 <code>SendTx</code>，<code>SendTx</code> 的实现在 <code>eth/api_backend.go</code> 中。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func (<span class="selector-tag">b</span> *EthApiBackend) SendTx(ctx context<span class="selector-class">.Context</span>, signedTx *types.Transaction) error &#123;</div><div class="line">	return <span class="selector-tag">b</span><span class="selector-class">.eth</span><span class="selector-class">.txPool</span><span class="selector-class">.AddLocal</span>(signedTx)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>AddLocal</code> 方法在 <code>core/tx_pool.go</code> 中：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">AddLocal</span><span class="params">(tx *types.Transaction)</span> <span class="title">error</span> &#123;</span></div><div class="line">	<span class="keyword">return</span> pool.addTx(tx, !pool.config.NoLocals)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续看 <code>addTx</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">addTx</span><span class="params">(tx *types.Transaction, local <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	pool.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> pool.mu.Unlock()</div><div class="line">	replace, err := pool.add(tx, local)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !replace &#123;</div><div class="line">		from, _ := types.Sender(pool.signer, tx)</div><div class="line">		pool.promoteExecutables([]common.Address&#123;from&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addTx</code> 将交易放入交易池中，<code>pool.add(tx, local)</code> 会返回一个 bool 类型，如果为 <code>true</code>，则表明这笔交易合法并且交易之前不存在于交易池，这时候调用 <code>promoteExecutables</code>，可以将可处理的交易变成待处理。所以说，交易池的交易大致分为两种，一种是提交了但还不能执行的，放在 queue 里等待能够被执行（比如 nonce 太高），还有就是等待执行的，放在 pending 里面等待执行。我们会分别探讨 <code>pool.add(tx, local)</code> 和 <code>pool.promoteExecutables</code> 这两个方法如何处理这两种交易。</p>
<h4 id="pool-add-tx-local"><a href="#pool-add-tx-local" class="headerlink" title="pool.add(tx, local)"></a><code>pool.add(tx, local)</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">add</span><span class="params">(tx *types.Transaction, local <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">	hash := tx.Hash()</div><div class="line">	<span class="keyword">if</span> pool.all[hash] != <span class="literal">nil</span> &#123;</div><div class="line">		log.Trace(<span class="string">"Discarding already known transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"known transaction: %x"</span>, hash)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := pool.validateTx(tx, local); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Trace(<span class="string">"Discarding invalid transaction"</span>, <span class="string">"hash"</span>, hash, <span class="string">"err"</span>, err)</div><div class="line">		invalidTxCounter.Inc(<span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">uint64</span>(<span class="built_in">len</span>(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</div><div class="line">		<span class="keyword">if</span> pool.priced.Underpriced(tx, pool.locals) &#123;</div><div class="line">			log.Trace(<span class="string">"Discarding underpriced transaction"</span>, <span class="string">"hash"</span>, hash, <span class="string">"price"</span>, tx.GasPrice())</div><div class="line">			underpricedTxCounter.Inc(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, ErrUnderpriced</div><div class="line">		&#125;</div><div class="line">		drop := pool.priced.Discard(<span class="built_in">len</span>(pool.all)-<span class="keyword">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue<span class="number">-1</span>), pool.locals)</div><div class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</div><div class="line">			log.Trace(<span class="string">"Discarding freshly underpriced transaction"</span>, <span class="string">"hash"</span>, tx.Hash(), <span class="string">"price"</span>, tx.GasPrice())</div><div class="line">			underpricedTxCounter.Inc(<span class="number">1</span>)</div><div class="line">			pool.removeTx(tx.Hash(), <span class="literal">false</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	from, _ := types.Sender(pool.signer, tx)</div><div class="line">	<span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</div><div class="line">		inserted, old := list.Add(tx, pool.config.PriceBump)</div><div class="line">		<span class="keyword">if</span> !inserted &#123;</div><div class="line">			pendingDiscardCounter.Inc(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">delete</span>(pool.all, old.Hash())</div><div class="line">			pool.priced.Removed()</div><div class="line">			pendingReplaceCounter.Inc(<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		pool.all[tx.Hash()] = tx</div><div class="line">		pool.priced.Put(tx)</div><div class="line">		pool.journalTx(from, tx)</div><div class="line">		log.Trace(<span class="string">"Pooled new executable transaction"</span>, <span class="string">"hash"</span>, hash, <span class="string">"from"</span>, from, <span class="string">"to"</span>, tx.To())</div><div class="line">		<span class="keyword">go</span> pool.txFeed.Send(TxPreEvent&#123;tx&#125;)</div><div class="line"></div><div class="line">		<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	replace, err := pool.enqueueTx(hash, tx)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> local &#123;</div><div class="line">		pool.locals.add(from)</div><div class="line">	&#125;</div><div class="line">	pool.journalTx(from, tx)</div><div class="line">	log.Trace(<span class="string">"Pooled new future transaction"</span>, <span class="string">"hash"</span>, hash, <span class="string">"from"</span>, from, <span class="string">"to"</span>, tx.To())</div><div class="line">	<span class="keyword">return</span> replace, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，根据交易哈希值，确定交易池中是否已经有这笔交易，如果有，则退出。接下来调用 <code>validateTx</code> 验证交易是否合法。</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func (pool *TxPool) validateTx(tx *types.Transaction, <span class="keyword">local</span> bool) <span class="built_in">error</span> &#123;</div><div class="line">	<span class="keyword">if</span> tx.Size() &gt; <span class="number">32</span>*<span class="number">1024</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrOversizedData</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> tx.Value().Sign() &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrNegativeValue</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> pool.currentMaxGas &lt; tx.Gas() &#123;</div><div class="line">		<span class="keyword">return</span> ErrGasLimit</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">from</span>, err := types.Sender(pool.signer, tx)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrInvalidSender</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">local</span> = <span class="keyword">local</span> || pool.locals.contains(<span class="keyword">from</span>)</div><div class="line">	<span class="keyword">if</span> !<span class="keyword">local</span> &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrUnderpriced</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> pool.currentState.GetNonce(<span class="keyword">from</span>) &gt; tx.Nonce() &#123;</div><div class="line">		<span class="keyword">return</span> ErrNonceTooLow</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> pool.currentState.GetBalance(<span class="keyword">from</span>).Cmp(tx.Cost()) &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrInsufficientFunds</div><div class="line">	&#125;</div><div class="line">	intrGas, err := IntrinsicGas(tx.Data(), tx.To() == <span class="literal">nil</span>, pool.homestead)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> tx.Gas() &lt; intrGas &#123;</div><div class="line">		<span class="keyword">return</span> ErrIntrinsicGas</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>validateTx</code> 有很多使用 if 语句的条件判断，大致会有如下判断：</p>
<ul>
<li>拒绝大于 32kb 的交易，防止 DDoS 攻击</li>
<li>拒绝转账金额小于0的交易</li>
<li>拒绝 gas 超过交易池 gas 上限的交易</li>
<li>验证这笔交易的签名是否合法</li>
<li>如果交易不是来自本地的，并且 gas 小于当前交易池中的 gas，拒绝这笔交易</li>
<li>当前用户 nonce 如果大于这笔交易的 nonce，拒绝这笔交易</li>
<li>当前账户余额不足，拒绝这笔交易，queue 和 pending 对应账户的交易会被删除</li>
<li>拒绝当前交易固有花费小于交易池 gas 的交易</li>
</ul>
<p>判断交易合法后，回到 <code>add</code> 方法，接着判断交易池的容量，如果交易池超过容量了，并且这笔交易的费用低于当前交易池中列表的最小值，拒绝这笔交易；如果这笔交易费用比当前交易池列表最小值高，那么从交易池中移除交易费用最低的交易，为这笔新交易腾出空间，也就是说按照 GasPrice 排出优先级。接着通过调用 <code>Overlaps</code> 通过检查这笔交易的 Nonce 值确认该用户是否已经存在这笔交易，如果已经存在，删除之前的交易，将该交易放入交易池，返回；如果不存在，调用 <code>enqueueTx</code> 将交易放入交易池，如果交易是本地发出的，将发送者保存在交易池的 local 中。注意到 <code>add</code> 方法最后会调用 <code>pool.journalTx(from, tx)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Warn(<span class="string">"Failed to journal local transaction"</span>, <span class="string">"err"</span>, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本地的交易会使用 journal 的功能存在磁盘，节点重启后可以重写导入。</p>
<h4 id="pool-promoteExecutables"><a href="#pool-promoteExecutables" class="headerlink" title="pool.promoteExecutables"></a><code>pool.promoteExecutables</code></h4><p><code>pool.add(tx, local)</code> 方法探讨完了，我们看看 <code>promoteExecutables</code> 方法，该方法的作用是将所有可以处理的交易放入 pending 区，并且移除所有非法交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">promoteExecutables</span><span class="params">(accounts []common.Address)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> accounts == <span class="literal">nil</span> &#123;</div><div class="line">		accounts = <span class="built_in">make</span>([]common.Address, <span class="number">0</span>, <span class="built_in">len</span>(pool.queue))</div><div class="line">		<span class="keyword">for</span> addr := <span class="keyword">range</span> pool.queue &#123;</div><div class="line">			accounts = <span class="built_in">append</span>(accounts, addr)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> accounts &#123;</div><div class="line">		list := pool.queue[addr]</div><div class="line">		<span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Forward(pool.currentState.GetNonce(addr)) &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(<span class="string">"Removed old queued transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			<span class="built_in">delete</span>(pool.all, hash)</div><div class="line">			pool.priced.Removed()</div><div class="line">		&#125;</div><div class="line">		drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</div><div class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(<span class="string">"Removed unpayable queued transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			<span class="built_in">delete</span>(pool.all, hash)</div><div class="line">			pool.priced.Removed()</div><div class="line">			queuedNofundsCounter.Inc(<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Ready(pool.pendingState.GetNonce(addr)) &#123;</div><div class="line">			hash := tx.Hash()</div><div class="line">			log.Trace(<span class="string">"Promoting queued transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			pool.promoteTx(addr, hash, tx)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !pool.locals.contains(addr) &#123;</div><div class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Cap(<span class="keyword">int</span>(pool.config.AccountQueue)) &#123;</div><div class="line">				hash := tx.Hash()</div><div class="line">				<span class="built_in">delete</span>(pool.all, hash)</div><div class="line">				pool.priced.Removed()</div><div class="line">				queuedRateLimitCounter.Inc(<span class="number">1</span>)</div><div class="line">				log.Trace(<span class="string">"Removed cap-exceeding queued transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> list.Empty() &#123;</div><div class="line">			<span class="built_in">delete</span>(pool.queue, addr)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	pending := <span class="keyword">uint64</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span> _, list := <span class="keyword">range</span> pool.pending &#123;</div><div class="line">		pending += <span class="keyword">uint64</span>(list.Len())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> pending &gt; pool.config.GlobalSlots &#123;</div><div class="line">		pendingBeforeCap := pending</div><div class="line">		spammers := prque.New()</div><div class="line">		<span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</div><div class="line">			<span class="keyword">if</span> !pool.locals.contains(addr) &amp;&amp; <span class="keyword">uint64</span>(list.Len()) &gt; pool.config.AccountSlots &#123;</div><div class="line">				spammers.Push(addr, <span class="keyword">float32</span>(list.Len()))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		offenders := []common.Address&#123;&#125;</div><div class="line">		<span class="keyword">for</span> pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() &#123;</div><div class="line">			offender, _ := spammers.Pop()</div><div class="line">			offenders = <span class="built_in">append</span>(offenders, offender.(common.Address))</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(offenders) &gt; <span class="number">1</span> &#123;</div><div class="line">				threshold := pool.pending[offender.(common.Address)].Len()</div><div class="line"></div><div class="line">				<span class="keyword">for</span> pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[<span class="built_in">len</span>(offenders)<span class="number">-2</span>]].Len() &gt; threshold &#123;</div><div class="line">					<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(offenders)<span class="number">-1</span>; i++ &#123;</div><div class="line">						list := pool.pending[offenders[i]]</div><div class="line">						<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Cap(list.Len() - <span class="number">1</span>) &#123;</div><div class="line">							hash := tx.Hash()</div><div class="line">							<span class="built_in">delete</span>(pool.all, hash)</div><div class="line">							pool.priced.Removed()</div><div class="line">							<span class="keyword">if</span> nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce &#123;</div><div class="line">								pool.pendingState.SetNonce(offenders[i], nonce)</div><div class="line">							&#125;</div><div class="line">							log.Trace(<span class="string">"Removed fairness-exceeding pending transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">						&#125;</div><div class="line">						pending--</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> pending &gt; pool.config.GlobalSlots &amp;&amp; <span class="built_in">len</span>(offenders) &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">for</span> pending &gt; pool.config.GlobalSlots &amp;&amp; <span class="keyword">uint64</span>(pool.pending[offenders[<span class="built_in">len</span>(offenders)<span class="number">-1</span>]].Len()) &gt; pool.config.AccountSlots &#123;</div><div class="line">				<span class="keyword">for</span> _, addr := <span class="keyword">range</span> offenders &#123;</div><div class="line">					list := pool.pending[addr]</div><div class="line">					<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Cap(list.Len() - <span class="number">1</span>) &#123;</div><div class="line">						hash := tx.Hash()</div><div class="line">						<span class="built_in">delete</span>(pool.all, hash)</div><div class="line">						pool.priced.Removed()</div><div class="line">						<span class="keyword">if</span> nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce &#123;</div><div class="line">							pool.pendingState.SetNonce(addr, nonce)</div><div class="line">						&#125;</div><div class="line">						log.Trace(<span class="string">"Removed fairness-exceeding pending transaction"</span>, <span class="string">"hash"</span>, hash)</div><div class="line">					&#125;</div><div class="line">					pending--</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		pendingRateLimitCounter.Inc(<span class="keyword">int64</span>(pendingBeforeCap - pending))</div><div class="line">	&#125;</div><div class="line">	queued := <span class="keyword">uint64</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span> _, list := <span class="keyword">range</span> pool.queue &#123;</div><div class="line">		queued += <span class="keyword">uint64</span>(list.Len())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> queued &gt; pool.config.GlobalQueue &#123;</div><div class="line">		addresses := <span class="built_in">make</span>(addresssByHeartbeat, <span class="number">0</span>, <span class="built_in">len</span>(pool.queue))</div><div class="line">		<span class="keyword">for</span> addr := <span class="keyword">range</span> pool.queue &#123;</div><div class="line">			<span class="keyword">if</span> !pool.locals.contains(addr) &#123;</div><div class="line">				addresses = <span class="built_in">append</span>(addresses, addressByHeartbeat&#123;addr, pool.beats[addr]&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sort.Sort(addresses)</div><div class="line">		<span class="keyword">for</span> drop := queued - pool.config.GlobalQueue; drop &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span>; &#123;</div><div class="line">			addr := addresses[<span class="built_in">len</span>(addresses)<span class="number">-1</span>]</div><div class="line">			list := pool.queue[addr.address]</div><div class="line"></div><div class="line">			addresses = addresses[:<span class="built_in">len</span>(addresses)<span class="number">-1</span>]</div><div class="line">			<span class="keyword">if</span> size := <span class="keyword">uint64</span>(list.Len()); size &lt;= drop &#123;</div><div class="line">				<span class="keyword">for</span> _, tx := <span class="keyword">range</span> list.Flatten() &#123;</div><div class="line">					pool.removeTx(tx.Hash(), <span class="literal">true</span>)</div><div class="line">				&#125;</div><div class="line">				drop -= size</div><div class="line">				queuedRateLimitCounter.Inc(<span class="keyword">int64</span>(size))</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			txs := list.Flatten()</div><div class="line">			<span class="keyword">for</span> i := <span class="built_in">len</span>(txs) - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; drop &gt; <span class="number">0</span>; i-- &#123;</div><div class="line">				pool.removeTx(txs[i].Hash(), <span class="literal">true</span>)</div><div class="line">				drop--</div><div class="line">				queuedRateLimitCounter.Inc(<span class="number">1</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先遍历所有当前账户交易，通过 <code>list.Forward</code> 方法迭代当前账户，检查 nonce，如果 nonce 太低，删除该交易。接着通过 <code>list.Filter</code> 方法检查余额不足或 gas 不足的交易，删除不满足的交易。这时得到的所有可执行的交易，通过调用 <code>promoteTx</code> 加入到 <code>pending</code> 里，接着移除超过了限制的交易。对于已经加入到 <code>promoted</code> 的交易，调用 <code>pool.txFeed.Send</code> 将消息发给订阅者，在 eth 协议里，这个交易会被广播出去。</p>
<p>经过上面的处理，<code>pending</code> 的数量可能会超过系统配置的数量，这时需要进行一些处理，移除一些交易。</p>
<p><code>pending</code> 处理完后，继续处理 future queue，队列里的数量也可能会超过 <code>GlobalQueue</code> 里的数量，根据心跳时间排列所有交易，移除最旧的交易。</p>
<h3 id="tx-list-go"><a href="#tx-list-go" class="headerlink" title="tx_list.go"></a>tx_list.go</h3><p>前文中有很多地方用到 txList 这个结构体里的方法，这些方法都在 <code>core/tx_list.go</code> 里，算是交易池的工具箱了，代码也有一些参考价值，所以分出一个独立的小节，选几个典型的方法讲解。</p>
<h4 id="nonceHeap"><a href="#nonceHeap" class="headerlink" title="nonceHeap"></a>nonceHeap</h4><p>我们在上文中知道维护交易池在很多情况下都需要一个根据 nonce 值排序的优先级队列，如果用堆来实现优先级队列，插入，删除的性能是 $O(log n)$，在 Golang 中，<code>container/heap</code> 包定义了堆的接口：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type <span class="keyword">Interface</span> <span class="keyword">interface</span> &#123;  </div><div class="line">    <span class="keyword">sort</span>.<span class="keyword">Interface</span>  </div><div class="line">    <span class="keyword">Push</span>(x <span class="keyword">interface</span>&#123;&#125;)</div><div class="line">    <span class="keyword">Pop</span>() <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>sort.Interface</code> 为：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Interface <span class="keyword">interface</span> &#123;</div><div class="line">	Len() <span class="function"><span class="keyword">int</span></span></div><div class="line">	<span class="title">Less</span>(<span class="params">i, j <span class="keyword">int</span></span>) <span class="keyword">bool</span></div><div class="line">	<span class="title">Swap</span>(<span class="params">i, j <span class="keyword">int</span></span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要实现 <code>Len</code>，<code>Less</code>，<code>Swap</code>，<code>Push</code>，<code>Pop</code> 这几个接口就可以实现堆。<code>nonceHeap</code> 实现了一个以 <code>nonce</code> 为基准的堆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> nonceHeap []<span class="keyword">uint64</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h nonceHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h nonceHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h nonceHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *nonceHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">uint64</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *nonceHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">	old := *h</div><div class="line">	n := <span class="built_in">len</span>(old)</div><div class="line">	x := old[n<span class="number">-1</span>]</div><div class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</div><div class="line">	<span class="keyword">return</span> x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="txSortedMap"><a href="#txSortedMap" class="headerlink" title="txSortedMap"></a>txSortedMap</h4><p><code>txSortedMap</code> 用来存储同一个账户下的所有交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> txSortedMap <span class="keyword">struct</span> &#123;</div><div class="line">	items <span class="keyword">map</span>[<span class="keyword">uint64</span>]*types.Transaction</div><div class="line">	index *nonceHeap</div><div class="line">	cache types.Transactions</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTxSortedMap</span><span class="params">()</span> *<span class="title">txSortedMap</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;txSortedMap&#123;</div><div class="line">		items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]*types.Transaction),</div><div class="line">		index: <span class="built_in">new</span>(nonceHeap),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>items</code> 是交易数据的 hash map，以 nonce 为索引，<code>index</code> 是以 <code>nonce</code> 为基准的优先级队列，<code>cache</code> 用来缓存已经排好序的交易。</p>
<h5 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *txSortedMap)</span> <span class="title">Get</span><span class="params">(nonce <span class="keyword">uint64</span>)</span> *<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> m.items[nonce]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Get 方法获取指定 nonce 的交易。</p>
<h5 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Put(tx *types.Transaction) &#123;</div><div class="line">	nonce := tx.Nonce()</div><div class="line">	<span class="keyword">if</span> m<span class="selector-class">.items</span>[nonce] == nil &#123;</div><div class="line">		heap.Push(m<span class="selector-class">.index</span>, nonce)</div><div class="line">	&#125;</div><div class="line">	m<span class="selector-class">.items</span>[nonce], m<span class="selector-class">.cache</span> = tx, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Put</code> 方法将交易插入到 map 中，同时更新 items。 </p>
<h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Forward(threshold uint64) types<span class="selector-class">.Transactions</span> &#123;</div><div class="line">	<span class="selector-tag">var</span> removed types<span class="selector-class">.Transactions</span></div><div class="line">	<span class="keyword">for</span> m<span class="selector-class">.index</span><span class="selector-class">.Len</span>() &gt; <span class="number">0</span> &amp;&amp; (*m.index)[<span class="number">0</span>] &lt; threshold &#123;</div><div class="line">		nonce := heap.Pop(m.index).(uint64)</div><div class="line">		removed = append(removed, m<span class="selector-class">.items</span>[nonce])</div><div class="line">		delete(m<span class="selector-class">.items</span>, nonce)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> m<span class="selector-class">.cache</span> != nil &#123;</div><div class="line">		m<span class="selector-class">.cache</span> = m<span class="selector-class">.cache</span>[len(removed):]</div><div class="line">	&#125;</div><div class="line">	return removed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Forward</code> 可以用来删除所有 <code>nonce</code> 小于 <code>threshold</code> 的交易，返回的是所有被移除的交易。</p>
<h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *txSortedMap)</span> <span class="title">Filter</span><span class="params">(filter <span class="keyword">func</span>(*types.Transaction)</span> <span class="title">bool</span>) <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> removed types.Transactions</div><div class="line"></div><div class="line">	<span class="keyword">for</span> nonce, tx := <span class="keyword">range</span> m.items &#123;</div><div class="line">		<span class="keyword">if</span> filter(tx) &#123;</div><div class="line">			removed = <span class="built_in">append</span>(removed, tx)</div><div class="line">			<span class="built_in">delete</span>(m.items, nonce)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(removed) &gt; <span class="number">0</span> &#123;</div><div class="line">		*m.index = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="number">0</span>, <span class="built_in">len</span>(m.items))</div><div class="line">		<span class="keyword">for</span> nonce := <span class="keyword">range</span> m.items &#123;</div><div class="line">			*m.index = <span class="built_in">append</span>(*m.index, nonce)</div><div class="line">		&#125;</div><div class="line">		heap.Init(m.index)</div><div class="line"></div><div class="line">		m.cache = <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> removed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 接收 <code>filter</code> 函数，删除所有使得 <code>filter</code> 函数调用返回 <code>true</code> 的交易，返回这些被移除的交易。</p>
<h5 id="Cap"><a href="#Cap" class="headerlink" title="Cap"></a>Cap</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *txSortedMap)</span> <span class="title">Cap</span><span class="params">(threshold <span class="keyword">int</span>)</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.items) &lt;= threshold &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> drops types.Transactions</div><div class="line"></div><div class="line">	sort.Sort(*m.index)</div><div class="line">	<span class="keyword">for</span> size := <span class="built_in">len</span>(m.items); size &gt; threshold; size-- &#123;</div><div class="line">		drops = <span class="built_in">append</span>(drops, m.items[(*m.index)[size<span class="number">-1</span>]])</div><div class="line">		<span class="built_in">delete</span>(m.items, (*m.index)[size<span class="number">-1</span>])</div><div class="line">	&#125;</div><div class="line">	*m.index = (*m.index)[:threshold]</div><div class="line">	heap.Init(m.index)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.cache != <span class="literal">nil</span> &#123;</div><div class="line">		m.cache = m.cache[:<span class="built_in">len</span>(m.cache)-<span class="built_in">len</span>(drops)]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> drops</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Cap</code> 根据 <code>threshold</code> 参数对 items 参数进行限制，删除超出的交易，重建堆，返回这些被移除的交易。</p>
<h5 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *txSortedMap)</span> <span class="title">Remove</span><span class="params">(nonce <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	_, ok := m.items[nonce]</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.index.Len(); i++ &#123;</div><div class="line">		<span class="keyword">if</span> (*m.index)[i] == nonce &#123;</div><div class="line">			heap.Remove(m.index, i)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">delete</span>(m.items, nonce)</div><div class="line">	m.cache = <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>nonce</code> 从堆里移除交易，如果没有这个交易返回 <code>false</code>。</p>
<h5 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *txSortedMap)</span> <span class="title">Ready</span><span class="params">(start <span class="keyword">uint64</span>)</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> m.index.Len() == <span class="number">0</span> || (*m.index)[<span class="number">0</span>] &gt; start &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> ready types.Transactions</div><div class="line">	<span class="keyword">for</span> next := (*m.index)[<span class="number">0</span>]; m.index.Len() &gt; <span class="number">0</span> &amp;&amp; (*m.index)[<span class="number">0</span>] == next; next++ &#123;</div><div class="line">		ready = <span class="built_in">append</span>(ready, m.items[next])</div><div class="line">		<span class="built_in">delete</span>(m.items, next)</div><div class="line">		heap.Pop(m.index)</div><div class="line">	&#125;</div><div class="line">	m.cache = <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> ready</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Ready</code> 返回从指定 <code>nonce</code> 开始，连续的交易。</p>
<h5 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (m *txSortedMap) Flatten() types<span class="selector-class">.Transactions</span> &#123;</div><div class="line">	<span class="keyword">if</span> m<span class="selector-class">.cache</span> == nil &#123;</div><div class="line">		m<span class="selector-class">.cache</span> = make(types<span class="selector-class">.Transactions</span>, <span class="number">0</span>, len(m.items))</div><div class="line">		<span class="keyword">for</span> _, tx := range m<span class="selector-class">.items</span> &#123;</div><div class="line">			m<span class="selector-class">.cache</span> = append(m<span class="selector-class">.cache</span>, tx)</div><div class="line">		&#125;</div><div class="line">		sort.Sort(types.TxByNonce(m.cache))</div><div class="line">	&#125;</div><div class="line">	txs := make(types<span class="selector-class">.Transactions</span>, len(m.cache))</div><div class="line">	copy(txs, m.cache)</div><div class="line">	return txs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个基于 <code>nonce</code> 排序的交易列表，缓存到 <code>cache</code> 字段里。</p>
<h4 id="txList"><a href="#txList" class="headerlink" title="txList"></a>txList</h4><p><code>txList</code> 用来存储连续的可执行的交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> txList <span class="keyword">struct</span> &#123;</div><div class="line">	strict <span class="keyword">bool</span></div><div class="line">	txs    *txSortedMap</div><div class="line"></div><div class="line">	costcap *big.Int</div><div class="line">	gascap  <span class="keyword">uint64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTxList</span><span class="params">(strict <span class="keyword">bool</span>)</span> *<span class="title">txList</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;txList&#123;</div><div class="line">		strict:  strict,</div><div class="line">		txs:     newTxSortedMap(),</div><div class="line">		costcap: <span class="built_in">new</span>(big.Int),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func (l *txList) Add(tx *types.Transaction, priceBump uint64) (bool, *types.Transaction) &#123;</div><div class="line">	old := l.txs.Get(tx.Nonce())</div><div class="line">	<span class="keyword">if</span> old != nil &#123;</div><div class="line">		threshold := <span class="keyword">new</span>(big.Int).Div(<span class="keyword">new</span>(big.Int).Mul(old.GasPrice(), big.NewInt(100+int64(priceBump))), big.NewInt(100))</div><div class="line">		<span class="keyword">if</span> old.GasPrice().Cmp(tx.GasPrice()) &gt;= 0 || threshold.Cmp(tx.GasPrice()) &gt; 0 &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	l.txs.Put(tx)</div><div class="line">	<span class="keyword">if</span> cost := tx.Cost(); l.costcap.Cmp(cost) &lt; <span class="number">0</span> &#123;</div><div class="line">		l.costcap = cost</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> gas := tx.Gas(); l.gascap &lt; gas &#123;</div><div class="line">		l.gascap = gas</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>, old</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Add</code> 方法会尝试插入一个交易，如果新的交易比老的交易的 GasPrice 值高出一定的数量，则会替换老的交易。 </p>
<h5 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Filter</span><span class="params">(costLimit *big.Int, gasLimit <span class="keyword">uint64</span>)</span> <span class="params">(types.Transactions, types.Transactions)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> l.costcap.Cmp(costLimit) &lt;= <span class="number">0</span> &amp;&amp; l.gascap &lt;= gasLimit &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	l.costcap = <span class="built_in">new</span>(big.Int).Set(costLimit)</div><div class="line">	l.gascap = gasLimit</div><div class="line"></div><div class="line">	removed := l.txs.Filter(<span class="function"><span class="keyword">func</span><span class="params">(tx *types.Transaction)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> tx.Cost().Cmp(costLimit) &gt; <span class="number">0</span> || tx.Gas() &gt; gasLimit &#125;)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> invalids types.Transactions</div><div class="line"></div><div class="line">	<span class="keyword">if</span> l.strict &amp;&amp; <span class="built_in">len</span>(removed) &gt; <span class="number">0</span> &#123;</div><div class="line">		lowest := <span class="keyword">uint64</span>(math.MaxUint64)</div><div class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> removed &#123;</div><div class="line">			<span class="keyword">if</span> nonce := tx.Nonce(); lowest &gt; nonce &#123;</div><div class="line">				lowest = nonce</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		invalids = l.txs.Filter(<span class="function"><span class="keyword">func</span><span class="params">(tx *types.Transaction)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> tx.Nonce() &gt; lowest &#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> removed, invalids</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Filter</code> 方法根据参数 <code>cost</code> 或 <code>gasLimit</code> 的值移除所有比该值更高的交易，被移除的交易会返回以便进一步处理。</p>
<h5 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Remove</span><span class="params">(tx *types.Transaction)</span> <span class="params">(<span class="keyword">bool</span>, types.Transactions)</span></span> &#123;</div><div class="line">	nonce := tx.Nonce()</div><div class="line">	<span class="keyword">if</span> removed := l.txs.Remove(nonce); !removed &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> l.strict &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, l.txs.Filter(<span class="function"><span class="keyword">func</span><span class="params">(tx *types.Transaction)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> tx.Nonce() &gt; nonce &#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除给定 <code>Nonce</code> 的交易，如果是严格模式，删除所有 <code>nonce</code> 大于给定 <code>Nonce</code> 的交易。</p>
<h5 id="Overlaps-Forward-Cap-Ready-Empty-Empty-Flatten"><a href="#Overlaps-Forward-Cap-Ready-Empty-Empty-Flatten" class="headerlink" title="Overlaps, Forward, Cap, Ready, Empty, Empty, Flatten"></a>Overlaps, Forward, Cap, Ready, Empty, Empty, Flatten</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Overlaps</span><span class="params">(tx *types.Transaction)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Get(tx.Nonce()) != <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Forward</span><span class="params">(threshold <span class="keyword">uint64</span>)</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Forward(threshold)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Cap</span><span class="params">(threshold <span class="keyword">int</span>)</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Cap(threshold)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Ready</span><span class="params">(start <span class="keyword">uint64</span>)</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Ready(start)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Len()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.Len() == <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *txList)</span> <span class="title">Flatten</span><span class="params">()</span> <span class="title">types</span>.<span class="title">Transactions</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> l.txs.Flatten()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Overlaps</code>, <code>Forward</code>, <code>Cap</code>, <code>Ready</code>, <code>Empty</code>, <code>Empty</code>, <code>Flatten</code> 直接调用 <code>txSortedMap</code> 的对应方法。</p>
<h4 id="priceHeap"><a href="#priceHeap" class="headerlink" title="priceHeap"></a>priceHeap</h4><p><code>priceHeap</code> 类似于上面提到的 <code>nonceHeap</code>，不过比较优先级时，优先比较 <code>GasPrice</code>，如果相同则比较 <code>Nonce</code>。这里不再赘述</p>
<h4 id="txPricedList"><a href="#txPricedList" class="headerlink" title="txPricedList"></a>txPricedList</h4><p><code>txPricedList</code> 类似于上面提到的 <code>txList</code>，其中有 <code>Put</code>, <code>Removed</code>, <code>Cap</code>, <code>Underpriced</code>, <code>Discard</code> 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是交易池的主要逻辑，在提交交易之后，数据会通过 geth 的 p2p 系统广播出去，接下来就等矿工进行挖矿了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97" target="_blank" rel="external">优先队列</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们探究了以太坊账户，转账的实现，在文末的时候挖了一个坑，调用了提交转账的 api 后我们就没有再继续往下走了。这一篇我们更进一步，看看交易池是怎么实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88accounts,%20transaction%20%E6%A8%A1%E5%9D%97-%E8%B4%A6%E6%88%B7%E5%92%8C%E8%BD%AC%E8%B4%A6%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）/</id>
    <published>2018-03-10T14:35:03.000Z</published>
    <updated>2018-09-10T00:38:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇分析 <code>geth</code> 中与账户和转账相关的源代码。</p>
<p>交易是以太坊里的一个很核心的概念，它不仅仅体现在价值的转移上。我们知道智能合约是以太坊的一个重大创新，而智能合约的执行是依靠交易来触发的，可以这么说，在以太坊中，大部分场景的状态转换都依靠交易实现，而交易又与账户紧密相关，所以这一篇我们将账户，转账这两个模块结合在一起来探讨。<br><a id="more"></a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>以太坊引入账户状态概念取代比特币 UTXO 模型。账户以地址为索引，地址是公钥的最后20字节。</p>
<p>以太坊中有两类账户，一类是外部账户，一类是合约账户。每个账户都有一个与之关联的账户状态和一个10字节地址，都可以用来存储以太币。</p>
<ul>
<li>外部账户（EOA）：由人创建，用私钥控制，没有代码与之关联，地址由公钥决定。私钥可用于对交易签名从而主动向其他账户发起交易进行消息传递。</li>
<li>合约账户：外部账户创建，由合约代码控制，有代码与之关联，其地址由合约创造者地址和该地址发出过的交易数量 nonce 共同决定。不能主动向其他账户发起交易，但可以『响应』其他账户进行消息调用。</li>
</ul>
<h3 id="生成外部账户"><a href="#生成外部账户" class="headerlink" title="生成外部账户"></a>生成外部账户</h3><p>生成一个账户地址大致是3步：</p>
<ol>
<li>设置账户秘钥（根据用户密码等信息）</li>
<li>通过 secp256k1 椭圆曲线密码算法，由私钥生成对应的公钥</li>
<li>根据公钥得到相应的账户地址</li>
</ol>
<h3 id="私钥的三种形态"><a href="#私钥的三种形态" class="headerlink" title="私钥的三种形态"></a>私钥的三种形态</h3><ul>
<li>Private Key，随机生成的256位二进制数字</li>
<li>Keystore &amp; Password，私钥和公钥以加密的方式保存一份 JSON 文件，存在 keystore 子目录下，这份 JSON 文件就是 Keystore，用户需要保存 Keystore，以及创建钱包时设置的密码。</li>
<li>Memonic code，由 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="external">bip 39</a> 提出，随机生成12~24个比较容易记住的单词，通过 PBKDF2 和 HMAC-SHA512 函数创建随机种子，再生成钱包。</li>
</ul>
<h3 id="外部账户和合约账户的区别"><a href="#外部账户和合约账户的区别" class="headerlink" title="外部账户和合约账户的区别"></a>外部账户和合约账户的区别</h3><p>外部账户可以通过创建以及用自己的私钥对交易进行签名，来发送消息给另一个外部账户或合约账户，在两个外部账户之间传送的消息只是一个简单的价值转移，但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作(包括转移代币，写入内部存储，挖出新代币，执行运算，创建一个新合约等)。合约账户不能自己发起交易，它只能在接收到一个消息（可以来自外部账户或合约账户）之后，为响应该消息触发一个交易。</p>
<h3 id="交易相关的基本概念"><a href="#交易相关的基本概念" class="headerlink" title="交易相关的基本概念"></a>交易相关的基本概念</h3><p>交易是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它可以是以太币的转账，也可以是包含智能合约代码的消息。</p>
<p>交易有3种类型。</p>
<ol>
<li>转账交易，从一个账户向另一个账户发送以太币</li>
<li>创建智能合约的交易，将合约部署到区块链上。</li>
<li>执行智能合约，执行已经部署在区块链上的智能合约。</li>
</ol>
<h3 id="转账流程"><a href="#转账流程" class="headerlink" title="转账流程"></a>转账流程</h3><ul>
<li>用户输入转出的地址，转入的地址和转出的金额</li>
<li>系统通过转出地址私钥对转账信息进行签名，以确保这笔交易是本人进行的</li>
<li>系统对交易信息进行确认</li>
<li>将交易加入到本地交易池</li>
<li>将交易信息广播到其他节点</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="账户（在-accounts-accounts-go-中定义）"><a href="#账户（在-accounts-accounts-go-中定义）" class="headerlink" title="账户（在 accounts/accounts.go 中定义）"></a>账户（在 accounts/accounts.go 中定义）</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Account</span> struct &#123;</div><div class="line">	<span class="type">Address</span> common.<span class="type">Address</span> `json:"address"`</div><div class="line">	<span class="type">URL</span>     <span class="type">URL</span>            `json:"url"`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交易相关的数据结构"><a href="#交易相关的数据结构" class="headerlink" title="交易相关的数据结构"></a>交易相关的数据结构</h3><p>交易的数据结构在 <code>core/types/transaction.go</code> 中定义。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">type Transaction struct &#123;</div><div class="line">	data txdata</div><div class="line">	hash atomic.Value</div><div class="line">	size atomic.Value</div><div class="line">	from atomic.Value</div><div class="line">&#125;</div><div class="line"></div><div class="line">type txdata struct &#123;</div><div class="line">	AccountNonce uint64          `<span class="string">json:</span><span class="string">"nonce"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Price        *big.Int        `<span class="string">json:</span><span class="string">"gasPrice"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	GasLimit     uint64          `<span class="string">json:</span><span class="string">"gas"</span>      <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Recipient    *common.Address `<span class="string">json:</span><span class="string">"to"</span>       <span class="string">rlp:</span><span class="string">"nil"</span>`</div><div class="line">	Amount       *big.Int        `<span class="string">json:</span><span class="string">"value"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Payload      []<span class="keyword">byte</span>          `<span class="string">json:</span><span class="string">"input"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	V *big.Int `<span class="string">json:</span><span class="string">"v"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	R *big.Int `<span class="string">json:</span><span class="string">"r"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	S *big.Int `<span class="string">json:</span><span class="string">"s"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Hash *common.Hash `<span class="string">json:</span><span class="string">"hash"</span> <span class="string">rlp:</span><span class="string">"-"</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Transaction</code> 结构体中，实际上只有一个 <code>data</code> 是有效字段，另外3个 <code>hash</code>, <code>size</code>, <code>from</code> 是用做缓存的。<code>txdata</code> 结构体中没有交易发送者，因为发起者可以通过签名数据获得。<code>txdata</code> 结构体其他字段的含义可以在下表中查看：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>AccountNonce</td>
<td>交易发送者已经发送交易的次数</td>
</tr>
<tr>
<td>Price</td>
<td>该交易的 gas 费用</td>
</tr>
<tr>
<td>GasLimit</td>
<td>本次交易允许消耗 gas 的最大数量</td>
</tr>
<tr>
<td>Recipient</td>
<td>交易接收者</td>
</tr>
<tr>
<td>Amount</td>
<td>交易的以太坊数量</td>
</tr>
<tr>
<td>Payload</td>
<td>交易携带的数据</td>
</tr>
<tr>
<td>V, R, S</td>
<td>交易的签名数据</td>
</tr>
</tbody>
</table>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p><code>accounts</code> 模块实现以太坊客户端钱包，账户管理。智能合约的 ABI 代码也在 <code>accounts/abi</code> 目录下。钱包的接口在 <code>accounts/accounts.go</code> 中定义，目前有两种该接口实现，一个是 keyStore，一个是 usbwallet。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Wallet</span> interface &#123;</div><div class="line">	<span class="type">URL</span>() <span class="type">URL</span></div><div class="line">	<span class="type">Status</span>() (string, error)</div><div class="line">	<span class="type">Open</span>(passphrase string) error</div><div class="line">	<span class="type">Close</span>() error</div><div class="line">	<span class="type">Accounts</span>() []<span class="type">Account</span></div><div class="line">	<span class="type">Contains</span>(account <span class="type">Account</span>) bool</div><div class="line">	<span class="type">Derive</span>(path <span class="type">DerivationPath</span>, pin bool) (<span class="type">Account</span>, error)</div><div class="line">	<span class="type">SelfDerive</span>(base <span class="type">DerivationPath</span>, chain ethereum.<span class="type">ChainStateReader</span>)</div><div class="line">	<span class="type">SignHash</span>(account <span class="type">Account</span>, hash []byte) ([]byte, error)</div><div class="line">	<span class="type">SignTx</span>(account <span class="type">Account</span>, tx *types.<span class="type">Transaction</span>, chainID *big.<span class="type">Int</span>) (*types.<span class="type">Transaction</span>, error)</div><div class="line">	<span class="type">SignHashWithPassphrase</span>(account <span class="type">Account</span>, passphrase string, hash []byte) ([]byte, error)</div><div class="line">	<span class="type">SignTxWithPassphrase</span>(account <span class="type">Account</span>, passphrase string, tx *types.<span class="type">Transaction</span>, chainID *big.<span class="type">Int</span>) (*types.<span class="type">Transaction</span>, error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL()</td>
<td>获取钱包可以访问的规范路径。它会被用来给所有的后端钱包进行排序</td>
</tr>
<tr>
<td>Status() (string, error)</td>
<td>返回一个文本值标识当前钱包状态，同时返回一个 error 标识钱包遇到的任何错误。</td>
</tr>
<tr>
<td>Open(passphrase string) error</td>
<td>初始化对钱包实例的访问。</td>
</tr>
<tr>
<td>Close() error</td>
<td>释放由 Open 方法占用的任何资源</td>
</tr>
<tr>
<td>Accounts() []Account</td>
<td>获取钱包中签名的账户</td>
</tr>
<tr>
<td>Contains(account Account) bool</td>
<td>判断一个账户是否属于本钱包</td>
</tr>
<tr>
<td>Derive(path DerivationPath, pin bool) (Account, error)</td>
<td>尝试在指定派生路径上派生出分层确定性账户，如果 pin 为 true，派生账户添加到钱包的跟踪账户列表中。</td>
</tr>
<tr>
<td>SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)</td>
<td>设置一个基本账户导出路径，从中钱包尝试发现非零账户，自动将其添加到跟踪账户列表中。</td>
</tr>
<tr>
<td>SignHash(account Account, hash []byte) ([]byte, error)</td>
<td>钱包需要额外验证才能签名时使用这个接口。</td>
</tr>
<tr>
<td>SignTx(account Account, tx <em>types.Transaction, chainID </em>big.Int) (*types.Transaction, error)</td>
<td>请求钱包对指定交易进行签名。</td>
</tr>
<tr>
<td>SignHashWithPassphrase(account Account, passphrase string, hash []byte) ([]byte, error)</td>
<td>请求钱包使用指定的 passphrase 给给定 hash 签名</td>
</tr>
<tr>
<td>SignTxWithPassphrase(account Account, passphrase string, tx <em>types.Transaction, chainID </em>big.Int) (*types.Transaction, error)</td>
<td>请求钱包使用给定 passphrase 给给定 transaction 签名。</td>
</tr>
</tbody>
</table>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Backend</span> interface &#123;</div><div class="line">	<span class="type">Wallets</span>() []<span class="type">Wallet</span></div><div class="line">	<span class="type">Subscribe</span>(sink chan&lt;- <span class="type">WalletEvent</span>) event.<span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Backend</code> 接口是一个钱包 provider，它包含一个钱包列表，在检测到钱包开启或关闭时可以接收到通知，可以用来请求签名交易。其中 <code>Wallets()</code> 返回当前可用的钱包，按字母顺序排序，<code>Subscribe()</code> 创建异步订阅的方法，当钱包发生变动时通过 chan 接收消息。</p>
<p>在 <code>accounts/manager.go</code> 中，定义了 <code>Manager</code> 结构体。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">Manager</span> struct &#123;</div><div class="line">	backends map[reflect.<span class="type">Type</span>][]<span class="type">Backend</span></div><div class="line">	updaters []event.<span class="type">Subscription</span></div><div class="line">	updates  chan <span class="type">WalletEvent</span></div><div class="line">	wallets  []<span class="type">Wallet</span></div><div class="line">	feed event.<span class="type">Feed</span></div><div class="line">	quit chan chan error</div><div class="line">	lock sync.<span class="type">RWMutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Manager</code> 是管理账户的入口，可以与各种 <code>backends</code> 进行通信。</p>
<p>其中 <code>backends</code> 是当前已注册的所有 <code>Backend</code>，<code>updaters</code> 是所有 <code>Backend</code> 的更新订阅器，<code>updates</code> 是 <code>Backend</code> 对应 <code>wallet</code> 事件更新的 chan，<code>wallets</code> 是所有已经注册的 <code>Backends</code> 的钱包的缓存，<code>feed</code> 用于钱包事件的通知，<code>quit</code> 用于退出的事件。<code>manager.go</code> 的代码没有什么很特别的地方，有兴趣的话可以自行查看源代码，这里只做概述。这里只挑几个典型的，下面讲解业务实例时会用到的方法。</p>
<h3 id="NewManager"><a href="#NewManager" class="headerlink" title="NewManager"></a><code>NewManager</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(backends ...Backend)</span> *<span class="title">Manager</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> wallets []Wallet</div><div class="line">	<span class="keyword">for</span> _, backend := <span class="keyword">range</span> backends &#123;</div><div class="line">		wallets = merge(wallets, backend.Wallets()...)</div><div class="line">	&#125;</div><div class="line">	updates := <span class="built_in">make</span>(<span class="keyword">chan</span> WalletEvent, <span class="number">4</span>*<span class="built_in">len</span>(backends))</div><div class="line"></div><div class="line">	subs := <span class="built_in">make</span>([]event.Subscription, <span class="built_in">len</span>(backends))</div><div class="line">	<span class="keyword">for</span> i, backend := <span class="keyword">range</span> backends &#123;</div><div class="line">		subs[i] = backend.Subscribe(updates)</div><div class="line">	&#125;</div><div class="line">	am := &amp;Manager&#123;</div><div class="line">		backends: <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type][]Backend),</div><div class="line">		updaters: subs,</div><div class="line">		updates:  updates,</div><div class="line">		wallets:  wallets,</div><div class="line">		quit:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, backend := <span class="keyword">range</span> backends &#123;</div><div class="line">		kind := reflect.TypeOf(backend)</div><div class="line">		am.backends[kind] = <span class="built_in">append</span>(am.backends[kind], backend)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> am.update()</div><div class="line">	<span class="keyword">return</span> am</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewManager</code> 会将所有 <code>backends</code> 的 wallets 收集起来，获取所有的 <code>backends</code> 的时间订阅，然后根据这些参数创建新的 <code>manager</code>。</p>
<h3 id="update"><a href="#update" class="headerlink" title="update()"></a><code>update()</code></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func (am *Manager) update() &#123;</div><div class="line">	defer func() &#123;</div><div class="line">		am<span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</div><div class="line">		<span class="keyword">for</span> _, sub := range am<span class="selector-class">.updaters</span> &#123;</div><div class="line">			sub.Unsubscribe()</div><div class="line">		&#125;</div><div class="line">		am<span class="selector-class">.updaters</span> = nil</div><div class="line">		am<span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		select &#123;</div><div class="line">		case event := &lt;-am<span class="selector-class">.updates</span>:</div><div class="line">			am<span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</div><div class="line">			switch event<span class="selector-class">.Kind</span> &#123;</div><div class="line">			case WalletArrived:</div><div class="line">				am<span class="selector-class">.wallets</span> = merge(am<span class="selector-class">.wallets</span>, event.Wallet)</div><div class="line">			case WalletDropped:</div><div class="line">				am<span class="selector-class">.wallets</span> = drop(am<span class="selector-class">.wallets</span>, event.Wallet)</div><div class="line">			&#125;</div><div class="line">			am<span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</div><div class="line"></div><div class="line">			am<span class="selector-class">.feed</span><span class="selector-class">.Send</span>(event)</div><div class="line"></div><div class="line">		case errc := &lt;-am<span class="selector-class">.quit</span>:</div><div class="line">			errc &lt;- nil</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>update</code>在 <code>NewManager</code> 作为一个 <code>goroutine</code> 被调用，一直运行，监控所有 backend 触发的更新消息，发给 feed 用来进行进一步的处理。</p>
<h3 id="Subscribe-sink-chan-lt-WalletEvent-event-Subscription"><a href="#Subscribe-sink-chan-lt-WalletEvent-event-Subscription" class="headerlink" title="Subscribe(sink chan&lt;- WalletEvent) event.Subscription"></a><code>Subscribe(sink chan&lt;- WalletEvent) event.Subscription</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *Manager)</span> <span class="title">Subscribe</span><span class="params">(sink <span class="keyword">chan</span>&lt;- WalletEvent)</span> <span class="title">event</span>.<span class="title">Subscription</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> am.feed.Subscribe(sink)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个异步的消息订阅对象，当钱包发生变动时可以收到信息。</p>
<h3 id="Find-account-Account-Wallet-error"><a href="#Find-account-Account-Wallet-error" class="headerlink" title="Find(account Account) (Wallet, error)"></a><code>Find(account Account) (Wallet, error)</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *Manager)</span> <span class="title">Find</span><span class="params">(account Account)</span> <span class="params">(Wallet, error)</span></span> &#123;</div><div class="line">	am.lock.RLock()</div><div class="line">	<span class="keyword">defer</span> am.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, wallet := <span class="keyword">range</span> am.wallets &#123;</div><div class="line">		<span class="keyword">if</span> wallet.Contains(account) &#123;</div><div class="line">			<span class="keyword">return</span> wallet, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, ErrUnknownAccount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Find</code> 方法会对钱包进行遍历，找到某个账户的钱包，由于钱包中的账户是动态的增加或删除的，所以我们需要加锁。</p>
<h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>如果是通过命令行创建账户，可以使用 <code>geth account new</code> 命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accountCreate</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	cfg := gethConfig&#123;Node: defaultNodeConfig()&#125;</div><div class="line">	<span class="keyword">if</span> file := ctx.GlobalString(configFileFlag.Name); file != <span class="string">""</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := loadConfig(file, &amp;cfg); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	scryptN, scryptP, keydir, err := cfg.Node.AccountConfig()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read configuration: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	password := getPassPhrase(<span class="string">"Your new account is locked with a password. Please give a password. Do not forget this password."</span>, <span class="literal">true</span>, <span class="number">0</span>, utils.MakePasswordList(ctx))</div><div class="line">	address, err := keystore.StoreKey(keydir, password, scryptN, scryptP)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to create account: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Address: &#123;%x&#125;\n"</span>, address)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑很简单。首先获取配置信息，通过 <code>getPassPhrase</code> 获取密码后，通过 <code>keystore.StoreKey</code> 获得账户地址。</p>
<p>在 <code>internal/ethapi/api.go</code> 中，也可以通过 <code>NewAccount</code> 获取新账户，这个 api 可以通过交互式命令行或 rpc 接口调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">NewAccount</span><span class="params">(password <span class="keyword">string</span>)</span> <span class="params">(common.Address, error)</span></span> &#123;</div><div class="line">	acc, err := fetchKeystore(s.am).NewAccount(password)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> acc.Address, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> common.Address&#123;&#125;, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先调用 <code>fetchKeystore</code>，通过 <code>backends</code> 获得 <code>KeyStore</code> 对象，最后通过调用 <code>keystore.go</code> 中的 <code>NewAccount</code> 获得新账户。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ks *KeyStore)</span> <span class="title">NewAccount</span><span class="params">(passphrase <span class="keyword">string</span>)</span> <span class="params">(accounts.Account, error)</span></span> &#123;</div><div class="line">	_, account, err := storeNewKey(ks.storage, crand.Reader, passphrase)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> accounts.Account&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	ks.cache.add(account)</div><div class="line">	ks.refreshWallets()</div><div class="line">	<span class="keyword">return</span> account, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewAccount</code> 会调用 <code>storeNewKey</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeNewKey</span><span class="params">(ks keyStore, rand io.Reader, auth <span class="keyword">string</span>)</span> <span class="params">(*Key, accounts.Account, error)</span></span> &#123;</div><div class="line">	key, err := newKey(rand)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, accounts.Account&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	a := accounts.Account&#123;Address: key.Address, URL: accounts.URL&#123;Scheme: KeyStoreScheme, Path: ks.JoinPath(keyFileName(key.Address))&#125;&#125;</div><div class="line">	<span class="keyword">if</span> err := ks.StoreKey(a.URL.Path, key, auth); err != <span class="literal">nil</span> &#123;</div><div class="line">		zeroKey(key.PrivateKey)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, a, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> key, a, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意第一个参数是 <code>keyStore</code>，这是一个接口类型。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> keyStore interface &#123;</div><div class="line">	GetKey(addr common.Address, filename <span class="keyword">string</span>, auth <span class="keyword">string</span>) (*<span class="built_in">Key</span>, <span class="built_in">error</span>)</div><div class="line">	StoreKey(filename <span class="keyword">string</span>, k *<span class="built_in">Key</span>, auth <span class="keyword">string</span>) <span class="built_in">error</span></div><div class="line">	JoinPath(filename <span class="keyword">string</span>) <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>storeNewKey</code> 首先调用 <code>newKey</code>，通过椭圆曲线加密算法获取公私钥对。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newKey</span><span class="params">(rand io.Reader)</span> <span class="params">(*Key, error)</span></span> &#123;</div><div class="line">	privateKeyECDSA, err := ecdsa.GenerateKey(crypto.S256(), rand)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> newKeyFromECDSA(privateKeyECDSA), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后会根据参数 ks 的类型调用对应的实现，通过 <code>geth account new</code> 命令创建新账户，调用的就是 <code>accounts/keystore/keystore_passphrase.go</code> 中的实现。即 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ks keyStorePassphrase)</span> <span class="title">StoreKey</span><span class="params">(filename <span class="keyword">string</span>, key *Key, auth <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	keyjson, err := EncryptKey(key, auth, ks.scryptN, ks.scryptP)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> writeKeyFile(filename, keyjson)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以深入到 <code>EncryptKey</code> 中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptKey</span><span class="params">(key *Key, auth <span class="keyword">string</span>, scryptN, scryptP <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	authArray := []<span class="keyword">byte</span>(auth)</div><div class="line">	salt := randentropy.GetEntropyCSPRNG(<span class="number">32</span>)</div><div class="line">	derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptR, scryptP, scryptDKLen)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	encryptKey := derivedKey[:<span class="number">16</span>]</div><div class="line">	keyBytes := math.PaddedBigBytes(key.PrivateKey.D, <span class="number">32</span>)</div><div class="line"></div><div class="line">	iv := randentropy.GetEntropyCSPRNG(aes.BlockSize) <span class="comment">// 16</span></div><div class="line">	cipherText, err := aesCTRXOR(encryptKey, keyBytes, iv)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	mac := crypto.Keccak256(derivedKey[<span class="number">16</span>:<span class="number">32</span>], cipherText)</div><div class="line"></div><div class="line">	scryptParamsJSON := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</div><div class="line">	scryptParamsJSON[<span class="string">"n"</span>] = scryptN</div><div class="line">	scryptParamsJSON[<span class="string">"r"</span>] = scryptR</div><div class="line">	scryptParamsJSON[<span class="string">"p"</span>] = scryptP</div><div class="line">	scryptParamsJSON[<span class="string">"dklen"</span>] = scryptDKLen</div><div class="line">	scryptParamsJSON[<span class="string">"salt"</span>] = hex.EncodeToString(salt)</div><div class="line"></div><div class="line">	cipherParamsJSON := cipherparamsJSON&#123;</div><div class="line">		IV: hex.EncodeToString(iv),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cryptoStruct := cryptoJSON&#123;</div><div class="line">		Cipher:       <span class="string">"aes-128-ctr"</span>,</div><div class="line">		CipherText:   hex.EncodeToString(cipherText),</div><div class="line">		CipherParams: cipherParamsJSON,</div><div class="line">		KDF:          keyHeaderKDF,</div><div class="line">		KDFParams:    scryptParamsJSON,</div><div class="line">		MAC:          hex.EncodeToString(mac),</div><div class="line">	&#125;</div><div class="line">	encryptedKeyJSONV3 := encryptedKeyJSONV3&#123;</div><div class="line">		hex.EncodeToString(key.Address[:]),</div><div class="line">		cryptoStruct,</div><div class="line">		key.Id.String(),</div><div class="line">		version,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> json.Marshal(encryptedKeyJSONV3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>EncryptKey</code> 的 key 参数是加密的账户，包括 ID，公私钥，地址，auth 参数是用户输入的密码，<code>scryptN</code> 参数是 scrypt 算法中的 N，<code>scryptP</code> 参数是 scrypt 算法中的 P。整个过程，首先对密码使用 scrypt 算法加密，得到加密后的密码 derivedKey，然后用 derivedKey 对私钥使用 AES-CTR 算法加密，得到密文 cipherText，再对 derivedKey 和 cipherText 进行哈希运算得到 mac，mac 起到签名的作用，在解密的时候可以验证合法性，防止别人篡改。<code>EncryptKey</code> 最终返回 json 字符串，Storekey 方法接下来会将其保存在文件中。</p>
<h3 id="列出所有账户"><a href="#列出所有账户" class="headerlink" title="列出所有账户"></a>列出所有账户</h3><p>列出所有账户的入口也在 <code>internal/ethapi/api.go</code> 里。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> (<span class="selector-tag">s</span> *<span class="selector-tag">PrivateAccountAPI</span>) <span class="selector-tag">ListAccounts</span>() <span class="selector-attr">[]</span><span class="selector-tag">common</span><span class="selector-class">.Address</span> &#123;</div><div class="line">	<span class="attribute">addresses </span>:= <span class="built_in">make</span>([]common.Address, 0) // return [] instead of nil if empty</div><div class="line">	for _, wallet := range s.am.<span class="built_in">Wallets</span>() &#123;</div><div class="line">		for _, account := range wallet.<span class="built_in">Accounts</span>() &#123;</div><div class="line">			addresses = <span class="built_in">append</span>(addresses, account.Address)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">return</span> <span class="selector-tag">addresses</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会从 <code>Account Manager</code> 中读取所有钱包信息，获取其对应的所有地址信息。</p>
<p>如果读者对 geth account 命令还有印象的话，geth account 命令还有 <code>update</code>，<code>import</code> 等方法，这里就不再讨论了。</p>
<h3 id="发起转账"><a href="#发起转账" class="headerlink" title="发起转账"></a>发起转账</h3><p>发起一笔转账的函数入口在 <code>internal/ethapi/api.go</code> 中。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, <span class="keyword">args</span> SendTxArgs) (common.Hash, <span class="keyword">error</span>) &#123;</div><div class="line">	account := accounts.Account&#123;Address: <span class="keyword">args</span>.From&#125;</div><div class="line">	wallet, <span class="keyword">err</span> := s.b.AccountManager().Find(account)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">args</span>.Nonce == nil &#123;</div><div class="line">		s.nonceLock.LockAddr(<span class="keyword">args</span>.From)</div><div class="line">		defer s.nonceLock.UnlockAddr(<span class="keyword">args</span>.From)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">args</span>.setDefaults(ctx, s.b); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	tx := <span class="keyword">args</span>.toTransaction()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> chainID *big.Int</div><div class="line">	<span class="keyword">if</span> config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) &#123;</div><div class="line">		chainID = config.ChainId</div><div class="line">	&#125;</div><div class="line">	signed, <span class="keyword">err</span> := wallet.SignTx(account, tx, chainID)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> submitTransaction(ctx, s.b, signed)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转账时，首先利用传入的参数 <code>from</code> 构造一个 <code>account</code>，表示转出方。然后通过 <code>accountMananger</code> 的 <code>Find</code> 方法获得这个账户的钱包(<code>Find</code> 方法在上面有介绍)，接下来有一个稍特别的地方。我们知道以太坊采用的是账户余额的体系，对于 UTXO 的方式来说，防止双花的方式很直观，一个输出不能同时被两个输入而引用，这种方式自然而然地就防止了发起转账时可能出现的双花，采用账户系统的以太坊没有这种便利，以太坊的做法是，每个账户有一个 nonce 值，它等于账户累计发起的交易数量，账户发起交易时，交易数据里必须包含 nonce，而且该值必须大于账户的 nonce 值，否则为非法，如果交易的 nonce 值减去账户的 nonce 值大于1，这个交易也不能打包到区块中，这确保了交易是按照一定的顺序执行的。如果有两笔交易有相同 nonce，那么其中只有一笔交易能够成功，通过给  nonce 加锁就是用来防止双花的问题。接着调用 <code>args.setDefaults(ctx, s.b)</code> 方法设置一些交易默认值。最后调用 <code>toTransaction</code> 方法创建交易：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="title">func</span> (args *<span class="type">SendTxArgs</span>) toTransaction() *types.<span class="type">Transaction</span> &#123;</div><div class="line">	var input []byte</div><div class="line">	if args.<span class="type">Data</span> != nil &#123;</div><div class="line">		input = *args.<span class="type">Data</span></div><div class="line">	&#125; else if args.<span class="type">Input</span> != nil &#123;</div><div class="line">		input = *args.<span class="type">Input</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> args.<span class="type">To</span> == nil &#123;</div><div class="line">		return types.<span class="type">NewContractCreation</span>(uint64(*args.<span class="type">Nonce</span>), (*big.<span class="type">Int</span>)(args.<span class="type">Value</span>), uint64(*args.<span class="type">Gas</span>), (*big.<span class="type">Int</span>)(args.<span class="type">GasPrice</span>), input)</div><div class="line">	&#125;</div><div class="line">	return types.<span class="type">NewTransaction</span>(uint64(*args.<span class="type">Nonce</span>), *args.<span class="type">To</span>, (*big.<span class="type">Int</span>)(args.<span class="type">Value</span>), uint64(*args.<span class="type">Gas</span>), (*big.<span class="type">Int</span>)(args.<span class="type">GasPrice</span>), input)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个分支，如果传入的交易的 <code>to</code> 参数不存在，那就表明这是一笔合约转账；如果有 <code>to</code> 参数，就是一笔普通的转账，深入后你会发现这两种转账最终调用的都是 <code>newTransaction</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(nonce <span class="keyword">uint64</span>, to common.Address, amount *big.Int, gasLimit <span class="keyword">uint64</span>, gasPrice *big.Int, data []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> newTransaction(nonce, &amp;to, amount, gasLimit, gasPrice, data)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContractCreation</span><span class="params">(nonce <span class="keyword">uint64</span>, amount *big.Int, gasLimit <span class="keyword">uint64</span>, gasPrice *big.Int, data []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> newTransaction(nonce, <span class="literal">nil</span>, amount, gasLimit, gasPrice, data)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>newTransaction</code> 的功能很简单，实际上就是返回一个 <code>Transaction</code> 实例。我们接着看 <code>SendTransaction</code> 方法接下来的部分。创建好一笔交易，接着我们通过 <code>ChainConfig</code> 方法获得区块链的配置信息，如果是 EIP155 里描述的配置，需要做特殊处理（待深入），然后调用 <code>SignTx</code> 对交易签名来确保这笔交易是真实有效的。<code>SignTx</code> 的接口定义在 <code>accounts/accounts.go</code> 中，这里我们看 keystore 的实现。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func (ks *KeyStore) SignTx(<span class="selector-tag">a</span> accounts<span class="selector-class">.Account</span>, tx *types<span class="selector-class">.Transaction</span>, chainID *big.Int) (*types<span class="selector-class">.Transaction</span>, error) &#123;</div><div class="line">	ks<span class="selector-class">.mu</span><span class="selector-class">.RLock</span>()</div><div class="line">	defer ks<span class="selector-class">.mu</span><span class="selector-class">.RUnlock</span>()</div><div class="line"></div><div class="line">	unlockedKey, found := ks<span class="selector-class">.unlocked</span>[<span class="selector-tag">a</span>.Address]</div><div class="line">	<span class="keyword">if</span> !found &#123;</div><div class="line">		return nil, ErrLocked</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> chainID != nil &#123;</div><div class="line">		return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey)</div><div class="line">	&#125;</div><div class="line">	return types.SignTx(tx, types.HomesteadSigner&#123;&#125;, unlockedKey.PrivateKey)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先验证账户是否已解锁，若没有解锁，直接报异常退出。接着根据 <code>chainID</code> 判断使用哪一种签名方式，调用相应 <code>SignTx</code> 方法进行签名。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> <span class="selector-tag">SignTx</span>(<span class="selector-tag">tx</span> *<span class="selector-tag">Transaction</span>, <span class="selector-tag">s</span> <span class="selector-tag">Signer</span>, <span class="selector-tag">prv</span> *<span class="selector-tag">ecdsa</span><span class="selector-class">.PrivateKey</span>) (*<span class="selector-tag">Transaction</span>, <span class="selector-tag">error</span>) &#123;</div><div class="line">	<span class="attribute">h </span>:= s.<span class="built_in">Hash</span>(tx)</div><div class="line">	sig, err := crypto.<span class="built_in">Sign</span>(h[:], prv)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">return</span> <span class="selector-tag">tx</span><span class="selector-class">.WithSignature</span>(<span class="selector-tag">s</span>, <span class="selector-tag">sig</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SignTx</code> 的功能是调用椭圆加密函数获得签名，得到带签名的交易后，通过 <code>SubmitTrasaction</code> 提交交易。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">if</span> err := b.SendTx(ctx, tx); err != nil &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> tx.To() == nil &#123;</div><div class="line">		signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number())</div><div class="line">		from, err := types.Sender(signer, tx)</div><div class="line">		<span class="keyword">if</span> err != nil &#123;</div><div class="line">			<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">		&#125;</div><div class="line">		addr := crypto.CreateAddress(from, tx.Nonce())</div><div class="line">		log.Info(<span class="string">"Submitted contract creation"</span>, <span class="string">"fullhash"</span>, tx.Hash().Hex(), <span class="string">"contract"</span>, addr.Hex())</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		log.Info(<span class="string">"Submitted transaction"</span>, <span class="string">"fullhash"</span>, tx.Hash().Hex(), <span class="string">"recipient"</span>, tx.To())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> tx.Hash(), nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>submitTransaction</code> 首先调用 <code>SendTx</code>，这个接口在 <code>internal/ethapi/backend.go</code> 中定义，而实现在 <code>eth/api_backend.go</code> 中，这部分代码涉及到交易池，我们在单独的交易池章节进行探讨，这里就此打住。</p>
<p>将交易写入交易池后，如果没有因错误退出，<code>submitTransaction</code> 会完成提交交易，返回交易哈希值。发起交易的这个过程就结束了，剩下的就交给矿工将交易上链。挖矿相关的代码会在之后的博客中进行介绍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇分析 &lt;code&gt;geth&lt;/code&gt; 中与账户和转账相关的源代码。&lt;/p&gt;
&lt;p&gt;交易是以太坊里的一个很核心的概念，它不仅仅体现在价值的转移上。我们知道智能合约是以太坊的一个重大创新，而智能合约的执行是依靠交易来触发的，可以这么说，在以太坊中，大部分场景的状态转换都依靠交易实现，而交易又与账户紧密相关，所以这一篇我们将账户，转账这两个模块结合在一起来探讨。&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（trie 模块-MPT 的实现）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（trie 模块-MPT 的实现）/</id>
    <published>2018-03-10T14:35:02.000Z</published>
    <updated>2018-09-18T18:23:30.552Z</updated>
    
    <content type="html"><![CDATA[<p>默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之前，读者应该对默克尔树，帕特里夏树这两个数据结构有一定了解，这些是阅读源代码的基础知识，这里只做概述。下面我们先分别介绍这两种数据结构。</p>
<a id="more"></a>
<h2 id="Merkle-Tree-默克尔树"><a href="#Merkle-Tree-默克尔树" class="headerlink" title="Merkle Tree 默克尔树"></a>Merkle Tree 默克尔树</h2><p>默克尔树即哈希树，它是一种树形数据结构，由一组叶结点，一组中间节点和一个根节点构成。最下面的叶结点包含基础数据，每个中间节点是它的子节点的哈希值，根节点是他的子节点的哈希值，表示默克尔树的根部。它的作用是对大容量的数据进行快速比对。对于一个数据集，我们可以将其分成多个小的数据集，存在叶子节点上，默克尔树的根节点存储的哈希值就表示这个数据集的哈希值，当更新、添加或删除树节点时，都需要更新节点的哈希值，根节点的哈希值也会有所不同，这样可以用根节点到数据节点这一路径的数据来证明数据的正确性，而这个数据量相比于整个数据集来说是很小的。</p>
<p>举两个实际的例子，你就能很好的理解默克尔树的作用。</p>
<h3 id="Dynano-数据库"><a href="#Dynano-数据库" class="headerlink" title="Dynano 数据库"></a>Dynano 数据库</h3><p>在 Amazon 的 Dynamo 数据库中，大量使用到默克尔树。场景是这样的：为了保证 Dynamo 集群中的数据存储的持久性，一台机器上的数据在其他机器上存有备份，也就是副本。副本经常需要同步，保证数据的一致，这时候需要对数据进行比对，找到不一致的地方。网络传输时间是这个过程的瓶颈，我们需要尽可能减少数据传输量。比对两台机器的数据，传输不一致的数据当然是最佳选择，如何比对？首先应该想到的是应该比对哈希值，避免之间传输数据带来的巨大传输量，其次，用二分法能更快的找到差异数据，如果能想到这两点，我们就和 Merkle 想的一样了。在每台机器对每个区间的数据构建默克尔树，比对数据时，从根节点开始比较，如果一致，表明两个副本一致，否则就遍历这颗二叉树，定位到差异数据的复杂度是 $O(log(n))$。</p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种中心索引式的 P2P 文件分析通信协议。进行 P2P 下载时，先从中心索引服务器获取一个扩展名为 torrent 的索引文件，torrent 文件包含了共享文件的信息，包括文件名，大小，文件的 Hash 和指向 Tracker 的 URL，当我们使用 BitTorrent 下载文件时有几个步骤：</p>
<ol>
<li>客户端 A 根据下载的种子文件得出资源的目标服务器地址，然后与目标服务器地址建立连接，进行数据块下载。</li>
<li>当一个数据块下载完成后，客户端 A 会计算该数据块的摘要，然后用这个摘要与先前种子文件里的摘要进行对比，如果一致，表示这个数据块下载成功，否则，重新下载。</li>
<li>当一个数据块下载成功，客户端 A 会与其他下载资源的客户端进行通信，告知它们它已经成功下载了一个数据库，其他客户端需要下载这个数据块时，会去客户端 A 下载。</li>
</ol>
<p>如果不采用默克尔树，可以采取 hash list 的方式，即将文件分成一个一个的数据块后，分别对其取 hash，这带来一个问题是，torrent 文件应该是越小越好，否则会对种子文件服务器造成很大的负载压力，要想要 torrent 文件很小，那么数据块就应该分得足够大，但数据块足够大的话，客户端下载完一个数据块后校验发现数据块无效，重新传输代价又很大。引入默克尔树可以解决这个问题，将所有数据块构造成默克尔树之后，种子文件可以只存放根节点的哈希值。当出现传输错误时可以使用二分查找快速找到出错的数据块，然后重新传输，</p>
<p>从上述的两个例子可以看到引入默克尔树的意义，默克尔树将哈希表和二叉树的结合起来，由根节点，中间节点和叶子节点组成，叶子节点存的是数据或哈希值，中间节点是它的两个孩子的哈希值，根节点也是它的两个孩子的哈希值，它表示这一组数据的指纹。根据哈希表和二叉树的特点我们可以知道，叶子节点数据的任何变动，都可以通过父节点体现，而通过二叉树，可以很快定位到变更的数据。</p>
<p>因此，默克尔树的典型应用场景有：</p>
<ul>
<li>快速比较大量数据：如果两个默克尔树的根节点的值相同，意味着它们代表的值相同</li>
<li>可以快速定位到变更的数据，复杂度是 $O(log(n))$</li>
<li>零知识证明</li>
</ul>
<h2 id="Patricia-帕特里夏树"><a href="#Patricia-帕特里夏树" class="headerlink" title="Patricia 帕特里夏树"></a>Patricia 帕特里夏树</h2><p>要搞懂帕特里夏树，首先要先搞懂字典树。</p>
<h3 id="trie-字典树"><a href="#trie-字典树" class="headerlink" title="trie 字典树"></a><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie 字典树</a></h3><p>也称前缀树，单词查找树，键树。它用来保存关联数组，其中的键通常是字符串，键不直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串。并不是所有节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>trie 的思想是用空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。如下图就是一个 trie 树。</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/trie_example.png" alt="trie"></p>
<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><ul>
<li>字符串检索</li>
</ul>
<p>Trie 树可以用来查询字符串，判断一个字符串是否存在于某个字符串集合。</p>
<ul>
<li>词频统计</li>
</ul>
<p>实现词频统计时，节点结构有一个字段来记录该节点表示的单词的个数。</p>
<ul>
<li>字符串排序</li>
</ul>
<p>一次插入字符串到 Trie 树的过程就是一次排序的过程，先序输出 Trie 树的所有关键字就可以得到有序的字符串。</p>
<ul>
<li>前缀匹配</li>
</ul>
<p>在搜索引擎中，使用 Trie 前缀可以找到所有以某个字符串为前缀的字符串集合。</p>
<p>Trie 的插入和查询效率都是 $O(m)$，其中 m 是待插入/查询的字符串的长度。相比于哈希查找，Trie 树中不同的关键字不会产生冲突，而且查询共同前缀的 key 时很高效，如果是使用哈希查找，需要遍历整个哈希表，时间效率为 $O(n)$，n 为哈希表的数据总数；但 Trie 的缺点是空间消耗比较大，如果是直接查找，效率是 $O(m)$，并且有 m 次 IO 的开销，对于磁盘的压力也很大，而哈希表的查找效率是 $O(1)$。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Trie 在 redisearch 中有<a href="https://github.com/RedisLabsModules/RediSearch/blob/master/src/trie/trie.c" target="_blank" rel="external">实现</a>，用来实现搜索提示。</p>
<p>弄清原理后，可以尝试自己动手实现一下，在 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="external">leetcode</a> 上有相关题目。</p>
<h3 id="PatriciaTrie-帕特里夏树"><a href="#PatriciaTrie-帕特里夏树" class="headerlink" title="PatriciaTrie 帕特里夏树"></a>PatriciaTrie 帕特里夏树</h3><p>又叫做基数树，压缩前缀树或紧凑前缀树（compact prefix tree)，是一种更节省空间的前缀树。它与 Trie 的区别是，如果某个节点只有一个子树，那么这个子树跟父节点合并，这样可以缩短 Trie 里不必要的深度，节约存储空间，加快搜索节点的速度。</p>
<p>帕特里夏树的诞生是因为 Trie 有一定的缺陷，Trie 树会给每个字符串分配一个节点，如果有很多很长的，又没有公共节点的字符串就会使得 Trie 退化成一个数组，如果以太坊直接使用的是 Trie 话，有可能造成严重的存储空间的浪费，导致 Dos 攻击。</p>
<h2 id="Merkle-Patricia-Tree-默克尔-帕特里夏树"><a href="#Merkle-Patricia-Tree-默克尔-帕特里夏树" class="headerlink" title="Merkle Patricia Tree 默克尔-帕特里夏树"></a>Merkle Patricia Tree 默克尔-帕特里夏树</h2><p>Merkle Patricia Tree 默克尔-帕特里夏树是一种融合了默克尔树和前缀树两种结构优点的，经过改良的数据结构，在以太坊中用来组织交易信息、账户状态及其变更、收据相关的数据，为我们提供一个高效地、易更新的、且代表整个状态树的『指纹』。</p>
<p>每一个以太坊的区块头包含3颗 MPT 树，分别是：</p>
<ul>
<li>交易树 txTrie<br>用来存储交易数据。路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后才生成，在挖矿结束后不会再更新。</li>
<li>状态树 stateTrie<br>世界状态存储的地方，存储了所有账户的信息，包括余额，交易次数，EVM 指令（合约数据）等等，每次交易执行，stateTrie 都会变化，这部分内容我们将在 <a href="#TODO">go-ethereum 源码笔记（core 模块-状态管理）</a> 这一篇进行探讨。路径是 <code>sha3(ethereumAddress)</code>，值是 <code>rlp(ethereumAccount)</code>，其中 <code>ethereumAccount</code> 是一个列表 <code>[nonce,balance,storageRoot,codeHash]</code>，而 <code>storageRoot</code> 是另一个独立的帕特里树，每个账户都有一个独立的帕特里夏树，它用来存储所有的合约数据。参考 <a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a>。</li>
<li>收据树 receiptTrie<br>路径是 <code>rlp(transactionIndex)</code>，其中 <code>transactionIndex</code> 是挖矿结束后得到的交易索引，在交易执行完后生成，在挖矿结束后不会再更新。</li>
</ul>
<h2 id="Geth-的-MPT"><a href="#Geth-的-MPT" class="headerlink" title="Geth 的 MPT"></a>Geth 的 MPT</h2><p>MPT 在以太坊中作为键值存储的数据结构，使得插入，查找，删除的复杂度为 <code>O(log(n))</code>，并且能获得默克尔树的全部特性。</p>
<p>根据<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">以太坊官方博客</a>所描述的，MPT 使得轻节点可以实现以下的查询：</p>
<ul>
<li>这笔交易被包含在特定的区块中了吗？</li>
<li>这笔交易在过去的30天中，发出 X 类型事件的所有实例(例如，一个众筹合约完成了它的目标)</li>
<li>目前我的账户余额是多少</li>
<li>这个账户是否存在</li>
<li>假设在这个合约中运行这笔交易，它的输出是什么</li>
</ul>
<p>其实第1种情况可以由交易树处理，第2种情况可以由收据树处理，第3，4，5中情况可以由状态树来处理，计算前4个查询任务相当简单，服务器找到对象，获取默克尔分支，将分支回复给客户端。<br>对于第5种查询任务，利用状态树实现，这种方式称为默克尔状态转换证明。轻节点想要得到一个可信的结果，这个问题相当于，如果在根 S 的状态树上运行交易 T，其结果状态树将是根为 S’，log 为 L，输出为 O’。为推断这个证明，服务器创建一个假的区块，状态设为 S，请求这笔交易时假装是轻客户端，请求这笔交易时，需要客户端确定一个账户的余额，然后这个假的轻客户端会发出一个余额查询请求，服务器会回应这些请求，也会将这些请求中的数据合并以一个证明的方式发送给轻节点，轻节点这时会进行验证，将服务器提供的证明作为数据库使用，如果客户端验证的结果和服务器提供的是一样的，客户端就接受这个证明。看起来这种方式跟默克尔证明没有本质区别，都很好的利用了默克尔树的特性。</p>
<p>接下来我们换个角度，根据默克尔树和帕特里夏树两种结构的特性来说明 MPT 在以太坊中起到的作用。</p>
<h3 id="默克尔树的作用"><a href="#默克尔树的作用" class="headerlink" title="默克尔树的作用"></a>默克尔树的作用</h3><h4 id="轻节点扩展"><a href="#轻节点扩展" class="headerlink" title="轻节点扩展"></a>轻节点扩展</h4><p>MPT 实现了默克尔树，所以能提供一个默克尔证明这个功能，而通过默克尔证明我们可以实现区块链的轻节点扩展。</p>
<h5 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h5><p>在以太坊中，全节点是指维护整个区块链数据的节点，这包括整个区块链中的区块头，所有交易信息，账户状态，交易收据信息。随着时间推移，整个区块链数据量会非常大，这使得在 PC 或移动设备上运行全节点的可能性很小。中本聪的论文中描述了这种情况，并利用默克尔树来解决这个问题。我们可以运行一种节点，这个节点只维护区块链中所有的区块头信息，这种节点就叫做轻节点。</p>
<h5 id="默克尔证明"><a href="#默克尔证明" class="headerlink" title="默克尔证明"></a>默克尔证明</h5><p>默克尔证明是指一个轻节点向一个全节点发起一次证明请求，询问完整的默克尔树中是否存在一个指定的节点（这里指的是树的节点），全节点会向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证其存在性。这里利用了哈希函数的特性保证了这个验证是真实可靠的。</p>
<p>当我们需要验证某笔交易确实存在于区块链时，轻节点不需要维护区块的信息，当它需要验证时，可以向全节点请求一条默克尔树的路径，该路径实际上是从根节点到叶子节点的所有节点的哈希值列表，轻节点收到这条路径后，一层层地计算根哈希，再与本地的根哈希匹配，如果匹配成功了则说明这笔交易是存在的。哈希操作是不可逆的，所以不存在一个所谓的恶意节点可以伪造一条假的路径使得计算的根哈希与轻节点的根哈希是一致的。有人可能会有疑问，为什么不直接向网络中的某个全节点请求交易数据是否在区块链中，如果这样做的话，就不能保证安全性了，区块链的美妙之处在于，上面存的数据是全网的共识，除非受到 51% 攻击，否则区块链的数据是完全可信的，这与中心化的数据库不同。如果是直接向网络中某节点或某些节点请求数据，可能这些节点都是恶意节点，不能保证安全性。需要说明的是，轻节点尽管没有参与维护整个区块链数据，它也是去中心化的，因为它所拿到的区块头数据是经过了全网共识的，所以有足够的安全保障。</p>
<h3 id="帕特里树的作用"><a href="#帕特里树的作用" class="headerlink" title="帕特里树的作用"></a>帕特里树的作用</h3><ul>
<li>存储任意长度的 key-value 键值对数据</li>
<li>快速索引根据哈希存储的数据集</li>
<li>引入了几种节点类型来提高效率，包括空节点，叶子节点，扩展节点，分支节点</li>
</ul>
<h2 id="MPT-在-geth-中的实现细节"><a href="#MPT-在-geth-中的实现细节" class="headerlink" title="MPT 在 geth 中的实现细节"></a>MPT 在 geth 中的实现细节</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在以太坊中，MPT 有四种类型的树节点，目的是压缩整体树高、降低操作复杂度。树节点可以分为以下四类：</p>
<ul>
<li>空节点</li>
<li>分支节点</li>
<li>叶子节点</li>
<li>扩展节点</li>
</ul>
<p>这些是黄皮书中的定义，在 geth 的实现中，上述概念有不同的结构与之对应。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="keyword">node</span> <span class="title">interface</span> &#123;</div><div class="line">	fstring(<span class="keyword">string</span>) <span class="keyword">string</span></div><div class="line">	cache() (hashNode, bool)</div><div class="line">	canUnload(cachegen, cachelimit uint16) bool</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> (</div><div class="line">	fullNode struct &#123;</div><div class="line">		Children [<span class="number">17</span>]<span class="keyword">node</span></div><div class="line">		<span class="title">flags</span>    nodeFlag</div><div class="line">	&#125;</div><div class="line">	shortNode struct &#123;</div><div class="line">		Key   []byte</div><div class="line">		Val   <span class="keyword">node</span></div><div class="line">		<span class="title">flags</span> nodeFlag</div><div class="line">	&#125;</div><div class="line">	hashNode  []byte</div><div class="line">	valueNode []byte</div><div class="line">)</div><div class="line">...</div><div class="line"><span class="keyword">type</span> nodeFlag struct &#123;</div><div class="line">	hash  hashNode</div><div class="line">	gen   uint16</div><div class="line">	dirty bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下图是一个世界状态的例子（摘自 <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" target="_blank" rel="external">Ethereum block architecture</a>）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/worldstatetrie.png" alt="worldstatetrie"></p>
<h4 id="fullNode"><a href="#fullNode" class="headerlink" title="fullNode"></a>fullNode</h4><p>fullNode 是一个可以携带多个子节点的节点。它有一个 node 数组类型的成员变量 Children，数组的前16个空位分别对应十六进制的0-9a-f，对于每个子节点，根据其 key 值的十六进制表示一一对应，Children 数组的第17位，fullNode 用来存储数据。</p>
<p>对应黄皮书中的分支节点。</p>
<h4 id="shortNode"><a href="#shortNode" class="headerlink" title="shortNode"></a>shortNode</h4><p>shortNode 是一个仅有一个子节点的节点。成员变量 Val 指向一个子节点，成员变量 Key 是一个由任意长度的字符串，这体现了压缩前缀树的特点，通过合并只有一个子节点的父节点和其子节点来缩短 Trie 的深度。</p>
<p>对应黄皮书里的扩展节点和叶子节点，通过 <code>shortNode.Val</code> 的类型来对应。</p>
<h4 id="valueNode"><a href="#valueNode" class="headerlink" title="valueNode"></a>valueNode</h4><p>valueNode 在 MPT 结构中存储真正的数据。充当 MPT 的叶子节点，不带子节点。</p>
<p>valueNode 是一个字节数组，但是它实现了 <code>fstring(string) string</code>, <code>cache() (hashNode, bool)</code>, <code>canUnload(cachegen, cachelimit uint16) bool</code> 这三个接口（实际上 fullNode，shortNode，hashNode 也实现了这三个接口），因此可以作为 fullNode，shortNode 中的 <code>node</code> 使用。valueNode 可以承接数据，携带的的是数据的 RLP 哈希值，长度为 32 byte，RLP 编码的值存在 LevelDB 里。</p>
<h4 id="hashNode"><a href="#hashNode" class="headerlink" title="hashNode"></a>hashNode</h4><p>hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存。遍历 MPT 时有时会遇到一个 hashNode，表明原来的 node 需要动态加载，hashNode 以 nodeFlag 结构体的成员 hash 的形式存在，如果 fullNode 或 shortNode 的成员变量发生变化，那么就需要更新它的 hashNode，在增删改的过程结束了都会调用 <code>trie.Hash()</code>，整个 MPT 自底向上变量，对所有清空的 hashNode 重新赋值，最终得到根节点的 hashNode，也就是整个 MPT 结构的哈希值。</p>
<p>结合之前讲过的基础知识，可以看到 fullNode 体现了 Trie 的特点，shortNode 实现了 PatriciaTrie 的特性（当然也实现了 Trie 的特性），hashNode 既实现了 MPT 节点的动态加载，也实现了默克尔树的功能。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Trie-的基本操作"><a href="#Trie-的基本操作" class="headerlink" title="Trie 的基本操作"></a>Trie 的基本操作</h4><p>我们首先将 Trie 看做一个黑盒，看看它具体暴露了什么接口，对全局有个总体的把握之后再深入其对应的细节。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"trie.New called without a database"</span>)</div><div class="line">	&#125;</div><div class="line">	trie := &amp;Trie&#123;</div><div class="line">		db:           db,</div><div class="line">		originalRoot: root,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (root != common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</div><div class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		trie.root = rootnode</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <code>New</code> 函数进行初始化，参数 root 是一个哈希值，如果哈希值不为空，说明数据中已存在 <code>Trie</code> 结构，调用 <code>trie.resolveHash</code> 方法来加载整个 Trie 树，如果 root 为空，新建 Trie 返回。</p>
<p>下面我们看看 Trie 结构的增删改查的过程，需要注意的是，MPT 是一棵树，这些数据结构的操作都是递归调用的过程，因此参数的上下文应该是当前这棵树下的含义。</p>
<h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">insert</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>, value node)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> v, ok := n.(valueNode); ok &#123;</div><div class="line">			<span class="keyword">return</span> !bytes.Equal(v, value.(valueNode)), value, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, value, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123;</div><div class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</div><div class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.<span class="built_in">copy</span>()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[<span class="number">0</span>]] = nn</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, n, n))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数 node 是当前插入的根节点，prefix 是当前已经处理的 key(即 Patricia 树中节点共有的前缀)，key 是待处理的部分，完整的 key 应该是 prefix + key，value 是需要插入的值。返回的名为 dirty 的布尔值在 commit 阶段指明该树是否需要重新进行哈希计算。</p>
<p>如果当前根节点类型为 shortNode(当前节点为叶子节点或扩展节点)，首先通过 <code>prefixLen</code> 方法计算公共前缀。</p>
<p>如果公共前缀长度等于 key 的长度，那么说明插入的 key 和待插入的树的 key 一样，这时分两种情况。</p>
<ul>
<li>如果 value 也一样，那么返回 false，即 dirty 为 false。</li>
<li>如果 value 不一样，实际上这是一个 <code>update</code> 的操作，这时返回的 dirty 为 true。</li>
</ul>
<p>如果公共前缀不完全匹配，又分两种情况。</p>
<ul>
<li>如果匹配长度为 0 的话，返回的是一个 fullNode，这个 fullNode 有两个 shortNode 类型的子节点，一个子节点即当前的根节点，另一个为以要插入的值为 node 的 shortNode；</li>
<li>匹配长度大于零，这时公共节点提取出来形成一个独立的 shortNode(扩展节点)，这个 shortNode 的 Val 是 fullNode，fullNode 的两个子节点，一个即当前的根节点，另一个为以要插入的值为 node 的 shortNode</li>
</ul>
<p>这部分逻辑是当前根节点类型为 shortNode 的情况，可以看到这里实际上是帕特里夏树的体现，对于 Trie 进行空间使用率的优化，如果一个父节点只有一个子节点，那么这个父节点将与其子节点合并，这样可以缩短搜索深度。</p>
<p>对于当前根节点类型为 fullNode 的情况，直接往对应的孩子节点调用 insert 方法，insert 方法会返回插入后的根节点，然后将该孩子指向这个返回的根节点即可。</p>
<p>对于当前根节点类型为 nil 的情况，即要插入的 Trie 是空的，直接返回一个 shortNode，Val 字段即为要插入的 node。</p>
<p>对于当前节点为 hashNode 的情况，表明要插入的当前根节点还在数据库中，没有加载到内存中，首先调用 <code>t.resolveHash(n, prefix)</code> 方法进行加载，在调用 insert 方法进行插入。</p>
<p>以上就是插入一个新节点的全部逻辑，基本上概括了帕特里夏树的特点，删，改，查的操作实际上大同小异，因此接下来的讲解会简略一点。</p>
<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := t.TryDelete(key); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryDelete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	t.root = n</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">delete</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		matchlen := prefixLen(key, n.Key)</div><div class="line">		<span class="keyword">if</span> matchlen &lt; <span class="built_in">len</span>(n.Key) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(key) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		dirty, child, err := t.<span class="built_in">delete</span>(n.Val, <span class="built_in">append</span>(prefix, key[:<span class="built_in">len</span>(n.Key)]...), key[<span class="built_in">len</span>(n.Key):])</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> child := child.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;concat(n.Key, child.Key...), child.Val, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, child, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		dirty, nn, err := t.<span class="built_in">delete</span>(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:])</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</div><div class="line">		&#125;</div><div class="line">		n = n.<span class="built_in">copy</span>()</div><div class="line">		n.flags = t.newFlag()</div><div class="line">		n.Children[key[<span class="number">0</span>]] = nn</div><div class="line">		</div><div class="line">		pos := <span class="number">-1</span></div><div class="line">		<span class="keyword">for</span> i, cld := <span class="keyword">range</span> n.Children &#123;</div><div class="line">			<span class="keyword">if</span> cld != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">if</span> pos == <span class="number">-1</span> &#123;</div><div class="line">					pos = i</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					pos = <span class="number">-2</span></div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> pos &gt;= <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> pos != <span class="number">16</span> &#123;</div><div class="line">				cnode, err := t.resolve(n.Children[pos], prefix)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> cnode, ok := cnode.(*shortNode); ok &#123;</div><div class="line">					k := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(pos)&#125;, cnode.Key...)</div><div class="line">					<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;k, cnode.Val, t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;[]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(pos)&#125;, n.Children[pos], t.newFlag()&#125;, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> valueNode:</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		rn, err := t.resolveHash(n, prefix)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		dirty, nn, err := t.<span class="built_in">delete</span>(rn, prefix, key)</div><div class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v (%v)"</span>, n, n, key))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除的真正逻辑在 <code>delete(n node, prefix, key []byte) (bool, node, error)</code> 这个方法里，其中参数 key 是通过 <code>keybytesToHex</code> 获得的 hex 编码。删除的过程也是递归调用，其中 node，prefix，key 参数意义与插入时的参数一致。</p>
<p>对于 shortNode 情况，首先进行 key 的匹配，如果匹配的长度小于根节点的 key 的长度，意味着要删除的节点不在这颗树上，返回 false 以及根节点，不做任何操作；如果匹配的长度正好等于 key 的长度，意味着完全匹配，返回 true 以及 nil(表明该节点已经被删除)。</p>
<p>如果匹配的长度等于根节点的 key 的长度，并且小于参数 key 的长度，那么意味着要删除的节点是该树的子节点，需要删除的是根树的一颗子树，那么继续递归调用。</p>
<p>对于删除 fullNode 的情况，如果 fullNode 删除后有两个及以上的子节点，删除后返回根节点即可，如果删除后只有一个子节点，那么需要将该根节点变成 shortNode 返回。</p>
<p>对于删除 hashNode 的情况，先加载节点到内存中再递归调用删除操作。</p>
<h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Update</span><span class="params">(key, value []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := t.TryUpdate(key, value); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryUpdate</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	k := keybytesToHex(key)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(value) != <span class="number">0</span> &#123;</div><div class="line">		_, n, err := t.insert(t.root, <span class="literal">nil</span>, k, valueNode(value))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		t.root = n</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新的操作，如果 value 长度不为零，即 value 不为空的话，直接调用插入操作，如果为空，则删除根节点。</p>
<h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	res, err := t.TryGet(key)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryGet</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	value, newroot, didResolve, err := t.tryGet(t.root, key, <span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">		t.root = newroot</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value, err</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">tryGet</span><span class="params">(origNode node, key []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, newnode node, didResolve <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> valueNode:</div><div class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">			n = n.<span class="built_in">copy</span>()</div><div class="line">			n.Val = newnode</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> value, n, didResolve, err</div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</div><div class="line">			n = n.<span class="built_in">copy</span>()</div><div class="line">			n.flags.gen = t.cachegen</div><div class="line">			n.Children[key[pos]] = newnode</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> value, n, didResolve, err</div><div class="line">	<span class="keyword">case</span> hashNode:</div><div class="line">		child, err := t.resolveHash(n, key[:pos])</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err</div><div class="line">		&#125;</div><div class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</div><div class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, origNode, origNode))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询的操作，实际上最终查的还是 valueNode，根据 key，根据 pos 指示的 key 位置跟根节点的 Key 属性值进行匹配，递归调用即可，与上述的操作很类似。</p>
<h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><p>提交阶段会将内存中的所有 trie 写入到数据库中。在这期间会根据 dirty 值做一件非常重要的事情，如果 dirty 置为 true 了，表明其代表的父节点有改动需要提交，hashNode 的成员 hash 设为空，需重新进行计算得到 hashNode 的哈希值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Commit</span><span class="params">(onleaf LeafCallback)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"commit called on trie with nil database"</span>)</div><div class="line">	&#125;</div><div class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	t.root = cached</div><div class="line">	t.cachegen++</div><div class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">hashRoot</span><span class="params">(db *Database, onleaf LeafCallback)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	h := newHasher(t.cachegen, t.cachelimit, onleaf)</div><div class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</div><div class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hash</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> n.canUnload(h.cachegen, h.cachelimit) &#123;</div><div class="line">			cacheUnloadCounter.Inc(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !dirty &#123;</div><div class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	collapsed, cached, err := h.hashChildren(n, db)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	hashed, err := h.store(collapsed, db, force)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</div><div class="line">	&#125;</div><div class="line">	cachedHash, _ := hashed.(hashNode)</div><div class="line">	<span class="keyword">switch</span> cn := cached.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">			cn.flags.dirty = <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		cn.flags.hash = cachedHash</div><div class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">			cn.flags.dirty = <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hashed, cached, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hashChildren</span><span class="params">(original node, db *Database)</span> <span class="params">(node, node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> n := original.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *shortNode:</div><div class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</div><div class="line">		collapsed.Key = hexToCompact(n.Key)</div><div class="line">		cached.Key = common.CopyBytes(n.Key)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</div><div class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> original, original, err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">case</span> *fullNode:</div><div class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</div><div class="line">			<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123;</div><div class="line">				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> original, original, err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</div><div class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> n, original, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提交 MPT 时，会调用 <code>Trie.hashRoot</code> 从根节点开始折叠，而 <code>hashRoot</code> 会调用 <code>trie/hasher.go</code> 里的 <code>hash</code> 方法，<code>hash</code> 方法和 <code>hashChildren</code> 方法会递归调用遍历整个 MPT，大致逻辑是：如果 node 没有子节点，直接返回；如果 node 是 shortNode，将 <code>valueNode</code> 作为参数调用 <code>hash</code> 方法；如果 node 是 fullNode，对其每个子节点调用 <code>hash</code> 方法。最终将这个 node 作为参数调用 <code>store</code> 方法，获得 RLP 编码，并进行哈希计算，获取哈希值，也就是 MPT 根节点的哈希值。</p>
<h4 id="Trie-的序列化和反序列化"><a href="#Trie-的序列化和反序列化" class="headerlink" title="Trie 的序列化和反序列化"></a>Trie 的序列化和反序列化</h4><p>上一篇文章 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</a> 介绍了 geth 里是怎么进行序列化和反序列化的，而通过上文我们知道了 MPT 有一个折叠和动态加载节点的过程，这个过程需要通过 rlp 模块进行序列化和反序列化，与 LevelDB 进行交互，我们来具体看看这个过程是怎么实现的。</p>
<h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">store</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash &#123;</div><div class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	h.tmp.Reset()</div><div class="line">	<span class="keyword">if</span> err := rlp.Encode(&amp;h.tmp, n); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"encode error: "</span> + err.Error())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.tmp) &lt; <span class="number">32</span> &amp;&amp; !force &#123;</div><div class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	hash, _ := n.cache()</div><div class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</div><div class="line">		hash = h.makeHashNode(h.tmp)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</div><div class="line">		hash := common.BytesToHash(hash)</div><div class="line"></div><div class="line">		db.lock.Lock()</div><div class="line">		db.insert(hash, h.tmp, n)</div><div class="line">		db.lock.Unlock()</div><div class="line"></div><div class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="keyword">case</span> *shortNode:</div><div class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok &#123;</div><div class="line">					h.onleaf(child, hash)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> *fullNode:</div><div class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</div><div class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</div><div class="line">						h.onleaf(child, hash)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> hash, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面有提到 store 方法，它通过调用 <code>rlp.Encode</code> 对节点进行 RLP 编码，然后计算哈希值，通过 <code>db.insert</code> 将其插入数据库，需注意的是分别对 shortNode，fullNode 调用的 <code>onleaf</code>方法，它用来存储外部的 MPT，如果没有猜错的话，它应该是用来存储账户相关内容的，待验证。</p>
<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">resolveHash</span><span class="params">(n hashNode, prefix []<span class="keyword">byte</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	cacheMissCounter.Inc(<span class="number">1</span>)</div><div class="line"></div><div class="line">	hash := common.BytesToHash(n)</div><div class="line">	<span class="keyword">if</span> node := t.db.node(hash, t.cachegen); node != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> node, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, &amp;MissingNodeError&#123;NodeHash: hash, Path: prefix&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">node</span><span class="params">(hash common.Hash, cachegen <span class="keyword">uint16</span>)</span> <span class="title">node</span></span> &#123;</div><div class="line">	db.lock.RLock()</div><div class="line">	node := db.nodes[hash]</div><div class="line">	db.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> node.obj(hash, cachegen)</div><div class="line">	&#125;</div><div class="line">	enc, err := db.diskdb.Get(hash[:])</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || enc == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mustDecodeNode(hash[:], enc, cachegen)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustDecodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>, cachegen <span class="keyword">uint16</span>)</span> <span class="title">node</span></span> &#123;</div><div class="line">	n, err := decodeNode(hash, buf, cachegen)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"node %x: %v"</span>, hash, err))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>, cachegen <span class="keyword">uint16</span>)</span> <span class="params">(node, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</div><div class="line">	&#125;</div><div class="line">	elems, _, err := rlp.SplitList(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"decode error: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">switch</span> c, _ := rlp.CountValues(elems); c &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">		n, err := decodeShort(hash, elems, cachegen)</div><div class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">"short"</span>)</div><div class="line">	<span class="keyword">case</span> <span class="number">17</span>:</div><div class="line">		n, err := decodeFull(hash, elems, cachegen)</div><div class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">"full"</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid number of list elements: %v"</span>, c)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到，在遍历的过程中，如果遇到了 hashNode，需要动态加载这个节点，这个方法就是 resolve。resolve 方法会调用 <code>trie/database.go</code> 的 <code>node</code> 方法，先从内存里拿，否则从硬盘里拿，接着调用 <code>trie/node.go</code> 的 <code>mustDecodeNode</code>，<code>mustDecodeNode</code> 是 <code>decodeNode</code> 的简单封装，在这里可以看到调用 rlp 模块进行反序列化的过程，根据 RLP 的 list 的长度来判断这个编码是什么节点，如果是2那么就是 shortNode，如果是17就是 fullNode，根据节点的不同调用相应的 decode 方法。</p>
<h4 id="默克尔证明-1"><a href="#默克尔证明-1" class="headerlink" title="默克尔证明"></a>默克尔证明</h4><p>前面已经介绍了默克尔证明的原理，而且我们现在也有了 MPT 的基础，这里我们直接看默克尔证明的代码。默克尔证明的相关逻辑主要在 <code>trie/proof.go</code> 里。</p>
<h5 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.Putter)</span> <span class="title">error</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	nodes := []node&#123;&#125;</div><div class="line">	tn := t.root</div><div class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(key) &gt; <span class="number">0</span> &amp;&amp; tn != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">				tn = <span class="literal">nil</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				tn = n.Val</div><div class="line">				key = key[<span class="built_in">len</span>(n.Key):]</div><div class="line">			&#125;</div><div class="line">			nodes = <span class="built_in">append</span>(nodes, n)</div><div class="line">		<span class="keyword">case</span> *fullNode:</div><div class="line">			tn = n.Children[key[<span class="number">0</span>]]</div><div class="line">			key = key[<span class="number">1</span>:]</div><div class="line">			nodes = <span class="built_in">append</span>(nodes, n)</div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			<span class="keyword">var</span> err error</div><div class="line">			tn, err = t.resolveHash(n, <span class="literal">nil</span>)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				log.Error(fmt.Sprintf(<span class="string">"Unhandled trie error: %v"</span>, err))</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	hasher := newHasher(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">for</span> i, n := <span class="keyword">range</span> nodes &#123;</div><div class="line">		n, _, _ = hasher.hashChildren(n, <span class="literal">nil</span>)</div><div class="line">		hn, _ := hasher.store(n, <span class="literal">nil</span>, <span class="literal">false</span>)</div><div class="line">		<span class="keyword">if</span> hash, ok := hn.(hashNode); ok || i == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> fromLevel &gt; <span class="number">0</span> &#123;</div><div class="line">				fromLevel--</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				enc, _ := rlp.EncodeToBytes(n)</div><div class="line">				<span class="keyword">if</span> !ok &#123;</div><div class="line">					hash = crypto.Keccak256(enc)</div><div class="line">				&#125;</div><div class="line">				proofDb.Put(hash, enc)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Prove</code> 方法用来获取指定 key 的默克尔证明。这个方法会遍历整个 MPT，获取从根节点到叶子节点这条路径上的所有节点的 hash 值列表。对于 key 不匹配的情况，则会返回一个最长匹配的列表。</p>
<h5 id="VerifyProof"><a href="#VerifyProof" class="headerlink" title="VerifyProof"></a>VerifyProof</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyProof</span><span class="params">(rootHash common.Hash, key []<span class="keyword">byte</span>, proofDb DatabaseReader)</span> <span class="params">(value []<span class="keyword">byte</span>, nodes <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	key = keybytesToHex(key)</div><div class="line">	wantHash := rootHash</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</div><div class="line">		buf, _ := proofDb.Get(wantHash[:])</div><div class="line">		<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">"proof node %d (hash %064x) missing"</span>, i, wantHash)</div><div class="line">		&#125;</div><div class="line">		n, err := decodeNode(wantHash[:], buf, <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">"bad proof node %d: %v"</span>, i, err)</div><div class="line">		&#125;</div><div class="line">		keyrest, cld := get(n, key)</div><div class="line">		<span class="keyword">switch</span> cld := cld.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			key = keyrest</div><div class="line">			<span class="built_in">copy</span>(wantHash[:], cld)</div><div class="line">		<span class="keyword">case</span> valueNode:</div><div class="line">			<span class="keyword">return</span> cld, i + <span class="number">1</span>, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(tn node, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, node)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> *shortNode:</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			tn = n.Val</div><div class="line">			key = key[<span class="built_in">len</span>(n.Key):]</div><div class="line">		<span class="keyword">case</span> *fullNode:</div><div class="line">			tn = n.Children[key[<span class="number">0</span>]]</div><div class="line">			key = key[<span class="number">1</span>:]</div><div class="line">		<span class="keyword">case</span> hashNode:</div><div class="line">			<span class="keyword">return</span> key, n</div><div class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">			<span class="keyword">return</span> key, <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> valueNode:</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%T: invalid node: %v"</span>, tn, tn))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VerifyProof</code> 方法以 roothash，key，proof 证明为参数，验证 key 是否存在于 MPT 的某条路径里，如果 key 确实存在，返回这个节点的索引 i，err 字段是 nil，否则返回 error。</p>
<h4 id="MPT-安全性"><a href="#MPT-安全性" class="headerlink" title="MPT 安全性"></a>MPT 安全性</h4><h5 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h5><p>MPT 存储的 key-value 值没有长度限制，虽然说使用的是 Patricia Trie，仍然会有整棵树深度越来越深的问题，这可能会导致查询节点需要多次 IO，影响效率；导致 Dos 攻击。<br>以太坊中里，与 MPT 交互时，key 还会进行一次 sha3 的哈希计算，这样一来，key 的长度是固定的32字节，可以避免树里出现很深的路径，同时也实现了 key 的加密存储。</p>
<p>这部分代码在 <code>trie/secure_trie.go</code>，<code>trie/hasher.go</code>，<code>crypto/sha3</code> 里面，没有什么特别的，基本上就是对增删改查的操作做了一层加 keccak256 算法的封装。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>前文介绍过分支节点，以太坊想要在效率和存储空间上达到一个平衡，所以 fullNode 只有17个孩子节点，这个值是与16进制有关的，MPT 的 key 值实际上有三种编码方法，Raw 编码，Hex 编码，HP 编码，Raw 编码即原始的字节数组，这种方式的问题是它的一个字节的范围很大，fullNode 的子树这么多会影响检索效率，当树节点需要存储到数据库时，会根据16进制来进行编码，Hex 编码和 HP 编码没本质区别，可以理解为 Hex 编码是存在于内存的中间形式，在以太坊的黄皮书了介绍的是 Hex Prefix Encoding，即 HP 编码。我们一一来看。</p>
<h5 id="Raw-编码（keybytes-encoding）"><a href="#Raw-编码（keybytes-encoding）" class="headerlink" title="Raw 编码（keybytes encoding）"></a>Raw 编码（keybytes encoding）</h5><p>原生的 key 字节数组，不做修改，这种方式是 MPT 对外提供 API 的默认方式，如果数据需要插入到树里，Raw 编码需要转换为 Hex 编码。</p>
<h5 id="Hex-编码（hex-encoding）"><a href="#Hex-编码（hex-encoding）" class="headerlink" title="Hex 编码（hex encoding）"></a>Hex 编码（hex encoding）</h5><p>Hex 编码用于对内存里的树节点 key 进行编码，当树节点需要持久化到数据库时，Hex 编码被转换为 HP 编码。</p>
<p>具体来说，这个编码的每个字节包含 key 的半个字节，尾部加一个 byte 的『终结符』16，表示这是 hex 格式。节点被加载到内存时 key 使用的是这种编码，因为方便访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></div><div class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</div><div class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</div><div class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></div><div class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></div><div class="line">	&#125;</div><div class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></div><div class="line">	<span class="keyword">return</span> nibbles</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是 Raw 编码转换为 Hex 编码的代码。</p>
<h5 id="HP-编码（compact-encoding）"><a href="#HP-编码（compact-encoding）" class="headerlink" title="HP 编码（compact encoding）"></a>HP 编码（compact encoding）</h5><p>全称是 Hex Prefix 编码，hex 编码解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但这种方式有数据冗余的问题，对于 shortNode，目前 hex 格式下的 key，长度会是原来 keybytes 格式下的两倍，这一点对于节点的哈希计算影响很大，compact 编码用于对 hex 格式进行优化。compact encoding 的主要思路是将 Hex 格式字符串先恢复到 keybytes 格式，同时加入当前编码的标记位，表示奇偶不同长度的 hex 格式。</p>
<p>具体来说，compact 编码首先会将 hex 尾部标记的 byte 去掉，然后将原来 hex 编码的包含的 key 的半个字节（称为 nibble）一一合并为1 byte，最后如果 hex 格式编码有效长度为奇数，在头部增加 0011xxxx，其中 xxxx 为第一个 nibble，否则在头部增加 00100000。节点在写入数据库时使用的是 compact 编码，因为可以节约磁盘。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func hexToCompact(<span class="built_in">hex</span> []<span class="built_in">byte</span>) []<span class="built_in">byte</span> &#123;</div><div class="line">	terminator := <span class="built_in">byte</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> hasTerm(<span class="built_in">hex</span>) &#123;</div><div class="line">		terminator = <span class="number">1</span></div><div class="line">		<span class="built_in">hex</span> = <span class="built_in">hex</span>[:len(<span class="built_in">hex</span>)<span class="number">-1</span>]</div><div class="line">	&#125;</div><div class="line">	buf := make([]<span class="built_in">byte</span>, len(<span class="built_in">hex</span>)/<span class="number">2</span>+<span class="number">1</span>)</div><div class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span></div><div class="line">	<span class="keyword">if</span> len(<span class="built_in">hex</span>)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</div><div class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> </div><div class="line">		buf[<span class="number">0</span>] |= <span class="built_in">hex</span>[<span class="number">0</span>]</div><div class="line">		<span class="built_in">hex</span> = <span class="built_in">hex</span>[<span class="number">1</span>:]</div><div class="line">	&#125;</div><div class="line">	decodeNibbles(<span class="built_in">hex</span>, buf[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">return</span> buf</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果该节点有 value，则 teerminator 为1，其中 <code>buf[0] = terminator &lt;&lt; 5</code> 表示，如果是叶子节点，<code>buf[0]</code> 为 00100000，否则为 00000000，接下来的 <code>if len(hex)&amp;1 == 1</code> if 判断表示 hex 长度为奇数的情况，这时将 buf[0] 赋值为 0011xxxx，其中 xxxx 为 hex[0] 的值，即第一个 nibble 的值，最后调用 <code>decodeNibbles</code>，将两个两个的 nibble 字节合并为一个字节。以上就是 HP 编码的整个过程。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie</a></li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external">leetcode, 208. Implement Trie(Prefix Tree)</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="external">Wiki Patricia Tree</a></li>
<li><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">merkling-in-ethereum</a></li>
<li><a href="https://github.com/ethereumjs/merkle-patricia-tree" target="_blank" rel="external">ethereumjs/merkle-patricia-tree</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默克尔树是区块链的基础结构，在比特币里它用来存放区块内的所有交易，用一个数字指纹（hash）来表示整个交易集合，在以太坊中，提出了一种新的数据结构叫做 Merkle Patricia Tree（常用翻译：默克尔帕特里夏树，缩写是 MPT），在以太坊中它用来组织管理账户，交易，收据等数据。从名字或许可以看出来它是一个组合名字，它实际上是默克尔树和帕特里夏树两种数据结构的结合，在阅读 trie 模块之前，读者应该对默克尔树，帕特里夏树这两个数据结构有一定了解，这些是阅读源代码的基础知识，这里只做概述。下面我们先分别介绍这两种数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（rlp 模块-序列化与反序列化）/</id>
    <published>2018-03-10T14:35:01.000Z</published>
    <updated>2018-09-18T18:23:04.643Z</updated>
    
    <content type="html"><![CDATA[<p>RLP 的定义，作用，用法在 <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="external">wiki</a> 文档中有文字说明，这部分我们只做简单描述。</p>
<p>在<a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">黄皮书</a>里有 RLP 的形式化说明，这里我会总结一下，然后侧重于分析源码，讲解实现原理。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>RLP（Recursive Length Prefix）递归长度前缀是一种编码算法，用于编码任意嵌套结构的二进制数据，它是以太坊中数据序列化和反序列化的主要方法，区块、交易等数据结构在持久化时会先经过 RLP 编码再存储到数据库，p2p 网络中节点之间的数据传输也需要 RLP 的编码。</p>
<p>RLP 有两个特点：一个是递归，被编码的数据是递归的结构，编码算法也是递归进行处理的；二是长度前缀，RLP 编码都带有一个前缀，这个前缀与被编码数据长度相关。</p>
<p>根据定义，RLP 编码只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如<code>[&quot;cat&quot;,[&quot;puppy&quot;,&quot;cow&quot;],&quot;horse&quot;,[[]],&quot;pig&quot;,[&quot;&quot;],&quot;sheep&quot;]</code>就是一个复杂的列表。其他类型的数据需要转成以上的两类。</p>
<h2 id="规则和例子"><a href="#规则和例子" class="headerlink" title="规则和例子"></a>规则和例子</h2><p>在 <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP#definition" target="_blank" rel="external">wiki</a> 中有详细定义，这里不赘述。</p>
<h2 id="黄皮书里的形式化方法"><a href="#黄皮书里的形式化方法" class="headerlink" title="黄皮书里的形式化方法"></a>黄皮书里的形式化方法</h2><p>在<a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">黄皮书</a>中有 RLP 的形式化定义，形式化的描述比大白话更直观，这里我们做一下简单总结:</p>
<p>首先定义集合 T：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structures%20T.png" alt="rlp-structure-t"></p>
<p>$\mathbb{T}$ 表示所有的字节数组和树形结构的组合，$\mathbb{L}$ 表示不止单一节点的树形结构，如结构体，树节点的分支节点，非叶子节点。 $\mathbb{O}$ 表示所有 byte 的集合，$\mathbb{B}$ 表示所有可能的字节数组，</p>
<p>$\mathbb{T}$ 和 $\mathbb{L}$ 是 RLP 需要处理的两种结构。</p>
<p>RLP 可以用两个子函数描述：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20sub-functions.png" alt="rlp-structure-rlp"></p>
<p>其中：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20Rbx.png" alt="rlp-structure-rbx"></p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/RLP%20structure%20Rlx.png" alt="rlp-structure-rlx"></p>
<p>对于 $\mathbb{B}$ 类型的字节数组，处理规则是：</p>
<ul>
<li>如果字节数组只有一个字节，并且字节大小小于 128，编码结果就是它本身。</li>
<li>如果字节数组（字符串）长度小于56，编码结果是128加上字节数组长度的和作为前缀，再加上原始数据。由于被编码的字符串长度是<code>55=0x37</code>，因此单字节前缀的最大值是 <code>0x80+0x37=0xb7</code>，即编码的第一个字节的取值范围是 <code>[0x80, 0xb7]</code>。</li>
<li>如果字节数组长度大于等于56，编码结果是: 以183加上原始数据的长度的大端表示的长度作为前缀，加上原始数据长度的大端表示，再加上原始数据。</li>
</ul>
<p>其中 $\mathtt{\tiny BE}$ 实际上表示去掉前导0的大端模式。</p>
<p>对于 $\mathtt{T} $类型（树形结构），处理规则是：</p>
<ul>
<li>首先对树形结构里面的每一个元素使用 RLP 处理，然后将结果连接起来，记为 s。</li>
<li>如果连接后的字节长度小于56，编码结果是：以192加上连接后的长度作为前缀，加上连接后的结果，即 <code>0xc0</code> 加上列表的总长度，编码的第一个字节的取值范围是 <code>[0xc0, 0xf7]</code>。</li>
<li>如果连接后的字节长度大于56字节，编码结果是：以247加上连接后的长度的大端模式的长度的结果作为前缀，加上连接后的长度的大端模式，再加上列表中各元素项 RLP 编码的结果。即 <code>0xf7</code> 加上列表总长度的二进制形式的字节长度。编码的第一个字节的取值范围是 <code>[0xf8, 0xff]</code>。</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>RLP 包的源码在 rlp 目录下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">├── decode.<span class="keyword">go</span>                         # 解码器，反序列化的过程，将 RLP 数据解码为 Golang 数据结构</div><div class="line">├── decode_tail_test.<span class="keyword">go</span></div><div class="line">├── decode_test.<span class="keyword">go</span></div><div class="line">├── doc.<span class="keyword">go</span>                            # 包的文档</div><div class="line">├── encode.<span class="keyword">go</span>                         # 编码器，序列化的过程，将 Golang 数据编码为 RLP 结构数据</div><div class="line">├── encode_test.<span class="keyword">go</span></div><div class="line">├── encoder_example_test.<span class="keyword">go</span></div><div class="line">├── raw.<span class="keyword">go</span>                            # 没有解码的原生数据</div><div class="line">├── raw_test.<span class="keyword">go</span></div><div class="line">└── typecache.<span class="keyword">go</span>                      # 类型缓存，记录了类型 -&gt;（编码器|解码器）的内容</div></pre></td></tr></table></figure>
<p>测试代码也是很好的参考文档，有时候甚至比注释还好懂，可以好好看看。这里我们开始讲解序列化和反序列化的代码实现。</p>
<h3 id="typeinfo"><a href="#typeinfo" class="headerlink" title="typeinfo"></a>typeinfo</h3><p>上面提到，对于不同的类型，有不同的编码方式，在 C++ 这样的语言中，可以通过相同函数名，不同类型，也就是重载来实现不同类型的编码器的分派，也可以通过泛型实现分派。</p>
<p>Go 不支持这些语言级别的特性，为了实现函数分派，引入了 <code>typeinfo</code> 结构，可以根据类型快速找到编码器和解码器函数，这部分内容在 <code>rlp/typecache.go</code> 中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var (</div><div class="line">	typeCacheMutex sync.RWMutex</div><div class="line">	typeCache      = make(map[typekey]*typeinfo)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">typeinfo</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	decoder</div><div class="line">	writer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">tags</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	tail <span class="keyword">bool</span></div><div class="line">	ignored <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">typekey</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	reflect.Type</div><div class="line">	tags</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>typeCacheMutex</code> 是读写锁，在多线程的使用过程中保护 <code>typeCache</code>，<code>typeCache</code> 的作用是记录类型和编码器函数的对应关系。</p>
<h4 id="获取编码器，解码器"><a href="#获取编码器，解码器" class="headerlink" title="获取编码器，解码器"></a>获取编码器，解码器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo</span><span class="params">(typ reflect.Type, tags tags)</span> <span class="params">(*typeinfo, error)</span></span> &#123;</div><div class="line">	typeCacheMutex.RLock()</div><div class="line">	info := typeCache[typekey&#123;typ, tags&#125;]</div><div class="line">	typeCacheMutex.RUnlock()</div><div class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	typeCacheMutex.Lock()</div><div class="line">	<span class="keyword">defer</span> typeCacheMutex.Unlock()</div><div class="line">	<span class="keyword">return</span> cachedTypeInfo1(typ, tags)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo1</span><span class="params">(typ reflect.Type, tags tags)</span> <span class="params">(*typeinfo, error)</span></span> &#123;</div><div class="line">	key := typekey&#123;typ, tags&#125;</div><div class="line">	info := typeCache[key]</div><div class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	typeCache[key] = <span class="built_in">new</span>(typeinfo)</div><div class="line">	info, err := genTypeInfo(typ, tags)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">delete</span>(typeCache, key)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	*typeCache[key] = *info</div><div class="line">	<span class="keyword">return</span> typeCache[key], err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没能明白 <code>cachedTypeInfo</code> 和 <code>cachedTypeInfo1</code> 的真正区别是什么，有熟悉这块代码的朋友可以赐教一下。</p>
<p>获取编码器，解码器时，首先会从缓存中请求，如果没有命中的话再调用 <code>genTypeInfo</code>。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func genTypeInfo(<span class="keyword">typ</span> reflect.<span class="keyword">Type</span>, tags tags) (info *typeinfo, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	info = new(typeinfo)</div><div class="line">	<span class="keyword">if</span> info.decoder, <span class="keyword">err</span> = makeDecoder(<span class="keyword">typ</span>, tags); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> info.writer, <span class="keyword">err</span> = makeWriter(<span class="keyword">typ</span>, tags); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> info, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编码器和解码器大同小异，只是方向不同，这里我们以编码器为例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeWriter</span><span class="params">(typ <span class="built_in">reflect</span>.<span class="keyword">Type</span>, ts tags)</span></span> (writer, error) &#123;</div><div class="line">	kind := typ.<span class="type">Kind</span>()</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> typ == rawValueType:</div><div class="line">		<span class="keyword">return</span> writeRawValue, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> typ.<span class="type">Implements</span>(encoderInterface):</div><div class="line">		<span class="keyword">return</span> writeEncoder, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind != <span class="built_in">reflect</span>.<span class="type">Ptr</span> &amp;&amp; <span class="built_in">reflect</span>.<span class="type">PtrTo</span>(typ).<span class="type">Implements</span>(encoderInterface):</div><div class="line">		<span class="keyword">return</span> writeEncoderNoPtr, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Interface</span>:</div><div class="line">		<span class="keyword">return</span> writeInterface, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> typ.<span class="type">AssignableTo</span>(<span class="built_in">reflect</span>.<span class="type">PtrTo</span>(bigInt)):</div><div class="line">		<span class="keyword">return</span> writeBigIntPtr, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> typ.<span class="type">AssignableTo</span>(bigInt):</div><div class="line">		<span class="keyword">return</span> writeBigIntNoPtr, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> isUint(kind):</div><div class="line">		<span class="keyword">return</span> writeUint, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Bool</span>:</div><div class="line">		<span class="keyword">return</span> writeBool, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">String</span>:</div><div class="line">		<span class="keyword">return</span> writeString, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Slice</span> &amp;&amp; isByte(typ.<span class="type">Elem</span>()):</div><div class="line">		<span class="keyword">return</span> writeBytes, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Array</span> &amp;&amp; isByte(typ.<span class="type">Elem</span>()):</div><div class="line">		<span class="keyword">return</span> writeByteArray, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Slice</span> || kind == <span class="built_in">reflect</span>.<span class="type">Array</span>:</div><div class="line">		<span class="keyword">return</span> makeSliceWriter(typ, ts)</div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Struct</span>:</div><div class="line">		<span class="keyword">return</span> makeStructWriter(typ)</div><div class="line">	<span class="keyword">case</span> kind == <span class="built_in">reflect</span>.<span class="type">Ptr</span>:</div><div class="line">		<span class="keyword">return</span> makePtrWriter(typ)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"rlp: type %v is not RLP-serializable"</span>, typ)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>makeWriter</code> 实际上就是一堆 switch 分支，根据不同的类型，调用不同的编码方法。接下来我们会挑取几个典型方法来看。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>首先看字符串的编码方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(val reflect.Value, w *encbuf)</span> <span class="title">error</span></span> &#123;</div><div class="line">	s := val.String()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="number">0x7f</span> &#123;</div><div class="line">		w.str = <span class="built_in">append</span>(w.str, s[<span class="number">0</span>])</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		w.encodeStringHeader(<span class="built_in">len</span>(s))</div><div class="line">		w.str = <span class="built_in">append</span>(w.str, s...)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于字符串，如果只有一个字节，并且字节大小小于128，编码结果是其本身，这对应规则一的第1点。对于第2，第3种情况，调用 <code>encodeStringHeader</code>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func (w *encbuf) encodeStringHeader(size int) &#123;</div><div class="line">	<span class="keyword">if</span> size &lt; <span class="number">56</span> &#123;</div><div class="line">		w<span class="selector-class">.str</span> = append(w<span class="selector-class">.str</span>, <span class="number">0</span>x80+byte(size))</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		sizesize := putint(w<span class="selector-class">.sizebuf</span>[<span class="number">1</span>:], uint64(size))</div><div class="line">		w<span class="selector-class">.sizebuf</span>[<span class="number">0</span>] = <span class="number">0</span>xB7 + byte(sizesize)</div><div class="line">		w<span class="selector-class">.str</span> = append(w<span class="selector-class">.str</span>, w<span class="selector-class">.sizebuf</span>[:sizesize+<span class="number">1</span>]...)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果长度小于56，编码结果是128加上字节数组长度的和作为前缀再加上原始数据，这对应的是第2种情况，如果长度大于等于56，则编码结果是0x87加上原始数据长度的大端表示的长度作为前缀，再加上原始数据长度的大端表示，再加上原始数据，这对应的是第3种情况。</p>
<p>再看树形结构的编码方法。</p>
<p>实际上这里所指的树形结构就是结构体数据。对于普通的类型，例如字符串，整形，布尔型，我们可以直接调用对应的编码方法，往 encbuf 里填充数据，对于结构体类型，我们没法确定其具体结构，但每种类型都实现了 writer 这一类型，即 <code>type writer func(reflect.Value, *encbuf) error</code>，注意到 writer 类型与 <code>func writeString(val reflect.Value, w *encbuf) error</code> 这些编码方法的类型是一致的。因此我们可以用递归的方式解决结构体类型的编码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeStructWriter</span><span class="params">(typ reflect.Type)</span> <span class="params">(writer, error)</span></span> &#123;</div><div class="line">	fields, err := structFields(typ)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	writer := <span class="function"><span class="keyword">func</span><span class="params">(val reflect.Value, w *encbuf)</span> <span class="title">error</span></span> &#123;</div><div class="line">		lh := w.list()</div><div class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> fields &#123;</div><div class="line">			<span class="keyword">if</span> err := f.info.writer(val.Field(f.index), w); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		w.listEnd(lh)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> writer, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先拿到该结构体的所有字段，然后定义一个 <code>writer</code> 的匿名方法，即 <code>writer func(reflect.Value, *encbuf) error</code> 类型，这个方法可能会被递归调用，在这个方法中，遍历之前通过 <code>structFields</code> 拿到的所有字段，调用对应的 writer 方法，这些结果都会加入到 <code>w</code>(encbuf 类型)中，根据 RLP 编码的定义，需要根据树形结构的长度确定前缀的大小，这是通过 <code>list</code>, <code>listEnd</code>, <code>size</code>, <code>toBytes</code> 等方法实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">list</span><span class="params">()</span> *<span class="title">listhead</span></span> &#123;</div><div class="line">	lh := &amp;listhead&#123;offset: <span class="built_in">len</span>(w.str), size: w.lhsize&#125;</div><div class="line">	w.lheads = <span class="built_in">append</span>(w.lheads, lh)</div><div class="line">	<span class="keyword">return</span> lh</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">listEnd</span><span class="params">(lh *listhead)</span></span> &#123;</div><div class="line">	lh.size = w.size() - lh.offset - lh.size</div><div class="line">	<span class="keyword">if</span> lh.size &lt; <span class="number">56</span> &#123;</div><div class="line">		w.lhsize += <span class="number">1</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		w.lhsize += <span class="number">1</span> + intsize(<span class="keyword">uint64</span>(lh.size))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(w.str) + w.lhsize</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">toBytes</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	out := <span class="built_in">make</span>([]<span class="keyword">byte</span>, w.size())</div><div class="line">	strpos := <span class="number">0</span></div><div class="line">	pos := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> _, head := <span class="keyword">range</span> w.lheads &#123;</div><div class="line">		n := <span class="built_in">copy</span>(out[pos:], w.str[strpos:head.offset])</div><div class="line">		pos += n</div><div class="line">		strpos += n</div><div class="line">		enc := head.encode(out[pos:])</div><div class="line">		pos += <span class="built_in">len</span>(enc)</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">copy</span>(out[pos:], w.str[strpos:])</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>toBytes()</code> 是 <code>encbuf</code> 最后的处理逻辑，返回最终的 RLP 数据。</p>
<p>编码即序列化的整个流程就是这样，解码的过程就不赘述了，相反流程而已，最后看一下 encode 模块暴露的外部方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> outer, ok := w.(*encbuf); ok &#123;</div><div class="line">		<span class="keyword">return</span> outer.encode(val)</div><div class="line">	&#125;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	<span class="keyword">defer</span> encbufPool.Put(eb)</div><div class="line">	eb.reset()</div><div class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> eb.toWriter(w)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToBytes</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	<span class="keyword">defer</span> encbufPool.Put(eb)</div><div class="line">	eb.reset()</div><div class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> eb.toBytes(), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToReader</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(size <span class="keyword">int</span>, r io.Reader, err error)</span></span> &#123;</div><div class="line">	eb := encbufPool.Get().(*encbuf)</div><div class="line">	eb.reset()</div><div class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> eb.size(), &amp;encReader&#123;buf: eb&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Encode</code>， <code>EncodeToBytes</code>，<code>EncodeToReader</code> 等方法将值编码到 <code>io.Writer</code>, <code>Bytes</code>, <code>reader</code> 等等，它们有一个共同点，都调用了 encode 这个内部方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">encode</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	rval := reflect.ValueOf(val)</div><div class="line">	ti, err := cachedTypeInfo(rval.Type(), tags&#123;&#125;)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ti.writer(rval, w)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>encode</code> 方法会从 <code>cachedTypeInfo</code> 中获得某类型对应的编码器，然后调用 <code>writer</code> 方法，结果就能写到 <code>encbuf</code> 类型中。<code>EncodeToBytes</code>，<code>EncodeToReader</code> 等只是最后调用的方法不一致，如果是调用 <code>toBytes</code>，则返回经过 RLP 编码的字节码数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="external">ethereum/wiki RLP</a></li>
<li><a href="https://github.com/ethereum/yellowpaper" target="_blank" rel="external">ethereum yellowpaper</a></li>
<li><a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/#rlp" target="_blank" rel="external">深入ethereum源码-p2p模块基础结构</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RLP 的定义，作用，用法在 &lt;a href=&quot;https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wiki&lt;/a&gt; 文档中有文字说明，这部分我们只做简单描述。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/ethereum/yellowpaper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;黄皮书&lt;/a&gt;里有 RLP 的形式化说明，这里我会总结一下，然后侧重于分析源码，讲解实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（core 模块-区块链操作）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（core 模块-区块链操作）/</id>
    <published>2018-03-10T14:35:00.000Z</published>
    <updated>2018-08-29T02:15:16.788Z</updated>
    
    <content type="html"><![CDATA[<p>区块链区块链，即区块组成的链，不妨先从区块谈起。这一篇我们将着眼于区块链的一些基本操作。在区块链中，区块存储有效信息，在阅读源代码之前，我们应该对区块头，区块体，区块链这些基本的数据结构有所了解。</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>Block</code>, <code>Header</code>, <code>BlockChain</code> 的数据结构请查阅 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></p>
<h2 id="区块链基本操作"><a href="#区块链基本操作" class="headerlink" title="区块链基本操作"></a>区块链基本操作</h2><h3 id="创世区块"><a href="#创世区块" class="headerlink" title="创世区块"></a>创世区块</h3><p>在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a> 这一篇，我们提到有一个 <code>geth init</code> 命令，它可以用来创建创世区块。如果我们将本地的 geth 节点连接测试网络或主网的话，我们不会再进行创世区块的创建，因为区块链已经存在了，这时候应该是从其他节点进行同步。而如果我们需要运行一个私有链的话，这时候就需要一个创建一个创世区块。这部分代码在 <code>core/genesis.go</code> 中。</p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>genesis.go</code> 会定义创世区块的数据结构，提供创建，查询创世区块的方法。</p>
<p>首先看 Genesis 结构体，它定义了创世区块应包含的数据。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type Genesis struct &#123;</div><div class="line">	Config     *params.ChainConfig `<span class="string">json:</span><span class="string">"config"</span>`</div><div class="line">	Nonce      uint64              `<span class="string">json:</span><span class="string">"nonce"</span>`</div><div class="line">	Timestamp  uint64              `<span class="string">json:</span><span class="string">"timestamp"</span>`</div><div class="line">	ExtraData  []<span class="keyword">byte</span>              `<span class="string">json:</span><span class="string">"extraData"</span>`</div><div class="line">	GasLimit   uint64              `<span class="string">json:</span><span class="string">"gasLimit"</span>   <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Difficulty *big.Int            `<span class="string">json:</span><span class="string">"difficulty"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Mixhash    common.Hash         `<span class="string">json:</span><span class="string">"mixHash"</span>`</div><div class="line">	Coinbase   common.Address      `<span class="string">json:</span><span class="string">"coinbase"</span>`</div><div class="line">	Alloc      GenesisAlloc        `<span class="string">json:</span><span class="string">"alloc"</span>      <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line"></div><div class="line">	Number     uint64      `<span class="string">json:</span><span class="string">"number"</span>`</div><div class="line">	GasUsed    uint64      `<span class="string">json:</span><span class="string">"gasUsed"</span>`</div><div class="line">	ParentHash common.Hash `<span class="string">json:</span><span class="string">"parentHash"</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>伴随创世区块的还有创世账户。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">type</span> GenesisAlloc <span class="meta">map</span>[<span class="meta">common</span>.<span class="keyword">Address]GenesisAccount</span></div><div class="line"></div><div class="line"><span class="symbol">type</span> GenesisAccount <span class="keyword">struct </span>&#123;</div><div class="line">	<span class="meta">Code</span>       []<span class="keyword">byte </span>                     `json:<span class="string">"code,omitempty"</span>`</div><div class="line">	Storage    <span class="meta">map</span>[<span class="meta">common</span>.Hash]<span class="meta">common</span>.Hash `json:<span class="string">"storage,omitempty"</span>`</div><div class="line">	<span class="keyword">Balance </span>   *<span class="keyword">big.Int </span>                   `json:<span class="string">"balance"</span> gencodec:<span class="string">"required"</span>`</div><div class="line">	Nonce      uint64                      `json:<span class="string">"nonce,omitempty"</span>`</div><div class="line">	PrivateKey []<span class="keyword">byte </span>                     `json:<span class="string">"secretKey,omitempty"</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h4><p><code>SetupGenesisBlock</code> 函数用来在数据库中写入创世区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupGenesisBlock</span><span class="params">(db ethdb.Database, genesis *Genesis)</span> <span class="params">(*params.ChainConfig, common.Hash, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &amp;&amp; genesis.Config == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> params.AllEthashProtocolChanges, common.Hash&#123;&#125;, errGenesisNoConfig</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stored := rawdb.ReadCanonicalHash(db, <span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> (stored == common.Hash&#123;&#125;) &#123;</div><div class="line">		<span class="keyword">if</span> genesis == <span class="literal">nil</span> &#123;</div><div class="line">			log.Info(<span class="string">"Writing default main-net genesis block"</span>)</div><div class="line">			genesis = DefaultGenesisBlock()</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			log.Info(<span class="string">"Writing custom genesis block"</span>)</div><div class="line">		&#125;</div><div class="line">		block, err := genesis.Commit(db)</div><div class="line">		<span class="keyword">return</span> genesis.Config, block.Hash(), err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &#123;</div><div class="line">		hash := genesis.ToBlock(<span class="literal">nil</span>).Hash()</div><div class="line">		<span class="keyword">if</span> hash != stored &#123;</div><div class="line">			<span class="keyword">return</span> genesis.Config, hash, &amp;GenesisMismatchError&#123;stored, hash&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	newcfg := genesis.configOrDefault(stored)</div><div class="line">	storedcfg := rawdb.ReadChainConfig(db, stored)</div><div class="line">	<span class="keyword">if</span> storedcfg == <span class="literal">nil</span> &#123;</div><div class="line">		log.Warn(<span class="string">"Found genesis block without chain config"</span>)</div><div class="line">		rawdb.WriteChainConfig(db, stored, newcfg)</div><div class="line">		<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> genesis == <span class="literal">nil</span> &amp;&amp; stored != params.MainnetGenesisHash &#123;</div><div class="line">		<span class="keyword">return</span> storedcfg, stored, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	height := rawdb.ReadHeaderNumber(db, rawdb.ReadHeadHeaderHash(db))</div><div class="line">	<span class="keyword">if</span> height == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> newcfg, stored, fmt.Errorf(<span class="string">"missing block number for head header hash"</span>)</div><div class="line">	&#125;</div><div class="line">	compatErr := storedcfg.CheckCompatible(newcfg, *height)</div><div class="line">	<span class="keyword">if</span> compatErr != <span class="literal">nil</span> &amp;&amp; *height != <span class="number">0</span> &amp;&amp; compatErr.RewindTo != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> newcfg, stored, compatErr</div><div class="line">	&#125;</div><div class="line">	rawdb.WriteChainConfig(db, stored, newcfg)</div><div class="line">	<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SetupGenesisBlock</code> 会根据创世区块返回一个区块链的配置。从 db 参数中拿到的区块里如果没有创世区块的话，首先提交一个新区块。接着通过调用 <code>genesis.configOrDefault(stored)</code> 拿到当前链的配置，测试兼容性后将配置写回 DB 中。最后返回区块链的配置信息。</p>
<p><code>Genesis</code> 有一个 <code>ToBlock</code> 方法，它会根据 <code>Genesis</code> 的数据，使用基于内存的数据库，创建一个区块并返回（通过 <code>types.NewBlock</code>）。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func (<span class="name">g</span> *Genesis) ToBlock(db ethdb.Database) *types.Block &#123;</div><div class="line">	if db == <span class="literal">nil</span> &#123;</div><div class="line">		db, _ = ethdb.NewMemDatabase()</div><div class="line">	&#125;</div><div class="line">	statedb, _ <span class="symbol">:=</span> state.New(<span class="name">common</span>.Hash&#123;&#125;, state.NewDatabase(<span class="name">db</span>))</div><div class="line">	for addr, account <span class="symbol">:=</span> range g.Alloc &#123;</div><div class="line">		statedb.AddBalance(<span class="name">addr</span>, account.Balance)</div><div class="line">		statedb.SetCode(<span class="name">addr</span>, account.Code)</div><div class="line">		statedb.SetNonce(<span class="name">addr</span>, account.Nonce)</div><div class="line">		for key, value <span class="symbol">:=</span> range account.Storage &#123;</div><div class="line">			statedb.SetState(<span class="name">addr</span>, key, value)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	root <span class="symbol">:=</span> statedb.IntermediateRoot(<span class="name">false</span>)</div><div class="line">	head <span class="symbol">:=</span> <span class="symbol">&amp;types</span>.Header&#123;</div><div class="line">		Number:     new(<span class="name">big</span>.Int).SetUint64(<span class="name">g</span>.Number),</div><div class="line">		Nonce:      types.EncodeNonce(<span class="name">g</span>.Nonce),</div><div class="line">		Time:       new(<span class="name">big</span>.Int).SetUint64(<span class="name">g</span>.Timestamp),</div><div class="line">		ParentHash: g.ParentHash,</div><div class="line">		Extra:      g.ExtraData,</div><div class="line">		GasLimit:   g.GasLimit,</div><div class="line">		GasUsed:    g.GasUsed,</div><div class="line">		Difficulty: g.Difficulty,</div><div class="line">		MixDigest:  g.Mixhash,</div><div class="line">		Coinbase:   g.Coinbase,</div><div class="line">		Root:       root,</div><div class="line">	&#125;</div><div class="line">	if g.GasLimit == <span class="number">0</span> &#123;</div><div class="line">		head.GasLimit = params.GenesisGasLimit</div><div class="line">	&#125;</div><div class="line">	if g.Difficulty == <span class="literal">nil</span> &#123;</div><div class="line">		head.Difficulty = params.GenesisDifficulty</div><div class="line">	&#125;</div><div class="line">	statedb.Commit(<span class="name">false</span>)</div><div class="line">	statedb.Database().TrieDB().Commit(<span class="name">root</span>, true)</div><div class="line"></div><div class="line">	return types.NewBlock(<span class="name">head</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Commit 方法将给定的 <code>genesis</code> 的区块和 <code>state</code> 写入数据库。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">g</span> *Genesis) Commit(<span class="keyword">db</span> ethdb.Database) (*types.Block, <span class="keyword">error</span>) &#123;</div><div class="line">	block := <span class="keyword">g</span>.ToBlock(<span class="keyword">db</span>)</div><div class="line">	<span class="keyword">if</span> block.Number().<span class="built_in">Sign</span>() != 0 &#123;</div><div class="line">		<span class="keyword">return</span> nil, fmt.Errorf(<span class="string">"can't commit genesis block with number &gt; 0"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteTd(<span class="keyword">db</span>, block.Hash(), block.NumberU64(), <span class="keyword">g</span>.Difficulty); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteBlock(<span class="keyword">db</span>, block); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteBlockReceipts(<span class="keyword">db</span>, block.Hash(), block.NumberU64(), nil); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteCanonicalHash(<span class="keyword">db</span>, block.Hash(), block.NumberU64()); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteHeadBlockHash(<span class="keyword">db</span>, block.Hash()); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := WriteHeadHeaderHash(<span class="keyword">db</span>, block.Hash()); <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line">	config := <span class="keyword">g</span>.Config</div><div class="line">	<span class="keyword">if</span> config == nil &#123;</div><div class="line">		config = params.AllEthashProtocolChanges</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> block, WriteChainConfig(<span class="keyword">db</span>, block.Hash(), config)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-NewBlockChain-初始化区块链"><a href="#使用-NewBlockChain-初始化区块链" class="headerlink" title="使用 NewBlockChain 初始化区块链"></a>使用 <code>NewBlockChain</code> 初始化区块链</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">(db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig, engine consensus.Engine, vmConfig vm.Config)</span> <span class="params">(*BlockChain, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> cacheConfig == <span class="literal">nil</span> &#123;</div><div class="line">		cacheConfig = &amp;CacheConfig&#123;</div><div class="line">			TrieNodeLimit: <span class="number">256</span> * <span class="number">1024</span> * <span class="number">1024</span>,</div><div class="line">			TrieTimeLimit: <span class="number">5</span> * time.Minute,</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bodyCache, _ := lru.New(bodyCacheLimit)</div><div class="line">	bodyRLPCache, _ := lru.New(bodyCacheLimit)</div><div class="line">	blockCache, _ := lru.New(blockCacheLimit)</div><div class="line">	futureBlocks, _ := lru.New(maxFutureBlocks)</div><div class="line">	badBlocks, _ := lru.New(badBlockLimit)</div><div class="line"></div><div class="line">	bc := &amp;BlockChain&#123;</div><div class="line">		chainConfig:  chainConfig,</div><div class="line">		cacheConfig:  cacheConfig,</div><div class="line">		db:           db,</div><div class="line">		triegc:       prque.New(),</div><div class="line">		stateCache:   state.NewDatabase(db),</div><div class="line">		quit:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		bodyCache:    bodyCache,</div><div class="line">		bodyRLPCache: bodyRLPCache,</div><div class="line">		blockCache:   blockCache,</div><div class="line">		futureBlocks: futureBlocks,</div><div class="line">		engine:       engine,</div><div class="line">		vmConfig:     vmConfig,</div><div class="line">		badBlocks:    badBlocks,</div><div class="line">	&#125;</div><div class="line">	bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))</div><div class="line">	bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))</div><div class="line"></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> bc.genesisBlock == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoGenesis</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</div><div class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</div><div class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</div><div class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</div><div class="line">				log.Error(<span class="string">"Found bad hash, rewinding chain"</span>, <span class="string">"number"</span>, header.Number, <span class="string">"hash"</span>, header.ParentHash)</div><div class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>)</div><div class="line">				log.Error(<span class="string">"Chain rewind was successful, resuming normal operation"</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> bc.update()</div><div class="line">	<span class="keyword">return</span> bc, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BlockChain</code> 的初始化需要 <code>ethdb.Database</code>,  <code>*CacheConfig</code>, <code>params.ChainConfig</code>， <code>consensus.Engine</code>，<code>vm.Config</code> 参数。它们分别表示 db 对象；缓存配置（在 <code>core/blockchain.go</code> 中定义）；区块链配置（可通过 <code>core/genesis.go</code> 中的 <code>SetupGenesisBlock</code> 拿到）；一致性引擎（可通过 <code>core/blockchain.go</code> 中的 <code>CreateConsensusEngine</code> 得到）；虚拟机配置（通过 <code>core/vm</code> 定义）这些实参需要提前定义，以 eth 的 <code>backend.go</code> 为例，你可以在初始化 Ethereum 对象时看到这些参数是怎么初始化的，当然你也可以查看对应的测试代码学习 <code>NewBlockChain</code> 如何使用。</p>
<p>回到 <code>NewBlockChain</code> 的具体代码，首先判断是否有默认 <code>cacheConfig</code>，如果没有根据默认配置创建 <code>cacheConfig</code>，再通过 hashicorp 公司的 lru 模块创建 <code>bodyCache</code>, <code>bodyRLPCache</code> 等缓存对象（lru 是 last recently used 的缩写，常见数据结构，不了解的朋友请自行查阅相关资料），根据这些信息创建 <code>BlockChain</code> 对象，然后通过调用 <code>BlockChain</code> 的 <code>SetValidator</code> 和 <code>SetProcessor</code> 方法创建验证器和处理器，接下来通过 <code>NewHeaderChain</code> 获得区块头，尝试判断创始区块是否存在，<code>bc.loadLastState()</code> 加载区块最新状态，最后检查当前状态，确保本地运行的区块链上没有非法的区块。接下来我们深入到 <code>loadLastState</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">loadLastState</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	head := GetHeadBlockHash(bc.db)</div><div class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</div><div class="line">		log.Warn(<span class="string">"Empty database, resetting chain"</span>)</div><div class="line">		<span class="keyword">return</span> bc.Reset()</div><div class="line">	&#125;</div><div class="line">	currentBlock := bc.GetBlockByHash(head)</div><div class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</div><div class="line">		log.Warn(<span class="string">"Head block missing, resetting chain"</span>, <span class="string">"hash"</span>, head)</div><div class="line">		<span class="keyword">return</span> bc.Reset()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Warn(<span class="string">"Head state missing, repairing chain"</span>, <span class="string">"number"</span>, currentBlock.Number(), <span class="string">"hash"</span>, currentBlock.Hash())</div><div class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bc.currentBlock.Store(currentBlock)</div><div class="line"></div><div class="line">	currentHeader := currentBlock.Header()</div><div class="line">	<span class="keyword">if</span> head := GetHeadHeaderHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</div><div class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(head); header != <span class="literal">nil</span> &#123;</div><div class="line">			currentHeader = header</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	bc.hc.SetCurrentHeader(currentHeader)</div><div class="line">	</div><div class="line">	bc.currentFastBlock.Store(currentBlock)</div><div class="line">	<span class="keyword">if</span> head := GetHeadFastBlockHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</div><div class="line">		<span class="keyword">if</span> block := bc.GetBlockByHash(head); block != <span class="literal">nil</span> &#123;</div><div class="line">			bc.currentFastBlock.Store(block)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Issue a status log for the user</span></div><div class="line">	<span class="comment">// ... </span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadLastState</code> 会从数据库中加载区块链状态，首先通过 <code>GetHeadBlockHash</code> 从数据库中取得当前区块头，如果当前区块不存在，即数据库为空的话，通过 <code>Reset</code> 将创始区块写入数据库以达到重置目的。如果当前区块不存在，同样通过 <code>Reset</code> 重置。接下来确认当前区块的世界状态是否正确，世界状态这是一个稍特别的概念，这个过程我们将在之后的文章中描述。如果有问题，则通过 <code>repair</code> 进行修复，<code>repair</code> 中是一个死循环，它会一直回溯当前区块，直到找到对应的世界状态。然后通过 <code>bc.hc.SetCurrentHeader</code> 设置当前区块头，并恢复快速同步区块。</p>
<p>在 <code>NewBlockChain</code> 调用 <code>loadLastState</code> 之后，会判断是否需要硬分叉，<code>BadHashes</code> 是手工配置的区块 hash 值，根据这些值我们可以决定是否以及如何进行硬分叉。最后以 goroutine 的方式调用 <code>bc.update()</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> (<span class="selector-tag">bc</span> *<span class="selector-tag">BlockChain</span>) <span class="selector-tag">update</span>() &#123;</div><div class="line">	<span class="attribute">futureTimer </span>:= time.<span class="built_in">Tick</span>(5 * time.Second)</div><div class="line">	for &#123;</div><div class="line">		select &#123;</div><div class="line">		case &lt;-futureTimer:</div><div class="line">			bc.<span class="built_in">procFutureBlocks</span>()</div><div class="line">		case &lt;-bc.quit:</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>update()</code> 的作用是定时处理 Future 区块，简单地来说就是定时调用 <code>procFutureBlocks</code>。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">func</span> (<span class="keyword">bc </span>*<span class="keyword">BlockChain) </span>procFutureBlocks() &#123;</div><div class="line">	<span class="keyword">blocks </span>:= make([]*types.<span class="keyword">Block, </span><span class="number">0</span>, <span class="keyword">bc.futureBlocks.Len())</span></div><div class="line">	for _, hash := range <span class="keyword">bc.futureBlocks.Keys() </span>&#123;</div><div class="line">		<span class="meta">if</span> <span class="keyword">block, </span>exist := <span class="keyword">bc.futureBlocks.Peek(hash); </span>exist &#123;</div><div class="line">			<span class="keyword">blocks </span>= append(<span class="keyword">blocks, </span><span class="keyword">block.(*types.Block))</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">if</span> len(<span class="keyword">blocks) </span>&gt; <span class="number">0</span> &#123;</div><div class="line">		types.<span class="keyword">BlockBy(types.Number).Sort(blocks)</span></div><div class="line">		for i := range <span class="keyword">blocks </span>&#123;</div><div class="line">			<span class="keyword">bc.InsertChain(blocks[i </span>: i+<span class="number">1</span>])</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>procFutureBlocks</code> 可以从 <code>futureBlocks</code> 拿到需要插入的区块，最终会调用 <code>InsertChain</code> 将区块插入到区块链中。</p>
<h3 id="插入区块"><a href="#插入区块" class="headerlink" title="插入区块"></a>插入区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">InsertChain</span><span class="params">(chain types.Blocks)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</div><div class="line">	n, events, logs, err := bc.insertChain(chain)</div><div class="line">	bc.PostChainEvents(events, logs)</div><div class="line">	<span class="keyword">return</span> n, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>InsertChain</code> 将尝试将给定的区块插入到规范的区块链中，或者创建一个分支，插入后，会通过 <code>PostChainEvents</code> 触发所有事件。下面我们看看 <code>insertChain</code> 的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">insertChain</span><span class="params">(chain types.Blocks)</span> <span class="params">(<span class="keyword">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, error)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(chain); i++ &#123;</div><div class="line">		<span class="keyword">if</span> chain[i].NumberU64() != chain[i<span class="number">-1</span>].NumberU64()+<span class="number">1</span> || chain[i].ParentHash() != chain[i<span class="number">-1</span>].Hash() &#123;</div><div class="line">			log.Error(<span class="string">"Non contiguous block insert"</span>, <span class="string">"number"</span>, chain[i].Number(), <span class="string">"hash"</span>, chain[i].Hash(),</div><div class="line">				<span class="string">"parent"</span>, chain[i].ParentHash(), <span class="string">"prevnumber"</span>, chain[i<span class="number">-1</span>].Number(), <span class="string">"prevhash"</span>, chain[i<span class="number">-1</span>].Hash())</div><div class="line"></div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"non contiguous insert: item %d is #%d [%x…], item %d is #%d [%x…] (parent [%x…])"</span>, i<span class="number">-1</span>, chain[i<span class="number">-1</span>].NumberU64(),</div><div class="line">				chain[i<span class="number">-1</span>].Hash().Bytes()[:<span class="number">4</span>], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:<span class="number">4</span>], chain[i].ParentHash().Bytes()[:<span class="number">4</span>])</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		stats         = insertStats&#123;startTime: mclock.Now()&#125;</div><div class="line">		events        = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(chain))</div><div class="line">		lastCanon     *types.Block</div><div class="line">		coalescedLogs []*types.Log</div><div class="line">	)</div><div class="line">	headers := <span class="built_in">make</span>([]*types.Header, <span class="built_in">len</span>(chain))</div><div class="line">	seals := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(chain))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</div><div class="line">		headers[i] = block.Header()</div><div class="line">		seals[i] = <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">	abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(abort)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">		<span class="comment">// Wait for the block's verification to complete ...</span></div><div class="line">		bstart := time.Now()</div><div class="line"></div><div class="line">		err := &lt;-results</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			err = bc.Validator().ValidateBody(block)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> &#123;</div><div class="line">		<span class="keyword">case</span> err == ErrKnownBlock:</div><div class="line">			<span class="keyword">if</span> bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() &#123;</div><div class="line">				stats.ignored++</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> err == consensus.ErrFutureBlock:</div><div class="line">			max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)</div><div class="line">			<span class="keyword">if</span> block.Time().Cmp(max) &gt; <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">return</span> i, events, coalescedLogs, fmt.Errorf(<span class="string">"future block: %v &gt; %v"</span>, block.Time(), max)</div><div class="line">			&#125;</div><div class="line">			bc.futureBlocks.Add(block.Hash(), block)</div><div class="line">			stats.queued++</div><div class="line">			<span class="keyword">continue</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> err == consensus.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):</div><div class="line">			bc.futureBlocks.Add(block.Hash(), block)</div><div class="line">			stats.queued++</div><div class="line">			<span class="keyword">continue</span></div><div class="line"></div><div class="line">		<span class="keyword">case</span> err == consensus.ErrPrunedAncestor:</div><div class="line">			currentBlock := bc.CurrentBlock()</div><div class="line">			localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</div><div class="line">			externTd := <span class="built_in">new</span>(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>), block.Difficulty())</div><div class="line">			<span class="keyword">if</span> localTd.Cmp(externTd) &gt; <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">if</span> err = bc.WriteBlockWithoutState(block, externTd); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">var</span> winner []*types.Block</div><div class="line"></div><div class="line">			parent := bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</div><div class="line">			<span class="keyword">for</span> !bc.HasState(parent.Root()) &#123;</div><div class="line">				winner = <span class="built_in">append</span>(winner, parent)</div><div class="line">				parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()<span class="number">-1</span>)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(winner)/<span class="number">2</span>; j++ &#123;</div><div class="line">				winner[j], winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j] = winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j], winner[j]</div><div class="line">			&#125;</div><div class="line">			bc.chainmu.Unlock()</div><div class="line">			_, evs, logs, err := bc.insertChain(winner)</div><div class="line">			bc.chainmu.Lock()</div><div class="line">			events, coalescedLogs = evs, logs</div><div class="line"></div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</div><div class="line">			bc.reportBlock(block, <span class="literal">nil</span>, err)</div><div class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">var</span> parent *types.Block</div><div class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</div><div class="line">			parent = bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			parent = chain[i<span class="number">-1</span>]</div><div class="line">		&#125;</div><div class="line">		state, err := state.New(parent.Root(), bc.stateCache)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			bc.reportBlock(block, receipts, err)</div><div class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			bc.reportBlock(block, receipts, err)</div><div class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		proctime := time.Since(bstart)</div><div class="line"></div><div class="line">		status, err := bc.WriteBlockWithState(block, receipts, state)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> status &#123;</div><div class="line">		<span class="keyword">case</span> CanonStatTy:</div><div class="line">			log.Debug(<span class="string">"Inserted new block"</span>, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, block.Hash(), <span class="string">"uncles"</span>, <span class="built_in">len</span>(block.Uncles()),</div><div class="line">				<span class="string">"txs"</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">"gas"</span>, block.GasUsed(), <span class="string">"elapsed"</span>, common.PrettyDuration(time.Since(bstart)))</div><div class="line"></div><div class="line">			coalescedLogs = <span class="built_in">append</span>(coalescedLogs, logs...)</div><div class="line">			blockInsertTimer.UpdateSince(bstart)</div><div class="line">			events = <span class="built_in">append</span>(events, ChainEvent&#123;block, block.Hash(), logs&#125;)</div><div class="line">			lastCanon = block</div><div class="line"></div><div class="line">			bc.gcproc += proctime</div><div class="line"></div><div class="line">		<span class="keyword">case</span> SideStatTy:</div><div class="line">			log.Debug(<span class="string">"Inserted forked block"</span>, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, block.Hash(), <span class="string">"diff"</span>, block.Difficulty(), <span class="string">"elapsed"</span>,</div><div class="line">				common.PrettyDuration(time.Since(bstart)), <span class="string">"txs"</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">"gas"</span>, block.GasUsed(), <span class="string">"uncles"</span>, <span class="built_in">len</span>(block.Uncles()))</div><div class="line"></div><div class="line">			blockInsertTimer.UpdateSince(bstart)</div><div class="line">			events = <span class="built_in">append</span>(events, ChainSideEvent&#123;block&#125;)</div><div class="line">		&#125;</div><div class="line">		stats.processed++</div><div class="line">		stats.usedGas += usedGas</div><div class="line">		stats.report(chain, i, bc.stateCache.TrieDB().Size())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</div><div class="line">		events = <span class="built_in">append</span>(events, ChainHeadEvent&#123;lastCanon&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>, events, coalescedLogs, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先做一个健康检查，确保要插入的链是有序且相互连接的。接下来通过 <code>bc.engine.VerifyHeaders</code> 调用一致性引擎来验证区块头是有效的。进入 <code>for i, block := range chain</code> 循环后，接收 <code>results</code> 这个 chan，可以获得一致性引擎获得区块头的结果，如果是已经插入的区块，跳过；如果是未来的区块，时间距离不是很长，加入到 <code>futureBlocks</code> 中，否则返回一条错误信息；如果没能找到该区块祖先，但在 <code>futureBlocks</code> 能找到，也加入到 <code>futureBlocks</code> 中。</p>
<p>加入 <code>futureBlocks</code> 的过程结束后，通过 <code>core/state_processor.go</code> 中的 Process 改变世界状态（关于世界状态的管理，可以阅读后续的文章 <a href="#TODO">go-ethereum 源码笔记（core 模块-状态管理）</a>）。在返回收据，日志，使用的 Gas 后。通过 <code>bc.Validator().ValidateState</code> 再次验证，通过后，通过 <code>WriteBlockAndState</code> 写入区块以及相关状态到区块链，<code>WriteBlockAndState</code> 我们接下来会详谈。最后，如果我们生成了一个新的区块头，最新的区块头等于 <code>lastCanon</code> 的哈希值，发布一个 <code>ChainHeadEvent</code> 的事件。</p>
<p>现在我们来看看 <code>WriteBlockAndState</code> 是如何写入区块及相关状态到区块链的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">func (bc *BlockChain) WriteBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) (status WriteStatus, err <span class="keyword">error</span>) &#123;</div><div class="line">	ptd := bc.GetTd(block.ParentHash(), block.NumberU64()-1)</div><div class="line">	<span class="keyword">if</span> ptd == nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, consensus.ErrUnknownAncestor</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	currentBlock := bc.CurrentBlock()</div><div class="line">	localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</div><div class="line">	externTd := <span class="keyword">new</span>(big.Int).Add(block.Difficulty(), ptd)</div><div class="line">	<span class="keyword">if</span> err := bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd); err != nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	batch := bc.db.NewBatch()</div><div class="line">	<span class="keyword">if</span> err := WriteBlock(batch, block); err != nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	root, err := state.Commit(bc.chainConfig.IsEIP158(block.Number()))</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	triedb := bc.stateCache.TrieDB()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> bc.cacheConfig.Disabled &#123;</div><div class="line">		<span class="keyword">if</span> err := triedb.Commit(root, <span class="keyword">false</span>); err != nil &#123;</div><div class="line">			<span class="keyword">return</span> NonStatTy, err</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		triedb.Reference(root, common.Hash&#123;&#125;)</div><div class="line">		bc.triegc.Push(root, -float32(block.NumberU64()))</div><div class="line"></div><div class="line">		<span class="keyword">if</span> current := block.NumberU64(); current &gt; triesInMemory &#123;</div><div class="line">			header := bc.GetHeaderByNumber(current - triesInMemory)</div><div class="line">			chosen := header.Number.Uint64()</div><div class="line"></div><div class="line">			var (</div><div class="line">				size  = triedb.Size()</div><div class="line">				limit = common.StorageSize(bc.cacheConfig.TrieNodeLimit) * 1024 * 1024</div><div class="line">			)</div><div class="line">			<span class="keyword">if</span> size &gt; limit || bc.gcproc &gt; bc.cacheConfig.TrieTimeLimit &#123;</div><div class="line">				<span class="keyword">if</span> chosen &lt; lastWrite+triesInMemory &#123;</div><div class="line">					<span class="keyword">switch</span> &#123;</div><div class="line">					<span class="keyword">case</span> size &gt;= <span class="number">2</span>*limit:</div><div class="line">						log.Warn(<span class="string">"State memory usage too high, committing"</span>, <span class="string">"size"</span>, size, <span class="string">"limit"</span>, limit, <span class="string">"optimum"</span>, float64(chosen-lastWrite)/triesInMemory)</div><div class="line">					<span class="keyword">case</span> bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit:</div><div class="line">						log.Info(<span class="string">"State in memory for too long, committing"</span>, <span class="string">"time"</span>, bc.gcproc, <span class="string">"allowance"</span>, bc.cacheConfig.TrieTimeLimit, <span class="string">"optimum"</span>, float64(chosen-lastWrite)/triesInMemory)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> chosen &gt;= lastWrite+triesInMemory || size &gt;= 2*limit || bc.gcproc &gt;= 2*bc.cacheConfig.TrieTimeLimit &#123;</div><div class="line">					triedb.Commit(header.Root, <span class="keyword">true</span>)</div><div class="line">					lastWrite = chosen</div><div class="line">					bc.gcproc = <span class="number">0</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> !bc.triegc.Empty() &#123;</div><div class="line">				root, number := bc.triegc.Pop()</div><div class="line">				<span class="keyword">if</span> uint64(-number) &gt; chosen &#123;</div><div class="line">					bc.triegc.Push(root, number)</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">				triedb.Dereference(root.(common.Hash), common.Hash&#123;&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := WriteBlockReceipts(batch, block.Hash(), block.NumberU64(), receipts); err != nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, err</div><div class="line">	&#125;</div><div class="line">	reorg := externTd.Cmp(localTd) &gt; 0</div><div class="line">	currentBlock = bc.CurrentBlock()</div><div class="line">	<span class="keyword">if</span> !reorg &amp;&amp; externTd.Cmp(localTd) == 0 &#123;</div><div class="line">		reorg = block.NumberU64() &lt; currentBlock.NumberU64() || (block.NumberU64() == currentBlock.NumberU64() &amp;&amp; mrand.Float64() &lt; <span class="number">0.5</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> reorg &#123;</div><div class="line">		<span class="keyword">if</span> block.ParentHash() != currentBlock.Hash() &#123;</div><div class="line">			<span class="keyword">if</span> err := bc.reorg(currentBlock, block); err != nil &#123;</div><div class="line">				<span class="keyword">return</span> NonStatTy, err</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := WriteTxLookupEntries(batch, block); err != nil &#123;</div><div class="line">			<span class="keyword">return</span> NonStatTy, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := WritePreimages(bc.db, block.NumberU64(), state.Preimages()); err != nil &#123;</div><div class="line">			<span class="keyword">return</span> NonStatTy, err</div><div class="line">		&#125;</div><div class="line">		status = CanonStatTy</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		status = SideStatTy</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := batch.Write(); err != nil &#123;</div><div class="line">		<span class="keyword">return</span> NonStatTy, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> status == CanonStatTy &#123;</div><div class="line">		bc.insert(block)</div><div class="line">	&#125;</div><div class="line">	bc.futureBlocks.Remove(block.Hash())</div><div class="line">	<span class="keyword">return</span> status, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WriteBlockWithState</code> 将区块以及相关所有的状态写入数据库。首先通过 <code>bc.GetTd(block.ParentHash(), block.NumberU64()-1)</code> 获取待插入区块的总难度，<code>bc.GetTd(bc.currentBlock.Hash(), bc.currentBlock.NumberU64())</code> 计算当前区块的区块链的总难度，<code>externTd := new(big.Int).Add(block.Difficulty(), ptd)</code> 获得新的区块链的总难度。通过 <code>bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd)</code> 写入区块 hash，高度，对应总难度。然后使用 <code>batch</code> 的方式写入区块的其他数据。插入数据后，判断这个区块的父区块是否为当前区块，如果不是，说明存在分叉，调用 <code>reorg</code> 重新组织区块链。插入成功后，调用 <code>bc.futureBlocks.Remove(block.Hash())</code> 从 <code>futureBlocks</code> 中移除区块。</p>
<p>下面我们来看看 <code>reorg</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">reorg</span><span class="params">(oldBlock, newBlock *types.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> oldBlock.NumberU64() &gt; newBlock.NumberU64() &#123;</div><div class="line">		<span class="keyword">for</span> ; oldBlock != <span class="literal">nil</span> &amp;&amp; oldBlock.NumberU64() != newBlock.NumberU64(); oldBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()<span class="number">-1</span>) &#123;</div><div class="line">			oldChain = <span class="built_in">append</span>(oldChain, oldBlock)</div><div class="line">			deletedTxs = <span class="built_in">append</span>(deletedTxs, oldBlock.Transactions()...)</div><div class="line"></div><div class="line">			collectLogs(oldBlock.Hash())</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> ; newBlock != <span class="literal">nil</span> &amp;&amp; newBlock.NumberU64() != oldBlock.NumberU64(); newBlock = bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()<span class="number">-1</span>) &#123;</div><div class="line">			newChain = <span class="built_in">append</span>(newChain, newBlock)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> oldBlock == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Invalid old chain"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> newBlock == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Invalid new chain"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">if</span> oldBlock.Hash() == newBlock.Hash() &#123;</div><div class="line">			commonBlock = oldBlock</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		oldChain = <span class="built_in">append</span>(oldChain, oldBlock)</div><div class="line">		newChain = <span class="built_in">append</span>(newChain, newBlock)</div><div class="line">		deletedTxs = <span class="built_in">append</span>(deletedTxs, oldBlock.Transactions()...)</div><div class="line">		collectLogs(oldBlock.Hash())</div><div class="line"></div><div class="line">		oldBlock, newBlock = bc.GetBlock(oldBlock.ParentHash(), oldBlock.NumberU64()<span class="number">-1</span>), bc.GetBlock(newBlock.ParentHash(), newBlock.NumberU64()<span class="number">-1</span>)</div><div class="line">		<span class="keyword">if</span> oldBlock == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"Invalid old chain"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> newBlock == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"Invalid new chain"</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(oldChain) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(newChain) &gt; <span class="number">0</span> &#123;</div><div class="line">		logFn := log.Debug</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(oldChain) &gt; <span class="number">63</span> &#123;</div><div class="line">			logFn = log.Warn</div><div class="line">		&#125;</div><div class="line">		logFn(<span class="string">"Chain split detected"</span>, <span class="string">"number"</span>, commonBlock.Number(), <span class="string">"hash"</span>, commonBlock.Hash(),</div><div class="line">			<span class="string">"drop"</span>, <span class="built_in">len</span>(oldChain), <span class="string">"dropfrom"</span>, oldChain[<span class="number">0</span>].Hash(), <span class="string">"add"</span>, <span class="built_in">len</span>(newChain), <span class="string">"addfrom"</span>, newChain[<span class="number">0</span>].Hash())</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		log.Error(<span class="string">"Impossible reorg, please file an issue"</span>, <span class="string">"oldnum"</span>, oldBlock.Number(), <span class="string">"oldhash"</span>, oldBlock.Hash(), <span class="string">"newnum"</span>, newBlock.Number(), <span class="string">"newhash"</span>, newBlock.Hash())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> addedTxs types.Transactions</div><div class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(newChain) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</div><div class="line">		<span class="keyword">if</span> err := WriteTxLookupEntries(bc.db, newChain[i]); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		addedTxs = <span class="built_in">append</span>(addedTxs, newChain[i].Transactions()...)</div><div class="line">	&#125;</div><div class="line">	diff := types.TxDifference(deletedTxs, addedTxs)</div><div class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> diff &#123;</div><div class="line">		DeleteTxLookupEntry(bc.db, tx.Hash())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(deletedLogs) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">go</span> bc.rmLogsFeed.Send(RemovedLogsEvent&#123;deletedLogs&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(oldChain) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> _, block := <span class="keyword">range</span> oldChain &#123;</div><div class="line">				bc.chainSideFeed.Send(ChainSideEvent&#123;Block: block&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提到，<code>reorg</code> 方法用来将新区块链替换本地区块链为规范链。对于老链比新链高的情况，减少老链，让它和新链一样高；否则的话减少新链，待后续插入。潜在的会丢失的交易会被当做事件发布。接着进入一个 for 循环，找到两条链共同的祖先。再将上述减少新链阶段保存的 <code>newChain</code> 一块块插入到链中，更新规范区块链的 key，并且写入交易的查询信息。最后是清理工作，删除交易查询信息，删除日志，并通过 <code>bc.rmLogsFeed.Send</code> 发送消息通知，删除了哪些旧链则通过 <code>bc.chainSideFeed.Send</code> 进行消息通知。</p>
<p>至此，插入区块的操作就完成了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/core-blockchain%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">core-blockchain源码分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链区块链，即区块组成的链，不妨先从区块谈起。这一篇我们将着眼于区块链的一些基本操作。在区块链中，区块存储有效信息，在阅读源代码之前，我们应该对区块头，区块体，区块链这些基本的数据结构有所了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（cmd 模块-其他命令）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（cmd 模块-其他命令）/</id>
    <published>2018-03-10T14:34:59.000Z</published>
    <updated>2018-08-18T07:33:33.922Z</updated>
    
    <content type="html"><![CDATA[<p>cmd 包中除了 ethereum cli 客户端还包括很多其他可执行命令。下面我们将一一分析这些子命令，与上一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a>一样，我们不会深入到其他模块中，这一篇仅限于 cmd 模块。</p>
<a id="more"></a>
<h2 id="abigen"><a href="#abigen" class="headerlink" title="abigen"></a>abigen</h2><p>abigen 可以根据 sol 或 abi 文件生成特定语言的封装，支持 golang, objc, java 3种语言。它也能够编译 Solidity 原文件，使开发更便利。</p>
<p>ABI 指的是 Application binary interface，字面意思是应用二进制接口。它是与区块链以外的以太坊系统中的合约进行交互的标准方式，同时也是合约与合约交互的标准方式。</p>
<p>除了通过 RPC 的方式调用，部署合约，我们还可以使用 IPC 的方式，即使用 abigen 这种方式，使得部署合约更简单，更易于与代码集成。</p>
<p>可以写一个简单的 <code>test.sol</code> 文件试一下，通过 <code>abigen --sol test.sol -pkg main --lang go --out test.go</code> 先生成一个 test.go 文件，观察这个生成的绑定文件你会发现这个文件生成了与这个合约交互的所有方法，里面还包含了部署的方法，可以通过客户端来可以调用这些方法。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">	flag.<span class="keyword">Parse</span>()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *abiFlag == <span class="string">""</span> &amp;&amp; *solFlag == <span class="string">""</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"No contract ABI (--abi) or Solidity source (--sol) specified\n"</span>)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*abiFlag != <span class="string">""</span> || *binFlag != <span class="string">""</span> || *typFlag != <span class="string">""</span>) &amp;&amp; *solFlag != <span class="string">""</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"Contract ABI (--abi), bytecode (--bin) and type (--type) flags are mutually exclusive with the Solidity source (--sol) flag\n"</span>)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> *pkgFlag == <span class="string">""</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"No destination package specified (--pkg)\n"</span>)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> lang bind.Lang</div><div class="line">	switch *langFlag &#123;</div><div class="line">	case <span class="string">"go"</span>:</div><div class="line">		lang = bind.LangGo</div><div class="line">	case <span class="string">"java"</span>:</div><div class="line">		lang = bind.LangJava</div><div class="line">	case <span class="string">"objc"</span>:</div><div class="line">		lang = bind.LangObjC</div><div class="line">	default:</div><div class="line">		fmt.Printf(<span class="string">"Unsupported destination language \"</span>%s\<span class="string">" (--lang)\n"</span>, *langFlag)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		abis  []<span class="built_in">string</span></div><div class="line">		bins  []<span class="built_in">string</span></div><div class="line">		types []<span class="built_in">string</span></div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> *solFlag != <span class="string">""</span> || *abiFlag == <span class="string">"-"</span> &#123;</div><div class="line">		exclude := make(map[string]bool)</div><div class="line">		<span class="keyword">for</span> _, kind := <span class="keyword">range</span> strings.<span class="keyword">Split</span>(*excFlag, <span class="string">","</span>) &#123;</div><div class="line">			exclude[strings.ToLower(kind)] = true</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> contracts map[string]*compiler.<span class="keyword">Contract</span></div><div class="line">		<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></div><div class="line">		<span class="keyword">if</span> *solFlag != <span class="string">""</span> &#123;</div><div class="line">			contracts, <span class="keyword">err</span> = compiler.CompileSolidity(*solcFlag, *solFlag)</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				fmt.Printf(<span class="string">"Failed to build Solidity contract: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">				os.<span class="keyword">Exit</span>(-1)</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			contracts, <span class="keyword">err</span> = contractsFromStdin()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				fmt.Printf(<span class="string">"Failed to read input ABIs from STDIN: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">				os.<span class="keyword">Exit</span>(-1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> name, <span class="keyword">contract</span> := <span class="keyword">range</span> contracts &#123;</div><div class="line">			<span class="keyword">if</span> exclude[strings.ToLower(name)] &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			abi, _ := json.Marshal(<span class="keyword">contract</span>.Info.AbiDefinition) <span class="comment">// Flatten the compiler parse</span></div><div class="line">			abis = <span class="keyword">append</span>(abis, <span class="built_in">string</span>(abi))</div><div class="line">			bins = <span class="keyword">append</span>(bins, <span class="keyword">contract</span>.Code)</div><div class="line"></div><div class="line">			nameParts := strings.<span class="keyword">Split</span>(name, <span class="string">":"</span>)</div><div class="line">			types = <span class="keyword">append</span>(types, nameParts[len(nameParts)-1])</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		abi, <span class="keyword">err</span> := ioutil.ReadFile(*abiFlag)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">			fmt.Printf(<span class="string">"Failed to read input ABI: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">			os.<span class="keyword">Exit</span>(-1)</div><div class="line">		&#125;</div><div class="line">		abis = <span class="keyword">append</span>(abis, <span class="built_in">string</span>(abi))</div><div class="line"></div><div class="line">		bin := []byte&#123;&#125;</div><div class="line">		<span class="keyword">if</span> *binFlag != <span class="string">""</span> &#123;</div><div class="line">			<span class="keyword">if</span> bin, <span class="keyword">err</span> = ioutil.ReadFile(*binFlag); <span class="keyword">err</span> != nil &#123;</div><div class="line">				fmt.Printf(<span class="string">"Failed to read input bytecode: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">				os.<span class="keyword">Exit</span>(-1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		bins = <span class="keyword">append</span>(bins, <span class="built_in">string</span>(bin))</div><div class="line"></div><div class="line">		kind := *typFlag</div><div class="line">		<span class="keyword">if</span> kind == <span class="string">""</span> &#123;</div><div class="line">			kind = *pkgFlag</div><div class="line">		&#125;</div><div class="line">		types = <span class="keyword">append</span>(types, kind)</div><div class="line">	&#125;</div><div class="line">	code, <span class="keyword">err</span> := bind.Bind(types, abis, bins, *pkgFlag, lang)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		fmt.Printf(<span class="string">"Failed to generate ABI binding: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> *outFlag == <span class="string">""</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"%s\n"</span>, code)</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := ioutil.WriteFile(*outFlag, []byte(code), 0600); <span class="keyword">err</span> != nil &#123;</div><div class="line">		fmt.Printf(<span class="string">"Failed to write ABI binding: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line">		os.<span class="keyword">Exit</span>(-1)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>abigen</code> 命令的源码很简单，实际上就是调用 <code>accounts/abi</code> 以及 Solidity 编译器，主要的实现还是在 <code>accounts/abi</code> 里，这部分我们在后面的文章会继续深入。</p>
<h2 id="bootnode"><a href="#bootnode" class="headerlink" title="bootnode"></a>bootnode</h2><p>bootnode 是 geth 客户端的精简版本，只实现了网络节点发现协议，不运行更高级别的应用协议。它可以用作轻量级引导节点，帮助在私有网络中查找 peers。</p>
<p>以太坊在启动时至少需要一个对等节点，这样才能接入整个以太坊网络，bootnode 相当于一个第三方的中介，node 在启动时会将自己的信息注册到 bootnode 的路由中，并且会从 bootnode 得到其它节点的路由信息，一旦有了对等节点信息后就可以不需要连接 bootnode。公有链的节点硬编码了一些 bootnode 节点地址。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">	var (</div><div class="line">		listenAddr  = flag.<span class="built_in">String</span>(<span class="string">"addr"</span>, <span class="string">":30301"</span>, <span class="string">"listen address"</span>)</div><div class="line">		genKey      = flag.<span class="built_in">String</span>(<span class="string">"genkey"</span>, <span class="string">""</span>, <span class="string">"generate a node key"</span>)</div><div class="line">		writeAddr   = flag.Bool(<span class="string">"writeaddress"</span>, <span class="literal">false</span>, <span class="string">"write out the node's pubkey hash and quit"</span>)</div><div class="line">		nodeKeyFile = flag.<span class="built_in">String</span>(<span class="string">"nodekey"</span>, <span class="string">""</span>, <span class="string">"private key filename"</span>)</div><div class="line">		nodeKeyHex  = flag.<span class="built_in">String</span>(<span class="string">"nodekeyhex"</span>, <span class="string">""</span>, <span class="string">"private key as hex (for testing)"</span>)</div><div class="line">		natdesc     = flag.<span class="built_in">String</span>(<span class="string">"nat"</span>, <span class="string">"none"</span>, <span class="string">"port mapping mechanism (any|none|upnp|pmp|extip:&lt;IP&gt;)"</span>)</div><div class="line">		netrestrict = flag.<span class="built_in">String</span>(<span class="string">"netrestrict"</span>, <span class="string">""</span>, <span class="string">"restrict network communication to the given IP networks (CIDR masks)"</span>)</div><div class="line">		runv5       = flag.Bool(<span class="string">"v5"</span>, <span class="literal">false</span>, <span class="string">"run a v5 topic discovery bootnode"</span>)</div><div class="line">		verbosity   = flag.<span class="built_in">Int</span>(<span class="string">"verbosity"</span>, <span class="built_in">int</span>(<span class="built_in">log</span>.LvlInfo), <span class="string">"log verbosity (0-9)"</span>)</div><div class="line">		vmodule     = flag.<span class="built_in">String</span>(<span class="string">"vmodule"</span>, <span class="string">""</span>, <span class="string">"log verbosity pattern"</span>)</div><div class="line"></div><div class="line">		nodeKey *ecdsa.PrivateKey</div><div class="line">		<span class="built_in">err</span>     <span class="keyword">error</span></div><div class="line">	)</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	glogger := <span class="built_in">log</span>.NewGlogHandler(<span class="built_in">log</span>.StreamHandler(os.Stderr, <span class="built_in">log</span>.TerminalFormat(<span class="literal">false</span>)))</div><div class="line">	glogger.Verbosity(<span class="built_in">log</span>.Lvl(*verbosity))</div><div class="line">	glogger.Vmodule(*vmodule)</div><div class="line">	<span class="built_in">log</span>.Root().SetHandler(glogger)</div><div class="line"></div><div class="line">	natm, <span class="built_in">err</span> := nat.Parse(*natdesc)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"-nat: %v"</span>, <span class="built_in">err</span>)</div><div class="line">	&#125;</div><div class="line">	switch &#123;</div><div class="line">	<span class="keyword">case</span> *genKey != <span class="string">""</span>:</div><div class="line">		nodeKey, <span class="built_in">err</span> = crypto.GenerateKey()</div><div class="line">		<span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"could not generate key: %v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">err</span> = crypto.SaveECDSA(*genKey, nodeKey); <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">		return</div><div class="line">	<span class="keyword">case</span> *nodeKeyFile == <span class="string">""</span> &amp;&amp; *nodeKeyHex == <span class="string">""</span>:</div><div class="line">		utils.Fatalf(<span class="string">"Use -nodekey or -nodekeyhex to specify a private key"</span>)</div><div class="line">	<span class="keyword">case</span> *nodeKeyFile != <span class="string">""</span> &amp;&amp; *nodeKeyHex != <span class="string">""</span>:</div><div class="line">		utils.Fatalf(<span class="string">"Options -nodekey and -nodekeyhex are mutually exclusive"</span>)</div><div class="line">	<span class="keyword">case</span> *nodeKeyFile != <span class="string">""</span>:</div><div class="line">		<span class="keyword">if</span> nodeKey, <span class="built_in">err</span> = crypto.LoadECDSA(*nodeKeyFile); <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"-nodekey: %v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">case</span> *nodeKeyHex != <span class="string">""</span>:</div><div class="line">		<span class="keyword">if</span> nodeKey, <span class="built_in">err</span> = crypto.HexToECDSA(*nodeKeyHex); <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"-nodekeyhex: %v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *writeAddr &#123;</div><div class="line">		fmt.Printf(<span class="string">"%v\n"</span>, discover.PubkeyID(&amp;nodeKey.PublicKey))</div><div class="line">		os.<span class="keyword">Exit</span>(<span class="number">0</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var restrictList *netutil.Netlist</div><div class="line">	<span class="keyword">if</span> *netrestrict != <span class="string">""</span> &#123;</div><div class="line">		restrictList, <span class="built_in">err</span> = netutil.ParseNetlist(*netrestrict)</div><div class="line">		<span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"-netrestrict: %v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	addr, <span class="built_in">err</span> := net.ResolveUDPAddr(<span class="string">"udp"</span>, *listenAddr)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"-ResolveUDPAddr: %v"</span>, <span class="built_in">err</span>)</div><div class="line">	&#125;</div><div class="line">	conn, <span class="built_in">err</span> := net.ListenUDP(<span class="string">"udp"</span>, addr)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"-ListenUDP: %v"</span>, <span class="built_in">err</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	realaddr := conn.LocalAddr().(*net.UDPAddr)</div><div class="line">	<span class="keyword">if</span> natm != nil &#123;</div><div class="line">		<span class="keyword">if</span> !realaddr.IP.IsLoopback() &#123;</div><div class="line">			go nat.Map(natm, nil, <span class="string">"udp"</span>, realaddr.Port, realaddr.Port, <span class="string">"ethereum discovery"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ext, <span class="built_in">err</span> := natm.ExternalIP(); <span class="built_in">err</span> == nil &#123;</div><div class="line">			realaddr = &amp;net.UDPAddr&#123;IP: ext, Port: realaddr.Port&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *runv5 &#123;</div><div class="line">		<span class="keyword">if</span> _, <span class="built_in">err</span> := discv5.ListenUDP(nodeKey, conn, realaddr, <span class="string">""</span>, restrictList); <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		cfg := discover.Config&#123;</div><div class="line">			PrivateKey:   nodeKey,</div><div class="line">			AnnounceAddr: realaddr,</div><div class="line">			NetRestrict:  restrictList,</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> _, <span class="built_in">err</span> := discover.ListenUDP(conn, cfg); <span class="built_in">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, <span class="built_in">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">select</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码里可以看到，这部分功能主要来自于 p2p 模块。后续我们会深入到该模块。</p>
<h2 id="clef"><a href="#clef" class="headerlink" title="clef"></a>clef</h2><p>clef 可以用来签署交易和数据，并且可以代替 geth 的账户管理。这部分代码我没有深入研究，看起来像是账户管理的另一种封装，实际的实现在 signer 目录下。</p>
<p>可以参考：<a href="https://github.com/holiman/qtsigner/" target="_blank" rel="external">A Python/QT based graphical user interface for the ethereum signer</a></p>
<h2 id="ethkey"><a href="#ethkey" class="headerlink" title="ethkey"></a>ethkey</h2><p>ethkey 是一个可以用来操作以太坊 keyfile 的工具。 </p>
<h2 id="evm"><a href="#evm" class="headerlink" title="evm"></a>evm</h2><p>对 evm 进行一些封装</p>
<p>执行合约前，将 Transaction 类型转化为 message，创建虚拟机（EVM）对象，计算一些 Gas 消耗，执行交易完毕后创建收据（Recipet）对象返回。</p>
<h2 id="faucet"><a href="#faucet" class="headerlink" title="faucet"></a>faucet</h2><p>faucet 测试网相关代码。</p>
<p>参考：<a href="https://faucet.rinkeby.io" target="_blank" rel="external">https://faucet.rinkeby.io</a> 和 <a href="https://coincentral.com/ethereum-faucets/" target="_blank" rel="external">https://coincentral.com/ethereum-faucets/</a></p>
<h2 id="p2psim"><a href="#p2psim" class="headerlink" title="p2psim"></a>p2psim</h2><p>模拟 p2p API 请求的工具</p>
<h2 id="puppeth"><a href="#puppeth" class="headerlink" title="puppeth"></a>puppeth</h2><p>用于搭建，维护私有链</p>
<h2 id="rlpdump"><a href="#rlpdump" class="headerlink" title="rlpdump"></a>rlpdump</h2><p>RLP 是 Recursive Length Prefix 的简写。是以太坊中的序列化方法。这个模块的作用是提供 RLP 数据的格式化输出。</p>
<h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p>swarm 是一个去中心化的内容存储和分发服务，这个模块是其命令行客户端。没有细看这部分代码，swarm 看起来很像 ipfs，而且代码还在快速迭代中，就不展开了。</p>
<p><a href="https://github.com/ethersphere/go-ethereum/wiki/IPFS-&amp;-SWARM" target="_blank" rel="external">IPFS &amp; SWARM</a></p>
<h2 id="wnode"><a href="#wnode" class="headerlink" title="wnode"></a>wnode</h2><p>这是一个简单的 Whisper 节点。它可以用作独立的引导节点，还可以用于不同的测试和诊断目的</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> &#123;</span></div><div class="line">	processArgs()</div><div class="line">	initialize()</div><div class="line">	<span class="built_in">run</span>()</div><div class="line">	<span class="built_in">shutdown</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cmd 模块下的其他命令的资料相对于 geth 命令的资料还是很少的，而且有几个工具看起来有个人开发工具的性质，看起来很有用。可能使用的人很少，没法集成到 geth 成为一个子命令，但不集成为一个单独的命令又太可惜；有的工具只是某些功能的一个封装，还有的是项目外的工具的封装，例如 Solidity，Swarm。如果未来对以太坊的功能，代码比较熟悉了，需要自己封装一个工具，这些代码是很有参考价值的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.cnblogs.com/baizx/p/7469125.html" target="_blank" rel="external">以太坊系列之十六: 使用golang与智能合约进行交互</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/wiki/Diagnostic-Tool-wnode" target="_blank" rel="external">Diagnostic Tool wnode</a></li>
<li><a href="https://solidity.readthedocs.io/en/develop/abi-spec.html#application-binary-interface-specification" target="_blank" rel="external">Application Binary Interface Specification</a></li>
<li><a href="https://bitshuo.com/topic/594a8c228e822fcb444317ec" target="_blank" rel="external">以太坊源码分析（3）深入解析ABI</a></li>
<li><a href="https://bitshuo.com/topic/58b41a0408d6a0f32a5bc0b7" target="_blank" rel="external">Ethereum的ABI详解</a></li>
<li><a href="http://qjpcpu.github.io/blog/2018/02/07/shen-ru-ethereumyuan-ma-whisperxie-yi-jie-du/" target="_blank" rel="external">深入ethereum源码-whisper协议解读</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27574253" target="_blank" rel="external">合约的另一种调用方式——IPC</a></li>
<li><a href="http://8btc.com/thread-31358-1-1.html" target="_blank" rel="external">DAG有向无环图是什么？</a></li>
<li><a href="https://g2ex.github.io/2017/09/12/ethereum-guidance/" target="_blank" rel="external">以太坊私有链搭建指南</a></li>
<li><a href="http://blog.csdn.net/DDFFR/article/details/78925410" target="_blank" rel="external">以太坊bootnode测试</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmd 包中除了 ethereum cli 客户端还包括很多其他可执行命令。下面我们将一一分析这些子命令，与上一篇 &lt;a href=&quot;https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;go-ethereum 源码笔记（cmd 模块-geth 命令）&lt;/a&gt;一样，我们不会深入到其他模块中，这一篇仅限于 cmd 模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（cmd 模块-geth 命令）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（cmd 模块-geth 命令）/</id>
    <published>2018-03-10T14:34:58.000Z</published>
    <updated>2018-09-08T13:59:16.858Z</updated>
    
    <content type="html"><![CDATA[<p>cmd 模块包含了很多子模块，基本上每个子模块表示一个可执行的命令，其中最重要的是 geth 命令，它是以太坊的命令行客户端。</p>
<p>geth 命令是以太坊提供的一个强大的命令行工具，它是使用以太坊的入口。它包括了很多子命令，你可以通过 <code>geth --help</code> 获得更多帮助信息。其运行方法是：<code>geth [选项] 命令 [命令选项][参数…]</code>。</p>
<a id="more"></a>
<p>以下是 geth 包含的子命令以及对应的简单描述。</p>
<table>
<thead>
<tr>
<th style="text-align:center">子命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">account</td>
<td style="text-align:center">管理账户</td>
</tr>
<tr>
<td style="text-align:center">attach</td>
<td style="text-align:center">启动交互式JavaScript环境（连接到节点）</td>
</tr>
<tr>
<td style="text-align:center">bug</td>
<td style="text-align:center">给 github 源代码仓库提 issue</td>
</tr>
<tr>
<td style="text-align:center">console</td>
<td style="text-align:center">启动交互式 JavaScript 环境</td>
</tr>
<tr>
<td style="text-align:center">copydb</td>
<td style="text-align:center">从文件夹创建本地链</td>
</tr>
<tr>
<td style="text-align:center">dump</td>
<td style="text-align:center">取出一个特定的区块</td>
</tr>
<tr>
<td style="text-align:center">dumpconfig</td>
<td style="text-align:center">显示配置值</td>
</tr>
<tr>
<td style="text-align:center">export</td>
<td style="text-align:center">导出区块链到文件</td>
</tr>
<tr>
<td style="text-align:center">import</td>
<td style="text-align:center">导入一个区块链文件</td>
</tr>
<tr>
<td style="text-align:center">init</td>
<td style="text-align:center">启动并初始化一个新的创世纪块</td>
</tr>
<tr>
<td style="text-align:center">js</td>
<td style="text-align:center">执行指定的JavaScript文件(多个)</td>
</tr>
<tr>
<td style="text-align:center">license</td>
<td style="text-align:center">显示许可信息</td>
</tr>
<tr>
<td style="text-align:center">makecache</td>
<td style="text-align:center">生成ethash验证缓存(用于测试)</td>
</tr>
<tr>
<td style="text-align:center">makedag</td>
<td style="text-align:center">生成ethash 挖矿DAG(用于测试)</td>
</tr>
<tr>
<td style="text-align:center">monitor</td>
<td style="text-align:center">监控和可视化节点指标</td>
</tr>
<tr>
<td style="text-align:center">removedb</td>
<td style="text-align:center">删除区块链和状态数据库</td>
</tr>
<tr>
<td style="text-align:center">version</td>
<td style="text-align:center">打印版本号</td>
</tr>
<tr>
<td style="text-align:center">wallet</td>
<td style="text-align:center">管理Ethereum预售钱包</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">显示一个命令或帮助一个命令列表</td>
</tr>
</tbody>
</table>
<p>本文将逐一分析 geth 模块的源码，了解 geth 命令的实现原理。需要注意的是，这里我们不会深入分析每一个模块，因为这些模块的实现实际上是以太坊每个功能模块的实现，在后续的文章我们会一一分析。这里只分析 geth 命令的实现。</p>
<p>将涉及到 cmd, node 目录。</p>
<p>geth 的命令行是通过 <a href="https://github.com/urfave/cli" target="_blank" rel="external">github.com/urfave/cli</a> 这个库实现的，通过这个库，我们可以轻松定义命令行程序的子命令，命令选项，命令参数，描述信息等等，如果想要进一步了解，可以查看该库文档。</p>
<p>geth 模块的入口在 <code>cmd/geth/main.go</code> 中，它会调用 <code>urfave/cli</code> 的中 app 的 <code>run</code> 方法，而 app 在 <code>init</code> 函数中初始化，在 Golang 中，如果有 <code>init</code> 方法，那么会在 <code>main</code> 函数之前执行 <code>init</code> 函数，它用于程序执行前的初始化工作。在 geth 模块中，<code>init()</code> 函数定义了命令行的入口是 <code>geth</code>，并且定义了 geth 的子命令、全局的命令选项、子命令的命令选项，按照 <code>urfave/cli</code> 的做法，不输入子命令会默认调用 geth，而 geth 方法其实就6行：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> <span class="selector-tag">geth</span>(<span class="selector-tag">ctx</span> *<span class="selector-tag">cli</span><span class="selector-class">.Context</span>) <span class="selector-tag">error</span> &#123;</div><div class="line">	<span class="attribute">node </span>:= <span class="built_in">makeFullNode</span>(ctx)</div><div class="line">	<span class="built_in">startNode</span>(ctx, node)</div><div class="line">	node.<span class="built_in">Wait</span>()</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会调用 <code>makeFullNode</code> 函数初始化一个全节点，该方法在 <code>geth/config.go</code> 中，接着通过 <code>startNode</code> 函数启动一个全节点，以阻塞的方式运行，等待着节点被终止。</p>
<p>我们先深入到 <code>makeFullNode</code> 函数中。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func makeFullNode(<span class="name">ctx</span> *cli.Context) *node.Node &#123;</div><div class="line">	stack, cfg <span class="symbol">:=</span> makeConfigNode(<span class="name">ctx</span>)</div><div class="line">	utils.RegisterEthService(<span class="name">stack</span>, <span class="symbol">&amp;cfg</span>.Eth)</div><div class="line">	if ctx.GlobalBool(<span class="name">utils</span>.DashboardEnabledFlag.Name) &#123;</div><div class="line">		utils.RegisterDashboardService(<span class="name">stack</span>, <span class="symbol">&amp;cfg</span>.Dashboard, gitCommit)</div><div class="line">	&#125;</div><div class="line">	// whether enable whisper ...</div><div class="line">	// whether register eth stats ...</div><div class="line">	return stack</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心的逻辑是首先通过配置文件和 flag 生成系统级的配置，然后将服务注入到节点。<br>先说 <code>makeConfigNode</code> 方法。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func makeConfigNode(ctx *cli.Context) (*node.Node, gethConfig) &#123;</div><div class="line">	<span class="attribute">cfg</span> := gethConfig&#123;</div><div class="line">		Eth:       eth<span class="variable">.DefaultConfig</span>,</div><div class="line">		Shh:       whisper<span class="variable">.DefaultConfig</span>,</div><div class="line">		Node:      defaultNodeConfig(),</div><div class="line">		Dashboard: dashboard<span class="variable">.DefaultConfig</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if file := ctx<span class="variable">.GlobalString</span>(configFileFlag<span class="variable">.Name</span>); <span class="attribute">file != "" &#123;</span></div><div class="line">		if err := loadConfig(file, &amp;cfg); <span class="attribute">err != nil &#123;</span></div><div class="line">			utils.Fatalf("%v", err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	stack, err := node<span class="variable">.New</span>(&amp;cfg<span class="variable">.Node</span>)</div><div class="line">	if err != nil &#123;</div><div class="line">		utils<span class="variable">.Fatalf</span>("Failed to create the protocol stack: %v", err)</div><div class="line">	&#125;</div><div class="line">	utils<span class="variable">.SetEthConfig</span>(ctx, stack, &amp;cfg<span class="variable">.Eth</span>)</div><div class="line">	if ctx<span class="variable">.GlobalIsSet</span>(utils<span class="variable">.EthStatsURLFlag</span><span class="variable">.Name</span>) &#123;</div><div class="line">		cfg<span class="variable">.Ethstats</span><span class="variable">.URL</span> = ctx<span class="variable">.GlobalString</span>(utils<span class="variable">.EthStatsURLFlag</span><span class="variable">.Name</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	utils<span class="variable">.SetShhConfig</span>(ctx, stack, &amp;cfg<span class="variable">.Shh</span>)</div><div class="line">	utils<span class="variable">.SetDashboardConfig</span>(ctx, &amp;cfg<span class="variable">.Dashboard</span>)</div><div class="line"></div><div class="line">	return stack, cfg</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>makeConfigNode</code> 会先载入默认配置，再载入配置文件中的配置，然后通过上下文的配置(在 <code>cmd/geth/main.go</code> 中的 <code>init</code> 方法中定义)进行设置。我们深入到 <code>RegisterEthService</code> 方法来查看服务是如何注入到节点中的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterEthService</span><span class="params">(stack *node.Node, cfg *eth.Config)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">if</span> cfg.SyncMode == downloader.LightSync &#123;</div><div class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span> <span class="params">(node.Service, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> les.New(ctx, cfg)</div><div class="line">		&#125;)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span> <span class="params">(node.Service, error)</span></span> &#123;</div><div class="line">			fullNode, err := eth.New(ctx, cfg)</div><div class="line">			<span class="keyword">if</span> fullNode != <span class="literal">nil</span> &amp;&amp; cfg.LightServ &gt; <span class="number">0</span> &#123;</div><div class="line">				ls, _ := les.NewLesServer(fullNode, cfg)</div><div class="line">				fullNode.AddLesServer(ls)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> fullNode, err</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		Fatalf(<span class="string">"Failed to register the Ethereum service: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RegisterEthService</code> 的代码在 <code>cmd/utils/flags.go</code> 中，如果同步模式是轻量级同步模式，启动轻量级客户端，否则启动全节点，实际的注册方法是 <code>stack.Register</code>。注入服务其实就是将新的服务注入到 <code>node</code> 对象的 <code>serviceFuncs</code> 数组中。这些内容将<a href="#TODO">go-ethereum 源码笔记（node 模块）</a> 描述。</p>
<p>接下来我们继续看 <code>geth/main.go</code> 的 <code>startNode</code> 函数，看看如何启动节点，这个方法在 <code>cmd/geth/main.go</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNode</span><span class="params">(ctx *cli.Context, stack *node.Node)</span></span> &#123;</div><div class="line">	debug.Memsize.Add(<span class="string">"node"</span>, stack)</div><div class="line">	utils.StartNode(stack)</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</div><div class="line"></div><div class="line">	passwords := utils.MakePasswordList(ctx)</div><div class="line">	unlocks := strings.Split(ctx.GlobalString(utils.UnlockedAccountFlag.Name), <span class="string">","</span>)</div><div class="line">	<span class="keyword">for</span> i, account := <span class="keyword">range</span> unlocks &#123;</div><div class="line">		<span class="keyword">if</span> trimmed := strings.TrimSpace(account); trimmed != <span class="string">""</span> &#123;</div><div class="line">			unlockAccount(ctx, ks, trimmed, i, passwords)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	events := <span class="built_in">make</span>(<span class="keyword">chan</span> accounts.WalletEvent, <span class="number">16</span>)</div><div class="line">	stack.AccountManager().Subscribe(events)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		rpcClient, err := stack.Attach()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Failed to attach to self: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		stateReader := ethclient.NewClient(rpcClient)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> _, wallet := <span class="keyword">range</span> stack.AccountManager().Wallets() &#123;</div><div class="line">			<span class="keyword">if</span> err := wallet.Open(<span class="string">""</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">				log.Warn(<span class="string">"Failed to open wallet"</span>, <span class="string">"url"</span>, wallet.URL(), <span class="string">"err"</span>, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> event := <span class="keyword">range</span> events &#123;</div><div class="line">			<span class="keyword">switch</span> event.Kind &#123;</div><div class="line">			<span class="keyword">case</span> accounts.WalletArrived:</div><div class="line">				<span class="keyword">if</span> err := event.Wallet.Open(<span class="string">""</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">					log.Warn(<span class="string">"New wallet appeared, failed to open"</span>, <span class="string">"url"</span>, event.Wallet.URL(), <span class="string">"err"</span>, err)</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">case</span> accounts.WalletOpened:</div><div class="line">				status, _ := event.Wallet.Status()</div><div class="line">				log.Info(<span class="string">"New wallet appeared"</span>, <span class="string">"url"</span>, event.Wallet.URL(), <span class="string">"status"</span>, status)</div><div class="line"></div><div class="line">				<span class="keyword">if</span> event.Wallet.URL().Scheme == <span class="string">"ledger"</span> &#123;</div><div class="line">					event.Wallet.SelfDerive(accounts.DefaultLedgerBaseDerivationPath, stateReader)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					event.Wallet.SelfDerive(accounts.DefaultBaseDerivationPath, stateReader)</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			<span class="keyword">case</span> accounts.WalletDropped:</div><div class="line">				log.Info(<span class="string">"Old wallet dropped"</span>, <span class="string">"url"</span>, event.Wallet.URL())</div><div class="line">				event.Wallet.Close()</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">if</span> ctx.GlobalBool(utils.MiningEnabledFlag.Name) || ctx.GlobalBool(utils.DeveloperFlag.Name) &#123;</div><div class="line">		<span class="keyword">if</span> ctx.GlobalBool(utils.LightModeFlag.Name) || ctx.GlobalString(utils.SyncModeFlag.Name) == <span class="string">"light"</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Light clients do not support mining"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">var</span> ethereum *eth.Ethereum</div><div class="line">		<span class="keyword">if</span> err := stack.Service(&amp;ethereum); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Ethereum service not running: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> threads := ctx.GlobalInt(utils.MinerThreadsFlag.Name); threads &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">type</span> threaded <span class="keyword">interface</span> &#123;</div><div class="line">				SetThreads(threads <span class="keyword">int</span>)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> th, ok := ethereum.Engine().(threaded); ok &#123;</div><div class="line">				th.SetThreads(threads)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ethereum.TxPool().SetGasPrice(utils.GlobalBig(ctx, utils.GasPriceFlag.Name))</div><div class="line">		<span class="keyword">if</span> err := ethereum.StartMining(<span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Failed to start mining: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>startNode</code> 方法启动节点，会开启所有已经注册的协议，解锁请求的账户，开启 RPC/IPC 接口，并开始挖矿。这里我们不再深入。</p>
<p>举两个例子。想要查阅某个命令或某些参数的帮助信息，可以使用：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ geth <span class="comment">--help</span></div></pre></td></tr></table></figure>
<p>查看各种命令，参数的提示信息。</p>
<p>如果想要启动一条私有链，可以使用下面的命令进行初始化：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="string">geth </span> <span class="built_in">--datadir</span> <span class="string">"./"</span> <span class="string">init </span><span class="string">genesis.</span><span class="string">json</span></div></pre></td></tr></table></figure>
<p>其中 genesis.json 是创始区块的配置信息。</p>
<p>然后执行下面的命令，创建私有链：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ geth --datadir <span class="string">"./"</span> --nodiscover console <span class="number">2</span><span class="meta">&gt;&gt;</span>geth.log</div></pre></td></tr></table></figure>
<p>上述就是直接运行 geth，不输入其他子命令的情况。geth 还有很多子命令，这些子命令在 <code>init()</code> 的 <code>app.Commands</code> 赋值语句中可以看到，接下来会概述这些子命令。</p>
<h2 id="chaincmd-go"><a href="#chaincmd-go" class="headerlink" title="chaincmd.go"></a>chaincmd.go</h2><h3 id="initCommand-geth-init"><a href="#initCommand-geth-init" class="headerlink" title="initCommand: geth init"></a>initCommand: geth init</h3><p>这个命令会进行初始化，生成创始区块。对应调用的方法是 <code>initGenesis</code>。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">func initGenesis(ctx *<span class="keyword">cli</span>.Context) <span class="keyword">error</span> &#123;</div><div class="line">	genesisPath := ctx.<span class="keyword">Args</span>().First()</div><div class="line">	<span class="keyword">if</span> len(genesisPath) == 0 &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Must supply path to genesis JSON file"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">file</span>, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(genesisPath)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read genesis file: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	defer <span class="keyword">file</span>.<span class="keyword">Close</span>()</div><div class="line"></div><div class="line">	genesis := new(core.Genesis)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := json.NewDecoder(<span class="keyword">file</span>).<span class="keyword">Decode</span>(genesis); <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"invalid genesis file: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">stack</span> := makeFullNode(ctx)</div><div class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> []string&#123;<span class="string">"chaindata"</span>, <span class="string">"lightchaindata"</span>&#125; &#123;</div><div class="line">		chaindb, <span class="keyword">err</span> := <span class="keyword">stack</span>.OpenDatabase(name, 0, 0)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Failed to open database: %v"</span>, <span class="keyword">err</span>)</div><div class="line">		&#125;</div><div class="line">		_, hash, <span class="keyword">err</span> := core.SetupGenesisBlock(chaindb, genesis)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Failed to write genesis block: %v"</span>, <span class="keyword">err</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">log</span>.Info(<span class="string">"Successfully wrote genesis state"</span>, <span class="string">"database"</span>, name, <span class="string">"hash"</span>, hash)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终会调用 <code>core/geth/chaincmd</code> 的 <code>SetupGenesisBlock</code>，这里具体的实现细节我们将在<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a> 介绍。</p>
<h3 id="importCommand-geth-import"><a href="#importCommand-geth-import" class="headerlink" title="importCommand: geth import"></a>importCommand: geth import</h3><p>导入一个区块链文件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">func importChain(ctx *<span class="keyword">cli</span>.Context) <span class="keyword">error</span> &#123;</div><div class="line">	<span class="keyword">if</span> len(ctx.<span class="keyword">Args</span>()) &lt; 1 &#123;</div><div class="line">		utils.Fatalf(<span class="string">"This command requires an argument."</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">stack</span> := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, <span class="keyword">stack</span>)</div><div class="line">	defer chainDb.<span class="keyword">Close</span>()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> peakMemAlloc, peakMemSys uint64</div><div class="line">	go func() &#123;</div><div class="line">		stats := new(runtime.MemStats)</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			runtime.ReadMemStats(stats)</div><div class="line">			<span class="keyword">if</span> atomic.LoadUint64(&amp;peakMemAlloc) &lt; stats.Alloc &#123;</div><div class="line">				atomic.StoreUint64(&amp;peakMemAlloc, stats.Alloc)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> atomic.LoadUint64(&amp;peakMemSys) &lt; stats.Sys &#123;</div><div class="line">				atomic.StoreUint64(&amp;peakMemSys, stats.Sys)</div><div class="line">			&#125;</div><div class="line">			time.<span class="keyword">Sleep</span>(5 * time.Second)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> len(ctx.<span class="keyword">Args</span>()) == 1 &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := utils.ImportChain(chain, ctx.<span class="keyword">Args</span>().First()); <span class="keyword">err</span> != nil &#123;</div><div class="line">			<span class="keyword">log</span>.<span class="keyword">Error</span>(<span class="string">"Import error"</span>, <span class="string">"err"</span>, <span class="keyword">err</span>)</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> ctx.<span class="keyword">Args</span>() &#123;</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := utils.ImportChain(chain, arg); <span class="keyword">err</span> != nil &#123;</div><div class="line">				<span class="keyword">log</span>.<span class="keyword">Error</span>(<span class="string">"Import error"</span>, <span class="string">"file"</span>, arg, <span class="string">"err"</span>, <span class="keyword">err</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	chain.Stop()</div><div class="line">	fmt.Printf(<span class="string">"Import done in %v.\n\n"</span>, time.Since(start))</div><div class="line"></div><div class="line">	<span class="keyword">db</span> := chainDb.(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	stats, <span class="keyword">err</span> := <span class="keyword">db</span>.LDB().GetProperty(<span class="string">"leveldb.stats"</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read database stats: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(stats)</div><div class="line"></div><div class="line">	ioStats, <span class="keyword">err</span> := <span class="keyword">db</span>.LDB().GetProperty(<span class="string">"leveldb.iostats"</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read database iostats: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(ioStats)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"Trie cache misses:  %d\n"</span>, trie.CacheMisses())</div><div class="line">	fmt.Printf(<span class="string">"Trie cache unloads: %d\n\n"</span>, trie.CacheUnloads())</div><div class="line"></div><div class="line">	mem := new(runtime.MemStats)</div><div class="line">	runtime.ReadMemStats(mem)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"Object memory: %.3f MB current, %.3f MB peak\n"</span>, float64(mem.Alloc)/1024/1024, float64(atomic.LoadUint64(&amp;peakMemAlloc))/1024/1024)</div><div class="line">	fmt.Printf(<span class="string">"System memory: %.3f MB current, %.3f MB peak\n"</span>, float64(mem.Sys)/1024/1024, float64(atomic.LoadUint64(&amp;peakMemSys))/1024/1024)</div><div class="line">	fmt.Printf(<span class="string">"Allocations:   %.3f million\n"</span>, float64(mem.Mallocs)/1000000)</div><div class="line">	fmt.Printf(<span class="string">"GC pause:      %v\n\n"</span>, time.Duration(mem.PauseTotalNs))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(utils.NoCompactionFlag.Name) &#123;</div><div class="line">		<span class="keyword">return</span> nil</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	fmt.Println(<span class="string">"Compacting entire database..."</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> = <span class="keyword">db</span>.LDB().CompactRange(util.<span class="keyword">Range</span>&#123;&#125;); <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Compaction failed: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Compaction done in %v.\n\n"</span>, time.Since(start))</div><div class="line"></div><div class="line">	stats, <span class="keyword">err</span> = <span class="keyword">db</span>.LDB().GetProperty(<span class="string">"leveldb.stats"</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read database stats: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(stats)</div><div class="line"></div><div class="line">	ioStats, <span class="keyword">err</span> = <span class="keyword">db</span>.LDB().GetProperty(<span class="string">"leveldb.iostats"</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read database iostats: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(ioStats)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正的逻辑在 <code>utils/cmd.go</code> 中的 <code>ImportChain</code>。</p>
<h3 id="exportCommand-geth-export"><a href="#exportCommand-geth-export" class="headerlink" title="exportCommand: geth export"></a>exportCommand: geth export</h3><p>导出一个区块链文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">exportChain</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ctx.Args()) &lt; <span class="number">1</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"This command requires an argument."</span>)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, _ := utils.MakeChain(ctx, stack)</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	fp := ctx.Args().First()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ctx.Args()) &lt; <span class="number">3</span> &#123;</div><div class="line">		err = utils.ExportChain(chain, fp)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		first, ferr := strconv.ParseInt(ctx.Args().Get(<span class="number">1</span>), <span class="number">10</span>, <span class="number">64</span>)</div><div class="line">		last, lerr := strconv.ParseInt(ctx.Args().Get(<span class="number">2</span>), <span class="number">10</span>, <span class="number">64</span>)</div><div class="line">		<span class="keyword">if</span> ferr != <span class="literal">nil</span> || lerr != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Export error in parsing parameters: block number not an integer\n"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> first &lt; <span class="number">0</span> || last &lt; <span class="number">0</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Export error: block number must be greater than 0\n"</span>)</div><div class="line">		&#125;</div><div class="line">		err = utils.ExportAppendChain(chain, fp, <span class="keyword">uint64</span>(first), <span class="keyword">uint64</span>(last))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Export error: %v\n"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Export done in %v\n"</span>, time.Since(start))</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>导出区块链的真正逻辑在 <code>utils/cmd.go</code> 中的 <code>ExportChain</code> 里。将导出一个 gz 文件。</p>
<h3 id="importPreimagesCommand-geth-import-preimages"><a href="#importPreimagesCommand-geth-import-preimages" class="headerlink" title="importPreimagesCommand: geth import-preimages"></a>importPreimagesCommand: geth import-preimages</h3><p>将一个 preimages 导入当前节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">importPreimages</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ctx.Args()) &lt; <span class="number">1</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"This command requires an argument."</span>)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	diskdb := utils.MakeChainDatabase(ctx, stack).(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">if</span> err := utils.ImportPreimages(diskdb, ctx.Args().First()); err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Export error: %v\n"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Export done in %v\n"</span>, time.Since(start))</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="exportPreimagesCommand-geth-export-preimages"><a href="#exportPreimagesCommand-geth-export-preimages" class="headerlink" title="exportPreimagesCommand: geth export-preimages"></a>exportPreimagesCommand: geth export-preimages</h3><p>从当前节点导出一个 image</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">exportPreimages</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ctx.Args()) &lt; <span class="number">1</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"This command requires an argument."</span>)</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	diskdb := utils.MakeChainDatabase(ctx, stack).(*ethdb.LDBDatabase)</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">if</span> err := utils.ExportPreimages(diskdb, ctx.Args().First()); err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Export error: %v\n"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Export done in %v\n"</span>, time.Since(start))</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="copydbCommand-geth-copydb"><a href="#copydbCommand-geth-copydb" class="headerlink" title="copydbCommand: geth copydb"></a>copydbCommand: <code>geth copydb</code></h3><p>复制一个本地区块文件到文件夹</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">func copyDb(<span class="name">ctx</span> *cli.Context) error &#123;</div><div class="line">	if len(ctx.Args()) != 1 &#123;</div><div class="line">		utils.Fatalf("Source chaindata directory path argument missing")</div><div class="line">	&#125;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, stack)</div><div class="line"></div><div class="line">	syncmode := *utils.GlobalTextMarshaler(<span class="name">ctx</span>, utils.SyncModeFlag.Name).(<span class="name">*downloader</span>.SyncMode)</div><div class="line">	dl <span class="symbol">:=</span> downloader.New(<span class="name">syncmode</span>, chainDb, new(<span class="name">event</span>.TypeMux), chain, <span class="literal">nil</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">	db, err <span class="symbol">:=</span> ethdb.NewLDBDatabase(<span class="name">ctx</span>.Args().First(), ctx.GlobalInt(<span class="name">utils</span>.CacheFlag.Name), <span class="number">256</span>)</div><div class="line">	if err != <span class="literal">nil</span> &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	hc, err <span class="symbol">:=</span> core.NewHeaderChain(<span class="name">db</span>, chain.Config(), chain.Engine(), func() bool &#123; return false &#125;)</div><div class="line">	if err != <span class="literal">nil</span> &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	peer <span class="symbol">:=</span> downloader.NewFakePeer(<span class="string">"local"</span>, db, hc, dl)</div><div class="line">	if err = dl.RegisterPeer(<span class="string">"local"</span>, <span class="number">63</span>, peer)<span class="comment">; err != nil &#123;</span></div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	start <span class="symbol">:=</span> time.Now()</div><div class="line"></div><div class="line">	currentHeader <span class="symbol">:=</span> hc.CurrentHeader()</div><div class="line">	if err = dl.Synchronise(<span class="string">"local"</span>, currentHeader.Hash(), hc.GetTd(<span class="name">currentHeader</span>.Hash(), currentHeader.Number.Uint64()), syncmode)<span class="comment">; err != nil &#123;</span></div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	for dl.Synchronising() &#123;</div><div class="line">		time.Sleep(<span class="number">10</span> * time.Millisecond)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf("Database copy done in %v\n", time.Since(start))</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	fmt.Println("Compacting entire database...")</div><div class="line">	if err = chainDb.(*ethdb.LDBDatabase).LDB().CompactRange(<span class="name">util</span>.Range&#123;&#125;)<span class="comment">; err != nil &#123;</span></div><div class="line">		utils.Fatalf(<span class="string">"Compaction failed: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Compaction done in %v.\n\n"</span>, time.Since(<span class="name">start</span>))</div><div class="line"></div><div class="line">	return <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一个文件夹中创建一个本地区块链。有意思的是这个过程并不是直接复制过去的，而是通过 <code>downloader</code> 模块里的 <code>NewFakePeer</code> 创建一个虚拟对等节点，然后再进行数据同步完成的。</p>
<h3 id="removedbCommand-geth-removedb"><a href="#removedbCommand-geth-removedb" class="headerlink" title="removedbCommand: geth removedb"></a>removedbCommand: <code>geth removedb</code></h3><p>在当前数据库中移除区块链。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDB</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"chaindata"</span>, <span class="string">"lightchaindata"</span>&#125; &#123;</div><div class="line">		logger := log.New(<span class="string">"database"</span>, name)</div><div class="line"></div><div class="line">		dbdir := stack.ResolvePath(name)</div><div class="line">		<span class="keyword">if</span> !common.FileExist(dbdir) &#123;</div><div class="line">			logger.Info(<span class="string">"Database doesn't exist, skipping"</span>, <span class="string">"path"</span>, dbdir)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		fmt.Println(dbdir)</div><div class="line">		confirm, err := console.Stdin.PromptConfirm(<span class="string">"Remove this database?"</span>)</div><div class="line">		<span class="keyword">switch</span> &#123;</div><div class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, err)</div><div class="line">		<span class="keyword">case</span> !confirm:</div><div class="line">			logger.Warn(<span class="string">"Database deletion aborted"</span>)</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			start := time.Now()</div><div class="line">			os.RemoveAll(dbdir)</div><div class="line">			logger.Info(<span class="string">"Database successfully deleted"</span>, <span class="string">"elapsed"</span>, common.PrettyDuration(time.Since(start)))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除数据库的过程倒是比较干脆，直接通过 <code>os</code> 模块移除这个文件夹。</p>
<h3 id="dumpCommand-geth-dump-lt-blockHash-gt-lt-blockNum-gt"><a href="#dumpCommand-geth-dump-lt-blockHash-gt-lt-blockNum-gt" class="headerlink" title="dumpCommand: geth dump [&lt;blockHash&gt; | &lt;blockNum&gt;]..."></a>dumpCommand: <code>geth dump [&lt;blockHash&gt; | &lt;blockNum&gt;]...</code></h3><p>dump 子命令可以移除一个或多个特定的区块</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func dump(<span class="name">ctx</span> *cli.Context) error &#123;</div><div class="line">	stack := makeFullNode(ctx)</div><div class="line">	chain, chainDb := utils.MakeChain(ctx, stack)</div><div class="line">	for _, arg := range ctx.Args() &#123;</div><div class="line">		var block *types.Block</div><div class="line">		if hashish(<span class="name">arg</span>) &#123;</div><div class="line">			block = chain.GetBlockByHash(<span class="name">common</span>.HexToHash(<span class="name">arg</span>))</div><div class="line">		&#125; else &#123;</div><div class="line">			num, _ <span class="symbol">:=</span> strconv.Atoi(<span class="name">arg</span>)</div><div class="line">			block = chain.GetBlockByNumber(<span class="name">uint64</span>(<span class="name">num</span>))</div><div class="line">		&#125;</div><div class="line">		if block == <span class="literal">nil</span> &#123;</div><div class="line">			fmt.Println(<span class="string">"&#123;&#125;"</span>)</div><div class="line">			utils.Fatalf(<span class="string">"block not found"</span>)</div><div class="line">		&#125; else &#123;</div><div class="line">			state, err <span class="symbol">:=</span> state.New(<span class="name">block</span>.Root(), state.NewDatabase(<span class="name">chainDb</span>))</div><div class="line">			if err != <span class="literal">nil</span> &#123;</div><div class="line">				utils.Fatalf(<span class="string">"could not create new state: %v"</span>, err)</div><div class="line">			&#125;</div><div class="line">			fmt.Printf(<span class="string">"%s\n"</span>, state.Dump())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	chainDb.Close()</div><div class="line">	return <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先根据区块号获取区块，然后调用 state 的 <code>Dump</code> 移除即可，这部分的实现在之后<a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a>会有描述。</p>
<h2 id="monitorcmd-go"><a href="#monitorcmd-go" class="headerlink" title="monitorcmd.go"></a>monitorcmd.go</h2><p>这部分代码不是核心内容，只是粗略的看了一下。</p>
<h3 id="monitorComand-geth-monitor"><a href="#monitorComand-geth-monitor" class="headerlink" title="monitorComand: geth monitor"></a>monitorComand: <code>geth monitor</code></h3><p>监控，图像化节点 metrics 数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		client *rpc.Client</div><div class="line">		err    error</div><div class="line">	)</div><div class="line">	endpoint := ctx.String(monitorCommandAttachFlag.Name)</div><div class="line">	<span class="keyword">if</span> client, err = dialRPC(endpoint); err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Unable to attach to geth node: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> client.Close()</div><div class="line"></div><div class="line">	metrics, err := retrieveMetrics(client)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to retrieve system metrics: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	monitored := resolveMetrics(metrics, ctx.Args())</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(monitored) == <span class="number">0</span> &#123;</div><div class="line">		list := expandMetrics(metrics, <span class="string">""</span>)</div><div class="line">		sort.Strings(list)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(list) &gt; <span class="number">0</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"No metrics specified.\n\nAvailable:\n - %s"</span>, strings.Join(list, <span class="string">"\n - "</span>))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"No metrics collected by geth (--%s).\n"</span>, utils.MetricsEnabledFlag.Name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sort.Strings(monitored)</div><div class="line">	<span class="keyword">if</span> cols := <span class="built_in">len</span>(monitored) / ctx.Int(monitorCommandRowsFlag.Name); cols &gt; <span class="number">6</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Requested metrics (%d) spans more that 6 columns:\n - %s"</span>, <span class="built_in">len</span>(monitored), strings.Join(monitored, <span class="string">"\n - "</span>))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := termui.Init(); err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Unable to initialize terminal UI: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> termui.Close()</div><div class="line"></div><div class="line">	rows := <span class="built_in">len</span>(monitored)</div><div class="line">	<span class="keyword">if</span> max := ctx.Int(monitorCommandRowsFlag.Name); rows &gt; max &#123;</div><div class="line">		rows = max</div><div class="line">	&#125;</div><div class="line">	cols := (<span class="built_in">len</span>(monitored) + rows - <span class="number">1</span>) / rows</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</div><div class="line">		termui.Body.AddRows(termui.NewRow())</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	footer := termui.NewPar(<span class="string">""</span>)</div><div class="line">	footer.Block.Border = <span class="literal">true</span></div><div class="line">	footer.Height = <span class="number">3</span></div><div class="line"></div><div class="line">	charts := <span class="built_in">make</span>([]*termui.LineChart, <span class="built_in">len</span>(monitored))</div><div class="line">	units := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(monitored))</div><div class="line">	data := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, <span class="built_in">len</span>(monitored))</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(monitored); i++ &#123;</div><div class="line">		charts[i] = createChart((termui.TermHeight() - footer.Height) / rows)</div><div class="line">		row := termui.Body.Rows[i%rows]</div><div class="line">		row.Cols = <span class="built_in">append</span>(row.Cols, termui.NewCol(<span class="number">12</span>/cols, <span class="number">0</span>, charts[i]))</div><div class="line">	&#125;</div><div class="line">	termui.Body.AddRows(termui.NewRow(termui.NewCol(<span class="number">12</span>, <span class="number">0</span>, footer)))</div><div class="line"></div><div class="line">	refreshCharts(client, monitored, data, units, charts, ctx, footer)</div><div class="line">	termui.Body.Align()</div><div class="line">	termui.Render(termui.Body)</div><div class="line"></div><div class="line">	termui.Handle(<span class="string">"/sys/kbd/C-c"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</div><div class="line">		termui.StopLoop()</div><div class="line">	&#125;)</div><div class="line">	termui.Handle(<span class="string">"/sys/wnd/resize"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</div><div class="line">		termui.Body.Width = termui.TermWidth()</div><div class="line">		<span class="keyword">for</span> _, chart := <span class="keyword">range</span> charts &#123;</div><div class="line">			chart.Height = (termui.TermHeight() - footer.Height) / rows</div><div class="line">		&#125;</div><div class="line">		termui.Body.Align()</div><div class="line">		termui.Render(termui.Body)</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		tick := time.NewTicker(time.Duration(ctx.Int(monitorCommandRefreshFlag.Name)) * time.Second)</div><div class="line">		<span class="keyword">for</span> <span class="keyword">range</span> tick.C &#123;</div><div class="line">			<span class="keyword">if</span> refreshCharts(client, monitored, data, units, charts, ctx, footer) &#123;</div><div class="line">				termui.Body.Align()</div><div class="line">			&#125;</div><div class="line">			termui.Render(termui.Body)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	termui.Loop()</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="accountcmd-go"><a href="#accountcmd-go" class="headerlink" title="accountcmd.go"></a>accountcmd.go</h2><h3 id="accountCommand"><a href="#accountCommand" class="headerlink" title="accountCommand"></a>accountCommand</h3><p>管理账户，这部分的实现在后续的博客<a href="https://knarfeh.com/2018/03/10/go-ethereum%20源码笔记（accounts,%20transaction%20模块）/" target="_blank" rel="external">go-ethereum 源码笔记（accounts, transaction 模块）</a>有描述。</p>
<h4 id="list-geth-account-list"><a href="#list-geth-account-list" class="headerlink" title="list: geth account list"></a>list: <code>geth account list</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accountList</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	<span class="keyword">var</span> index <span class="keyword">int</span></div><div class="line">	<span class="keyword">for</span> _, wallet := <span class="keyword">range</span> stack.AccountManager().Wallets() &#123;</div><div class="line">		<span class="keyword">for</span> _, account := <span class="keyword">range</span> wallet.Accounts() &#123;</div><div class="line">			fmt.Printf(<span class="string">"Account #%d: &#123;%x&#125; %s\n"</span>, index, account.Address, &amp;account.URL)</div><div class="line">			index++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <code>accounts/manager.go</code> 的 <code>Wallets</code> 拿到所有账户。</p>
<h4 id="new-geth-account-new"><a href="#new-geth-account-new" class="headerlink" title="new: geth account new"></a>new: <code>geth account new</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accountCreate</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	cfg := gethConfig&#123;Node: defaultNodeConfig()&#125;</div><div class="line">	<span class="keyword">if</span> file := ctx.GlobalString(configFileFlag.Name); file != <span class="string">""</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := loadConfig(file, &amp;cfg); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"%v"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	utils.SetNodeConfig(ctx, &amp;cfg.Node)</div><div class="line">	scryptN, scryptP, keydir, err := cfg.Node.AccountConfig()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to read configuration: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	password := getPassPhrase(<span class="string">"Your new account is locked with a password. Please give a password. Do not forget this password."</span>, <span class="literal">true</span>, <span class="number">0</span>, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	address, err := keystore.StoreKey(keydir, password, scryptN, scryptP)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to create account: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Address: &#123;%x&#125;\n"</span>, address)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个账户，成功后输出地址。通过 <code>accounts</code> 模块实现。</p>
<h4 id="update：geth-account-update-lt-address-gt"><a href="#update：geth-account-update-lt-address-gt" class="headerlink" title="update：geth account update &lt;address&gt;"></a>update：<code>geth account update &lt;address&gt;</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accountUpdate</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ctx.Args()) == <span class="number">0</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"No accounts specified to update"</span>)</div><div class="line">	&#125;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> ctx.Args() &#123;</div><div class="line">		account, oldPassword := unlockAccount(ctx, ks, addr, <span class="number">0</span>, <span class="literal">nil</span>)</div><div class="line">		newPassword := getPassPhrase(<span class="string">"Please give a new password. Do not forget this password."</span>, <span class="literal">true</span>, <span class="number">0</span>, <span class="literal">nil</span>)</div><div class="line">		<span class="keyword">if</span> err := ks.Update(account, oldPassword, newPassword); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Could not update the account: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先通过 <code>AccountManager</code> 拿到 keystore，然后调用 <code>Update</code> 更新密码</p>
<h4 id="import-geth-account-import-lt-keyfile-gt"><a href="#import-geth-account-import-lt-keyfile-gt" class="headerlink" title="import: geth account import &lt;keyfile&gt;"></a>import: <code>geth account import &lt;keyfile&gt;</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accountImport</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	keyfile := ctx.Args().First()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(keyfile) == <span class="number">0</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"keyfile must be given as argument"</span>)</div><div class="line">	&#125;</div><div class="line">	key, err := crypto.LoadECDSA(keyfile)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to load the private key: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	passphrase := getPassPhrase(<span class="string">"Your new account is locked with a password. Please give a password. Do not forget this password."</span>, <span class="literal">true</span>, <span class="number">0</span>, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</div><div class="line">	acct, err := ks.ImportECDSA(key, passphrase)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Could not create the account: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Address: &#123;%x&#125;\n"</span>, acct.Address)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先通过 <code>AccountManager</code> 拿到 keystore，调用 <code>ImportPreSaleKey</code> 导入账户。</p>
<h3 id="walletCommand-geth-wallet-import-path-to-my-presale-wallet"><a href="#walletCommand-geth-wallet-import-path-to-my-presale-wallet" class="headerlink" title="walletCommand: geth wallet import /path/to/my/presale.wallet"></a>walletCommand: <code>geth wallet import /path/to/my/presale.wallet</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">importWallet</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	keyfile := ctx.Args().First()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(keyfile) == <span class="number">0</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"keyfile must be given as argument"</span>)</div><div class="line">	&#125;</div><div class="line">	keyJSON, err := ioutil.ReadFile(keyfile)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Could not read wallet file: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stack, _ := makeConfigNode(ctx)</div><div class="line">	passphrase := getPassPhrase(<span class="string">""</span>, <span class="literal">false</span>, <span class="number">0</span>, utils.MakePasswordList(ctx))</div><div class="line"></div><div class="line">	ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</div><div class="line">	acct, err := ks.ImportPreSaleKey(keyJSON, passphrase)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"%v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Address: &#123;%x&#125;\n"</span>, acct.Address)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>AccountManager</code> 管理以太坊预售钱包。</p>
<h2 id="consolecmd-go"><a href="#consolecmd-go" class="headerlink" title="consolecmd.go"></a>consolecmd.go</h2><h3 id="consoleCommand-geth-console"><a href="#consoleCommand-geth-console" class="headerlink" title="consoleCommand: geth console"></a>consoleCommand: <code>geth console</code></h3><p>启动一个 Javascript 交互式环境</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">localConsole</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	node := makeFullNode(ctx)</div><div class="line">	startNode(ctx, node)</div><div class="line">	<span class="keyword">defer</span> node.Stop()</div><div class="line"></div><div class="line">	client, err := node.Attach()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to attach to the inproc geth: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to start the JavaScript console: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> console.Stop(<span class="literal">false</span>)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> script := ctx.GlobalString(utils.ExecFlag.Name); script != <span class="string">""</span> &#123;</div><div class="line">		console.Evaluate(script)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	console.Welcome()</div><div class="line">	console.Interactive()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动本地的一个交互式 Javascript 环境，功能是通过 <code>console</code> 模块提供的，而 <code>console</code> 模块是对 <a href="https://github.com/robertkrimen/otto" target="_blank" rel="external">robertkrimen/otto</a> 的一个封装。otto 是一个 Golang 实现的 Javascript 解释器，可以实现在 Golang 中执行 Javascript，并且可以让在虚拟机里的 Javascript 调用 Golang 函数，实现 Golang 和 Javascript 的相互操作。</p>
<h3 id="attachCommand"><a href="#attachCommand" class="headerlink" title="attachCommand"></a>attachCommand</h3><p>启动一个 JS 交互式环境(连接到节点)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">remoteConsole</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	endpoint := ctx.Args().First()</div><div class="line">	<span class="keyword">if</span> endpoint == <span class="string">""</span> &#123;</div><div class="line">		path := node.DefaultDataDir()</div><div class="line">		<span class="keyword">if</span> ctx.GlobalIsSet(utils.DataDirFlag.Name) &#123;</div><div class="line">			path = ctx.GlobalString(utils.DataDirFlag.Name)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> path != <span class="string">""</span> &#123;</div><div class="line">			<span class="keyword">if</span> ctx.GlobalBool(utils.TestnetFlag.Name) &#123;</div><div class="line">				path = filepath.Join(path, <span class="string">"testnet"</span>)</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ctx.GlobalBool(utils.RinkebyFlag.Name) &#123;</div><div class="line">				path = filepath.Join(path, <span class="string">"rinkeby"</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		endpoint = fmt.Sprintf(<span class="string">"%s/geth.ipc"</span>, path)</div><div class="line">	&#125;</div><div class="line">	client, err := dialRPC(endpoint)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Unable to attach to remote geth: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to start the JavaScript console: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> console.Stop(<span class="literal">false</span>)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> script := ctx.GlobalString(utils.ExecFlag.Name); script != <span class="string">""</span> &#123;</div><div class="line">		console.Evaluate(script)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console.Welcome()</div><div class="line">	console.Interactive()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过指定 endpoint 的方式，连接到某个节点的交互式 Javascript 环境。</p>
<h3 id="javascriptCommand-geth-js-lt-jsfile-gt-jsfile"><a href="#javascriptCommand-geth-js-lt-jsfile-gt-jsfile" class="headerlink" title="javascriptCommand: geth js &lt;jsfile&gt; [jsfile...]"></a>javascriptCommand: <code>geth js &lt;jsfile&gt; [jsfile...]</code></h3><p>执行 Javascript 文件中的命令(可以为多个文件)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ephemeralConsole</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	node := makeFullNode(ctx)</div><div class="line">	startNode(ctx, node)</div><div class="line">	<span class="keyword">defer</span> node.Stop()</div><div class="line"></div><div class="line">	client, err := node.Attach()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to attach to the inproc geth: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	config := console.Config&#123;</div><div class="line">		DataDir: utils.MakeDataDir(ctx),</div><div class="line">		DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">		Client:  client,</div><div class="line">		Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console, err := console.New(config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Failed to start the JavaScript console: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> console.Stop(<span class="literal">false</span>)</div><div class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> ctx.Args() &#123;</div><div class="line">		<span class="keyword">if</span> err = console.Execute(file); err != <span class="literal">nil</span> &#123;</div><div class="line">			utils.Fatalf(<span class="string">"Failed to execute %s: %v"</span>, file, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	abort := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</div><div class="line">	signal.Notify(abort, syscall.SIGINT, syscall.SIGTERM)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		&lt;-abort</div><div class="line">		os.Exit(<span class="number">0</span>)</div><div class="line">	&#125;()</div><div class="line">	console.Stop(<span class="literal">true</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过遍历调用传输的文件路径，执行 <code>console.Execute</code>，执行 js 命令。</p>
<h2 id="misccmd-go"><a href="#misccmd-go" class="headerlink" title="misccmd.go"></a>misccmd.go</h2><h3 id="makecacheCommand-geth-makecache-lt-block-number-gt-lt-outputdir-gt"><a href="#makecacheCommand-geth-makecache-lt-block-number-gt-lt-outputdir-gt" class="headerlink" title="makecacheCommand: geth makecache &lt;block number&gt; &lt;outputdir&gt;"></a>makecacheCommand: <code>geth makecache &lt;block number&gt; &lt;outputdir&gt;</code></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func makecache(ctx *<span class="keyword">cli</span>.Context) <span class="keyword">error</span> &#123;</div><div class="line">	<span class="keyword">args</span> := ctx.<span class="keyword">Args</span>()</div><div class="line">	<span class="keyword">if</span> len(<span class="keyword">args</span>) != 2 &#123;</div><div class="line">		utils.Fatalf(`Usage: geth makecache &lt;block number&gt; &lt;outputdir&gt;`)</div><div class="line">	&#125;</div><div class="line">	block, <span class="keyword">err</span> := strconv.ParseUint(<span class="keyword">args</span>[0], 0, 64)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Invalid block number: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	ethash.MakeCache(block, <span class="keyword">args</span>[1])</div><div class="line"></div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成 ethash 的验证缓存。这部分内容将在<a href="#TODO">go-ethereum 源码笔记（miner，consensus 模块）</a>描述。</p>
<h3 id="makedagCommand-geth-makedag-lt-block-number-gt-lt-outputdir-gt"><a href="#makedagCommand-geth-makedag-lt-block-number-gt-lt-outputdir-gt" class="headerlink" title="makedagCommand: geth makedag &lt;block number&gt; &lt;outputdir&gt;"></a>makedagCommand: <code>geth makedag &lt;block number&gt; &lt;outputdir&gt;</code></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func makedag(ctx *<span class="keyword">cli</span>.Context) <span class="keyword">error</span> &#123;</div><div class="line">	<span class="keyword">args</span> := ctx.<span class="keyword">Args</span>()</div><div class="line">	<span class="keyword">if</span> len(<span class="keyword">args</span>) != 2 &#123;</div><div class="line">		utils.Fatalf(`Usage: geth makedag &lt;block number&gt; &lt;outputdir&gt;`)</div><div class="line">	&#125;</div><div class="line">	block, <span class="keyword">err</span> := strconv.ParseUint(<span class="keyword">args</span>[0], 0, 64)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		utils.Fatalf(<span class="string">"Invalid block number: %v"</span>, <span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">	ethash.MakeDataset(block, <span class="keyword">args</span>[1])</div><div class="line"></div><div class="line">	<span class="keyword">return</span> nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 ethash 的 <code>MakeDataset</code>，生成挖矿需要的 DAG 数据集。</p>
<h3 id="versionCommand-geth-version"><a href="#versionCommand-geth-version" class="headerlink" title="versionCommand: geth version"></a>versionCommand: <code>geth version</code></h3><p>输出版本号。</p>
<h3 id="bugCommand"><a href="#bugCommand" class="headerlink" title="bugCommand"></a>bugCommand</h3><p>给 <code>https://github.com/ethereum/go-ethereum/issues/new</code> 这个 url 拼接参数，给源代码仓库提一个 issue</p>
<h3 id="licenseCommand-geth-license"><a href="#licenseCommand-geth-license" class="headerlink" title="licenseCommand: geth license"></a>licenseCommand: <code>geth license</code></h3><p>输出 License 信息。</p>
<h2 id="config-go"><a href="#config-go" class="headerlink" title="config.go"></a>config.go</h2><h3 id="dumpConfigCommand-geth-dumpconfig"><a href="#dumpConfigCommand-geth-dumpconfig" class="headerlink" title="dumpConfigCommand: geth dumpconfig"></a>dumpConfigCommand: <code>geth dumpconfig</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dumpConfig</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	_, cfg := makeConfigNode(ctx)</div><div class="line">	comment := <span class="string">""</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> cfg.Eth.Genesis != <span class="literal">nil</span> &#123;</div><div class="line">		cfg.Eth.Genesis = <span class="literal">nil</span></div><div class="line">		comment += <span class="string">"# Note: this config doesn't contain the genesis block.\n\n"</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	out, err := tomlSettings.Marshal(&amp;cfg)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	io.WriteString(os.Stdout, comment)</div><div class="line">	os.Stdout.Write(out)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>makeConfigNode</code> 前面已经提过，这个方法用来获取当前配置信息，<code>dumpConfig</code> 函数通过 <code>makeConfigNode</code> 获取配置，然后将其输出在屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmd 模块包含了很多子模块，基本上每个子模块表示一个可执行的命令，其中最重要的是 geth 命令，它是以太坊的命令行客户端。&lt;/p&gt;
&lt;p&gt;geth 命令是以太坊提供的一个强大的命令行工具，它是使用以太坊的入口。它包括了很多子命令，你可以通过 &lt;code&gt;geth --help&lt;/code&gt; 获得更多帮助信息。其运行方法是：&lt;code&gt;geth [选项] 命令 [命令选项][参数…]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（基础知识）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（基础知识）/</id>
    <published>2018-03-10T14:34:57.000Z</published>
    <updated>2018-09-18T18:23:48.885Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将梳理以太坊的基本概念，说明一些值得注意的地方，这里不会讲解比特币的原理，代码，但会介绍以太坊与比特币的差异，所以最好看过比特币的论文，对比特币的基本原理、实现有所了解。这一篇将以太坊的白皮书作为重要参考，可以看做是以太坊白皮书的概述。以太坊的白皮书是一个非常好的学习资料，它在介绍以太坊前分析了比特币存在的问题，因此我们可以通过这份白皮书了解整个加密货币的生态。</p>
<a id="more"></a>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul>
<li>简单性</li>
<li>普遍性</li>
<li>模块化</li>
<li>敏捷性</li>
<li>不歧视，非审查</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>见上一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>智能合约是以太坊与比特币最大的不同。智能合约是不可篡改的合同，它运行在由以太坊组成的分布式计算机上，由一段支持图灵完备的程序实现。</p>
<p><strong>初学</strong>智能合约的最佳资料：<a href="https://cryptozombies.io/" target="_blank" rel="external">cryptozombies</a></p>
<p>智能合约与一般的程序有些不同：</p>
<ul>
<li>Address 类型可以定位用户，定位合约的代码</li>
<li>语言内嵌框架支持支付，所以提供了一些如 payable 的关键字，在语言层面支持支付</li>
<li>使用区块链作为存储</li>
<li>运行环境是去中心化的网络，比较强调合约或函数执行的调用方式。</li>
<li>一旦出现异常，所有的执行都会回撤，合约的执行具有原子性</li>
</ul>
<p>有四种专用语言可以写智能合约，Solidity，Serpent，Mutan，LLL。</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><h5 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h5><p>受 Javascript 启发。</p>
<p>是以太坊的首选语言，语法接近 Javascript，它是一种面向对象的语言，易于被掌握和使用，由于语法与 Javascript 相近，并且学习门栏相对较低，目前是使用人数最多的智能合约开发语言。编译器用 C++ 实现。</p>
<p>项目主页是：<a href="https://github.com/ethereum/solidity" target="_blank" rel="external">ethereum/solidity</a></p>
<h5 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a>Serpent</h5><p>受 Python 启发。兼顾底层语言效率和良好编程风格的同时尽可能追求简洁，加入了一些针对合约编程的特性。编译器用 C++ 实现。</p>
<p>项目主页是：<a href="https://github.com/ethereum/serpent" target="_blank" rel="external">ethereum/serpent</a></p>
<h5 id="Mutan"><a href="#Mutan" class="headerlink" title="Mutan"></a>Mutan</h5><p>受 Golang 启发。Golang 实现，2015年就被废弃了。</p>
<p>项目主页是：<a href="https://github.com/obscuren/mutan" target="_blank" rel="external">obscuren/mutan</a></p>
<h5 id="LLL-Lisp-Like-Language"><a href="#LLL-Lisp-Like-Language" class="headerlink" title="LLL(Lisp Like Language)"></a>LLL(Lisp Like Language)</h5><p>受 Lisp 启发。</p>
<h4 id="特征-来自知识星球-区块链学习小组-的讨论"><a href="#特征-来自知识星球-区块链学习小组-的讨论" class="headerlink" title="特征 (来自知识星球 区块链学习小组 的讨论)"></a>特征 (来自知识星球 <a href="https://t.zsxq.com/fiauZZJ" target="_blank" rel="external">区块链学习小组</a> 的讨论)</h4><ul>
<li>自治 一旦启动，不受干预</li>
<li>自足 程序自主控制其计算涉及的资源，有权限调配参与者的资金，财产</li>
<li>去中心化 不依赖某个单独的服务器，由分布式网络的节点共同支持运行</li>
</ul>
<h4 id="DApp-的优势"><a href="#DApp-的优势" class="headerlink" title="DApp 的优势"></a>DApp 的优势</h4><ul>
<li>DApp 大多为开源项目，公开透明</li>
<li>去中心化</li>
<li>具有激励机制</li>
<li>具有共识协议</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>信用卡的定期扣款(按月订阅的自动扣款)</li>
<li>飞机延误险(各类保险)</li>
<li>ICO</li>
<li>…</li>
</ul>
<h3 id="EVM-高级语言"><a href="#EVM-高级语言" class="headerlink" title="EVM 高级语言"></a>EVM 高级语言</h3><p>以太坊实现了一个叫做 Ethereum Virtual Machine 的运行时环境，类似于 JVM，它的主要工作是执行智能合约的字节码。</p>
<h3 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h3><p>以太坊中有两类账户，外部账户和合约账户，两类账户对于 EVM 来说没有区别，每个账户都有一个与之关联的账户状态和一个20字节的地址，都可以存储以太币。</p>
<p>外部账户：由私钥控制，没有代码与之关联，地址由公钥决定。私钥可用于对交易签名从而主动向其他账户发起交易（transaction）进行消息传递。</p>
<p>合约账户：由合约代码控制，有代码与之关联，其地址由合约创建者的地址和该地址发出过的交易数量 nonce 共同决定。不能主动向其他账户发起交易，但可以『响应』其他账户进行消息调用（message call）。</p>
<p>外部账户之间的消息传递是价值转移的过程，外部账户到合约账户的交易或合约账户到合约账户的消息会激发合约账户代码的执行，允许它执行如转移代币，写入内部存储，执行运算，创建合约等各种操作。</p>
<p>不论账户类型，账户状态都包含以下四个字段：</p>
<ul>
<li>nonce：由账户发出的交易数及创建的合约数量决定。</li>
<li>Balance：余额，账户拥有以太币数量，单位为 Wei，1Ether=10^18Wei。</li>
<li>storageRoot：存储根节点，账户内容的 Merkle Patricia 树根节点的哈希编码。</li>
<li>codeHash：代码哈希，与账户关联的 EVM 代码的哈希值，外部账户的 codeHash 为一个空字符串的哈希，创建后不可更改。状态数据库中包含所有代码片段哈希, 以便后续使用。</li>
</ul>
<h3 id="Gas-的设计"><a href="#Gas-的设计" class="headerlink" title="Gas 的设计"></a>Gas 的设计</h3><p>以太坊是一个能够运行智能合约的去中心化平台，它提供了一个以太坊虚拟机，简称 EVM，开发者可以在上面开发各种应用，而且它是图灵完备的，这意味着我们写的智能合约是可以运行死循环的。要知道，『不存在这样一个程序，它能够检测任何程序在给定输入上是否会结束』，这称为图灵停机问题。以太坊用一个很精彩的设计来解决这个问题，这就是 Gas。Gas 的设计基于这样一个想法：执行程序应该是消耗资源的，每一步操作，ADD 也好，DIV 也好，都应该消耗不同程度的资源，资源提前消耗完了，就强行终止程序。总的来说，Gas 是以太坊中对所有活动进行消耗资源计量的单位，包括但不限于：转账，合约创建，合约指令执行，扩展内存。Gas 是一个浮动的量，每一笔交易可以自行指定 Gas 价格(以以太币计算)，价格越高，矿工将你的交易打包进区块的优先级就越高。最终，Gas 的消耗等于消耗的 Gas 数量乘以 Gas 价格，这笔钱将奖励给矿工。交易完成后，剩余的 Gas 以购买时的价格退回到交易发送者账户，若交易过程中发生 Gas 不足异常(out-of-gas, OOG)，交易会被当做无效交易，已消耗 Gas 不会退回，仍作为矿工贡献计算资源的奖励。</p>
<p>更多细节请查阅：<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees" target="_blank" rel="external">wiki/Design-Rationale#gas-and-fees</a></p>
<h3 id="世界状态"><a href="#世界状态" class="headerlink" title="世界状态"></a>世界状态</h3><p>世界状态是地址(160位标示符)和账户状态(序列化为 RLP 的数据结构)间的映射，区块链不直接存储世界状态，而是在区块头中存储相关 Merkle Patricia 树根节点的哈希值。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>日志是 EVM 提供的一项功能。开发者可以在合约代码里记录各种事件产生的日志，这些日志可以帮助开发者调试代码，或者作为在区块链上发生交易的证据。</p>
<h3 id="各版本特性"><a href="#各版本特性" class="headerlink" title="各版本特性"></a>各版本特性</h3><ul>
<li>Frontier（边境）2015年7月发布，以太坊的第一个版本，只有命令行界面，主要使用者是开发者</li>
<li>Homestead（家园）2016年3月发布，第一个生产环境版本，加快了交易速度，增加图形界面，让普通用户也可以使用以太坊的功能</li>
<li>Metropolis（大都会）2017年10月发布，这个阶段分两个版本，先是拜占庭，2017年10月发布，然后是君士坦丁堡，预计2018年发布，增加浏览器，应用商店的特性，使用更方便，可以安装插件实现更多功能。更轻量、更快速、更安全。</li>
<li>Serenity（宁静）时间待定，使用 PoS，使用 Casper 共识算法。</li>
</ul>
<h2 id="以太坊和比特币的差异"><a href="#以太坊和比特币的差异" class="headerlink" title="以太坊和比特币的差异"></a>以太坊和比特币的差异</h2><h3 id="理念不同"><a href="#理念不同" class="headerlink" title="理念不同"></a>理念不同</h3><p>比特币想要实现的是电子现金系统，而以太坊想要实现的是图灵完备的智能合约平台。</p>
<h3 id="智能合约-VS-Script"><a href="#智能合约-VS-Script" class="headerlink" title="智能合约 VS Script"></a>智能合约 VS Script</h3><p>比特币协议本身也是可以实现智能协议的。在比特币中，有一个交易脚本语言，它是一种基于栈的执行语言，包含基本算数计算、基本逻辑（if 等）、报错及返回结果和一些加密指令，但不支持循环。</p>
<p>根据比特币协议的实现，在花费 UTXO 前，必须满足脚本的要求，即满足解锁 UTXO脚本，用私钥匹配解锁脚本（Signature script），以保证交易只能花费自己的比特币，即交易的输入，交易的输入指向的是锁定脚本（PubKey script），它确保签名能匹配输出地址。显然我们可以应用更复杂的脚本实现智能合约，没有循环也可以用重复的代码实现，显然这样的方法太糟糕了。</p>
<p>比特币的脚本语言存在的几处限制在 Vitalik 最初发布的白皮书里也有描述：</p>
<ul>
<li>缺乏图灵完整性，不支持循环语句</li>
<li>价值盲区，无法对 UTXO 进行精细化控制</li>
<li>不能保存状态，UTXO 只有用完和没用两种状态，没法实现多阶段期权合约</li>
<li>区块链盲区，UTXO 中没有区块链数据(随机数，时间戳，前一个区块哈希)，不能挖掘随机性的潜在价值</li>
</ul>
<p>更具体的描述可以查看<a href="https://github.com/knarfeh/papers/blob/master/Blockchain/Ethereum/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf" target="_blank" rel="external">这个地址</a>。</p>
<p>我们知道区块链的本质是一个分布式的公共数据库，它最早用来包括数字交易记录，这也是它到目前为止最为广泛的应用，区块链的特别之处在于，它不需要任何中央权威机构来维护，它是一个不需要第三方的 p2p 的框架。以太坊的智能合约让它与比特币又有了本质的不同，把区块链看做分布式数据库，那么以太坊就是一个能够能够在数据库上运行分布式应用的超级计算机，是智能合约让以太坊和比特币有了本质的不同，它是代码和数据（状态）的集合。</p>
<p>比特币的脚本有诸多限制，能够编写的程序有限，而以太坊的智能合约是图灵完备的，它非常适合于对信任、安全和持久性要求较高的应用场景，如：数字货币、数字资产、投票，保险、金融应用、预测市场，产权所有权管理、物联网等等。目前来说，除了数字货币之外，真正落地的应用还不多，因为区块链还存在诸多问题，比如亟需解决的交易性能问题，因此隔离见证，闪电网络，侧链等技术飞速发展，各种公链也针对某些问题提出自己的方案，这些既是挑战，也是机遇。</p>
<h3 id="Accounts-VS-UTXO"><a href="#Accounts-VS-UTXO" class="headerlink" title="Accounts VS UTXO"></a>Accounts VS UTXO</h3><p>比特币用 UTXO 方法计算某账户的余额，UTXO 即 Unspent Transaction Outputs。这个概念稍稍有点复杂，这里只做简单介绍。比特币整个系统的状态由未花费交易输出组成。每个 UTXO 都有拥有者和自身的价值属性，一笔交易会消费若干个 UTXO，同时也会生成若干个新的 UTXO，UTXO 有下面几点约束：</p>
<ol>
<li>每个被引用的输入必须有效，且未被使用过</li>
<li>交易的签名必须与每笔输入的所有者签名匹配</li>
<li>输入的总值必须等于或大于输出的总值</li>
</ol>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/en-transaction-propagation.png" alt="transaction of bitcoin, https://bitcoin.org/img/dev/en-transaction-propagation.svg"></p>
<p>个人认为理解 UTXO 的最佳方式是读这个<a href="https://github.com/Jeiwan/blockchain_go" target="_blank" rel="external">仓库</a>的源代码，这个作者写了7篇文章，实现了一个比特币的原型，Bitcoin Core 的代码是 C++ 写的，且代码复杂，年代久远，这个仓库使用 Golang，简单易懂，UTXO 的实现在 <a href="https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket" target="_blank" rel="external">Transactions 1</a>。感兴趣的朋友可以进一步阅读。</p>
<p>UTXO 的好处是（来自以太坊的维基）：</p>
<ol>
<li>匿名性更好，一个用户接收到一笔转账，这些转账的输入可以有多个私钥形成，但其实这些输入可以是同一个人的，这样能保证一定程度的匿名性。</li>
<li>UTXO 是无状态的，更具扩展性。</li>
</ol>
<p>以太坊没有采用 UTXO 的方式进行记账，而是采用了传统金融的记账方式–使用账户，每笔交易只有一个输入，一个输出，一个签名。使用单独的账户系统的好处是（来自以太坊维基）：</p>
<ol>
<li>节省大量存储空间。每笔交易只有一个输入和一个输出。</li>
<li>可替换性。可操控性可能更好一些，使用账户模型可以更轻松地实现黑名单这样的模式。</li>
<li>编码上更简单。获取账户余额时，只需要一个查询，而比特币需要整合指定地址所拥有的所有 UTXO 的总值。</li>
<li>可以更轻松地实现轻客户端。</li>
</ol>
<p>Vitalik 在一篇<a href="https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53" target="_blank" rel="external">博客</a>中还谈到 UTXO 可能引发拒绝服务漏洞。而且基于 UTXO 的模型与有状态的智能合约不太契合。以太坊最终选择使用账户模型。</p>
<p>以太坊使用状态（state）的概念来存储一系列账户，每个账户有自己的余额以及特定数据（代码或内部存储），如果交易发起方有足够余额支付交易费用，则交易有效，发起方账户扣除相应金额，接收账户增加余额。账户还用于智能合约的创建和执行，可以通过转账来触发接收账户对应的代码的执行，该账户的内部存储可能会发生变化，同时也可以创建额外信息发给其他账户，触发新的交易。从这一点可以看到，dapp 需要跟用户状态进行复杂的交互，通过 UTXO 实现会比较难满足需求。</p>
<h3 id="区块链设计的不同"><a href="#区块链设计的不同" class="headerlink" title="区块链设计的不同"></a>区块链设计的不同</h3><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><p>比特币的区块包括区块头和区块体两部分，区块头封装了前一个区块的哈希值、时间戳，随机数，默克尔树根值和当前区块的哈希值，区块体中包括交易计数和交易详情。区块结构如下图（摘自 Bitcoin 白皮书）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/bitcoin_block_from_bitcoinpaper.png" alt="bitcoin_block"></p>
<h4 id="以太坊-1"><a href="#以太坊-1" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊在比特币区块链基础上做了一些调整，区块主要由区块头、交易列表和叔区块头三部分组成。区块头包括父区块的哈希值、叔区块的哈希值、状态树根哈希值、交易树根哈希值、收据树根哈希值、时间戳、随机数，比较特别的是采用了改进的默克尔树，压缩前缀树的结构 MPT，这部分在 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT 的实现）</a> 会进一步探讨。区块结构如下图（摘自 <a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="external">Ethereum 博客</a>）：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/ethblockchain_full.png" alt="ethereum_block"></p>
<h3 id="PoW-机制的不同"><a href="#PoW-机制的不同" class="headerlink" title="PoW 机制的不同"></a>PoW 机制的不同</h3><p>PoW，Proof of Work 的缩写，即工作量证明，又称挖矿，目前比特币，以太坊都基于 PoW 算法实现共识机制，即根据挖矿的贡献决定货币的分配。</p>
<h4 id="比特币-1"><a href="#比特币-1" class="headerlink" title="比特币"></a>比特币</h4><p>比特币的 PoW 的过程，需要不断调整 Nonce 值，对区块头做双重 SHA256 哈希运算，使得结果满足给定数量前导0的哈希值的过程。其中前导0的个数，取决于挖矿难度，前导 0 的个数越多，挖矿难度越大。</p>
<h4 id="以太坊-2"><a href="#以太坊-2" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊的 PoW 算法可以表示为如下公式：$RAND(h, n) &lt;= M/d$<br>其中 $RAND()$ 表示一个概念函数，代表一系列的复杂运算，h 和 n 为输入，即区块 Header 的哈希、以及 Header 中的 Nonce。M 表示一个极大的数，此处使用 $2^{256}-1$。d 为区块难度，即Header 中的 Difficulty。在 h 和 n 确定的情况下，d 越大，挖矿难度越大。需不断变更 Nonce，使$RAND(h, n)$ 满足 $RAND(h, n) &lt;= M / d$ 完成 PoW。</p>
<p>需要注意的是以太坊目前的 PoW 只是临时的，未来将会是 PoS 的形式，到时候不会再需要耗费大量电力进行挖矿。</p>
<h3 id="挖矿难度更新"><a href="#挖矿难度更新" class="headerlink" title="挖矿难度更新"></a>挖矿难度更新</h3><h4 id="比特币-2"><a href="#比特币-2" class="headerlink" title="比特币"></a>比特币</h4><p>比特币每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下：</p>
<ol>
<li>找到前2016个块的第一个块，计算生成这2016个块花费的时间。<br>即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。</li>
<li>计算前2016个块的难度总和，即单个块的难度x总时间。</li>
<li>计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。</li>
<li>要求新的难度，难度不低于参数定义的最小难度。</li>
</ol>
<h4 id="以太坊-3"><a href="#以太坊-3" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊每次挖矿都需计算当前区块难度。按版本不同有三种计算难度的规则，分别为：<code>calcDifficultyByzantium</code>（Byzantium 版本）、<code>calcDifficultyHomestead</code>（Homestead 版本）、<code>calcDifficultyFrontier</code>（Frontier 版本）。以 <code>calcDifficultyHomestead</code> 为例。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">本区块难度 = 父区块难度 + 难度调整 + 难度炸弹</div><div class="line">难度调整 = 父区块难度 <span class="regexp">//</span> <span class="number">2048</span> * MAX(<span class="number">1</span> - (block_timestamp - parent_timestamp) <span class="regexp">//</span> <span class="number">10</span>, -<span class="number">99</span>)</div><div class="line">难度炸弹 = INT(<span class="number">2</span>**((block_number <span class="regexp">//</span> <span class="number">100000</span>) - <span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>以太坊的区块难度以单个区块为单位进行调整，所以可以比较快地适应算力变化，难度炸弹也是一个很有意思的设计，难度炸弹是指数级增长的，到某个阶段矿工会因为无利可图自动退场，这时 PoS 也应该成熟了，这对于矿工来说是一个预防针。</p>
<h3 id="奖励机制"><a href="#奖励机制" class="headerlink" title="奖励机制"></a>奖励机制</h3><h4 id="比特币-3"><a href="#比特币-3" class="headerlink" title="比特币"></a>比特币</h4><p>在比特币的设计中，最初每挖出一个区块会奖励50个 BTC，每挖出21万个，奖励就会减半，第1-210000个区块，每块奖励50btc，第210001-420000个区块，每块奖励25btc……以此类推。</p>
<p>因此 BTC 的总量为：210000×50(1+0.5+0.25+0.125+……)=2100万</p>
<h4 id="以太坊-4"><a href="#以太坊-4" class="headerlink" title="以太坊"></a>以太坊</h4><p>以太坊提出了一个叔块的概念。叔块是指没能成为主链的，但在后面的区块放入了 uncles 字段中的区块。</p>
<p>相比于比特币，以太坊对叔块也有奖励，为什么这么做呢，我们知道以太坊的出块时间是15秒左右，相比于比特币，以太坊更容易出现临时分叉和孤块，因为出块时间比较短，区块在整个网络中也比较难传播，对于网速比较慢的矿工就不占优势了，因此挖矿的时候，对于叔块也是有奖励的。</p>
<p>我们知道以太坊是一个运行智能合约的去中心化的平台，它有一个以太坊虚拟机（Ethereum Virtual Machine，常用缩写 EVM）的概念，EVM 是就像一个超级计算机，它是图灵完备的，写程序的时候可能会出现死循环，而智能合约应该避免这种情况，这引出一个<a href="https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="external">停机问题</a>，简单来说就是不存在能够检测程序进入了死循环的方法，以太坊提出了一种设计解决这个问题，EVM 规定了每条指令都会消耗一定的 Gas，指令越复杂，消耗的 Gas 越多，程序运行前是有一个消耗 Gas 的上限的，运行过程中 Gas 消耗完了，无论程序有没有执行完都会被强行终止。智能合约运行时花费的 Gas 最终会奖励给矿工。</p>
<p>综上，以太坊的挖矿奖励包括两部分：</p>
<h5 id="普通区块奖励"><a href="#普通区块奖励" class="headerlink" title="普通区块奖励"></a>普通区块奖励</h5><ul>
<li>固定奖励5ETH</li>
<li>花费的 Gas</li>
<li>如果区块中包括叔块，每包含一个可以得到5ETH的1/32</li>
</ul>
<h5 id="叔块奖励"><a href="#叔块奖励" class="headerlink" title="叔块奖励"></a>叔块奖励</h5><p>叔块奖励 = ( 叔块高度 + 8 - 包含叔块的区块的高度 ) * 普通区块奖励 / 8</p>
<h3 id="其他一些细节上的差异"><a href="#其他一些细节上的差异" class="headerlink" title="其他一些细节上的差异"></a>其他一些细节上的差异</h3><ul>
<li>出块时间，比特币的出块时间是平均10分钟，以太坊的平均出块时间是15秒。以太坊相对于比特币有更大的系统吞吐量和更小的交易确认间隔，尽管从长远来看，这远远不够。</li>
<li>区块奖励，比特币诞生于2009年1月，刚开始时区块奖励是50 BTC，每四年减半一次，2012年11月到2016年7月是25 BTC，目前是12.5 BTC，到2020年的2月将变成6.25 BTC；以太坊的挖矿奖励5个以太币，大都会版本后改成3个以太币。</li>
<li>以太币最多可以显示小数点后18位，比特币最多是小数点后8位。</li>
<li>…</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://en.bitcoin.it/wiki/Script" target="_blank" rel="external">Script</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="external">ethereum white paper</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees" target="_blank" rel="external">wiki/Design-Rationale#gas-and-fees</a></li>
<li><a href="https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53" target="_blank" rel="external">Thoughts on UTXOs by Vitalik Buterin, Co-Founder of Ethereum</a></li>
<li><a href="https://ethfans.org/posts/thoughts-on-utxo" target="_blank" rel="external">关于 UTXO 的思考</a></li>
<li><a href="https://steemit.com/ethereum/@alexma/2-utxo-vs" target="_blank" rel="external">浅谈以太坊（2）——以太坊的不同之处之UTXO vs 账户余额</a></li>
<li><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/" target="_blank" rel="external">比特币脚本及交易分析 - 智能合约雏形</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28830859" target="_blank" rel="external">以太坊(Ethereum ETH)是如何计算难度的</a></li>
<li><a href="https://cryptozombies.io/" target="_blank" rel="external">cryptozombies</a></li>
<li><a href="https://eips.ethereum.org/EIPS" target="_blank" rel="external">EIPs</a></li>
<li><a href="https://github.com/EthFans/wiki/wiki/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6" target="_blank" rel="external">EthFans/wiki/智能合约</a></li>
<li><a href="https://dbarobin.com/2018/01/24/blockchain-smart-contract/" target="_blank" rel="external">理解智能合约</a></li>
<li><a href="http://www.8btc.com/the-beginners-guide-to-ethereum-s-2020-roadmap" target="_blank" rel="external">以太坊路线图入门指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/ethereum" target="_blank" rel="external">以太坊技术专栏</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇将梳理以太坊的基本概念，说明一些值得注意的地方，这里不会讲解比特币的原理，代码，但会介绍以太坊与比特币的差异，所以最好看过比特币的论文，对比特币的基本原理、实现有所了解。这一篇将以太坊的白皮书作为重要参考，可以看做是以太坊白皮书的概述。以太坊的白皮书是一个非常好的学习资料，它在介绍以太坊前分析了比特币存在的问题，因此我们可以通过这份白皮书了解整个加密货币的生态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>go-ethereum 源码笔记（概览）</title>
    <link href="http://knarfeh.github.io/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/"/>
    <id>http://knarfeh.github.io/2018/03/10/go-ethereum 源码笔记（概览）/</id>
    <published>2018-03-10T14:34:56.000Z</published>
    <updated>2018-10-13T03:43:41.261Z</updated>
    
    <content type="html"><![CDATA[<p>花了一点时间读以太坊的源代码，内容太多，所以一边看一边写，没想到越写越多，于是想着把笔记整理出来。</p>
<p>源码解读是一件费力不讨好的事情，因为看代码的时候我们看到的是最终解决方案，虽然可以看到 commit 的历史，但我们看不到作者的思路，踩过的坑，而且 geth 的设计文档，功能的相关讨论等信息不像 Kubernetes 那么规范透明，所以我看这些代码的时候很多地方也只是一知半解，欢迎有更多经验的朋友批评指正，不吝赐教，也欢迎有价值的讨论。看了一些书和文章，所以我这也算不上多原创，基本上所有看过的链接都记在 reference 里面了。有的代码暂时看不懂就只能靠猜了，等待之后的实践中验证想法。尽管如此，对于同样想要阅读 geth 的源代码的人来说总还是有些作用，对于我个人来说整理出来这些文章也是一个总结知识，把点连成面的过程，希望同时能帮到其他人。</p>
<p>geth 版本：master 分支，a1eb9c7d13240fd250866219a502d0cdc9924e06</p>
<a id="more"></a>
<p>这是第一篇，可以作为索引，后续发布其他文章后会不断更新👇</p>
<ul>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（概览）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（基础知识）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-geth%20%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-geth 命令）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88cmd%20%E6%A8%A1%E5%9D%97-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（cmd 模块-其他命令）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%93%8D%E4%BD%9C%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-区块链操作）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88rlp%20%E6%A8%A1%E5%9D%97-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（rlp 模块-序列化与反序列化）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88trie%20%E6%A8%A1%E5%9D%97-MPT%20%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（trie 模块-MPT的实现）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88accounts,%20transaction%20%E6%A8%A1%E5%9D%97-%E8%B4%A6%E6%88%B7%E5%92%8C%E8%BD%AC%E8%B4%A6%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（accounts, transaction 模块-账户和转账）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-交易池模块）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88miner,%20consensus%20%E6%A8%A1%E5%9D%97-%E6%8C%96%E7%9F%BF%E5%92%8C%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（miner,consensus 模块-挖矿和共识算法)</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88ethdb%20%E6%A8%A1%E5%9D%97%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（ethdb 模块）</a></li>
<li><a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88core%20%E6%A8%A1%E5%9D%97-%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BA%A4%E6%98%93%E6%94%B6%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（core 模块-世界状态，交易收据管理）</a></li>
</ul>
<h2 id="涉及到的计算机专业知识"><a href="#涉及到的计算机专业知识" class="headerlink" title="涉及到的计算机专业知识"></a>涉及到的计算机专业知识</h2><ul>
<li>网络知识，p2p 网络（Kad 算法） ，rpc 等等</li>
<li>加密学，暂时不需要很深入，除非是像 <a href="http://teahour.fm/2018/07/08/how-to-build-blockchain-from-scratch.html" target="_blank" rel="external">How to build blockchain from scratch?</a> 说的需要构建加密函数相关的库，在大多数的场景下只需要知道加密函数的基本原理和使用。当然越深入越好，这一块也可以做出创新；安全对于很多行业是命脉，对于区块链来说更是如此。推荐阅读密码学入门经典：<a href="https://book.douban.com/subject/26265544/" target="_blank" rel="external">图解密码技术</a></li>
<li>编译原理，看 EVM 相关的实现时需要知道一些基本概念。</li>
<li>分布式系统原理(一致性算法)</li>
<li>智能合约</li>
<li>数据库(LevelDB)，了解 LSM 的特点，不需要太深入的了解，知道 API 调用即可。当然知道底层原理最好，这块也有改进的空间，微博上的<a href="https://weibo.com/1875401263/GtTacBjm2?filter=hot&amp;root_comment_id=0&amp;type=comment" target="_blank" rel="external">邓草原</a>同学在做这方面的工作，针对区块链的数据特点设计专门的存储引擎，TPS 有不小的提升，不过我还没有细看代码，从讨论来看应该是参考了 Kafka 的存储特点。</li>
<li>一些数据结构<ul>
<li>MPT</li>
<li>DAG</li>
<li>布隆过滤器</li>
<li>…</li>
</ul>
</li>
</ul>
<p>写完了这个系列可能会加个思维导图。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="总体架构图（来自-Ethereum-block-architecture）"><a href="#总体架构图（来自-Ethereum-block-architecture）" class="headerlink" title="总体架构图（来自 Ethereum block architecture）"></a>总体架构图（来自 <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" target="_blank" rel="external">Ethereum block architecture</a>）</h3><p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/stackexchange-ethereum-block-architecture.jpg" alt="https://i.stack.imgur.com/afWDt.jpg"></p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p><a href="https://book.douban.com/subject/30199891/" target="_blank" rel="external">以太坊技术详解与实战</a>这本书里介绍了以太坊的分层架构，其中的图片还挺有参考价值的，网络上没有找到原图，所以我自己画了一下：</p>
<p><img src="https://knarfeh-1254074221.cos.na-siliconvalley.myqcloud.com/ethereum-leveld-architecture.png" alt="ethereum-leveld-architecture"></p>
<h4 id="底层服务"><a href="#底层服务" class="headerlink" title="底层服务"></a>底层服务</h4><p>底层服务包括 P2P 网络、LevelDB 数据库、密码学算法和分片优化等基础服务。</p>
<h4 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h4><p>核心层包括区块链、共识算法和以太坊虚拟机等。</p>
<h4 id="顶层应用"><a href="#顶层应用" class="headerlink" title="顶层应用"></a>顶层应用</h4><p>这一层包括 API 接口、智能合约以及去中心化应用。</p>
<h2 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h2><h3 id="core-types-block-go-区块的数据结构"><a href="#core-types-block-go-区块的数据结构" class="headerlink" title="/core/types/block.go 区块的数据结构"></a><code>/core/types/block.go</code> 区块的数据结构</h3><p>区块的数据结构在 <code>core/types/block.go</code> 中定义。先混个眼熟吧。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type Block struct &#123;</div><div class="line">	<span class="selector-tag">header</span>       *Header</div><div class="line">	uncles       []*Header</div><div class="line">	transactions Transactions</div><div class="line">	hash atomic<span class="selector-class">.Value</span></div><div class="line">	size atomic<span class="selector-class">.Value</span></div><div class="line">	<span class="selector-tag">td</span> *big<span class="selector-class">.Int</span></div><div class="line">	ReceivedAt   <span class="selector-tag">time</span><span class="selector-class">.Time</span></div><div class="line">	ReceivedFrom interface&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>重要字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>header 指向 Header 结构（之后会详细说明），header 存储一个区块的基本信息。</td>
</tr>
<tr>
<td>uncles</td>
<td>指向 Header 结构</td>
</tr>
<tr>
<td>transactions</td>
<td>一组 transaction 结构</td>
</tr>
<tr>
<td>hash</td>
<td>当前区块的哈希值</td>
</tr>
<tr>
<td>size</td>
<td>当前区块的大小</td>
</tr>
<tr>
<td>td</td>
<td>当前区块高度</td>
</tr>
<tr>
<td>ReceivedAt</td>
<td>接收时间</td>
</tr>
<tr>
<td>ReceivedFrom</td>
<td>来源</td>
</tr>
</tbody>
</table>
<p>交易组成区块，一个一个区块以单向链表的形式连在一起组成区块链，毋庸置疑，这是最基础的数据结构，在 geth 的源代码中大量用到。</p>
<p>其中 <code>Header</code> 的数据结构定义为：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type Header struct &#123;</div><div class="line">	ParentHash  common.Hash    `<span class="string">json:</span><span class="string">"parentHash"</span>       <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	UncleHash   common.Hash    `<span class="string">json:</span><span class="string">"sha3Uncles"</span>       <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Coinbase    common.Address `<span class="string">json:</span><span class="string">"miner"</span>            <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Root        common.Hash    `<span class="string">json:</span><span class="string">"stateRoot"</span>        <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	TxHash      common.Hash    `<span class="string">json:</span><span class="string">"transactionsRoot"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	ReceiptHash common.Hash    `<span class="string">json:</span><span class="string">"receiptsRoot"</span>     <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Bloom       Bloom          `<span class="string">json:</span><span class="string">"logsBloom"</span>        <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Difficulty  *big.Int       `<span class="string">json:</span><span class="string">"difficulty"</span>       <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Number      *big.Int       `<span class="string">json:</span><span class="string">"number"</span>           <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	GasLimit    uint64         `<span class="string">json:</span><span class="string">"gasLimit"</span>         <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	GasUsed     uint64         `<span class="string">json:</span><span class="string">"gasUsed"</span>          <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Time        *big.Int       `<span class="string">json:</span><span class="string">"timestamp"</span>        <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Extra       []<span class="keyword">byte</span>         `<span class="string">json:</span><span class="string">"extraData"</span>        <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	MixDigest   common.Hash    `<span class="string">json:</span><span class="string">"mixHash"</span>          <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Nonce       BlockNonce     `<span class="string">json:</span><span class="string">"nonce"</span>            <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ParentHash</td>
<td>父区块的哈希值</td>
</tr>
<tr>
<td>UncleHash</td>
<td>叔区块的哈希值</td>
</tr>
<tr>
<td>Coinbase</td>
<td>矿工得到奖励的账户，一般是矿工本地第一个账户</td>
</tr>
<tr>
<td>Root</td>
<td>表示当前所有用户状态</td>
</tr>
<tr>
<td>TxHash</td>
<td>本区块所有交易 Hash，即摘要</td>
</tr>
<tr>
<td>ReceiptHash</td>
<td>本区块所有收据 Hash，即摘要</td>
</tr>
<tr>
<td>Bloom</td>
<td>布隆过滤器，用来搜索收据</td>
</tr>
<tr>
<td>Difficulty</td>
<td>该区块难度，动态调整，与父区块和本区块挖矿时间有关。可参考 <code>github.com/ethereum/go-ethereum/consensus/ethash/consensus.go</code> 的 <code>CalcDifficulty</code></td>
</tr>
<tr>
<td>Number</td>
<td>该区块高度</td>
</tr>
<tr>
<td>GasLimit</td>
<td>gas 用量上限，该数值根据父区块 gas 用量调节，如果 <code>parentGasUsed &gt; parentGasLimit * (2/3)</code> ，则增大该数值，反之则减小该数值。可参看 <code>github.com/ethereum/go-ethereum/core/block_validator.go</code> 的 <code>CalcGasLimit</code></td>
</tr>
<tr>
<td>GasUsed</td>
<td>实际花费的 gas</td>
</tr>
<tr>
<td>Time</td>
<td>新区块的出块时间，严格来说是开始挖矿的时间</td>
</tr>
<tr>
<td>Extra</td>
<td>额外数据</td>
</tr>
<tr>
<td>MixDigest</td>
<td>混合哈希，与 nonce 结合使用</td>
</tr>
<tr>
<td>Nonce</td>
<td>加密学中的概念，在基本概念章节中有介绍</td>
</tr>
</tbody>
</table>
<p>它包含区块的属性信息，<code>ParentHash</code> 表示该区块的父区块哈希，我们通过 <code>ParentHash</code> 这个字段将一个一个区块连接起来组成区块链，但实际上我们并不会直接将链整个的存起来，它是以一定的数据结构一块一块存放的，geth 的底层数据库用的是 LevelDB，这是一个 key-value 数据库，要得到父区块时，我们通过 <code>ParentHash</code> 以及其他字符串组成 key，在 LevelDB 中查询该 key 对应的值，就能拿到父区块。</p>
<h3 id="core-blockchain-go-区块链的数据结构"><a href="#core-blockchain-go-区块链的数据结构" class="headerlink" title="/core/blockchain.go 区块链的数据结构"></a>/core/blockchain.go 区块链的数据结构</h3><p><code>core/blockchain.go</code> 的 <code>BlockChain</code> 结构体定义了区块链的数据结构</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">type BlockChain struct &#123;</div><div class="line">	chainConfig *params<span class="selector-class">.ChainConfig</span></div><div class="line">	cacheConfig *CacheConfig</div><div class="line"></div><div class="line">	db     ethdb<span class="selector-class">.Database</span></div><div class="line">	triegc *prque<span class="selector-class">.Prque</span></div><div class="line">	gcproc <span class="selector-tag">time</span><span class="selector-class">.Duration</span></div><div class="line"></div><div class="line">	hc            *HeaderChain</div><div class="line">	rmLogsFeed    event<span class="selector-class">.Feed</span></div><div class="line">	chainFeed     event<span class="selector-class">.Feed</span></div><div class="line">	chainSideFeed event<span class="selector-class">.Feed</span></div><div class="line">	chainHeadFeed event<span class="selector-class">.Feed</span></div><div class="line">	logsFeed      event<span class="selector-class">.Feed</span></div><div class="line">	scope         event<span class="selector-class">.SubscriptionScope</span></div><div class="line">	genesisBlock  *types<span class="selector-class">.Block</span></div><div class="line"></div><div class="line">	mu      sync<span class="selector-class">.RWMutex</span></div><div class="line">	chainmu sync<span class="selector-class">.RWMutex</span></div><div class="line">	procmu  sync<span class="selector-class">.RWMutex</span></div><div class="line"></div><div class="line">	checkpoint       int</div><div class="line">	currentBlock     atomic<span class="selector-class">.Value</span></div><div class="line">	currentFastBlock atomic<span class="selector-class">.Value</span></div><div class="line"></div><div class="line">	stateCache   state<span class="selector-class">.Database</span></div><div class="line">	bodyCache    *lru<span class="selector-class">.Cache</span></div><div class="line">	bodyRLPCache *lru<span class="selector-class">.Cache</span></div><div class="line">	blockCache   *lru<span class="selector-class">.Cache</span></div><div class="line">	futureBlocks *lru<span class="selector-class">.Cache</span></div><div class="line"></div><div class="line">	quit    chan struct&#123;&#125;</div><div class="line">	running int32</div><div class="line">	procInterrupt int32</div><div class="line">	wg            sync<span class="selector-class">.WaitGroup</span></div><div class="line"></div><div class="line">	engine    consensus<span class="selector-class">.Engine</span></div><div class="line">	processor Processor</div><div class="line">	validator Validator</div><div class="line">	vmConfig  vm<span class="selector-class">.Config</span></div><div class="line"></div><div class="line">	badBlocks *lru<span class="selector-class">.Cache</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UncleHash</code> 是 <code>Block</code> 结构体成员 <code>uncles</code> 的 RLP 哈希值，<code>uncles</code> 是一个 <code>Headers</code> 数组，关于叔区块，可以查阅以太坊的<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#uncle-incentivization" target="_blank" rel="external">设计原理</a>。在下一篇 <a href="https://knarfeh.com/2018/03/10/go-ethereum%20%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/" target="_blank" rel="external">go-ethereum 源码笔记（基础知识）</a> 会详细介绍叔区块。</p>
<p>Block 对象中还有一个比较重要的数据结构，那就是 <code>Transaction</code>，它是交易相关逻辑的基础。</p>
<h3 id="core-types-transaction-go-交易的数据结构"><a href="#core-types-transaction-go-交易的数据结构" class="headerlink" title="/core/types/transaction.go 交易的数据结构"></a><code>/core/types/transaction.go</code> 交易的数据结构</h3><p>交易的数据结构</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type Transaction struct &#123;</div><div class="line">	data txdata</div><div class="line">	<span class="comment">// caches</span></div><div class="line">	hash atomic.Value</div><div class="line">	size atomic.Value</div><div class="line">	from atomic.Value</div><div class="line">&#125;</div><div class="line"></div><div class="line">type txdata struct &#123;</div><div class="line">	AccountNonce uint64          `<span class="string">json:</span><span class="string">"nonce"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Price        *big.Int        `<span class="string">json:</span><span class="string">"gasPrice"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	GasLimit     uint64          `<span class="string">json:</span><span class="string">"gas"</span>      <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Recipient    *common.Address `<span class="string">json:</span><span class="string">"to"</span>       <span class="string">rlp:</span><span class="string">"nil"</span>`</div><div class="line">	Amount       *big.Int        `<span class="string">json:</span><span class="string">"value"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	Payload      []<span class="keyword">byte</span>          `<span class="string">json:</span><span class="string">"input"</span>    <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line"></div><div class="line">	V *big.Int `<span class="string">json:</span><span class="string">"v"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	R *big.Int `<span class="string">json:</span><span class="string">"r"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line">	S *big.Int `<span class="string">json:</span><span class="string">"s"</span> <span class="string">gencodec:</span><span class="string">"required"</span>`</div><div class="line"></div><div class="line">	Hash *common.Hash `<span class="string">json:</span><span class="string">"hash"</span> <span class="string">rlp:</span><span class="string">"-"</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转账的定义中只有转入方，转出方的地址没有直接暴露。每一笔转账都有独立的 Price 和 GasLimit，这是 Ethereum 的安全保护策略，是一个值得称赞的设计，如果你对这个不熟悉，请查阅：<a href="https://github.com/ethereum/wiki/wiki/Glossary" target="_blank" rel="external">wiki/Glossary</a>，在之后的文章中也会有介绍。</p>
<h2 id="geth-目录结构简述"><a href="#geth-目录结构简述" class="headerlink" title="geth 目录结构简述"></a>geth 目录结构简述</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">accounts        实现以太坊账户管理</div><div class="line"><span class="keyword">build </span>          编译和构建的一些脚本和配置</div><div class="line">cmd             命令行工具，又分了很多的命令行工具，下面会一个一个介绍</div><div class="line">    abigen      将以太坊智能合约定义转换为类型安全的 Go 或 <span class="keyword">Java </span>包的源码转换器</div><div class="line">    <span class="keyword">bootnode	</span>启动一个用于网络发现的节点</div><div class="line">    evm         以太坊虚拟机的开发工具，用来提供一个可配置的，受隔离的代码调试环境</div><div class="line">    faucet		以太坊 faucet 测试网络</div><div class="line">    geth        以太坊命令行客户端，最重要的一个工具</div><div class="line">    p2psim      提供了一个工具来模拟 p2p 的 API</div><div class="line">    puppeth     创建一个新的以太坊网络的向导</div><div class="line">    rlpdump     提供了一个 RLP 数据的格式化输出</div><div class="line">    <span class="keyword">swarm </span>      <span class="keyword">swarm </span>网络的接入点</div><div class="line">    util        提供了一些公共的工具</div><div class="line">    wnode       这是一个简单的 Whisper 节点。它可以用作独立的引导节点。此外可以用于不同的测试和诊断目的</div><div class="line">common      	提供了一些公共的工具类</div><div class="line">consensus       提供了以太坊的一些共识算法，比如 ethhash, clique(proof-of-authority)</div><div class="line">console         与终端交互相关的代码</div><div class="line">containers		Docker 容器相关的代码</div><div class="line">contracts		以太坊域名服务，票据支付方案</div><div class="line">core            以太坊的核心数据结构和算法(虚拟机，状态，区块链，布隆过滤器)</div><div class="line">crypto          加密和 hash 算法</div><div class="line">dashboard		以太坊后台管理 UI</div><div class="line">eth             实现了以太坊的协议</div><div class="line">ethclient       提供了以太坊的 RPC 客户端</div><div class="line">ethdb           封装 geth 的数据库(包括实际使用的 Leveldb 和供测试使用的内存数据库)</div><div class="line">ethstats        提供网络状态的报告</div><div class="line">event           处理实时的事件</div><div class="line">les             实现了以太坊的轻量级协议子集</div><div class="line">light           为以太坊轻量级客户端提供按需检索的功能</div><div class="line">log             提供对人机都友好的日志信息</div><div class="line">metrics         提供磁盘计数器</div><div class="line">miner           提供以太坊的区块创建和挖矿</div><div class="line">mobile          移动端使用的一些 warpper</div><div class="line">node            以太坊的多种类型的节点</div><div class="line">p2p             以太坊 p2p 网络协议</div><div class="line">rlp             以太坊编码算法</div><div class="line">rpc             远程方法调用</div><div class="line"><span class="keyword">swarm </span>          <span class="keyword">swarm </span>网络</div><div class="line">tests           测试</div><div class="line">trie            实现以太坊中的默克尔帕特里夏树</div><div class="line">whisper         提供了 whisper 节点的协议</div></pre></td></tr></table></figure>
<h2 id="从编译源代码开始"><a href="#从编译源代码开始" class="headerlink" title="从编译源代码开始"></a>从编译源代码开始</h2><p>按照官方文档的建议设置好开发环境，在 go-ethereum 执行 <code>make build</code> 之后，我们可以在 build/bin 目录下找到 abigen, ethkey 等等可执行文件，实际上这些文件的入口函数都在 cmd 目录下，接下来的文章里我们会逐一介绍这些命令。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://bitcoin.org/en/developer-documentation" target="_blank" rel="external">bitcoin developer documentation</a></li>
<li><a href="lilymoana.github.io/ethereum_theory.html">以太坊工作原理概述</a></li>
<li><a href="http://ibloodline.com/articles/2018/02/05/go-ethereum.html" target="_blank" rel="external">go-ethereum 源码解读（一）</a></li>
<li><a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="external">ethereum 黄皮书</a></li>
<li><a href="https://ethereum.gitbooks.io/frontier-guide/content/index.html" target="_blank" rel="external">Ethereum Frontier Guide</a></li>
<li><a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis" target="_blank" rel="external">go-ethereum-code-analysis</a></li>
<li><a href="https://github.com/libp2p/specs" target="_blank" rel="external">libp2p/specs</a></li>
<li><a href="https://github.com/wugang33/go-ethereum-code-analysis/blob/master/go-ethereum%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="external">go ethereum 目录介绍</a></li>
<li><a href="https://book.douban.com/subject/30199891/" target="_blank" rel="external">以太坊技术详解与实战</a></li>
<li><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="external">图解密码技术</a></li>
<li><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale" target="_blank" rel="external">以太坊设计原理</a> ，非常重要，建议多读几遍</li>
<li><a href="https://github.com/ethereum/pydevp2p" target="_blank" rel="external">ethereum/pydevp2p</a></li>
<li><a href="https://github.com/Jeiwan/blockchain_go" target="_blank" rel="external">Jeiwan/blockchain_go</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture/757" target="_blank" rel="external">Ethereum block architecture</a></li>
<li><a href="https://www.reddit.com/r/ethereum/" target="_blank" rel="external">Ethereum reddit</a></li>
<li><a href="https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369" target="_blank" rel="external">How does ethereum work anyway</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了一点时间读以太坊的源代码，内容太多，所以一边看一边写，没想到越写越多，于是想着把笔记整理出来。&lt;/p&gt;
&lt;p&gt;源码解读是一件费力不讨好的事情，因为看代码的时候我们看到的是最终解决方案，虽然可以看到 commit 的历史，但我们看不到作者的思路，踩过的坑，而且 geth 的设计文档，功能的相关讨论等信息不像 Kubernetes 那么规范透明，所以我看这些代码的时候很多地方也只是一知半解，欢迎有更多经验的朋友批评指正，不吝赐教，也欢迎有价值的讨论。看了一些书和文章，所以我这也算不上多原创，基本上所有看过的链接都记在 reference 里面了。有的代码暂时看不懂就只能靠猜了，等待之后的实践中验证想法。尽管如此，对于同样想要阅读 geth 的源代码的人来说总还是有些作用，对于我个人来说整理出来这些文章也是一个总结知识，把点连成面的过程，希望同时能帮到其他人。&lt;/p&gt;
&lt;p&gt;geth 版本：master 分支，a1eb9c7d13240fd250866219a502d0cdc9924e06&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="cryptocurrency" scheme="http://knarfeh.github.io/tags/cryptocurrency/"/>
    
      <category term="geth" scheme="http://knarfeh.github.io/tags/geth/"/>
    
  </entry>
  
  <entry>
    <title>Docker 清理卫士</title>
    <link href="http://knarfeh.github.io/2017/12/15/Docker%20%E6%B8%85%E7%90%86%E5%8D%AB%E5%A3%AB/"/>
    <id>http://knarfeh.github.io/2017/12/15/Docker 清理卫士/</id>
    <published>2017-12-15T05:24:57.000Z</published>
    <updated>2018-10-19T16:10:17.360Z</updated>
    
    <content type="html"><![CDATA[<p>本文对释放 Docker 占的磁盘，网络，数据卷的命令做一个整理。内容部分来自网络，一部分来自自己的总结。</p>
<a id="more"></a>
<h2 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h2><p>来自 <a href="https://github.com/chadoe/docker-cleanup-volumes" target="_blank" rel="external">chadoe/docker-cleanup-volumes</a></p>
<p>清理所有没有打标签的 volume：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="keyword">volume</span><span class="bash"> rm $(docker volume ls -qf dangling=<span class="literal">true</span>)</span></div></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="keyword">volume</span><span class="bash"> ls -qf dangling=<span class="literal">true</span> | xargs -r docker volume rm</span></div></pre></td></tr></table></figure>
<h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><p>列出本机创建的所有 network：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>docker network ls</div></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network <span class="keyword">ls</span> | <span class="keyword">grep</span> <span class="string">"bridge"</span></div></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network <span class="keyword">rm</span> $(docker network <span class="keyword">ls</span> | grep <span class="string">"bridge"</span> | awk '/ / &#123; <span class="keyword">print</span> <span class="variable">$1</span> &#125;')</div></pre></td></tr></table></figure>
<h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p>来自 <a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> docker images</div><div class="line"><span class="symbol">$</span> docker rmi <span class="symbol">$</span>(docker images --filter <span class="string">"dangling=true"</span> -q --<span class="keyword">no</span>-<span class="built-in">trunc</span>)</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>docker images | grep <span class="string">"none"</span></div><div class="line"><span class="variable">$ </span>docker rmi <span class="variable">$(</span>docker images | grep <span class="string">"none"</span> | awk <span class="string">'/ / &#123; print $3 &#125;'</span>)</div></pre></td></tr></table></figure>
<h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>来自 <a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></p>
<p>删除所有已经退出的容器</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker rm $(docker <span class="keyword">ps</span> -<span class="keyword">qa</span> --<span class="keyword">no</span>-<span class="built_in">trunc</span> --<span class="built_in">filter</span> <span class="string">"status=exited"</span>)</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm `docker <span class="keyword">ps</span> -<span class="keyword">a</span> | <span class="keyword">grep</span> -i <span class="string">'exited'</span> | awk &#123;<span class="string">'print $1'</span>&#125;`</div></pre></td></tr></table></figure>
<h2 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h2><p>从<a href="https://github.com/moby/moby/blob/master/CHANGELOG.md#1130-2017-01-18" target="_blank" rel="external">1.13.0</a>版本开始，docker 引入了 <code>docker system prune</code> 命令，可以用来清理主机的磁盘空间。该命令可以一键清理所有已停止的容器；所有未被容器引用的 volume（dangling volume）；所有未被容器引用的网络；所有 dangling 的镜像。命令执行完后可以看到释放的空间的大小。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker system prune</span></div></pre></td></tr></table></figure>
<p>如果要移除所有未被使用的镜像（不仅仅是 dangling 的），可以使用</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">system</span> prune -<span class="keyword">a</span></div></pre></td></tr></table></figure>
<p>dangling 的镜像的定义是未被其他镜像引用的镜像，如果构建了新的镜像，但该镜像没有被打上一个新的标签，那么之前打了这个标签的镜像就是 dangling 镜像，它的 name 属性是 none。总的来说，如果一个镜像与任何一个打上标签的镜像没有关联，它就是 dangling 镜像。如果镜像的 repository 和 tag 都是 none，称为 intermediate 镜像。</p>
<p>prune 方法的实现在 <a href="https://github.com/moby/moby/blob/master/daemon/prune.go" target="_blank" rel="external"><code>https://github.com/moby/moby/blob/master/daemon/prune.go</code></a> 里，有兴趣的话可以看看这个方法的实现。</p>
<h3 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">image</span> prune</div></pre></td></tr></table></figure>
<h2 id="k8s-的-PodGC"><a href="#k8s-的-PodGC" class="headerlink" title="k8s 的 PodGC"></a>k8s 的 PodGC</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/" target="_blank" rel="external">Garbage Collection</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.calazan.com/docker-cleanup-commands/" target="_blank" rel="external">docker-cleanup-commands</a></li>
<li><a href="https://github.com/chadoe/docker-cleanup-volumes" target="_blank" rel="external">chadoe/docker-cleanup-volumes</a></li>
<li><a href="https://gist.github.com/bastman/5b57ddb3c11942094f8d0a97d461b430" target="_blank" rel="external">Docker - How to cleanup (unused) resources</a></li>
<li><a href="http://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images" target="_blank" rel="external">how-to-remove-old-and-unused-docker-images</a></li>
<li><a href="https://github.com/spotify/docker-gc" target="_blank" rel="external">spotify/docker-gc</a></li>
<li><a href="https://blog.docker.com/2017/01/whats-new-in-docker-1-13/" target="_blank" rel="external">whats-new-in-docker-1-13</a></li>
<li><a href="https://stackoverflow.com/questions/45142528/docker-what-is-a-dangling-image-and-what-is-an-unused-image" target="_blank" rel="external">Docker: What is a dangling image and what is an unused image?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对释放 Docker 占的磁盘，网络，数据卷的命令做一个整理。内容部分来自网络，一部分来自自己的总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://knarfeh.github.io/tags/Docker/"/>
    
      <category term="k8s" scheme="http://knarfeh.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>【podcast】Go Time</title>
    <link href="http://knarfeh.github.io/2017/11/03/%E3%80%90podcast%E3%80%91Go%20Time/"/>
    <id>http://knarfeh.github.io/2017/11/03/【podcast】Go Time/</id>
    <published>2017-11-03T09:41:35.000Z</published>
    <updated>2018-06-09T09:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>不定期更新。</p>
<p>最后更新时间：Sat May 20 18:49:50 CST 2018</p>
<a id="more"></a>
<p>文稿地址：<a href="https://github.com/thechangelog/transcripts/" target="_blank" rel="external">thechangelog/transcripts</a></p>
<h2 id="79-New-Go-branding-strategy-May-8-2018，时长：1-12-20"><a href="#79-New-Go-branding-strategy-May-8-2018，时长：1-12-20" class="headerlink" title="#79 New Go branding strategy, May 8, 2018，时长：1:12:20"></a>#79 <a href="https://changelog.com/gotime/79" target="_blank" rel="external">New Go branding strategy</a>, May 8, 2018，时长：1:12:20</h2><ul>
<li>嘉宾是 Go 团队的产品 Leader，<a href="https://twitter.com/search?q=spf13&amp;src=typd" target="_blank" rel="external">Steve Francia</a>，之前在 MongoDB, Docker 工作</li>
<li>2017 年 Go 的用户量增长了 76%，也就是说超过70万的开发者开始用 Go</li>
<li><a href="https://blog.golang.org/gopher" target="_blank" rel="external">https://blog.golang.org/gopher</a></li>
<li>39:47 谈到 Golang Logo 相关的版权问题</li>
<li><a href="https://golang.org/s/brandbook" target="_blank" rel="external">https://golang.org/s/brandbook</a></li>
<li><a href="https://github.com/google/gvisor" target="_blank" rel="external">gVisor</a>，k8s 和 Docker 可以使用的容器运行时，可以查看这篇 <a href="https://cloudplatform.googleblog.com/2018/05/Open-sourcing-gVisor-a-sandboxed-container-runtime.html" target="_blank" rel="external">博客</a></li>
</ul>
<p>TOREVIEW</p>
<h2 id="78-Hacking-drones-with-Go-Apr-30-2018-时长：1-10-02"><a href="#78-Hacking-drones-with-Go-Apr-30-2018-时长：1-10-02" class="headerlink" title="#78 Hacking drones with Go, Apr 30, 2018, 时长：1:10:02"></a>#78 <a href="https://changelog.com/gotime/78" target="_blank" rel="external">Hacking drones with Go</a>, Apr 30, 2018, 时长：1:10:02</h2><ul>
<li>Computer Vision, OpenCV, <a href="https://gocv.io/" target="_blank" rel="external">GoCV</a></li>
<li>计算机视觉的一个非常好的应用是拍照防抖，应用到大疆无人机，Tello</li>
</ul>
<p>TODO</p>
<h2 id="BONUS-Go-and-WebAssembly-Wasm-–-BONUS-Apr-26-2018-时长："><a href="#BONUS-Go-and-WebAssembly-Wasm-–-BONUS-Apr-26-2018-时长：" class="headerlink" title="#BONUS Go and WebAssembly (Wasm) – BONUS, Apr 26, 2018, 时长："></a>#BONUS <a href="https://changelog.com/news/J3L0/visit" target="_blank" rel="external">Go and WebAssembly (Wasm) – BONUS</a>, Apr 26, 2018, 时长：</h2><h2 id="76-Building-a-distributed-index-with-Go-时长："><a href="#76-Building-a-distributed-index-with-Go-时长：" class="headerlink" title="#76 Building a distributed index with Go, , 时长："></a>#76 <a href="https://changelog.com/gotime/76" target="_blank" rel="external">Building a distributed index with Go</a>, , 时长：</h2><h2 id="75-GoLand-IDE-and-managing-Gopher-Slack-时长："><a href="#75-GoLand-IDE-and-managing-Gopher-Slack-时长：" class="headerlink" title="#75 GoLand IDE and managing Gopher Slack, , 时长："></a>#75 <a href="https://changelog.com/gotime/75" target="_blank" rel="external">GoLand IDE and managing Gopher Slack</a>, , 时长：</h2><h2 id="74-Gophercises-and-creating-content-for-Gophers-时长："><a href="#74-Gophercises-and-creating-content-for-Gophers-时长：" class="headerlink" title="#74 Gophercises and creating content for Gophers, , 时长："></a>#74 <a href="https://changelog.com/gotime/74" target="_blank" rel="external">Gophercises and creating content for Gophers</a>, , 时长：</h2><h2 id="73-CockroachDB-and-distributed-databases-in-Go-时长："><a href="#73-CockroachDB-and-distributed-databases-in-Go-时长：" class="headerlink" title="#73 CockroachDB and distributed databases in Go, , 时长："></a>#73 <a href="https://changelog.com/gotime/73" target="_blank" rel="external">CockroachDB and distributed databases in Go</a>, , 时长：</h2><h2 id="72-Learning-and-teaching-Go-时长："><a href="#72-Learning-and-teaching-Go-时长：" class="headerlink" title="#72 Learning and teaching Go, , 时长："></a>#72 <a href="https://changelog.com/gotime/72" target="_blank" rel="external">Learning and teaching Go</a>, , 时长：</h2><h2 id="71-Go-is-for-everyone-时长："><a href="#71-Go-is-for-everyone-时长：" class="headerlink" title="#71 Go is for everyone, , 时长："></a>#71 <a href="https://changelog.com/gotime/71" target="_blank" rel="external">Go is for everyone</a>, , 时长：</h2><h2 id="70-From-Russia-with-love-时长："><a href="#70-From-Russia-with-love-时长：" class="headerlink" title="#70 From Russia with love, , 时长："></a>#70 <a href="https://changelog.com/gotime/70" target="_blank" rel="external">From Russia with love</a>, , 时长：</h2><h2 id="69-Golang-Flow-FaaS-and-Buffalo-Mar-9-2018-时长：00-47-57"><a href="#69-Golang-Flow-FaaS-and-Buffalo-Mar-9-2018-时长：00-47-57" class="headerlink" title="#69 Golang Flow, FaaS, and Buffalo,  Mar 9, 2018 , 时长：00:47:57"></a>#69 <a href="https://changelog.com/gotime/69" target="_blank" rel="external">Golang Flow, FaaS, and Buffalo</a>,  Mar 9, 2018 , 时长：00:47:57</h2><ul>
<li>links<ul>
<li><a href="https://blog.cloudflare.com/using-go-as-a-scripting-language-in-linux/" target="_blank" rel="external">Using Go as a scripting language in Linux</a></li>
</ul>
</li>
<li>嘉宾 Brian Scott 从事 Web 开发相关的工作，面向客户的应用，Web 技术，云自动化等等，维护 GolangFlow.io 这个网站(灵感来自 <a href="rubyflow.com">rubyflow</a>），给 <a href="https://github.com/gocolly/colly" target="_blank" rel="external">Colly</a> 贡献过代码。给 Amazon Lambda 贡献 Go 的支持，玩过一段时间 <a href="https://www.openfaas.com/" target="_blank" rel="external">OpenFaaS</a>。最近在看区块链相关的项目。</li>
<li>FaaS 最佳的使用场景可能是 ETL，转码之类的工作。</li>
<li>16:00 开始聊 Buffalo</li>
<li>24:58 开始聊 versioned go，dep</li>
<li>Go 1.10 要出了</li>
<li><a href="https://blog.cloudflare.com/using-go-as-a-scripting-language-in-linux/" target="_blank" rel="external">Cloudflare post: using-go-as-a-scripting-language-in-linux</a></li>
</ul>
<p>TOREVIEW</p>
<h2 id="68-SPECIAL-—-Ask-us-anything-pt-2-时长："><a href="#68-SPECIAL-—-Ask-us-anything-pt-2-时长：" class="headerlink" title="#68 SPECIAL — Ask us anything! (pt. 2), , 时长："></a>#68 <a href="https://changelog.com/gotime/68" target="_blank" rel="external">SPECIAL — Ask us anything! (pt. 2)</a>, , 时长：</h2><h2 id="67-Supporting-the-Go-community-时长："><a href="#67-Supporting-the-Go-community-时长：" class="headerlink" title="#67 Supporting the Go community, , 时长："></a>#67 <a href="https://changelog.com/gotime/67" target="_blank" rel="external">Supporting the Go community</a>, , 时长：</h2><h2 id="66-Performance-Fuzzing-and-Magic-时长："><a href="#66-Performance-Fuzzing-and-Magic-时长：" class="headerlink" title="#66 Performance, Fuzzing, and Magic, , 时长："></a>#66 <a href="https://changelog.com/gotime/66" target="_blank" rel="external">Performance, Fuzzing, and Magic</a>, , 时长：</h2><h2 id="65-GopherCon-Brazil-amp-Genetics-with-Vitor-De-Mario-时长："><a href="#65-GopherCon-Brazil-amp-Genetics-with-Vitor-De-Mario-时长：" class="headerlink" title="#65 GopherCon Brazil &amp; Genetics with Vitor De Mario, , 时长："></a>#65 <a href="https://changelog.com/gotime/65" target="_blank" rel="external">GopherCon Brazil &amp; Genetics with Vitor De Mario</a>, , 时长：</h2><h2 id="64-InfluxDB-amp-IoT-Data-时长："><a href="#64-InfluxDB-amp-IoT-Data-时长：" class="headerlink" title="#64 InfluxDB &amp; IoT Data, , 时长："></a>#64 <a href="https://changelog.com/gotime/64" target="_blank" rel="external">InfluxDB &amp; IoT Data</a>, , 时长：</h2><h2 id="63-Kubernetes-and-Virtual-Kubelet-Jan-15-2018-时长：1-13-16"><a href="#63-Kubernetes-and-Virtual-Kubelet-Jan-15-2018-时长：1-13-16" class="headerlink" title="#63 Kubernetes and Virtual Kubelet, Jan 15, 2018, 时长：1:13:16"></a>#63 <a href="https://changelog.com/gotime/63" target="_blank" rel="external">Kubernetes and Virtual Kubelet</a>, Jan 15, 2018, 时长：1:13:16</h2><h2 id="62-Building-Blocks-with-Jeff-Lindsay-Dec-1-2017-时长：1-10-31"><a href="#62-Building-Blocks-with-Jeff-Lindsay-Dec-1-2017-时长：1-10-31" class="headerlink" title="#62 Building Blocks with Jeff Lindsay, Dec 1, 2017, 时长：1:10:31"></a>#62 <a href="https://changelog.com/gotime/62" target="_blank" rel="external">Building Blocks with Jeff Lindsay</a>, Dec 1, 2017, 时长：1:10:31</h2><ul>
<li>嘉宾是 <a href="">Jeff Lindsay</a></li>
</ul>
<h2 id="61-Loggregator-gRPC-and-Diodes-with-Jason-Keene-amp-Andrew-Poydence-时长："><a href="#61-Loggregator-gRPC-and-Diodes-with-Jason-Keene-amp-Andrew-Poydence-时长：" class="headerlink" title="#61 Loggregator, gRPC, and Diodes with Jason Keene &amp; Andrew Poydence, , 时长："></a>#61 <a href="https://changelog.com/gotime/61" target="_blank" rel="external">Loggregator, gRPC, and Diodes with Jason Keene &amp; Andrew Poydence</a>, , 时长：</h2><h2 id="60-Why-WADL-When-You-Can-Swagger-with-Ivan-Porto-Carrero-时长："><a href="#60-Why-WADL-When-You-Can-Swagger-with-Ivan-Porto-Carrero-时长：" class="headerlink" title="#60 Why WADL When You Can Swagger? with Ivan Porto Carrero, , 时长："></a>#60 <a href="https://changelog.com/gotime/60" target="_blank" rel="external">Why WADL When You Can Swagger? with Ivan Porto Carrero</a>, , 时长：</h2><h2 id="59-Improved-Improved-Improved-i3-with-Michael-Stapelberg-时长："><a href="#59-Improved-Improved-Improved-i3-with-Michael-Stapelberg-时长：" class="headerlink" title="#59 Improved Improved Improved (i3) with Michael Stapelberg, , 时长："></a>#59 <a href="https://changelog.com/gotime/59" target="_blank" rel="external">Improved Improved Improved (i3) with Michael Stapelberg</a>, , 时长：</h2><h2 id="58-Full-time-Open-Source-with-Dmitri-Shuralyov-时长："><a href="#58-Full-time-Open-Source-with-Dmitri-Shuralyov-时长：" class="headerlink" title="#58 Full-time Open Source with Dmitri Shuralyov,  , 时长："></a>#58 <a href="https://changelog.com/gotime/58" target="_blank" rel="external">Full-time Open Source with Dmitri Shuralyov</a>,  , 时长：</h2><h2 id="57-Presenting-a-Pragmatic-Perspective-with-Cindy-Sridharan-时长："><a href="#57-Presenting-a-Pragmatic-Perspective-with-Cindy-Sridharan-时长：" class="headerlink" title="#57 Presenting a Pragmatic Perspective with Cindy Sridharan,  , 时长："></a>#57 <a href="https://changelog.com/gotime/57" target="_blank" rel="external">Presenting a Pragmatic Perspective with Cindy Sridharan</a>,  , 时长：</h2><h2 id="56-Container-Security-and-Demystifying-Complexity-with-Liz-Rice-时长："><a href="#56-Container-Security-and-Demystifying-Complexity-with-Liz-Rice-时长：" class="headerlink" title="#56 Container Security and Demystifying Complexity with Liz Rice, , 时长："></a>#56 <a href="https://changelog.com/gotime/56" target="_blank" rel="external">Container Security and Demystifying Complexity with Liz Rice</a>, , 时长：</h2><h2 id="55-Dep-Cross-platform-and-Getting-Started-with-Carolyn-Van-Slyck-时长："><a href="#55-Dep-Cross-platform-and-Getting-Started-with-Carolyn-Van-Slyck-时长：" class="headerlink" title="#55 Dep, Cross-platform, and Getting Started with Carolyn Van Slyck,  , 时长："></a>#55 <a href="https://changelog.com/gotime/55" target="_blank" rel="external">Dep, Cross-platform, and Getting Started with Carolyn Van Slyck</a>,  , 时长：</h2><h2 id="54-Go-at-Walmart-and-Scale-with-Chase-Adams-时长："><a href="#54-Go-at-Walmart-and-Scale-with-Chase-Adams-时长：" class="headerlink" title="#54 Go at Walmart (and Scale) with Chase Adams,  , 时长："></a>#54 <a href="https://changelog.com/gotime/54" target="_blank" rel="external">Go at Walmart (and Scale) with Chase Adams</a>,  , 时长：</h2><h2 id="53-GopherCon-2017-A-Retrospective-时长："><a href="#53-GopherCon-2017-A-Retrospective-时长：" class="headerlink" title="#53 GopherCon 2017: A Retrospective,  , 时长："></a>#53 <a href="https://changelog.com/gotime/53" target="_blank" rel="external">GopherCon 2017: A Retrospective</a>,  , 时长：</h2><h2 id="52-All-About-The-Go-Compiler-with-David-Chase-时长："><a href="#52-All-About-The-Go-Compiler-with-David-Chase-时长：" class="headerlink" title="#52 All About The Go Compiler with David Chase,  , 时长："></a>#52 <a href="https://changelog.com/gotime/52" target="_blank" rel="external">All About The Go Compiler with David Chase</a>,  , 时长：</h2><h2 id="51-Infosec-Research-and-App-Security-Jul-19-2017-时长："><a href="#51-Infosec-Research-and-App-Security-Jul-19-2017-时长：" class="headerlink" title="#51 Infosec Research and App Security, Jul 19, 2017 , 时长："></a>#51 <a href="https://changelog.com/gotime/51" target="_blank" rel="external">Infosec Research and App Security</a>, Jul 19, 2017 , 时长：</h2><h2 id="50-Bringing-Kubernetes-to-Azure-with-Kris-Nova-时长："><a href="#50-Bringing-Kubernetes-to-Azure-with-Kris-Nova-时长：" class="headerlink" title="#50 Bringing Kubernetes to Azure with Kris Nova, , 时长："></a>#50 <a href="https://changelog.com/gotime/50" target="_blank" rel="external">Bringing Kubernetes to Azure with Kris Nova</a>, , 时长：</h2><h2 id="49-Adventures-in-VS-Code-with-Ramya-Rao-时长："><a href="#49-Adventures-in-VS-Code-with-Ramya-Rao-时长：" class="headerlink" title="#49 Adventures in VS Code with Ramya Rao, , 时长："></a>#49 <a href="https://changelog.com/gotime/49" target="_blank" rel="external">Adventures in VS Code with Ramya Rao</a>, , 时长：</h2><h2 id="48-Restic-and-Backups-Done-Right-with-Alexander-Neumann-时长："><a href="#48-Restic-and-Backups-Done-Right-with-Alexander-Neumann-时长：" class="headerlink" title="#48 Restic and Backups (Done Right) with Alexander Neumann, , 时长："></a>#48 <a href="https://changelog.com/gotime/48" target="_blank" rel="external">Restic and Backups (Done Right) with Alexander Neumann</a>, , 时长：</h2><h2 id="47-Docker-Moby-and-Containers-with-Solomon-Hykes-May-25-2017-时长-1-09-46"><a href="#47-Docker-Moby-and-Containers-with-Solomon-Hykes-May-25-2017-时长-1-09-46" class="headerlink" title="#47 Docker, Moby, and Containers with Solomon Hykes, May 25, 2017 , 时长: 1:09:46"></a>#47 <a href="https://changelog.com/gotime/47" target="_blank" rel="external">Docker, Moby, and Containers with Solomon Hykes</a>, May 25, 2017 , 时长: 1:09:46</h2><ul>
<li>嘉宾是 Solomon Hykes，Docker 的创始人和 CTO</li>
<li>DotCloud, 类似 Heroku, GAE，后改名 Docker</li>
<li>在 DotCloud 不使用 Go，使用 Python</li>
<li>后半段在聊为什么改名 Moby 以及商业化和开源之间的一些矛盾</li>
</ul>
<p>TOREVIEW</p>
<h2 id="46-Periph-io-Drivers-and-Hardware-with-Marc-Antoine-Ruel-时长："><a href="#46-Periph-io-Drivers-and-Hardware-with-Marc-Antoine-Ruel-时长：" class="headerlink" title="#46 Periph.io, Drivers, and Hardware with Marc-Antoine Ruel, , 时长："></a>#46 <a href="https://changelog.com/gotime/46" target="_blank" rel="external">Periph.io, Drivers, and Hardware with Marc-Antoine Ruel</a>, , 时长：</h2><h2 id="45-SPECIAL-—-Ask-Us-Anything-时长："><a href="#45-SPECIAL-—-Ask-Us-Anything-时长：" class="headerlink" title="#45 SPECIAL — Ask Us Anything!, , 时长："></a>#45 <a href="https://changelog.com/gotime/45" target="_blank" rel="external">SPECIAL — Ask Us Anything!</a>, , 时长：</h2><h2 id="44-Go4-and-Contributing-to-Go-with-Brad-Fitzpatrick-时长："><a href="#44-Go4-and-Contributing-to-Go-with-Brad-Fitzpatrick-时长：" class="headerlink" title="#44 Go4 and Contributing to Go with Brad Fitzpatrick, , 时长："></a>#44 <a href="https://changelog.com/gotime/44" target="_blank" rel="external">Go4 and Contributing to Go with Brad Fitzpatrick</a>, , 时长：</h2><h2 id="43-Getting-Better-Mentoring-and-Drawing-Gophers-with-Ashley-McNamara-时长："><a href="#43-Getting-Better-Mentoring-and-Drawing-Gophers-with-Ashley-McNamara-时长：" class="headerlink" title="#43 Getting Better, Mentoring, and Drawing Gophers with Ashley McNamara, , 时长："></a>#43 <a href="https://changelog.com/gotime/43" target="_blank" rel="external">Getting Better, Mentoring, and Drawing Gophers with Ashley McNamara</a>, , 时长：</h2><h2 id="42-Race-Detection-Firmware-and-Production-grade-Go-with-Kavya-Joshi-时长："><a href="#42-Race-Detection-Firmware-and-Production-grade-Go-with-Kavya-Joshi-时长：" class="headerlink" title="#42 Race Detection, Firmware, and Production-grade Go with Kavya Joshi, , 时长："></a>#42 <a href="https://changelog.com/gotime/42" target="_blank" rel="external">Race Detection, Firmware, and Production-grade Go with Kavya Joshi</a>, , 时长：</h2><h2 id="41-Distributed-Messaging-and-Network-Clients-with-Wally-Quevedo-时长："><a href="#41-Distributed-Messaging-and-Network-Clients-with-Wally-Quevedo-时长：" class="headerlink" title="#41 Distributed Messaging and Network Clients with Wally Quevedo, , 时长："></a>#41 <a href="https://changelog.com/gotime/41" target="_blank" rel="external">Distributed Messaging and Network Clients with Wally Quevedo</a>, , 时长：</h2><h2 id="40-Game-Development-and-Rebuilding-Microservices-with-Luna-Duclos-时长："><a href="#40-Game-Development-and-Rebuilding-Microservices-with-Luna-Duclos-时长：" class="headerlink" title="#40 Game Development and Rebuilding Microservices with Luna Duclos, , 时长："></a>#40 <a href="https://changelog.com/gotime/40" target="_blank" rel="external">Game Development and Rebuilding Microservices with Luna Duclos</a>, , 时长：</h2><h2 id="39-Splice-Audio-and-Compassion-with-Matt-Aimonetti-时长："><a href="#39-Splice-Audio-and-Compassion-with-Matt-Aimonetti-时长：" class="headerlink" title="#39 Splice, Audio, and Compassion with Matt Aimonetti, , 时长："></a>#39 <a href="https://changelog.com/gotime/39" target="_blank" rel="external">Splice, Audio, and Compassion with Matt Aimonetti</a>, , 时长：</h2><h2 id="38-Go-Developer-Survey-with-Steve-Francia-时长："><a href="#38-Go-Developer-Survey-with-Steve-Francia-时长：" class="headerlink" title="#38 Go Developer Survey with Steve Francia, , 时长："></a>#38 <a href="https://changelog.com/gotime/38" target="_blank" rel="external">Go Developer Survey with Steve Francia</a>, , 时长：</h2><h2 id="37-Gobot-Hardware-and-Gatekeeping-with-Ron-Evans-时长："><a href="#37-Gobot-Hardware-and-Gatekeeping-with-Ron-Evans-时长：" class="headerlink" title="#37 Gobot, Hardware, and Gatekeeping with Ron Evans, , 时长："></a>#37 <a href="https://changelog.com/gotime/37" target="_blank" rel="external">Gobot, Hardware, and Gatekeeping with Ron Evans</a>, , 时长：</h2><h2 id="36-Dependency-Management-Semver-and-Community-Consensus-with-Sam-Boyer-时长："><a href="#36-Dependency-Management-Semver-and-Community-Consensus-with-Sam-Boyer-时长：" class="headerlink" title="#36 Dependency Management, Semver, and Community Consensus with Sam Boyer, , 时长："></a>#36 <a href="https://changelog.com/gotime/36" target="_blank" rel="external">Dependency Management, Semver, and Community Consensus with Sam Boyer</a>, , 时长：</h2><h2 id="35-Honeycomb-Complex-Systems-and-Saving-Sanity-with-Charity-Majors-时长："><a href="#35-Honeycomb-Complex-Systems-and-Saving-Sanity-with-Charity-Majors-时长：" class="headerlink" title="#35 Honeycomb, Complex Systems, and Saving Sanity with Charity Majors, , 时长："></a>#35 <a href="https://changelog.com/gotime/35" target="_blank" rel="external">Honeycomb, Complex Systems, and Saving Sanity with Charity Majors</a>, , 时长：</h2><h2 id="34-Pachyderm-Provenance-and-Data-Lakes-with-Joe-Doliner-时长："><a href="#34-Pachyderm-Provenance-and-Data-Lakes-with-Joe-Doliner-时长：" class="headerlink" title="#34 Pachyderm, Provenance, and Data Lakes with Joe Doliner, , 时长："></a>#34 <a href="https://changelog.com/gotime/34" target="_blank" rel="external">Pachyderm, Provenance, and Data Lakes with Joe Doliner</a>, , 时长：</h2><h2 id="33-Gopherize-me-GitHub-Stars-and-BitBar-with-Mat-Ryer-时长："><a href="#33-Gopherize-me-GitHub-Stars-and-BitBar-with-Mat-Ryer-时长：" class="headerlink" title="#33 Gopherize.me, GitHub Stars and BitBar with Mat Ryer, , 时长："></a>#33 <a href="https://changelog.com/gotime/33" target="_blank" rel="external">Gopherize.me, GitHub Stars and BitBar with Mat Ryer</a>, , 时长：</h2><h2 id="32-Hellogopher-whosthere-with-Filippo-Valsorda-时长："><a href="#32-Hellogopher-whosthere-with-Filippo-Valsorda-时长：" class="headerlink" title="#32 Hellogopher, whosthere? with Filippo Valsorda, , 时长："></a>#32 <a href="https://changelog.com/gotime/32" target="_blank" rel="external">Hellogopher, whosthere? with Filippo Valsorda</a>, , 时长：</h2><h2 id="31-Go-Jocko-and-Kafka-with-Travis-Jeffery-JAN-26-2017-时长："><a href="#31-Go-Jocko-and-Kafka-with-Travis-Jeffery-JAN-26-2017-时长：" class="headerlink" title="#31 Go, Jocko, and Kafka with Travis Jeffery, JAN 26 2017, 时长："></a>#31 <a href="https://changelog.com/gotime/31" target="_blank" rel="external">Go, Jocko, and Kafka with Travis Jeffery</a>, JAN 26 2017, 时长：</h2><p>最近在关注 Jocko 这个项目，所以先把这期听完吧。这期嘉宾是 Travis Jeffery，Jocko 的作者。加拿大人，父母是企业家（农场主？）一直到大学，最有意思的经历是：『If I don’t finish my degree, can you get me into the U.S.?』『Okay, well I’m done.』『So I dropped out and started a startup with some friends and we ended up selling out to Shopify』</p>
<p>Travis 谈为什么开发 Go 版本的 Kafka。用了很多年。他觉得 Kafka 历史包袱很重，比如依赖 JVM，Zookeeper，他同时非常不喜欢 Kafka 的配置方式。Kafka 是：replicated，distributed commit log service。jocko 项目状态：就快 feature-complete。</p>
<p>Kafka 客户端做的事情：根据 Kafka 协议进行编码。写数据用的是追加的方式，维护了一个 offset，它表明下一个字节的数据应该往哪里写，这些 log 的 offset 是用一个 index 文件维护的，搜索，访问时速度很快。这是 Kafka 的性能为什么那么好的关键。Travis 写了一篇博客来说明这个机制。</p>
<p>开发 jocko 的大部分时间都花在一致性和服务发现上。利用 Serf 和 Raft 保证一致性和服务发现。Travis 调研了 Etcd, Consul, Nomad，特别是 Consul 和 Nomad，提供了很好的例子。</p>
<p>31:40 左右，谈到 ESR 的一篇文章。如果在技术会议上被性别歧视了，唯一的，最佳的反击是用一个牛逼的 github 账号回应。</p>
<p>TODO</p>
<h2 id="30-Discussing-Imposter-Syndrome-with-Johnny-Boursiquot-and-Bill-Kennedy-时长："><a href="#30-Discussing-Imposter-Syndrome-with-Johnny-Boursiquot-and-Bill-Kennedy-时长：" class="headerlink" title="#30 Discussing Imposter Syndrome with Johnny Boursiquot and Bill Kennedy, , 时长："></a>#30 <a href="https://changelog.com/gotime/30" target="_blank" rel="external">Discussing Imposter Syndrome with Johnny Boursiquot and Bill Kennedy</a>, , 时长：</h2><h2 id="29-Go-and-Buffalo-Live-from-Dunkin’-Donuts-with-Mark-Bates-时长："><a href="#29-Go-and-Buffalo-Live-from-Dunkin’-Donuts-with-Mark-Bates-时长：" class="headerlink" title="#29 Go and Buffalo Live from Dunkin’ Donuts with Mark Bates, , 时长："></a>#29 <a href="https://changelog.com/gotime/29" target="_blank" rel="external">Go and Buffalo Live from Dunkin’ Donuts with Mark Bates</a>, , 时长：</h2><h2 id="28-Creating-a-Programming-Language-with-Thorsten-Ball-时长："><a href="#28-Creating-a-Programming-Language-with-Thorsten-Ball-时长：" class="headerlink" title="#28 Creating a Programming Language with Thorsten Ball, , 时长："></a>#28 <a href="https://changelog.com/gotime/28" target="_blank" rel="external">Creating a Programming Language with Thorsten Ball</a>, , 时长：</h2><h2 id="27-The-Go-Compiler-and-Go-1-8-with-Keith-Randall-时长："><a href="#27-The-Go-Compiler-and-Go-1-8-with-Keith-Randall-时长：" class="headerlink" title="#27 The Go Compiler and Go 1.8 with Keith Randall, , 时长："></a>#27 <a href="https://changelog.com/gotime/27" target="_blank" rel="external">The Go Compiler and Go 1.8 with Keith Randall</a>, , 时长：</h2><h2 id="26-Teaching-and-Learning-Go-with-Todd-McLeod-时长："><a href="#26-Teaching-and-Learning-Go-with-Todd-McLeod-时长：" class="headerlink" title="#26 Teaching and Learning Go with Todd McLeod, , 时长："></a>#26 <a href="https://changelog.com/gotime/26" target="_blank" rel="external">Teaching and Learning Go with Todd McLeod</a>, , 时长：</h2><h2 id="25-Go-Kit-Dependency-Management-amp-Microservices-with-Peter-Bourgon-时长："><a href="#25-Go-Kit-Dependency-Management-amp-Microservices-with-Peter-Bourgon-时长：" class="headerlink" title="#25 Go Kit, Dependency Management &amp; Microservices with Peter Bourgon, , 时长："></a>#25 <a href="https://changelog.com/gotime/25" target="_blank" rel="external">Go Kit, Dependency Management &amp; Microservices with Peter Bourgon</a>, , 时长：</h2><h2 id="24-Juju-Jujucharms-and-Gorram-with-Nate-Finch-时长："><a href="#24-Juju-Jujucharms-and-Gorram-with-Nate-Finch-时长：" class="headerlink" title="#24 Juju, Jujucharms, and Gorram with Nate Finch, , 时长："></a>#24 <a href="https://changelog.com/gotime/24" target="_blank" rel="external">Juju, Jujucharms, and Gorram with Nate Finch</a>, , 时长：</h2><h2 id="23-Open-Sourcing-Chain’s-Developer-Platform-with-Tess-Rinearson-时长："><a href="#23-Open-Sourcing-Chain’s-Developer-Platform-with-Tess-Rinearson-时长：" class="headerlink" title="#23 Open Sourcing Chain’s Developer Platform with Tess Rinearson, , 时长："></a>#23 <a href="https://changelog.com/gotime/23" target="_blank" rel="external">Open Sourcing Chain’s Developer Platform with Tess Rinearson</a>, , 时长：</h2><h2 id="22-Go-Work-Groups-and-Hardware-Projects-with-Jaana-B-Dogan-时长："><a href="#22-Go-Work-Groups-and-Hardware-Projects-with-Jaana-B-Dogan-时长：" class="headerlink" title="#22 Go Work Groups and Hardware Projects with Jaana B. Dogan, , 时长："></a>#22 <a href="https://changelog.com/gotime/22" target="_blank" rel="external">Go Work Groups and Hardware Projects with Jaana B. Dogan</a>, , 时长：</h2><h2 id="21-Building-a-Startup-on-Go-with-Blake-Mizerany-时长："><a href="#21-Building-a-Startup-on-Go-with-Blake-Mizerany-时长：" class="headerlink" title="#21 Building a Startup on Go with Blake Mizerany, , 时长："></a>#21 <a href="https://changelog.com/gotime/21" target="_blank" rel="external">Building a Startup on Go with Blake Mizerany</a>, , 时长：</h2><h2 id="20-Kubernetes-Containers-and-Go-with-Kelsey-Hightower-OCT-13-2016-时长：1-14-5"><a href="#20-Kubernetes-Containers-and-Go-with-Kelsey-Hightower-OCT-13-2016-时长：1-14-5" class="headerlink" title="#20 Kubernetes, Containers, and Go with Kelsey Hightower, OCT 13 2016, 时长：1:14:5"></a>#20 <a href="https://changelog.com/gotime/20" target="_blank" rel="external">Kubernetes, Containers, and Go with Kelsey Hightower</a>, OCT 13 2016, 时长：1:14:5</h2><h2 id="19-Programming-Practices-Exercism-and-Open-Source-with-Katrina-Owen-时长："><a href="#19-Programming-Practices-Exercism-and-Open-Source-with-Katrina-Owen-时长：" class="headerlink" title="#19 Programming Practices, Exercism, and Open Source with Katrina Owen, , 时长："></a>#19 <a href="https://changelog.com/gotime/19" target="_blank" rel="external">Programming Practices, Exercism, and Open Source with Katrina Owen</a>, , 时长：</h2><h2 id="18-Aaron-Schlesinger-on-Go-in-5-Minutes-and-Design-Patterns-JUL-28-2016-时长："><a href="#18-Aaron-Schlesinger-on-Go-in-5-Minutes-and-Design-Patterns-JUL-28-2016-时长：" class="headerlink" title="#18 Aaron Schlesinger on Go in 5 Minutes and Design Patterns, JUL 28 2016, 时长："></a>#18 <a href="https://changelog.com/gotime/18" target="_blank" rel="external">Aaron Schlesinger on Go in 5 Minutes and Design Patterns</a>, JUL 28 2016, 时长：</h2><h2 id="17-Monorepos-Mentoring-and-Testing-with-Bryan-Liles-JUL-28-2016-时长："><a href="#17-Monorepos-Mentoring-and-Testing-with-Bryan-Liles-JUL-28-2016-时长：" class="headerlink" title="#17 Monorepos, Mentoring, and Testing with Bryan Liles, JUL 28 2016, 时长："></a>#17 <a href="https://changelog.com/gotime/17" target="_blank" rel="external">Monorepos, Mentoring, and Testing with Bryan Liles</a>, JUL 28 2016, 时长：</h2><h2 id="16-SOLID-Go-Design-with-Dave-Cheney-JUL-28-2016-时长："><a href="#16-SOLID-Go-Design-with-Dave-Cheney-JUL-28-2016-时长：" class="headerlink" title="#16 SOLID Go Design with Dave Cheney, JUL 28 2016, 时长："></a>#16 <a href="https://changelog.com/gotime/16" target="_blank" rel="external">SOLID Go Design with Dave Cheney</a>, JUL 28 2016, 时长：</h2><h2 id="15-The-Go-Standard-Library-with-Ben-Johnson-JUL-28-2016-时长："><a href="#15-The-Go-Standard-Library-with-Ben-Johnson-JUL-28-2016-时长：" class="headerlink" title="#15 The Go Standard Library with Ben Johnson, JUL 28 2016, 时长："></a>#15 <a href="https://changelog.com/gotime/15" target="_blank" rel="external">The Go Standard Library with Ben Johnson</a>, JUL 28 2016, 时长：</h2><h2 id="14-Matt-Holt-on-CaddyServer-the-ACME-Protocol-and-TLS-JUL-28-2016-时长："><a href="#14-Matt-Holt-on-CaddyServer-the-ACME-Protocol-and-TLS-JUL-28-2016-时长：" class="headerlink" title="#14 Matt Holt on CaddyServer, the ACME Protocol, and TLS, JUL 28 2016, 时长："></a>#14 <a href="https://changelog.com/gotime/14" target="_blank" rel="external">Matt Holt on CaddyServer, the ACME Protocol, and TLS</a>, JUL 28 2016, 时长：</h2><h2 id="13-Francesc-Campoy-on-GopherCon-and-Understanding-nil-时长："><a href="#13-Francesc-Campoy-on-GopherCon-and-Understanding-nil-时长：" class="headerlink" title="#13 Francesc Campoy on GopherCon and Understanding nil, , 时长："></a>#13 <a href="https://changelog.com/gotime/13" target="_blank" rel="external">Francesc Campoy on GopherCon and Understanding nil</a>, , 时长：</h2><h2 id="12-Beyang-Liu-on-Go-at-Sourcegraph-and-Writing-Better-Code-时长："><a href="#12-Beyang-Liu-on-Go-at-Sourcegraph-and-Writing-Better-Code-时长：" class="headerlink" title="#12 Beyang Liu on Go at Sourcegraph and Writing Better Code, , 时长："></a>#12 <a href="https://changelog.com/gotime/12" target="_blank" rel="external">Beyang Liu on Go at Sourcegraph and Writing Better Code</a>, , 时长：</h2><h2 id="11-Maintaining-Open-Source-Docker-and-dotfiles-with-Jessie-Frazelle-Guests-Aug-10-2016-时长：1-06-23"><a href="#11-Maintaining-Open-Source-Docker-and-dotfiles-with-Jessie-Frazelle-Guests-Aug-10-2016-时长：1-06-23" class="headerlink" title="#11 Maintaining Open Source, Docker, and dotfiles with Jessie Frazelle Guests , Aug 10, 2016, 时长：1:06:23"></a>#11 <a href="https://changelog.com/gotime/11" target="_blank" rel="external">Maintaining Open Source, Docker, and dotfiles with Jessie Frazelle Guests </a>, Aug 10, 2016, 时长：1:06:23</h2><ul>
<li>嘉宾是 Jessie Frazelle，刚加入 Fastly 全职写 Golang，之前是 Docker 的维护者</li>
<li>20分钟左右，谈接受 PRs 的流程，如果是一个比较大的 PR，一般会先有一个 design review</li>
<li>Jessie 在 Mesos 的时候写 C++</li>
<li>maintainerati.org 开源项目的 maintainer 们</li>
<li>40分钟左右聊到 <a href="http://gokit.io/" target="_blank" rel="external">GoKit</a></li>
<li><a href="https://www.twitch.tv/gophercon" target="_blank" rel="external">https://www.twitch.tv/gophercon</a> goghercon 的直播地址</li>
<li><a href="http://goconvey.co" target="_blank" rel="external">http://goconvey.co</a> 一个用于 Golang 测试的框架</li>
</ul>
<p>TOREVIEW</p>
<h2 id="10-State-of-Go-Survey-and-Go-at-Heroku-AUG-10-2016-时长："><a href="#10-State-of-Go-Survey-and-Go-at-Heroku-AUG-10-2016-时长：" class="headerlink" title="#10 State of Go Survey and Go at Heroku, AUG 10 2016, 时长："></a>#10 <a href="https://changelog.com/gotime/10" target="_blank" rel="external">State of Go Survey and Go at Heroku</a>, AUG 10 2016, 时长：</h2><h2 id="9-Scott-Mansfield-on-Go-at-Netflix-JUL-28-2016-时长："><a href="#9-Scott-Mansfield-on-Go-at-Netflix-JUL-28-2016-时长：" class="headerlink" title="#9 Scott Mansfield on Go at Netflix, JUL 28 2016, 时长："></a>#9 <a href="https://changelog.com/gotime/9" target="_blank" rel="external">Scott Mansfield on Go at Netflix</a>, JUL 28 2016, 时长：</h2><h2 id="8-Asim-Aslam-on-Micro-the-Go-Microservice-Toolkit-时长："><a href="#8-Asim-Aslam-on-Micro-the-Go-Microservice-Toolkit-时长：" class="headerlink" title="#8 Asim Aslam on Micro, the Go Microservice Toolkit, , 时长："></a>#8 <a href="https://changelog.com/gotime/8" target="_blank" rel="external">Asim Aslam on Micro, the Go Microservice Toolkit</a>, , 时长：</h2><p>嘉宾是 Kelsey Hightower，主要关注 Golang，Kubernetes，CoreOS，Puppet Labs</p>
<p>9:20 左右，谈 K8s 的 plugin 系统<br>23:50 kelseyhightower/KubernetesTheHardWay (Linode 可以一键搭建 Kubernetes 集群，好像很便宜的样子)</p>
<h2 id="7-Raphael-Simon-on-goa-the-Framework-for-Building-Microservices-时长："><a href="#7-Raphael-Simon-on-goa-the-Framework-for-Building-Microservices-时长：" class="headerlink" title="#7 Raphaël Simon on goa, the Framework for Building Microservices, , 时长："></a>#7 <a href="https://changelog.com/gotime/7" target="_blank" rel="external">Raphaël Simon on goa, the Framework for Building Microservices</a>, , 时长：</h2><h2 id="6-Bill-Kennedy-on-Mechanical-Sympathy-时长："><a href="#6-Bill-Kennedy-on-Mechanical-Sympathy-时长：" class="headerlink" title="#6 Bill Kennedy on Mechanical Sympathy, , 时长："></a>#6 <a href="https://changelog.com/gotime/6" target="_blank" rel="external">Bill Kennedy on Mechanical Sympathy</a>, , 时长：</h2><h2 id="5-Raphael-Simon-on-goa-the-Framework-for-Building-Microservices-JUL-26-2016-时长："><a href="#5-Raphael-Simon-on-goa-the-Framework-for-Building-Microservices-JUL-26-2016-时长：" class="headerlink" title="#5 Raphaël Simon on goa, the Framework for Building Microservices, JUL 26 2016, 时长："></a>#5 <a href="https://changelog.com/gotime/5" target="_blank" rel="external">Raphaël Simon on goa, the Framework for Building Microservices</a>, JUL 26 2016, 时长：</h2><h2 id="4-Go-and-Data-Science-with-Daniel-Whitenack-JUN-16-2016-时长："><a href="#4-Go-and-Data-Science-with-Daniel-Whitenack-JUN-16-2016-时长：" class="headerlink" title="#4 Go and Data Science with Daniel Whitenack, JUN 16 2016, 时长："></a>#4 <a href="https://changelog.com/gotime/4" target="_blank" rel="external">Go and Data Science with Daniel Whitenack</a>, JUN 16 2016, 时长：</h2><h2 id="3-Early-Go-Adoption-with-Travis-Reeder-JUN-10-2016-时长："><a href="#3-Early-Go-Adoption-with-Travis-Reeder-JUN-10-2016-时长：" class="headerlink" title="#3 Early Go Adoption with Travis Reeder, JUN 10 2016, 时长："></a>#3 <a href="https://changelog.com/gotime/3" target="_blank" rel="external">Early Go Adoption with Travis Reeder</a>, JUN 10 2016, 时长：</h2><h2 id="2-Go-Community-Discussions-with-Cory-LaNou-JUN-2-2016-时长：49-26"><a href="#2-Go-Community-Discussions-with-Cory-LaNou-JUN-2-2016-时长：49-26" class="headerlink" title="#2 Go Community Discussions with Cory LaNou, JUN 2 2016, 时长：49:26"></a>#2 <a href="https://changelog.com/gotime/2" target="_blank" rel="external">Go Community Discussions with Cory LaNou</a>, JUN 2 2016, 时长：49:26</h2><h2 id="1-The-Kick-Off-Show-MAY-19-2016-时长：32-30"><a href="#1-The-Kick-Off-Show-MAY-19-2016-时长：32-30" class="headerlink" title="#1 The Kick Off Show  MAY 19 2016 时长：32:30"></a>#1 <a href="https://changelog.com/gotime/1" target="_blank" rel="external">The Kick Off Show</a>  MAY 19 2016 时长：32:30</h2><ul>
<li>第一期节目，主持人是：<a href="https://github.com/erikstmartin" target="_blank" rel="external">Erik St. Martin</a>, <a href="https://github.com/carlisia" target="_blank" rel="external">Carlisia Pinto</a>, <a href="https://github.com/bketelsen" target="_blank" rel="external">Brian Ketelsen</a> </li>
<li>前10来分钟，从 Go 的漏洞到 vim-go, 再谈到 vim，再到 neovim</li>
<li><a href="https://twitter.com/@YourFirstPR" target="_blank" rel="external">https://twitter.com/@YourFirstPR</a> </li>
<li>提到 Rancher Lab 的体验很好<br>TOREVIEW</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不定期更新。&lt;/p&gt;
&lt;p&gt;最后更新时间：Sat May 20 18:49:50 CST 2018&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://knarfeh.github.io/tags/Life/"/>
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="Blog" scheme="http://knarfeh.github.io/tags/Blog/"/>
    
      <category term="Podcast" scheme="http://knarfeh.github.io/tags/Podcast/"/>
    
      <category term="Ruby" scheme="http://knarfeh.github.io/tags/Ruby/"/>
    
      <category term="Notes" scheme="http://knarfeh.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>【podcast】The Changelog</title>
    <link href="http://knarfeh.github.io/2017/11/03/%E3%80%90podcast%E3%80%91The%20Changelog/"/>
    <id>http://knarfeh.github.io/2017/11/03/【podcast】The Changelog/</id>
    <published>2017-11-03T09:40:03.000Z</published>
    <updated>2018-07-17T02:36:15.269Z</updated>
    
    <content type="html"><![CDATA[<p>不定期更新。</p>
<p>最后更新时间：Sat Jun  9 15:46:00 CST 2018</p>
<a id="more"></a>
<p>文稿地址：<a href="https://github.com/thechangelog/transcripts/" target="_blank" rel="external">thechangelog/transcripts</a></p>
<h2 id="300-Corporate-interests-in-open-source-and-dev-culture-Jun-6-2018，时长：1-33-42"><a href="#300-Corporate-interests-in-open-source-and-dev-culture-Jun-6-2018，时长：1-33-42" class="headerlink" title="#300 Corporate interests in open source and dev culture,  Jun 6, 2018，时长：1:33:42"></a>#300 <a href="https://changelog.com/podcast/300" target="_blank" rel="external">Corporate interests in open source and dev culture</a>,  Jun 6, 2018，时长：1:33:42</h2><ul>
<li>嘉宾是 </li>
</ul>
<h2 id="299-Curl-turns-20-HTTP-2-and-QUIC-Jun-6-2018，时长：1-33-42"><a href="#299-Curl-turns-20-HTTP-2-and-QUIC-Jun-6-2018，时长：1-33-42" class="headerlink" title="#299 Curl turns 20, HTTP/2, and QUIC Jun 6, 2018，时长：1:33:42"></a>#299 <a href="https://changelog.com/news/9N3J/visit" target="_blank" rel="external">Curl turns 20, HTTP/2, and QUIC</a> Jun 6, 2018，时长：1:33:42</h2><h2 id="287-Truffle-framework-and-decentralized-Ethereum-apps-Mar-13-2018，时长：1-13-09"><a href="#287-Truffle-framework-and-decentralized-Ethereum-apps-Mar-13-2018，时长：1-13-09" class="headerlink" title="#287 Truffle framework and decentralized Ethereum apps,  Mar 13, 2018，时长：1:13:09"></a>#287 <a href="https://changelog.com/podcast/287" target="_blank" rel="external">Truffle framework and decentralized Ethereum apps</a>,  Mar 13, 2018，时长：1:13:09</h2><ul>
<li>Truffle 是一个以太坊 DApp 开发的集成开发环境。嘉宾是 Tim Coulter - <a href="https://twitter.com/timothyjcoulter" target="_blank" rel="external">Twitter</a>，<a href="https://github.com/tcoulter" target="_blank" rel="external">GitHub</a>。</li>
<li><a href="https://www.ethpm.com/docs/integration-guide" target="_blank" rel="external">ethpm</a> 以太坊包管理工具</li>
<li>比特币团队在构建一种名叫 Simplicity 的语言。</li>
<li>Truffle 团队到现在只有6个人。14:00-16:00 类比 Truffle 和 Rails</li>
<li>25:16 解释为什么不用 Python，Javascript。eWASM，笑尿了🤣</li>
<li>32:32 Truffle 的目标之一是让其他的框架也能轻易地写智能合约的测试。</li>
<li>55:35 CryptoKitties</li>
</ul>
<p>TOREVIEW</p>
<h2 id="283-Devhints-TL-DR-for-Developer-Documentation-Feb-9-2018，时长：1-21-57"><a href="#283-Devhints-TL-DR-for-Developer-Documentation-Feb-9-2018，时长：1-21-57" class="headerlink" title="#283 Devhints - TL;DR for Developer Documentation,  Feb 9, 2018，时长：1:21:57"></a>#283 <a href="https://changelog.com/podcast/283" target="_blank" rel="external">Devhints - TL;DR for Developer Documentation</a>,  Feb 9, 2018，时长：1:21:57</h2><ul>
<li><a href="https://devhints.io/" target="_blank" rel="external">devhints</a> 是来自菲律宾的开发者 <a href="https://github.com/rstacruz" target="_blank" rel="external">Rico Sta. Cruz</a> 的作品，devhints 是一个开发者的备忘录，记录了一些语言，框架，工具常用到的细节。Rico 本来是做设计的，后来开始写 Ruby，写 Sinatra 和 Rails</li>
<li>rscss.io 也是基于 docpress 构建的。docpress 类似于 GitBook</li>
</ul>
<p>需要一些前端开发的背景知识才能完全听懂他们在说什么，查了不少里面提到的名词。</p>
<p>TOREVIEW</p>
<h2 id="282-The-Impact-and-Future-of-Kubernetes-Feb-2-2018，时长：0-45-34"><a href="#282-The-Impact-and-Future-of-Kubernetes-Feb-2-2018，时长：0-45-34" class="headerlink" title="#282 The Impact and Future of Kubernetes,  Feb 2, 2018，时长：0:45:34"></a>#282 <a href="https://changelog.com/podcast/282" target="_blank" rel="external">The Impact and Future of Kubernetes</a>,  Feb 2, 2018，时长：0:45:34</h2><ul>
<li>嘉宾是 Brendan Burns，k8s 联合创始人，Gabe Monroy, Deis 作者。</li>
<li>Deis 项目，一个开源的 Heroku</li>
<li>Open Service Broker 项目，比如说运行一个 DB，看起来像是运行一个 DB container，但其实例是云服务厂商如 MySQL 的。</li>
<li>Metaparticle，一个用于开发原生 k8s 应用的库。<a href="https://metaparticle.io/" target="_blank" rel="external">https://metaparticle.io/</a></li>
<li>00:37:51 提到 12factor.net</li>
<li>结尾提到 VIrtual Kubelet</li>
</ul>
<p>TOREVIEW</p>
<h2 id="281-Gitcoin-Sustaining-Open-Source-with-Cryptocurrency-Jan-26-2018，时长：1-16-33"><a href="#281-Gitcoin-Sustaining-Open-Source-with-Cryptocurrency-Jan-26-2018，时长：1-16-33" class="headerlink" title="#281 Gitcoin: Sustaining Open Source with Cryptocurrency,  Jan 26, 2018，时长：1:16:33"></a>#281 <a href="https://changelog.com/podcast/281" target="_blank" rel="external">Gitcoin: Sustaining Open Source with Cryptocurrency</a>,  Jan 26, 2018，时长：1:16:33</h2><h2 id="278-Blockchains-and-Databases-at-OSCON-Dec-14-2017，时长：0-56-54"><a href="#278-Blockchains-and-Databases-at-OSCON-Dec-14-2017，时长：0-56-54" class="headerlink" title="#278 Blockchains and Databases at OSCON,  Dec 14, 2017，时长：0:56:54"></a>#278 <a href="https://changelog.com/podcast/278" target="_blank" rel="external">Blockchains and Databases at OSCON</a>,  Dec 14, 2017，时长：0:56:54</h2><h2 id="271-My-Roadmap-to-Become-a-Blockchain-Engineer-Nov-8-2017，时长：1-04-17"><a href="#271-My-Roadmap-to-Become-a-Blockchain-Engineer-Nov-8-2017，时长：1-04-17" class="headerlink" title="#271 My Roadmap to Become a Blockchain Engineer,  Nov 8, 2017，时长：1:04:17"></a>#271 <a href="https://changelog.com/podcast/271" target="_blank" rel="external">My Roadmap to Become a Blockchain Engineer</a>,  Nov 8, 2017，时长：1:04:17</h2><ul>
<li>嘉宾是 Preethi Kasireddy，两年前的今天，写了一篇 Medium 的文章，Why I left the best job in the world，那个时候在 Andreessen Horowitz。曾经在高盛工作。后面决定去一个创业公司 Andreessen Horowitz。开始时学 Python，放弃了几次，然后学 Javascript，有一个周五直接没有上班学了一整天，后来辞职了，自学了几个月加入了 Coinbase 做全栈工程师。</li>
<li>离职 Coinbase 是因为找到一个 entrepreneur bug</li>
<li>Brendan Eich 参与的 Brave 浏览器，计划发行一种 token，让用户可以在使用浏览器的时候从中受益，36:00，Preethi 对区块链的应用的介绍可以再看几遍。</li>
<li>50:17:00 Preethi 分享学习方法，写博客</li>
<li>Preethi 的<a href="http://preethikasireddy.me/" target="_blank" rel="external">网站</a>，<a href="https://github.com/iam-peekay" target="_blank" rel="external">github</a>，<a href="https://twitter.com/iam_preethi" target="_blank" rel="external">twitter</a></li>
</ul>
<p>TOREVIEW</p>
<h2 id="250-The-Backstory-of-Kubernetes-with-Tim-Hockin-and-Aparna-Sinha-May-21-2017，时长：1-10-43"><a href="#250-The-Backstory-of-Kubernetes-with-Tim-Hockin-and-Aparna-Sinha-May-21-2017，时长：1-10-43" class="headerlink" title="#250 The Backstory of Kubernetes with Tim Hockin and Aparna Sinha,  May 21, 2017，时长：1:10:43"></a>#250 <a href="https://changelog.com/podcast/250" target="_blank" rel="external">The Backstory of Kubernetes with Tim Hockin and Aparna Sinha</a>,  May 21, 2017，时长：1:10:43</h2><ul>
<li>嘉宾是 Tim Hockin，k8s 的 founder，core engineer，Aparna Sinha 首席产品经理</li>
<li>Borg 始于 2003 年，Tim 在使用 Borg 的过程中总是会想，如果没有离开了 Google，没有 Borg 怎么办，我能重建一个 borg 吗？在2013年 docker 横空出世时，他们觉得这东西有点 borg 的意思，只不过它标准化了容器的概念。<a href="https://research.google.com/pubs/pub43438.html" target="_blank" rel="external">Borg 系统</a> 这篇文章的影响力很大，对 Mesos 的发展也有影响。</li>
<li>2014年6月6日，Kubernetes 在 DockerCon 上首次亮相。</li>
<li>Kubernetes 曾经考虑过 Seven 这个名字。『Google 不需要关注 Kubernetes 的 SEO 问题』，『不不不，别瞎说，我们从未操纵过搜索结果』– 来自硅谷的梗</li>
<li>PokémonGo 原来是用 Kubernetes 进行扩容的。</li>
</ul>
<p>TOREVIEW</p>
<h2 id="222-Ethereum-and-Cryptocurrency-with-Gavin-Wood-Sep-30-2016，时长：1-24-47"><a href="#222-Ethereum-and-Cryptocurrency-with-Gavin-Wood-Sep-30-2016，时长：1-24-47" class="headerlink" title="#222 Ethereum and Cryptocurrency with Gavin Wood,  Sep 30, 2016，时长：1:24:47"></a>#222 <a href="https://changelog.com/podcast/222" target="_blank" rel="external">Ethereum and Cryptocurrency with Gavin Wood</a>,  Sep 30, 2016，时长：1:24:47</h2><ul>
<li>嘉宾是 Gavin Wood，以太坊创始人，Solidity 创始人，Ethcore （创建了 Parity）创始人</li>
<li>Gavin Wood 给以太坊的定义是：programmable money</li>
<li>智能合约的概念最早来自90年代的 Nick Szabo</li>
<li>35% 开始讲解 DAO 的概念，Decentralized Autonomous Organization</li>
</ul>
<p>TOREVIEW</p>
<h2 id="204-IPFS-InterPlanetary-File-System-with-Juan-Benet-May-21-2016，时长：1-13-37"><a href="#204-IPFS-InterPlanetary-File-System-with-Juan-Benet-May-21-2016，时长：1-13-37" class="headerlink" title="#204 IPFS (InterPlanetary File System) with Juan Benet,  May 21, 2016，时长：1:13:37"></a>#204 <a href="https://changelog.com/podcast/204" target="_blank" rel="external">IPFS (InterPlanetary File System) with Juan Benet</a>,  May 21, 2016，时长：1:13:37</h2><ul>
<li>嘉宾是 Juan Benet，IPFS 的开发者。<a href="https://ipfs.io" target="_blank" rel="external">ipfs</a></li>
<li>12:10 IPFS, where the idea came from, how it started, the genesis story of this project. 最后提到了一些分布式文件系统的项目，Plan 9，9p，Venti，Fossil</li>
<li>19:46 IPFS is a new way of moving around content on the network.</li>
<li>24:00 how it works.</li>
<li>31:26 谈 IPFS 的激励机制。</li>
<li>34:35 self-certifying namespace, SFS，类似于 git 系统里当前指针的概念，当我们有了新的提交指针指向的是最新的提交。文件系统里的 DNS。</li>
<li>41:12 practical use of IPFS. CDN, package manager, IPFS 使用 GX 这个 go 包管理器进行包管理的。</li>
<li>58:40 CRDT, Convergent Replicated Data Type or Conflict-Free Replicated Data Type or Commutative Replicated Data Type。CRDT 类似于 Google Docs 实现的 operational transform，它保证了所有的操作不会冲突</li>
<li>节目最后讨论了一些 IPFS 的应用场景以及未来展望</li>
</ul>
<p>TOREVIEW</p>
<h2 id="200-JavaScript-and-Robots-Apr-19-2016，时长：1-29-40"><a href="#200-JavaScript-and-Robots-Apr-19-2016，时长：1-29-40" class="headerlink" title="#200 JavaScript and Robots,  Apr 19, 2016，时长：1:29:40"></a>#200 <a href="https://changelog.com/podcast/200" target="_blank" rel="external">JavaScript and Robots</a>,  Apr 19, 2016，时长：1:29:40</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不定期更新。&lt;/p&gt;
&lt;p&gt;最后更新时间：Sat Jun  9 15:46:00 CST 2018&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://knarfeh.github.io/tags/Life/"/>
    
      <category term="Golang" scheme="http://knarfeh.github.io/tags/Golang/"/>
    
      <category term="Blog" scheme="http://knarfeh.github.io/tags/Blog/"/>
    
      <category term="Podcast" scheme="http://knarfeh.github.io/tags/Podcast/"/>
    
      <category term="Ruby" scheme="http://knarfeh.github.io/tags/Ruby/"/>
    
      <category term="Notes" scheme="http://knarfeh.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>【podcast】JS Party</title>
    <link href="http://knarfeh.github.io/2017/11/03/%E3%80%90podcast%E3%80%91JS%20Party/"/>
    <id>http://knarfeh.github.io/2017/11/03/【podcast】JS Party/</id>
    <published>2017-11-03T09:40:03.000Z</published>
    <updated>2018-08-18T06:29:21.159Z</updated>
    
    <content type="html"><![CDATA[<p>不定期更新。</p>
<p>最后更新时间：Tue Jul 24 23:06:06 CST 2018</p>
<a id="more"></a>
<p>文稿地址：<a href="https://github.com/thechangelog/transcripts/" target="_blank" rel="external">thechangelog/transcripts</a></p>
<h2 id="34-JavaScript-eating-the-world-desktop-edition-with-Shelley-Vohr-and-Jeremy-Apthorp-Jul-13-2018，时长：1-02-11"><a href="#34-JavaScript-eating-the-world-desktop-edition-with-Shelley-Vohr-and-Jeremy-Apthorp-Jul-13-2018，时长：1-02-11" class="headerlink" title="#34 JavaScript eating the world, desktop edition with Shelley Vohr and Jeremy Apthorp,  Jul 13, 2018，时长：1:02:11"></a>#34 <a href="https://changelog.com/jsparty/34" target="_blank" rel="external">JavaScript eating the world, desktop edition with Shelley Vohr and Jeremy Apthorp</a>,  Jul 13, 2018，时长：1:02:11</h2><h2 id="33-Enough-string-to-hang-yourself-with-Jerod-Santo-Nick-Nisi-and-Kevin-Ball-Jul-6-2018，时长：58-28"><a href="#33-Enough-string-to-hang-yourself-with-Jerod-Santo-Nick-Nisi-and-Kevin-Ball-Jul-6-2018，时长：58-28" class="headerlink" title="#33 Enough string to hang yourself with Jerod Santo, Nick Nisi, and Kevin Ball,  Jul 6, 2018，时长：58:28"></a>#33 <a href="https://changelog.com/jsparty/33" target="_blank" rel="external">Enough string to hang yourself with Jerod Santo, Nick Nisi, and Kevin Ball</a>,  Jul 6, 2018，时长：58:28</h2><h2 id="32-WASM-is-AWSM-with-Kevin-Ball-Suz-Hinton-and-Jay-Phelps-Jun-29-2018，时长：1-01-57"><a href="#32-WASM-is-AWSM-with-Kevin-Ball-Suz-Hinton-and-Jay-Phelps-Jun-29-2018，时长：1-01-57" class="headerlink" title="#32 WASM is AWSM with Kevin Ball, Suz Hinton, and Jay Phelps,  Jun 29, 2018，时长：1:01:57"></a>#32 <a href="https://changelog.com/jsparty/32" target="_blank" rel="external">WASM is AWSM with Kevin Ball, Suz Hinton, and Jay Phelps</a>,  Jun 29, 2018，时长：1:01:57</h2><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html" target="_blank" rel="external">WebAssembly 现状与实战</a></li>
</ul>
<h2 id="31-GraphQL-when-to-use-JavaScript-JS-robotics-with-Brian-Douglas-Aimee-Knight-and-Bryan-Hughes-Jun-22-2018，时长：1-06-52"><a href="#31-GraphQL-when-to-use-JavaScript-JS-robotics-with-Brian-Douglas-Aimee-Knight-and-Bryan-Hughes-Jun-22-2018，时长：1-06-52" class="headerlink" title="#31 GraphQL, when to use JavaScript, JS robotics with Brian Douglas, Aimee Knight, and Bryan Hughes,  Jun 22, 2018，时长：1:06:52"></a>#31 <a href="https://changelog.com/jsparty/31" target="_blank" rel="external">GraphQL, when to use JavaScript, JS robotics with Brian Douglas, Aimee Knight, and Bryan Hughes</a>,  Jun 22, 2018，时长：1:06:52</h2><h2 id="30-Do-what-every-developer-does-blame-other-people-with-Nick-Nisi-Suz-Hinton-and-Jerod-Santo-Jun-19-2018，时长：1-11-33"><a href="#30-Do-what-every-developer-does-blame-other-people-with-Nick-Nisi-Suz-Hinton-and-Jerod-Santo-Jun-19-2018，时长：1-11-33" class="headerlink" title="#30 Do what every developer does: blame other people with Nick Nisi, Suz Hinton, and Jerod Santo,  Jun 19, 2018，时长：1:11:33"></a>#30 <a href="https://changelog.com/jsparty/30" target="_blank" rel="external">Do what every developer does: blame other people with Nick Nisi, Suz Hinton, and Jerod Santo</a>,  Jun 19, 2018，时长：1:11:33</h2><h2 id="29-Node’s-survey-Ry’s-regrets-Microsoft’s-GitHub-with-Kevin-Ball-Nick-Nisi-and-Jerod-Santo-Jun-8-2018，时长：1-04-26"><a href="#29-Node’s-survey-Ry’s-regrets-Microsoft’s-GitHub-with-Kevin-Ball-Nick-Nisi-and-Jerod-Santo-Jun-8-2018，时长：1-04-26" class="headerlink" title="#29 Node’s survey, Ry’s regrets, Microsoft’s GitHub with Kevin Ball, Nick Nisi, and Jerod Santo,  Jun 8, 2018，时长：1:04:26"></a>#29 <a href="https://changelog.com/jsparty/29" target="_blank" rel="external">Node’s survey, Ry’s regrets, Microsoft’s GitHub with Kevin Ball, Nick Nisi, and Jerod Santo</a>,  Jun 8, 2018，时长：1:04:26</h2><h2 id="28-ML-in-JS…-well…-yes-with-Suz-Hinton-Jerod-Santo-Kevin-Ball-and-Christopher-Hiller-Jun-1-2018，时长：53-44"><a href="#28-ML-in-JS…-well…-yes-with-Suz-Hinton-Jerod-Santo-Kevin-Ball-and-Christopher-Hiller-Jun-1-2018，时长：53-44" class="headerlink" title="#28 ML in JS… well… yes? with Suz Hinton, Jerod Santo, Kevin Ball, and Christopher Hiller,  Jun 1, 2018，时长：53:44"></a>#28 <a href="https://changelog.com/jsparty/28" target="_blank" rel="external">ML in JS… well… yes? with Suz Hinton, Jerod Santo, Kevin Ball, and Christopher Hiller</a>,  Jun 1, 2018，时长：53:44</h2><h2 id="27-A-tooling-extravaganza-with-Kevin-Ball-Alex-Sexton-Nick-Nisi-and-Christopher-Hiller-May-25-2018，时长：57-58"><a href="#27-A-tooling-extravaganza-with-Kevin-Ball-Alex-Sexton-Nick-Nisi-and-Christopher-Hiller-May-25-2018，时长：57-58" class="headerlink" title="#27 A tooling extravaganza! with Kevin Ball, Alex Sexton, Nick Nisi, and Christopher Hiller,  May 25, 2018，时长：57:58"></a>#27 <a href="https://changelog.com/jsparty/27" target="_blank" rel="external">A tooling extravaganza! with Kevin Ball, Alex Sexton, Nick Nisi, and Christopher Hiller</a>,  May 25, 2018，时长：57:58</h2><h2 id="26-🎊-TS-Party-🎊-with-Jerod-Santo-Nick-Nisi-and-Christopher-Hiller-May-18-2018，时长：59-08"><a href="#26-🎊-TS-Party-🎊-with-Jerod-Santo-Nick-Nisi-and-Christopher-Hiller-May-18-2018，时长：59-08" class="headerlink" title="#26 🎊 TS Party! 🎊 with Jerod Santo, Nick Nisi, and Christopher Hiller,  May 18, 2018，时长：59:08"></a>#26 <a href="https://changelog.com/jsparty/26" target="_blank" rel="external">🎊 TS Party! 🎊 with Jerod Santo, Nick Nisi, and Christopher Hiller</a>,  May 18, 2018，时长：59:08</h2><h2 id="25-Dojo-2-0-with-Dylan-Schiemann-May-11-2018，时长：1-06-24"><a href="#25-Dojo-2-0-with-Dylan-Schiemann-May-11-2018，时长：1-06-24" class="headerlink" title="#25 Dojo 2.0 with Dylan Schiemann,  May 11, 2018，时长：1:06:24"></a>#25 <a href="https://changelog.com/jsparty/25" target="_blank" rel="external">Dojo 2.0 with Dylan Schiemann</a>,  May 11, 2018，时长：1:06:24</h2><h2 id="24-Cool-depending-on-your-definition-of-cool-with-Feross-Aboukhadijeh-Suz-Hinton-Nick-Nisi-and-Alex-Sexton-May-7-2018，时长：54-24"><a href="#24-Cool-depending-on-your-definition-of-cool-with-Feross-Aboukhadijeh-Suz-Hinton-Nick-Nisi-and-Alex-Sexton-May-7-2018，时长：54-24" class="headerlink" title="#24 Cool, depending on your definition of cool with Feross Aboukhadijeh, Suz Hinton, Nick Nisi, and Alex Sexton,  May 7, 2018，时长：54:24"></a>#24 <a href="https://changelog.com/jsparty/24" target="_blank" rel="external">Cool, depending on your definition of cool with Feross Aboukhadijeh, Suz Hinton, Nick Nisi, and Alex Sexton</a>,  May 7, 2018，时长：54:24</h2><h2 id="23-The-state-of-Node-security-with-Suz-Hinton-Christopher-Hiller-Jerod-Santo-and-Adam-Baldwin-Guests-Apr-30-2018，时长：54-51"><a href="#23-The-state-of-Node-security-with-Suz-Hinton-Christopher-Hiller-Jerod-Santo-and-Adam-Baldwin-Guests-Apr-30-2018，时长：54-51" class="headerlink" title="#23 The state of Node security with Suz Hinton, Christopher Hiller, Jerod Santo, and Adam Baldwin Guests,  Apr 30, 2018，时长：54:51"></a>#23 <a href="https://changelog.com/jsparty/23" target="_blank" rel="external">The state of Node security with Suz Hinton, Christopher Hiller, Jerod Santo, and Adam Baldwin Guests</a>,  Apr 30, 2018，时长：54:51</h2><h2 id="22-PWAs-to-eat-the-world-Or-maybe-not-News-at-11-with-Jerod-Santo-Safia-Abdalla-Nick-Nisi-and-Kevin-Ball-Apr-23-2018，时长：56-25"><a href="#22-PWAs-to-eat-the-world-Or-maybe-not-News-at-11-with-Jerod-Santo-Safia-Abdalla-Nick-Nisi-and-Kevin-Ball-Apr-23-2018，时长：56-25" class="headerlink" title="#22 PWAs to eat the world. Or maybe not. News at 11! with Jerod Santo, Safia Abdalla, Nick Nisi, and Kevin Ball,  Apr 23, 2018，时长：56:25"></a>#22 <a href="https://changelog.com/jsparty/22" target="_blank" rel="external">PWAs to eat the world. Or maybe not. News at 11! with Jerod Santo, Safia Abdalla, Nick Nisi, and Kevin Ball</a>,  Apr 23, 2018，时长：56:25</h2><ul>
<li>Safia Abdalla 正在写一篇关于 Curl 的文章</li>
<li>PWA 指的是 Progressive Web App，渐进式网络应用程序</li>
</ul>
<h2 id="21-Oh-the-places-JS-will-go-with-Jerod-Santo-Suz-Hinton-Feross-Aboukhadijeh-and-Kevin-Ball-Apr-13-2018，时长：54-47"><a href="#21-Oh-the-places-JS-will-go-with-Jerod-Santo-Suz-Hinton-Feross-Aboukhadijeh-and-Kevin-Ball-Apr-13-2018，时长：54-47" class="headerlink" title="#21 Oh, the places JS will go with Jerod Santo, Suz Hinton, Feross Aboukhadijeh, and Kevin Ball,  Apr 13, 2018，时长：54:47"></a>#21 <a href="https://changelog.com/jsparty/21" target="_blank" rel="external">Oh, the places JS will go with Jerod Santo, Suz Hinton, Feross Aboukhadijeh, and Kevin Ball</a>,  Apr 13, 2018，时长：54:47</h2><h2 id="20-JS-Party-is-back-🎉-with-Jerod-Santo-Safia-Abdalla-Nick-Nisi-and-Christopher-Hiller-Apr-6-2018，时长：48-34"><a href="#20-JS-Party-is-back-🎉-with-Jerod-Santo-Safia-Abdalla-Nick-Nisi-and-Christopher-Hiller-Apr-6-2018，时长：48-34" class="headerlink" title="#20 JS Party is back! 🎉 with Jerod Santo, Safia Abdalla, Nick Nisi, and Christopher Hiller,  Apr 6, 2018，时长：48:34"></a>#20 <a href="https://changelog.com/jsparty/20" target="_blank" rel="external">JS Party is back! 🎉 with Jerod Santo, Safia Abdalla, Nick Nisi, and Christopher Hiller</a>,  Apr 6, 2018，时长：48:34</h2><h2 id="19-Web-Audio-API-and-TypeScript-is-Turing-Complete-with-Myles-Borins-Aug-18-2017，时长：41-47"><a href="#19-Web-Audio-API-and-TypeScript-is-Turing-Complete-with-Myles-Borins-Aug-18-2017，时长：41-47" class="headerlink" title="#19 Web Audio API and TypeScript is Turing Complete with Myles Borins,  Aug 18, 2017，时长：41:47"></a>#19 <a href="https://changelog.com/jsparty/19" target="_blank" rel="external">Web Audio API and TypeScript is Turing Complete with Myles Borins</a>,  Aug 18, 2017，时长：41:47</h2><h2 id="18-2017-Node-js-User-Survey-and-Beaker-Browser-with-Paul-Frazee-Aug-18-2017，时长：55-07"><a href="#18-2017-Node-js-User-Survey-and-Beaker-Browser-with-Paul-Frazee-Aug-18-2017，时长：55-07" class="headerlink" title="#18 2017 Node.js User Survey and Beaker Browser with Paul Frazee,  Aug 18, 2017，时长：55:07"></a>#18 <a href="https://changelog.com/jsparty/18" target="_blank" rel="external">2017 Node.js User Survey and Beaker Browser with Paul Frazee</a>,  Aug 18, 2017，时长：55:07</h2><h2 id="17-AMA-—-BasicAttentionToken-Robotics-IDE’s-and-Stuff-with-Adam-Stacoviak-Mikeal-Rogers-and-Rachel-White-Aug-18-2017，时长：55-52"><a href="#17-AMA-—-BasicAttentionToken-Robotics-IDE’s-and-Stuff-with-Adam-Stacoviak-Mikeal-Rogers-and-Rachel-White-Aug-18-2017，时长：55-52" class="headerlink" title="#17 AMA — BasicAttentionToken, Robotics, IDE’s and Stuff with Adam Stacoviak, Mikeal Rogers, and Rachel White,  Aug 18, 2017，时长：55:52"></a>#17 <a href="https://changelog.com/jsparty/17" target="_blank" rel="external">AMA — BasicAttentionToken, Robotics, IDE’s and Stuff with Adam Stacoviak, Mikeal Rogers, and Rachel White</a>,  Aug 18, 2017，时长：55:52</h2><h2 id="16-ES-Modules-and-ESM-Loader-with-John-David-Dalton-Jul-26-2017，时长：1-09-28"><a href="#16-ES-Modules-and-ESM-Loader-with-John-David-Dalton-Jul-26-2017，时长：1-09-28" class="headerlink" title="#16 ES Modules and ESM Loader with John-David Dalton,  Jul 26, 2017，时长：1:09:28"></a>#16 <a href="https://changelog.com/jsparty/3" target="_blank" rel="external">ES Modules and ESM Loader with John-David Dalton</a>,  Jul 26, 2017，时长：1:09:28</h2><h2 id="15-Async-Control-Flow-and-Threats-to-the-Open-Web-with-Kyle-Simpson-Jul-7-2017，时长：1-10-42"><a href="#15-Async-Control-Flow-and-Threats-to-the-Open-Web-with-Kyle-Simpson-Jul-7-2017，时长：1-10-42" class="headerlink" title="#15 Async Control Flow and Threats to the Open Web with Kyle Simpson,  Jul 7, 2017，时长：1:10:42"></a>#15 <a href="https://changelog.com/jsparty/15" target="_blank" rel="external">Async Control Flow and Threats to the Open Web with Kyle Simpson</a>,  Jul 7, 2017，时长：1:10:42</h2><h2 id="14-Inside-Node-8-Glitch-Building-a-Community-Around-Education-Jun-23-2017，时长：46-27"><a href="#14-Inside-Node-8-Glitch-Building-a-Community-Around-Education-Jun-23-2017，时长：46-27" class="headerlink" title="#14 Inside Node 8, Glitch, Building a Community Around Education,  Jun 23, 2017，时长：46:27"></a>#14 <a href="https://changelog.com/jsparty/14" target="_blank" rel="external">Inside Node 8, Glitch, Building a Community Around Education</a>,  Jun 23, 2017，时长：46:27</h2><h2 id="13-Inside-the-Release-of-npm-5-and-Sheetsee-with-Rebecca-Turner-Kat-Marchan-amp-Jessica-Lord-Jun-13-2017，时长：54-54"><a href="#13-Inside-the-Release-of-npm-5-and-Sheetsee-with-Rebecca-Turner-Kat-Marchan-amp-Jessica-Lord-Jun-13-2017，时长：54-54" class="headerlink" title="#13 Inside the Release of npm@5 and Sheetsee with Rebecca Turner, Kat Marchán &amp; Jessica Lord,  Jun 13, 2017，时长：54:54"></a>#13 <a href="https://changelog.com/jsparty/13" target="_blank" rel="external">Inside the Release of npm@5 and Sheetsee with Rebecca Turner, Kat Marchán &amp; Jessica Lord</a>,  Jun 13, 2017，时长：54:54</h2><h2 id="12-Using-ES6-7-create-react-app-and-Electron-with-Mikeal-Rogers-Rachel-White-amp-Alex-Sexton-Jun-1-2017，时长：1-05-05"><a href="#12-Using-ES6-7-create-react-app-and-Electron-with-Mikeal-Rogers-Rachel-White-amp-Alex-Sexton-Jun-1-2017，时长：1-05-05" class="headerlink" title="#12 Using ES6/7, create-react-app, and Electron! with Mikeal Rogers, Rachel White &amp; Alex Sexton, Jun 1, 2017，时长：1:05:05"></a>#12 <a href="https://changelog.com/jsparty/3" target="_blank" rel="external">Using ES6/7, create-react-app, and Electron! with Mikeal Rogers, Rachel White &amp; Alex Sexton</a>, Jun 1, 2017，时长：1:05:05</h2><h2 id="11-Web-Standards-ECMAScript-Modules-in-Browsers-and-Learning-JS-with-Alex-Sexton-and-guest-hosts-Wes-Bos-amp-Mike-Taylor-May-26-2017，时长：1-03-34"><a href="#11-Web-Standards-ECMAScript-Modules-in-Browsers-and-Learning-JS-with-Alex-Sexton-and-guest-hosts-Wes-Bos-amp-Mike-Taylor-May-26-2017，时长：1-03-34" class="headerlink" title="#11 Web Standards, ECMAScript Modules in Browsers, and Learning JS with Alex Sexton and guest hosts Wes Bos &amp; Mike Taylor,  May 26, 2017，时长：1:03:34"></a>#11 <a href="https://changelog.com/jsparty/11" target="_blank" rel="external">Web Standards, ECMAScript Modules in Browsers, and Learning JS with Alex Sexton and guest hosts Wes Bos &amp; Mike Taylor</a>,  May 26, 2017，时长：1:03:34</h2><h2 id="10-yayQuery-Reunion-with-Alex-Sexton-Paul-Irish-Rebecca-Murphey-and-Adam-Sontag-May-2-2017，时长：1-10-25"><a href="#10-yayQuery-Reunion-with-Alex-Sexton-Paul-Irish-Rebecca-Murphey-and-Adam-Sontag-May-2-2017，时长：1-10-25" class="headerlink" title="#10 yayQuery Reunion! with Alex Sexton, Paul Irish, Rebecca Murphey, and Adam Sontag,  May 2, 2017，时长：1:10:25"></a>#10 <a href="https://changelog.com/jsparty/10" target="_blank" rel="external">yayQuery Reunion! with Alex Sexton, Paul Irish, Rebecca Murphey, and Adam Sontag</a>,  May 2, 2017，时长：1:10:25</h2><h2 id="9-P2P-Web-WebRTC-WebTorrent-IPFS-and-React-VR-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Apr-25-2017，时长：1-01-01"><a href="#9-P2P-Web-WebRTC-WebTorrent-IPFS-and-React-VR-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Apr-25-2017，时长：1-01-01" class="headerlink" title="#9 P2P Web, WebRTC, WebTorrent, IPFS, and React VR with Mikeal Rogers, Alex Sexton &amp; Rachel White,  Apr 25, 2017，时长：1:01:01"></a>#9 <a href="https://changelog.com/jsparty/9" target="_blank" rel="external">P2P Web, WebRTC, WebTorrent, IPFS, and React VR with Mikeal Rogers, Alex Sexton &amp; Rachel White</a>,  Apr 25, 2017，时长：1:01:01</h2><h2 id="8-Good-Documentation-Non-blocking-UI-Rendering-Node-Community-Updates-with-Tracy-Hinds-Apr-23-2017，时长：53-54"><a href="#8-Good-Documentation-Non-blocking-UI-Rendering-Node-Community-Updates-with-Tracy-Hinds-Apr-23-2017，时长：53-54" class="headerlink" title="#8 Good Documentation, Non-blocking UI Rendering, Node Community Updates with Tracy Hinds,  Apr 23, 2017，时长：53:54"></a>#8 <a href="https://changelog.com/jsparty/8" target="_blank" rel="external">Good Documentation, Non-blocking UI Rendering, Node Community Updates with Tracy Hinds</a>,  Apr 23, 2017，时长：53:54</h2><h2 id="7-VM-Neutrality-in-Node-N-API-Learning-JavaScript-Mastodon-Apr-14-2017，时长：58-30"><a href="#7-VM-Neutrality-in-Node-N-API-Learning-JavaScript-Mastodon-Apr-14-2017，时长：58-30" class="headerlink" title="#7 VM Neutrality in Node (N-API), Learning JavaScript, Mastodon,  Apr 14, 2017，时长：58:30"></a>#7 <a href="https://changelog.com/jsparty/7" target="_blank" rel="external">VM Neutrality in Node (N-API), Learning JavaScript, Mastodon</a>,  Apr 14, 2017，时长：58:30</h2><h2 id="6-Web-Components-and-WTF-is-Shadow-DOM-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Apr-11-2017，时长："><a href="#6-Web-Components-and-WTF-is-Shadow-DOM-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Apr-11-2017，时长：" class="headerlink" title="#6 Web Components and WTF is Shadow DOM? with Mikeal Rogers, Alex Sexton &amp; Rachel White,  Apr 11, 2017，时长："></a>#6 <a href="https://changelog.com/jsparty/6" target="_blank" rel="external">Web Components and WTF is Shadow DOM? with Mikeal Rogers, Alex Sexton &amp; Rachel White</a>,  Apr 11, 2017，时长：</h2><h2 id="5-JavaScript-in-Latin-America-with-Juan-Pablo-Buritica-Mar-31-2017，时长：1-01-56"><a href="#5-JavaScript-in-Latin-America-with-Juan-Pablo-Buritica-Mar-31-2017，时长：1-01-56" class="headerlink" title="#5 JavaScript in Latin America with Juan Pablo Buritica,  Mar 31, 2017，时长：1:01:56"></a>#5 <a href="https://changelog.com/jsparty/5" target="_blank" rel="external">JavaScript in Latin America with Juan Pablo Buritica</a>,  Mar 31, 2017，时长：1:01:56</h2><h2 id="4-PWAs-Progressive-Web-Apps-Service-Workers-Time-Glitch-with-special-guest-Jenn-Schiffer-Mar-24-2017，时长：1-01-55"><a href="#4-PWAs-Progressive-Web-Apps-Service-Workers-Time-Glitch-with-special-guest-Jenn-Schiffer-Mar-24-2017，时长：1-01-55" class="headerlink" title="#4 PWAs (Progressive Web Apps), Service Workers, Time, Glitch with special guest Jenn Schiffer,  Mar 24, 2017，时长：1:01:55"></a>#4 <a href="https://changelog.com/jsparty/4" target="_blank" rel="external">PWAs (Progressive Web Apps), Service Workers, Time, Glitch with special guest Jenn Schiffer</a>,  Mar 24, 2017，时长：1:01:55</h2><h2 id="3-JavaScript-Fatigue-AMP-Paths-js-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-17-2017，时长：58-08"><a href="#3-JavaScript-Fatigue-AMP-Paths-js-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-17-2017，时长：58-08" class="headerlink" title="#3 JavaScript Fatigue, AMP, Paths.js with Mikeal Rogers, Alex Sexton &amp; Rachel White,  Mar 17, 2017，时长：58:08"></a>#3 <a href="https://changelog.com/jsparty/3" target="_blank" rel="external">JavaScript Fatigue, AMP, Paths.js with Mikeal Rogers, Alex Sexton &amp; Rachel White</a>,  Mar 17, 2017，时长：58:08</h2><h2 id="2-Web-Assembly-Higher-Education-with-JavaScript-JS-Standards-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-10-2017，时长：55-32"><a href="#2-Web-Assembly-Higher-Education-with-JavaScript-JS-Standards-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-10-2017，时长：55-32" class="headerlink" title="#2 Web Assembly, Higher Education with JavaScript, JS Standards with Mikeal Rogers, Alex Sexton &amp; Rachel White,  Mar 10, 2017，时长：55:32"></a>#2 <a href="https://changelog.com/jsparty/2" target="_blank" rel="external">Web Assembly, Higher Education with JavaScript, JS Standards with Mikeal Rogers, Alex Sexton &amp; Rachel White</a>,  Mar 10, 2017，时长：55:32</h2><h2 id="1-Security-on-the-Web-Node-async-await-AR-js-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-3-2017，时长：56-47"><a href="#1-Security-on-the-Web-Node-async-await-AR-js-with-Mikeal-Rogers-Alex-Sexton-amp-Rachel-White-Mar-3-2017，时长：56-47" class="headerlink" title="#1 Security on the Web, Node async/await, AR.js with Mikeal Rogers, Alex Sexton &amp; Rachel White,  Mar 3, 2017，时长：56:47"></a>#1 <a href="https://changelog.com/jsparty/1" target="_blank" rel="external">Security on the Web, Node async/await, AR.js with Mikeal Rogers, Alex Sexton &amp; Rachel White</a>,  Mar 3, 2017，时长：56:47</h2><ul>
<li>这一期主要是讨论 Web 的安全性问题。</li>
<li>SHA1 在 git 中被大量使用。</li>
</ul>
<p>TODO</p>
<h2 id="Meet-Rachel-White-Panelist-of-JS-Party-Feb-24-2017，时长：56-47"><a href="#Meet-Rachel-White-Panelist-of-JS-Party-Feb-24-2017，时长：56-47" class="headerlink" title="Meet Rachel White Panelist of JS Party,  Feb 24, 2017，时长：56:47"></a><a href="https://changelog.com/jsparty/meet-rachel-white" target="_blank" rel="external">Meet Rachel White Panelist of JS Party</a>,  Feb 24, 2017，时长：56:47</h2><ul>
<li>微软 DX 团队的前端工程师，Tech Evangelist 的 Rachel White。曾在 IBM Watson，Adobe Behance 工作。</li>
<li>Rachel 植入了一个 RFID 芯片到手腕里。目前正在学 React</li>
</ul>
<p>TOREVIEW</p>
<h2 id="Meet-Alex-Sexton-Feb-24-2017，时长：37-46"><a href="#Meet-Alex-Sexton-Feb-24-2017，时长：37-46" class="headerlink" title="Meet Alex Sexton, Feb 24, 2017，时长：37:46"></a><a href="https://changelog.com/jsparty/meet-alex-sexton" target="_blank" rel="external">Meet Alex Sexton</a>, Feb 24, 2017，时长：37:46</h2><ul>
<li>Alex 写了12年 Javascript。这四年在 Stripe，在德州奥斯丁远程工作。Alex 参与了 jQuery，是董事会成员。在 Modernizr 也做了很多工作。</li>
</ul>
<p>TODO</p>
<h2 id="Meet-Mikeal-Rogers-Feb-24-2017，时长：37-46"><a href="#Meet-Mikeal-Rogers-Feb-24-2017，时长：37-46" class="headerlink" title="Meet Mikeal Rogers,  Feb 24, 2017，时长：37:46"></a><a href="https://changelog.com/jsparty/meet-mikeal-rogers" target="_blank" rel="external">Meet Mikeal Rogers</a>,  Feb 24, 2017，时长：37:46</h2><ul>
<li>3位主持是 <a href="https://twitter.com/mikeal" target="_blank" rel="external">Mikeal Rogers</a>，<a href="https://twitter.com/adamstac" target="_blank" rel="external">Adam Stacoviak</a>，<a href="https://twitter.com/jerodsanto" target="_blank" rel="external">Jerod Santo</a>。JS Party 的前3期将分别介绍3位主持作为节目的开场。</li>
<li>这一次将介绍 Mikeal Rogers。之前在 Mozilla 工作，写 Python 和 Javascript，现在已经不写 Python 了。四年在 Windmill 项目上(类似 Selenium)。</li>
<li>Mideal 是 io.js 的 leader 之一。</li>
<li>节目末介绍了联系方式。</li>
</ul>
<p>TOREVIEW</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不定期更新。&lt;/p&gt;
&lt;p&gt;最后更新时间：Tue Jul 24 23:06:06 CST 2018&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://knarfeh.github.io/tags/Life/"/>
    
      <category term="Blog" scheme="http://knarfeh.github.io/tags/Blog/"/>
    
      <category term="Podcast" scheme="http://knarfeh.github.io/tags/Podcast/"/>
    
      <category term="Ruby" scheme="http://knarfeh.github.io/tags/Ruby/"/>
    
      <category term="Notes" scheme="http://knarfeh.github.io/tags/Notes/"/>
    
      <category term="Javascript" scheme="http://knarfeh.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
